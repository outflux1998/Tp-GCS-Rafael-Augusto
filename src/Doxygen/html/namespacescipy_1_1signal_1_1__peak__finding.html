<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.signal._peak_finding Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html">_peak_finding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._peak_finding Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab855d9e2608dc3b8d651b1f9fed85804" id="r_ab855d9e2608dc3b8d651b1f9fed85804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#ab855d9e2608dc3b8d651b1f9fed85804">_boolrelextrema</a> (data, comparator, axis=0, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=1, mode='clip')</td></tr>
<tr class="separator:ab855d9e2608dc3b8d651b1f9fed85804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d18336288f089a9ae51ea0835900be9" id="r_a6d18336288f089a9ae51ea0835900be9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a6d18336288f089a9ae51ea0835900be9">argrelmin</a> (data, axis=0, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=1, mode='clip')</td></tr>
<tr class="separator:a6d18336288f089a9ae51ea0835900be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdab1483729a45cad1df3c8ec962420" id="r_a8bdab1483729a45cad1df3c8ec962420"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a8bdab1483729a45cad1df3c8ec962420">argrelmax</a> (data, axis=0, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=1, mode='clip')</td></tr>
<tr class="separator:a8bdab1483729a45cad1df3c8ec962420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8015d8ec4044a941b4c63c635abbed86" id="r_a8015d8ec4044a941b4c63c635abbed86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a8015d8ec4044a941b4c63c635abbed86">argrelextrema</a> (data, comparator, axis=0, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=1, mode='clip')</td></tr>
<tr class="separator:a8015d8ec4044a941b4c63c635abbed86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d24b40496cb9253fb27a3167a0ddd" id="r_a5f1d24b40496cb9253fb27a3167a0ddd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a5f1d24b40496cb9253fb27a3167a0ddd">_arg_x_as_expected</a> (value)</td></tr>
<tr class="separator:a5f1d24b40496cb9253fb27a3167a0ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09a4aa0b159096b2b2a9bd5484b43e6a" id="r_a09a4aa0b159096b2b2a9bd5484b43e6a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a09a4aa0b159096b2b2a9bd5484b43e6a">_arg_peaks_as_expected</a> (value)</td></tr>
<tr class="separator:a09a4aa0b159096b2b2a9bd5484b43e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a652a48cb6116e2fa1a6c9fda226b1" id="r_ab0a652a48cb6116e2fa1a6c9fda226b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#ab0a652a48cb6116e2fa1a6c9fda226b1">_arg_wlen_as_expected</a> (value)</td></tr>
<tr class="separator:ab0a652a48cb6116e2fa1a6c9fda226b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f439873f25cb41c1690628a3f15999" id="r_a74f439873f25cb41c1690628a3f15999"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a74f439873f25cb41c1690628a3f15999">peak_prominences</a> (x, peaks, wlen=None)</td></tr>
<tr class="separator:a74f439873f25cb41c1690628a3f15999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fd0269f882b5937fe2cb4f48637241" id="r_a69fd0269f882b5937fe2cb4f48637241"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a69fd0269f882b5937fe2cb4f48637241">peak_widths</a> (x, peaks, rel_height=0.5, prominence_data=None, wlen=None)</td></tr>
<tr class="separator:a69fd0269f882b5937fe2cb4f48637241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707e43f9ea1fb27c7887cb9bd443bb36" id="r_a707e43f9ea1fb27c7887cb9bd443bb36"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a707e43f9ea1fb27c7887cb9bd443bb36">_unpack_condition_args</a> (interval, x, peaks)</td></tr>
<tr class="separator:a707e43f9ea1fb27c7887cb9bd443bb36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5205083c802b8c5db8e65f6300356ed6" id="r_a5205083c802b8c5db8e65f6300356ed6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a5205083c802b8c5db8e65f6300356ed6">_select_by_property</a> (peak_properties, pmin, pmax)</td></tr>
<tr class="separator:a5205083c802b8c5db8e65f6300356ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c27548cf1c4f29d7bac6adcb8aa397" id="r_a07c27548cf1c4f29d7bac6adcb8aa397"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a07c27548cf1c4f29d7bac6adcb8aa397">_select_by_peak_threshold</a> (x, peaks, tmin, tmax)</td></tr>
<tr class="separator:a07c27548cf1c4f29d7bac6adcb8aa397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc47decb695a648b0281cd4bbc018cf4" id="r_abc47decb695a648b0281cd4bbc018cf4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#abc47decb695a648b0281cd4bbc018cf4">find_peaks</a> (x, height=None, threshold=None, distance=None, prominence=None, width=None, wlen=None, rel_height=0.5, plateau_size=None)</td></tr>
<tr class="separator:abc47decb695a648b0281cd4bbc018cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae1d46babbb6337ceaef561c2d347b9" id="r_aeae1d46babbb6337ceaef561c2d347b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#aeae1d46babbb6337ceaef561c2d347b9">_identify_ridge_lines</a> (matr, max_distances, gap_thresh)</td></tr>
<tr class="separator:aeae1d46babbb6337ceaef561c2d347b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa965c24dfaf489986fad8270ec5a2f13" id="r_aa965c24dfaf489986fad8270ec5a2f13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#aa965c24dfaf489986fad8270ec5a2f13">_filter_ridge_lines</a> (cwt, ridge_lines, window_size=None, min_length=None, min_snr=1, noise_perc=10)</td></tr>
<tr class="separator:aa965c24dfaf489986fad8270ec5a2f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965539740f1f0f0b9fdb5df09e03bf5e" id="r_a965539740f1f0f0b9fdb5df09e03bf5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__peak__finding.html#a965539740f1f0f0b9fdb5df09e03bf5e">find_peaks_cwt</a> (vector, widths, wavelet=None, max_distances=None, gap_thresh=None, min_length=None, min_snr=1, noise_perc=10, window_size=None)</td></tr>
<tr class="separator:a965539740f1f0f0b9fdb5df09e03bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for identifying peaks in signals.
</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a09a4aa0b159096b2b2a9bd5484b43e6a" name="a09a4aa0b159096b2b2a9bd5484b43e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09a4aa0b159096b2b2a9bd5484b43e6a">&#9670;&#160;</a></span>_arg_peaks_as_expected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._arg_peaks_as_expected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure argument `peaks` is a 1-D C-contiguous array of dtype('intp').

Used in `peak_prominences` and `peak_widths` to make `peaks` compatible
with the signature of the wrapped Cython functions.

Returns
-------
value : ndarray
    A 1-D C-contiguous array with dtype('intp').
</pre> <div class="fragment"><div class="line"><span class="lineno">  267</span><span class="keyword">def </span>_arg_peaks_as_expected(value):</div>
<div class="line"><span class="lineno">  268</span>    <span class="stringliteral">&quot;&quot;&quot;Ensure argument `peaks` is a 1-D C-contiguous array of dtype(&#39;intp&#39;).</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral">    Used in `peak_prominences` and `peak_widths` to make `peaks` compatible</span></div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    with the signature of the wrapped Cython functions.</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    value : ndarray</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        A 1-D C-contiguous array with dtype(&#39;intp&#39;).</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  278</span>    value = np.asarray(value)</div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordflow">if</span> value.size == 0:</div>
<div class="line"><span class="lineno">  280</span>        <span class="comment"># Empty arrays default to np.float64 but are valid input</span></div>
<div class="line"><span class="lineno">  281</span>        value = np.array([], dtype=np.intp)</div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  283</span>        <span class="comment"># Safely convert to C-contiguous array of type np.intp</span></div>
<div class="line"><span class="lineno">  284</span>        value = value.astype(np.intp, order=<span class="stringliteral">&#39;C&#39;</span>, casting=<span class="stringliteral">&#39;safe&#39;</span>,</div>
<div class="line"><span class="lineno">  285</span>                             subok=<span class="keyword">False</span>, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  287</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;cannot safely cast `peaks` to dtype(&#39;intp&#39;)&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">if</span> value.ndim != 1:</div>
<div class="line"><span class="lineno">  289</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`peaks` must be a 1-D array&#39;</span>)</div>
<div class="line"><span class="lineno">  290</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  291</span> </div>
<div class="line"><span class="lineno">  292</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0a652a48cb6116e2fa1a6c9fda226b1" name="ab0a652a48cb6116e2fa1a6c9fda226b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a652a48cb6116e2fa1a6c9fda226b1">&#9670;&#160;</a></span>_arg_wlen_as_expected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._arg_wlen_as_expected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure argument `wlen` is of type `np.intp` and larger than 1.

Used in `peak_prominences` and `peak_widths`.

Returns
-------
value : np.intp
    The original `value` rounded up to an integer or -1 if `value` was
    None.
</pre> <div class="fragment"><div class="line"><span class="lineno">  293</span><span class="keyword">def </span>_arg_wlen_as_expected(value):</div>
<div class="line"><span class="lineno">  294</span>    <span class="stringliteral">&quot;&quot;&quot;Ensure argument `wlen` is of type `np.intp` and larger than 1.</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">    Used in `peak_prominences` and `peak_widths`.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">    value : np.intp</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        The original `value` rounded up to an integer or -1 if `value` was</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">        None.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  304</span>    <span class="keywordflow">if</span> value <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  305</span>        <span class="comment"># _peak_prominences expects an intp; -1 signals that no value was</span></div>
<div class="line"><span class="lineno">  306</span>        <span class="comment"># supplied by the user</span></div>
<div class="line"><span class="lineno">  307</span>        value = -1</div>
<div class="line"><span class="lineno">  308</span>    <span class="keywordflow">elif</span> 1 &lt; value:</div>
<div class="line"><span class="lineno">  309</span>        <span class="comment"># Round up to a positive integer</span></div>
<div class="line"><span class="lineno">  310</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.can_cast(value, np.intp, <span class="stringliteral">&quot;safe&quot;</span>):</div>
<div class="line"><span class="lineno">  311</span>            value = math.ceil(value)</div>
<div class="line"><span class="lineno">  312</span>        value = np.intp(value)</div>
<div class="line"><span class="lineno">  313</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  314</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`wlen` must be larger than 1, was {}&#39;</span></div>
<div class="line"><span class="lineno">  315</span>                         .format(value))</div>
<div class="line"><span class="lineno">  316</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  317</span> </div>
<div class="line"><span class="lineno">  318</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f1d24b40496cb9253fb27a3167a0ddd" name="a5f1d24b40496cb9253fb27a3167a0ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d24b40496cb9253fb27a3167a0ddd">&#9670;&#160;</a></span>_arg_x_as_expected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._arg_x_as_expected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure argument `x` is a 1-D C-contiguous array of dtype('float64').

Used in `find_peaks`, `peak_prominences` and `peak_widths` to make `x`
compatible with the signature of the wrapped Cython functions.

Returns
-------
value : ndarray
    A 1-D C-contiguous array with dtype('float64').
</pre> <div class="fragment"><div class="line"><span class="lineno">  250</span><span class="keyword">def </span>_arg_x_as_expected(value):</div>
<div class="line"><span class="lineno">  251</span>    <span class="stringliteral">&quot;&quot;&quot;Ensure argument `x` is a 1-D C-contiguous array of dtype(&#39;float64&#39;).</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    Used in `find_peaks`, `peak_prominences` and `peak_widths` to make `x`</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    compatible with the signature of the wrapped Cython functions.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  256</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  257</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  258</span><span class="stringliteral">    value : ndarray</span></div>
<div class="line"><span class="lineno">  259</span><span class="stringliteral">        A 1-D C-contiguous array with dtype(&#39;float64&#39;).</span></div>
<div class="line"><span class="lineno">  260</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  261</span>    value = np.asarray(value, order=<span class="stringliteral">&#39;C&#39;</span>, dtype=np.float64)</div>
<div class="line"><span class="lineno">  262</span>    <span class="keywordflow">if</span> value.ndim != 1:</div>
<div class="line"><span class="lineno">  263</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`x` must be a 1-D array&#39;</span>)</div>
<div class="line"><span class="lineno">  264</span>    <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab855d9e2608dc3b8d651b1f9fed85804" name="ab855d9e2608dc3b8d651b1f9fed85804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab855d9e2608dc3b8d651b1f9fed85804">&#9670;&#160;</a></span>_boolrelextrema()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._boolrelextrema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'clip'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Calculate the relative extrema of `data`.

Relative extrema are calculated by finding locations where
``comparator(data[n], data[n+1:n+order+1])`` is True.

Parameters
----------
data : ndarray
    Array in which to find the relative extrema.
comparator : callable
    Function to use to compare two data points.
    Should take two arrays as arguments.
axis : int, optional
    Axis over which to select from `data`. Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n,n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated. 'wrap' (wrap around) or
    'clip' (treat overflow as the same as the last (or first) element).
    Default 'clip'. See numpy.take.

Returns
-------
extrema : ndarray
    Boolean array of the same shape as `data` that is True at an extrema,
    False otherwise.

See also
--------
argrelmax, argrelmin

Examples
--------
&gt;&gt;&gt; testdata = np.array([1,2,3,2,1])
&gt;&gt;&gt; _boolrelextrema(testdata, np.greater, axis=0)
array([False, False,  True, False, False], dtype=bool)</pre> <div class="fragment"><div class="line"><span class="lineno">   22</span><span class="keyword">def </span>_boolrelextrema(data, comparator, axis=0, order=1, mode=&#39;clip&#39;):</div>
<div class="line"><span class="lineno">   23</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    Calculate the relative extrema of `data`.</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    Relative extrema are calculated by finding locations where</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">    ``comparator(data[n], data[n+1:n+order+1])`` is True.</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">    data : ndarray</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral">        Array in which to find the relative extrema.</span></div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    comparator : callable</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">        Function to use to compare two data points.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">        Should take two arrays as arguments.</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">        Axis over which to select from `data`. Default is 0.</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        How many points on each side to use for the comparison</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        to consider ``comparator(n,n+x)`` to be True.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">        How the edges of the vector are treated. &#39;wrap&#39; (wrap around) or</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        &#39;clip&#39; (treat overflow as the same as the last (or first) element).</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">        Default &#39;clip&#39;. See numpy.take.</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">    extrema : ndarray</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        Boolean array of the same shape as `data` that is True at an extrema,</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        False otherwise.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">    argrelmax, argrelmin</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    &gt;&gt;&gt; testdata = np.array([1,2,3,2,1])</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    &gt;&gt;&gt; _boolrelextrema(testdata, np.greater, axis=0)</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">    array([False, False,  True, False, False], dtype=bool)</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   63</span>    if((int(order) != order) <span class="keywordflow">or</span> (order &lt; 1)):</div>
<div class="line"><span class="lineno">   64</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Order must be an int &gt;= 1&#39;</span>)</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span>    datalen = data.shape[axis]</div>
<div class="line"><span class="lineno">   67</span>    locs = np.arange(0, datalen)</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>    results = np.ones(data.shape, dtype=bool)</div>
<div class="line"><span class="lineno">   70</span>    main = data.take(locs, axis=axis, mode=mode)</div>
<div class="line"><span class="lineno">   71</span>    <span class="keywordflow">for</span> shift <span class="keywordflow">in</span> range(1, order + 1):</div>
<div class="line"><span class="lineno">   72</span>        plus = data.take(locs + shift, axis=axis, mode=mode)</div>
<div class="line"><span class="lineno">   73</span>        minus = data.take(locs - shift, axis=axis, mode=mode)</div>
<div class="line"><span class="lineno">   74</span>        results &amp;= comparator(main, plus)</div>
<div class="line"><span class="lineno">   75</span>        results &amp;= comparator(main, minus)</div>
<div class="line"><span class="lineno">   76</span>        if(~results.any()):</div>
<div class="line"><span class="lineno">   77</span>            <span class="keywordflow">return</span> results</div>
<div class="line"><span class="lineno">   78</span>    <span class="keywordflow">return</span> results</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa965c24dfaf489986fad8270ec5a2f13" name="aa965c24dfaf489986fad8270ec5a2f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa965c24dfaf489986fad8270ec5a2f13">&#9670;&#160;</a></span>_filter_ridge_lines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._filter_ridge_lines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cwt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ridge_lines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_snr</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noise_perc</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Filter ridge lines according to prescribed criteria. Intended
to be used for finding relative maxima.

Parameters
----------
cwt : 2-D ndarray
    Continuous wavelet transform from which the `ridge_lines` were defined.
ridge_lines : 1-D sequence
    Each element should contain 2 sequences, the rows and columns
    of the ridge line (respectively).
window_size : int, optional
    Size of window to use to calculate noise floor.
    Default is ``cwt.shape[1] / 20``.
min_length : int, optional
    Minimum length a ridge line needs to be acceptable.
    Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.
min_snr : float, optional
    Minimum SNR ratio. Default 1. The signal is the value of
    the cwt matrix at the shortest length scale (``cwt[0, loc]``), the
    noise is the `noise_perc`th percentile of datapoints contained within a
    window of `window_size` around ``cwt[0, loc]``.
noise_perc : float, optional
    When calculating the noise floor, percentile of data points
    examined below which to consider noise. Calculated using
    scipy.stats.scoreatpercentile.

References
----------
.. [1] Bioinformatics (2006) 22 (17): 2059-2065.
   :doi:`10.1093/bioinformatics/btl355`</pre> <div class="fragment"><div class="line"><span class="lineno"> 1127</span>                        min_snr=1, noise_perc=10):</div>
<div class="line"><span class="lineno"> 1128</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    Filter ridge lines according to prescribed criteria. Intended</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    to be used for finding relative maxima.</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    cwt : 2-D ndarray</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">        Continuous wavelet transform from which the `ridge_lines` were defined.</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    ridge_lines : 1-D sequence</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">        Each element should contain 2 sequences, the rows and columns</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">        of the ridge line (respectively).</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    window_size : int, optional</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">        Size of window to use to calculate noise floor.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">        Default is ``cwt.shape[1] / 20``.</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    min_length : int, optional</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">        Minimum length a ridge line needs to be acceptable.</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">        Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral">    min_snr : float, optional</span></div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">        Minimum SNR ratio. Default 1. The signal is the value of</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">        the cwt matrix at the shortest length scale (``cwt[0, loc]``), the</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        noise is the `noise_perc`th percentile of datapoints contained within a</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">        window of `window_size` around ``cwt[0, loc]``.</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    noise_perc : float, optional</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">        When calculating the noise floor, percentile of data points</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">        examined below which to consider noise. Calculated using</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">        scipy.stats.scoreatpercentile.</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    .. [1] Bioinformatics (2006) 22 (17): 2059-2065.</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">       :doi:`10.1093/bioinformatics/btl355`</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1161</span>    num_points = cwt.shape[1]</div>
<div class="line"><span class="lineno"> 1162</span>    <span class="keywordflow">if</span> min_length <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1163</span>        min_length = np.ceil(cwt.shape[0] / 4)</div>
<div class="line"><span class="lineno"> 1164</span>    <span class="keywordflow">if</span> window_size <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1165</span>        window_size = np.ceil(num_points / 20)</div>
<div class="line"><span class="lineno"> 1166</span> </div>
<div class="line"><span class="lineno"> 1167</span>    window_size = int(window_size)</div>
<div class="line"><span class="lineno"> 1168</span>    hf_window, odd = divmod(window_size, 2)</div>
<div class="line"><span class="lineno"> 1169</span> </div>
<div class="line"><span class="lineno"> 1170</span>    <span class="comment"># Filter based on SNR</span></div>
<div class="line"><span class="lineno"> 1171</span>    row_one = cwt[0, :]</div>
<div class="line"><span class="lineno"> 1172</span>    noises = np.empty_like(row_one)</div>
<div class="line"><span class="lineno"> 1173</span>    <span class="keywordflow">for</span> ind, val <span class="keywordflow">in</span> enumerate(row_one):</div>
<div class="line"><span class="lineno"> 1174</span>        window_start = max(ind - hf_window, 0)</div>
<div class="line"><span class="lineno"> 1175</span>        window_end = min(ind + hf_window + odd, num_points)</div>
<div class="line"><span class="lineno"> 1176</span>        noises[ind] = scoreatpercentile(row_one[window_start:window_end],</div>
<div class="line"><span class="lineno"> 1177</span>                                        per=noise_perc)</div>
<div class="line"><span class="lineno"> 1178</span> </div>
<div class="line"><span class="lineno"> 1179</span>    <span class="keyword">def </span>filt_func(line):</div>
<div class="line"><span class="lineno"> 1180</span>        <span class="keywordflow">if</span> len(line[0]) &lt; min_length:</div>
<div class="line"><span class="lineno"> 1181</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1182</span>        snr = abs(cwt[line[0][0], line[1][0]] / noises[line[1][0]])</div>
<div class="line"><span class="lineno"> 1183</span>        <span class="keywordflow">if</span> snr &lt; min_snr:</div>
<div class="line"><span class="lineno"> 1184</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1185</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1186</span> </div>
<div class="line"><span class="lineno"> 1187</span>    <span class="keywordflow">return</span> list(filter(filt_func, ridge_lines))</div>
<div class="line"><span class="lineno"> 1188</span> </div>
<div class="line"><span class="lineno"> 1189</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aeae1d46babbb6337ceaef561c2d347b9" name="aeae1d46babbb6337ceaef561c2d347b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeae1d46babbb6337ceaef561c2d347b9">&#9670;&#160;</a></span>_identify_ridge_lines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._identify_ridge_lines </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>matr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gap_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Identify ridges in the 2-D matrix.

Expect that the width of the wavelet feature increases with increasing row
number.

Parameters
----------
matr : 2-D ndarray
    Matrix in which to identify ridge lines.
max_distances : 1-D sequence
    At each row, a ridge line is only connected
    if the relative max at row[n] is within
    `max_distances`[n] from the relative max at row[n+1].
gap_thresh : int
    If a relative maximum is not found within `max_distances`,
    there will be a gap. A ridge line is discontinued if
    there are more than `gap_thresh` points without connecting
    a new relative maximum.

Returns
-------
ridge_lines : tuple
    Tuple of 2 1-D sequences. `ridge_lines`[ii][0] are the rows of the
    ii-th ridge-line, `ridge_lines`[ii][1] are the columns. Empty if none
    found.  Each ridge-line will be sorted by row (increasing), but the
    order of the ridge lines is not specified.

References
----------
.. [1] Bioinformatics (2006) 22 (17): 2059-2065.
   :doi:`10.1093/bioinformatics/btl355`

Examples
--------
&gt;&gt;&gt; rng = np.random.default_rng()
&gt;&gt;&gt; data = rng.random((5,5))
&gt;&gt;&gt; ridge_lines = _identify_ridge_lines(data, 1, 1)

Notes
-----
This function is intended to be used in conjunction with `cwt`
as part of `find_peaks_cwt`.</pre> <div class="fragment"><div class="line"><span class="lineno"> 1006</span><span class="keyword">def </span>_identify_ridge_lines(matr, max_distances, gap_thresh):</div>
<div class="line"><span class="lineno"> 1007</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1008</span><span class="stringliteral">    Identify ridges in the 2-D matrix.</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1010</span><span class="stringliteral">    Expect that the width of the wavelet feature increases with increasing row</span></div>
<div class="line"><span class="lineno"> 1011</span><span class="stringliteral">    number.</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    matr : 2-D ndarray</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral">        Matrix in which to identify ridge lines.</span></div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    max_distances : 1-D sequence</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">        At each row, a ridge line is only connected</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">        if the relative max at row[n] is within</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral">        `max_distances`[n] from the relative max at row[n+1].</span></div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    gap_thresh : int</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">        If a relative maximum is not found within `max_distances`,</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">        there will be a gap. A ridge line is discontinued if</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">        there are more than `gap_thresh` points without connecting</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral">        a new relative maximum.</span></div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ridge_lines : tuple</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">        Tuple of 2 1-D sequences. `ridge_lines`[ii][0] are the rows of the</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        ii-th ridge-line, `ridge_lines`[ii][1] are the columns. Empty if none</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        found.  Each ridge-line will be sorted by row (increasing), but the</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        order of the ridge lines is not specified.</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    .. [1] Bioinformatics (2006) 22 (17): 2059-2065.</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">       :doi:`10.1093/bioinformatics/btl355`</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">    &gt;&gt;&gt; rng = np.random.default_rng()</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    &gt;&gt;&gt; data = rng.random((5,5))</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">    &gt;&gt;&gt; ridge_lines = _identify_ridge_lines(data, 1, 1)</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">    This function is intended to be used in conjunction with `cwt`</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">    as part of `find_peaks_cwt`.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1052</span>    if(len(max_distances) &lt; matr.shape[0]):</div>
<div class="line"><span class="lineno"> 1053</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Max_distances must have at least as many rows &#39;</span></div>
<div class="line"><span class="lineno"> 1054</span>                         <span class="stringliteral">&#39;as matr&#39;</span>)</div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="line"><span class="lineno"> 1056</span>    all_max_cols = _boolrelextrema(matr, np.greater, axis=1, order=1)</div>
<div class="line"><span class="lineno"> 1057</span>    <span class="comment"># Highest row for which there are any relative maxima</span></div>
<div class="line"><span class="lineno"> 1058</span>    has_relmax = np.nonzero(all_max_cols.any(axis=1))[0]</div>
<div class="line"><span class="lineno"> 1059</span>    if(len(has_relmax) == 0):</div>
<div class="line"><span class="lineno"> 1060</span>        <span class="keywordflow">return</span> []</div>
<div class="line"><span class="lineno"> 1061</span>    start_row = has_relmax[-1]</div>
<div class="line"><span class="lineno"> 1062</span>    <span class="comment"># Each ridge line is a 3-tuple:</span></div>
<div class="line"><span class="lineno"> 1063</span>    <span class="comment"># rows, cols,Gap number</span></div>
<div class="line"><span class="lineno"> 1064</span>    ridge_lines = [[[start_row],</div>
<div class="line"><span class="lineno"> 1065</span>                   [col],</div>
<div class="line"><span class="lineno"> 1066</span>                   0] <span class="keywordflow">for</span> col <span class="keywordflow">in</span> np.nonzero(all_max_cols[start_row])[0]]</div>
<div class="line"><span class="lineno"> 1067</span>    final_lines = []</div>
<div class="line"><span class="lineno"> 1068</span>    rows = np.arange(start_row - 1, -1, -1)</div>
<div class="line"><span class="lineno"> 1069</span>    cols = np.arange(0, matr.shape[1])</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="keywordflow">for</span> row <span class="keywordflow">in</span> rows:</div>
<div class="line"><span class="lineno"> 1071</span>        this_max_cols = cols[all_max_cols[row]]</div>
<div class="line"><span class="lineno"> 1072</span> </div>
<div class="line"><span class="lineno"> 1073</span>        <span class="comment"># Increment gap number of each line,</span></div>
<div class="line"><span class="lineno"> 1074</span>        <span class="comment"># set it to zero later if appropriate</span></div>
<div class="line"><span class="lineno"> 1075</span>        <span class="keywordflow">for</span> line <span class="keywordflow">in</span> ridge_lines:</div>
<div class="line"><span class="lineno"> 1076</span>            line[2] += 1</div>
<div class="line"><span class="lineno"> 1077</span> </div>
<div class="line"><span class="lineno"> 1078</span>        <span class="comment"># XXX These should always be all_max_cols[row]</span></div>
<div class="line"><span class="lineno"> 1079</span>        <span class="comment"># But the order might be different. Might be an efficiency gain</span></div>
<div class="line"><span class="lineno"> 1080</span>        <span class="comment"># to make sure the order is the same and avoid this iteration</span></div>
<div class="line"><span class="lineno"> 1081</span>        prev_ridge_cols = np.array([line[1][-1] <span class="keywordflow">for</span> line <span class="keywordflow">in</span> ridge_lines])</div>
<div class="line"><span class="lineno"> 1082</span>        <span class="comment"># Look through every relative maximum found at current row</span></div>
<div class="line"><span class="lineno"> 1083</span>        <span class="comment"># Attempt to connect them with existing ridge lines.</span></div>
<div class="line"><span class="lineno"> 1084</span>        <span class="keywordflow">for</span> ind, col <span class="keywordflow">in</span> enumerate(this_max_cols):</div>
<div class="line"><span class="lineno"> 1085</span>            <span class="comment"># If there is a previous ridge line within</span></div>
<div class="line"><span class="lineno"> 1086</span>            <span class="comment"># the max_distance to connect to, do so.</span></div>
<div class="line"><span class="lineno"> 1087</span>            <span class="comment"># Otherwise start a new one.</span></div>
<div class="line"><span class="lineno"> 1088</span>            line = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1089</span>            if(len(prev_ridge_cols) &gt; 0):</div>
<div class="line"><span class="lineno"> 1090</span>                diffs = np.abs(col - prev_ridge_cols)</div>
<div class="line"><span class="lineno"> 1091</span>                closest = np.argmin(diffs)</div>
<div class="line"><span class="lineno"> 1092</span>                <span class="keywordflow">if</span> diffs[closest] &lt;= max_distances[row]:</div>
<div class="line"><span class="lineno"> 1093</span>                    line = ridge_lines[closest]</div>
<div class="line"><span class="lineno"> 1094</span>            if(line <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1095</span>                <span class="comment"># Found a point close enough, extend current ridge line</span></div>
<div class="line"><span class="lineno"> 1096</span>                line[1].append(col)</div>
<div class="line"><span class="lineno"> 1097</span>                line[0].append(row)</div>
<div class="line"><span class="lineno"> 1098</span>                line[2] = 0</div>
<div class="line"><span class="lineno"> 1099</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1100</span>                new_line = [[row],</div>
<div class="line"><span class="lineno"> 1101</span>                            [col],</div>
<div class="line"><span class="lineno"> 1102</span>                            0]</div>
<div class="line"><span class="lineno"> 1103</span>                ridge_lines.append(new_line)</div>
<div class="line"><span class="lineno"> 1104</span> </div>
<div class="line"><span class="lineno"> 1105</span>        <span class="comment"># Remove the ridge lines with gap_number too high</span></div>
<div class="line"><span class="lineno"> 1106</span>        <span class="comment"># XXX Modifying a list while iterating over it.</span></div>
<div class="line"><span class="lineno"> 1107</span>        <span class="comment"># Should be safe, since we iterate backwards, but</span></div>
<div class="line"><span class="lineno"> 1108</span>        <span class="comment"># still tacky.</span></div>
<div class="line"><span class="lineno"> 1109</span>        <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> range(len(ridge_lines) - 1, -1, -1):</div>
<div class="line"><span class="lineno"> 1110</span>            line = ridge_lines[ind]</div>
<div class="line"><span class="lineno"> 1111</span>            <span class="keywordflow">if</span> line[2] &gt; gap_thresh:</div>
<div class="line"><span class="lineno"> 1112</span>                final_lines.append(line)</div>
<div class="line"><span class="lineno"> 1113</span>                del ridge_lines[ind]</div>
<div class="line"><span class="lineno"> 1114</span> </div>
<div class="line"><span class="lineno"> 1115</span>    out_lines = []</div>
<div class="line"><span class="lineno"> 1116</span>    <span class="keywordflow">for</span> line <span class="keywordflow">in</span> (final_lines + ridge_lines):</div>
<div class="line"><span class="lineno"> 1117</span>        sortargs = np.array(np.argsort(line[0]))</div>
<div class="line"><span class="lineno"> 1118</span>        rows, cols = np.zeros_like(sortargs), np.zeros_like(sortargs)</div>
<div class="line"><span class="lineno"> 1119</span>        rows[sortargs] = line[0]</div>
<div class="line"><span class="lineno"> 1120</span>        cols[sortargs] = line[1]</div>
<div class="line"><span class="lineno"> 1121</span>        out_lines.append([rows, cols])</div>
<div class="line"><span class="lineno"> 1122</span> </div>
<div class="line"><span class="lineno"> 1123</span>    <span class="keywordflow">return</span> out_lines</div>
<div class="line"><span class="lineno"> 1124</span> </div>
<div class="line"><span class="lineno"> 1125</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a07c27548cf1c4f29d7bac6adcb8aa397" name="a07c27548cf1c4f29d7bac6adcb8aa397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c27548cf1c4f29d7bac6adcb8aa397">&#9670;&#160;</a></span>_select_by_peak_threshold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._select_by_peak_threshold </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Evaluate which peaks fulfill the threshold condition.

Parameters
----------
x : ndarray
    A 1-D array which is indexable by `peaks`.
peaks : ndarray
    Indices of peaks in `x`.
tmin, tmax : scalar or ndarray or None
     Minimal and / or maximal required thresholds. If supplied as ndarrays
     their size must match `peaks`. ``None`` is interpreted as an open
     border.

Returns
-------
keep : bool
    A boolean mask evaluating to true where `peaks` fulfill the threshold
    condition.
left_thresholds, right_thresholds : ndarray
    Array matching `peak` containing the thresholds of each peak on
    both sides.

Notes
-----

.. versionadded:: 1.1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  678</span><span class="keyword">def </span>_select_by_peak_threshold(x, peaks, tmin, tmax):</div>
<div class="line"><span class="lineno">  679</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    Evaluate which peaks fulfill the threshold condition.</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        A 1-D array which is indexable by `peaks`.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral">    peaks : ndarray</span></div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        Indices of peaks in `x`.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    tmin, tmax : scalar or ndarray or None</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral">         Minimal and / or maximal required thresholds. If supplied as ndarrays</span></div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">         their size must match `peaks`. ``None`` is interpreted as an open</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">         border.</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    keep : bool</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">        A boolean mask evaluating to true where `peaks` fulfill the threshold</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        condition.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">    left_thresholds, right_thresholds : ndarray</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        Array matching `peak` containing the thresholds of each peak on</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        both sides.</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  707</span>    <span class="comment"># Stack thresholds on both sides to make min / max operations easier:</span></div>
<div class="line"><span class="lineno">  708</span>    <span class="comment"># tmin is compared with the smaller, and tmax with the greater thresold to</span></div>
<div class="line"><span class="lineno">  709</span>    <span class="comment"># each peak&#39;s side</span></div>
<div class="line"><span class="lineno">  710</span>    stacked_thresholds = np.vstack([x[peaks] - x[peaks - 1],</div>
<div class="line"><span class="lineno">  711</span>                                    x[peaks] - x[peaks + 1]])</div>
<div class="line"><span class="lineno">  712</span>    keep = np.ones(peaks.size, dtype=bool)</div>
<div class="line"><span class="lineno">  713</span>    <span class="keywordflow">if</span> tmin <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  714</span>        min_thresholds = np.min(stacked_thresholds, axis=0)</div>
<div class="line"><span class="lineno">  715</span>        keep &amp;= (tmin &lt;= min_thresholds)</div>
<div class="line"><span class="lineno">  716</span>    <span class="keywordflow">if</span> tmax <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  717</span>        max_thresholds = np.max(stacked_thresholds, axis=0)</div>
<div class="line"><span class="lineno">  718</span>        keep &amp;= (max_thresholds &lt;= tmax)</div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span>    <span class="keywordflow">return</span> keep, stacked_thresholds[0], stacked_thresholds[1]</div>
<div class="line"><span class="lineno">  721</span> </div>
<div class="line"><span class="lineno">  722</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5205083c802b8c5db8e65f6300356ed6" name="a5205083c802b8c5db8e65f6300356ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5205083c802b8c5db8e65f6300356ed6">&#9670;&#160;</a></span>_select_by_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._select_by_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>peak_properties</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pmax</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Evaluate where the generic property of peaks confirms to an interval.

Parameters
----------
peak_properties : ndarray
    An array with properties for each peak.
pmin : None or number or ndarray
    Lower interval boundary for `peak_properties`. ``None`` is interpreted as
    an open border.
pmax : None or number or ndarray
    Upper interval boundary for `peak_properties`. ``None`` is interpreted as
    an open border.

Returns
-------
keep : bool
    A boolean mask evaluating to true where `peak_properties` confirms to the
    interval.

See Also
--------
find_peaks

Notes
-----

.. versionadded:: 1.1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  640</span><span class="keyword">def </span>_select_by_property(peak_properties, pmin, pmax):</div>
<div class="line"><span class="lineno">  641</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  642</span><span class="stringliteral">    Evaluate where the generic property of peaks confirms to an interval.</span></div>
<div class="line"><span class="lineno">  643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  644</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  645</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  646</span><span class="stringliteral">    peak_properties : ndarray</span></div>
<div class="line"><span class="lineno">  647</span><span class="stringliteral">        An array with properties for each peak.</span></div>
<div class="line"><span class="lineno">  648</span><span class="stringliteral">    pmin : None or number or ndarray</span></div>
<div class="line"><span class="lineno">  649</span><span class="stringliteral">        Lower interval boundary for `peak_properties`. ``None`` is interpreted as</span></div>
<div class="line"><span class="lineno">  650</span><span class="stringliteral">        an open border.</span></div>
<div class="line"><span class="lineno">  651</span><span class="stringliteral">    pmax : None or number or ndarray</span></div>
<div class="line"><span class="lineno">  652</span><span class="stringliteral">        Upper interval boundary for `peak_properties`. ``None`` is interpreted as</span></div>
<div class="line"><span class="lineno">  653</span><span class="stringliteral">        an open border.</span></div>
<div class="line"><span class="lineno">  654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  655</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral">    keep : bool</span></div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        A boolean mask evaluating to true where `peak_properties` confirms to the</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        interval.</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral">    find_peaks</span></div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  670</span>    keep = np.ones(peak_properties.size, dtype=bool)</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">if</span> pmin <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  672</span>        keep &amp;= (pmin &lt;= peak_properties)</div>
<div class="line"><span class="lineno">  673</span>    <span class="keywordflow">if</span> pmax <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  674</span>        keep &amp;= (peak_properties &lt;= pmax)</div>
<div class="line"><span class="lineno">  675</span>    <span class="keywordflow">return</span> keep</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a707e43f9ea1fb27c7887cb9bd443bb36" name="a707e43f9ea1fb27c7887cb9bd443bb36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a707e43f9ea1fb27c7887cb9bd443bb36">&#9670;&#160;</a></span>_unpack_condition_args()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding._unpack_condition_args </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>peaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Parse condition arguments for `find_peaks`.

Parameters
----------
interval : number or ndarray or sequence
    Either a number or ndarray or a 2-element sequence of the former. The
    first value is always interpreted as `imin` and the second, if supplied,
    as `imax`.
x : ndarray
    The signal with `peaks`.
peaks : ndarray
    An array with indices used to reduce `imin` and / or `imax` if those are
    arrays.

Returns
-------
imin, imax : number or ndarray or None
    Minimal and maximal value in `argument`.

Raises
------
ValueError :
    If interval border is given as array and its size does not match the size
    of `x`.

Notes
-----

.. versionadded:: 1.1.0
</pre> <div class="fragment"><div class="line"><span class="lineno">  590</span><span class="keyword">def </span>_unpack_condition_args(interval, x, peaks):</div>
<div class="line"><span class="lineno">  591</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">    Parse condition arguments for `find_peaks`.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  596</span><span class="stringliteral">    interval : number or ndarray or sequence</span></div>
<div class="line"><span class="lineno">  597</span><span class="stringliteral">        Either a number or ndarray or a 2-element sequence of the former. The</span></div>
<div class="line"><span class="lineno">  598</span><span class="stringliteral">        first value is always interpreted as `imin` and the second, if supplied,</span></div>
<div class="line"><span class="lineno">  599</span><span class="stringliteral">        as `imax`.</span></div>
<div class="line"><span class="lineno">  600</span><span class="stringliteral">    x : ndarray</span></div>
<div class="line"><span class="lineno">  601</span><span class="stringliteral">        The signal with `peaks`.</span></div>
<div class="line"><span class="lineno">  602</span><span class="stringliteral">    peaks : ndarray</span></div>
<div class="line"><span class="lineno">  603</span><span class="stringliteral">        An array with indices used to reduce `imin` and / or `imax` if those are</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        arrays.</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral">    imin, imax : number or ndarray or None</span></div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">        Minimal and maximal value in `argument`.</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    ValueError :</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">        If interval border is given as array and its size does not match the size</span></div>
<div class="line"><span class="lineno">  615</span><span class="stringliteral">        of `x`.</span></div>
<div class="line"><span class="lineno">  616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  617</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  618</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  619</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  620</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  621</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  622</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  623</span>        imin, imax = interval</div>
<div class="line"><span class="lineno">  624</span>    <span class="keywordflow">except</span> (TypeError, ValueError):</div>
<div class="line"><span class="lineno">  625</span>        imin, imax = (interval, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  626</span> </div>
<div class="line"><span class="lineno">  627</span>    <span class="comment"># Reduce arrays if arrays</span></div>
<div class="line"><span class="lineno">  628</span>    <span class="keywordflow">if</span> isinstance(imin, np.ndarray):</div>
<div class="line"><span class="lineno">  629</span>        <span class="keywordflow">if</span> imin.size != x.size:</div>
<div class="line"><span class="lineno">  630</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;array size of lower interval border must match x&#39;</span>)</div>
<div class="line"><span class="lineno">  631</span>        imin = imin[peaks]</div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">if</span> isinstance(imax, np.ndarray):</div>
<div class="line"><span class="lineno">  633</span>        <span class="keywordflow">if</span> imax.size != x.size:</div>
<div class="line"><span class="lineno">  634</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;array size of upper interval border must match x&#39;</span>)</div>
<div class="line"><span class="lineno">  635</span>        imax = imax[peaks]</div>
<div class="line"><span class="lineno">  636</span> </div>
<div class="line"><span class="lineno">  637</span>    <span class="keywordflow">return</span> imin, imax</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8015d8ec4044a941b4c63c635abbed86" name="a8015d8ec4044a941b4c63c635abbed86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8015d8ec4044a941b4c63c635abbed86">&#9670;&#160;</a></span>argrelextrema()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.argrelextrema </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comparator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'clip'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the relative extrema of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative extrema.
comparator : callable
    Function to use to compare two data points.
    Should take two arrays as arguments.
axis : int, optional
    Axis over which to select from `data`. Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated. 'wrap' (wrap around) or
    'clip' (treat overflow as the same as the last (or first) element).
    Default is 'clip'. See `numpy.take`.

Returns
-------
extrema : tuple of ndarrays
    Indices of the maxima in arrays of integers. ``extrema[k]`` is
    the array of indices of axis `k` of `data`. Note that the
    return value is a tuple even when `data` is 1-D.

See Also
--------
argrelmin, argrelmax

Notes
-----

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import argrelextrema
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelextrema(x, np.greater)
(array([3, 6]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelextrema(y, np.less, axis=1)
(array([0, 2]), array([2, 1]))</pre> <div class="fragment"><div class="line"><span class="lineno">  194</span><span class="keyword">def </span>argrelextrema(data, comparator, axis=0, order=1, mode=&#39;clip&#39;):</div>
<div class="line"><span class="lineno">  195</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    Calculate the relative extrema of `data`.</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    data : ndarray</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">        Array in which to find the relative extrema.</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    comparator : callable</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        Function to use to compare two data points.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        Should take two arrays as arguments.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        Axis over which to select from `data`. Default is 0.</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        How many points on each side to use for the comparison</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">        to consider ``comparator(n, n+x)`` to be True.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">        How the edges of the vector are treated. &#39;wrap&#39; (wrap around) or</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        &#39;clip&#39; (treat overflow as the same as the last (or first) element).</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        Default is &#39;clip&#39;. See `numpy.take`.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    extrema : tuple of ndarrays</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">        Indices of the maxima in arrays of integers. ``extrema[k]`` is</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">        the array of indices of axis `k` of `data`. Note that the</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        return value is a tuple even when `data` is 1-D.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">    argrelmin, argrelmax</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import argrelextrema</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    &gt;&gt;&gt; argrelextrema(x, np.greater)</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    (array([3, 6]),)</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2],</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    ...               [2, 2, 0, 0],</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    ...               [5, 3, 4, 4]])</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; argrelextrema(y, np.less, axis=1)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    (array([0, 2]), array([2, 1]))</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  245</span>    results = _boolrelextrema(data, comparator,</div>
<div class="line"><span class="lineno">  246</span>                              axis, order, mode)</div>
<div class="line"><span class="lineno">  247</span>    <span class="keywordflow">return</span> np.nonzero(results)</div>
<div class="line"><span class="lineno">  248</span> </div>
<div class="line"><span class="lineno">  249</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8bdab1483729a45cad1df3c8ec962420" name="a8bdab1483729a45cad1df3c8ec962420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdab1483729a45cad1df3c8ec962420">&#9670;&#160;</a></span>argrelmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.argrelmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'clip'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the relative maxima of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative maxima.
axis : int, optional
    Axis over which to select from `data`. Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated.
    Available options are 'wrap' (wrap around) or 'clip' (treat overflow
    as the same as the last (or first) element).
    Default 'clip'. See `numpy.take`.

Returns
-------
extrema : tuple of ndarrays
    Indices of the maxima in arrays of integers. ``extrema[k]`` is
    the array of indices of axis `k` of `data`. Note that the
    return value is a tuple even when `data` is 1-D.

See Also
--------
argrelextrema, argrelmin, find_peaks

Notes
-----
This function uses `argrelextrema` with np.greater as comparator. Therefore,
it  requires a strict inequality on both sides of a value to consider it a
maximum. This means flat maxima (more than one sample wide) are not detected.
In case of 1-D `data` `find_peaks` can be used to detect all
local maxima, including flat ones.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import argrelmax
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelmax(x)
(array([3, 6]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelmax(y, axis=1)
(array([0]), array([1]))
</pre> <div class="fragment"><div class="line"><span class="lineno">  138</span><span class="keyword">def </span>argrelmax(data, axis=0, order=1, mode=&#39;clip&#39;):</div>
<div class="line"><span class="lineno">  139</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">    Calculate the relative maxima of `data`.</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">    data : ndarray</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">        Array in which to find the relative maxima.</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">        Axis over which to select from `data`. Default is 0.</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        How many points on each side to use for the comparison</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">        to consider ``comparator(n, n+x)`` to be True.</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        How the edges of the vector are treated.</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        Available options are &#39;wrap&#39; (wrap around) or &#39;clip&#39; (treat overflow</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        as the same as the last (or first) element).</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">        Default &#39;clip&#39;. See `numpy.take`.</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    extrema : tuple of ndarrays</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        Indices of the maxima in arrays of integers. ``extrema[k]`` is</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral">        the array of indices of axis `k` of `data`. Note that the</span></div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">        return value is a tuple even when `data` is 1-D.</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    argrelextrema, argrelmin, find_peaks</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    This function uses `argrelextrema` with np.greater as comparator. Therefore,</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    it  requires a strict inequality on both sides of a value to consider it a</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    maximum. This means flat maxima (more than one sample wide) are not detected.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    In case of 1-D `data` `find_peaks` can be used to detect all</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    local maxima, including flat ones.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import argrelmax</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    &gt;&gt;&gt; argrelmax(x)</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    (array([3, 6]),)</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2],</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    ...               [2, 2, 0, 0],</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    ...               [5, 3, 4, 4]])</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    &gt;&gt;&gt; argrelmax(y, axis=1)</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    (array([0]), array([1]))</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  191</span>    <span class="keywordflow">return</span> argrelextrema(data, np.greater, axis, order, mode)</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d18336288f089a9ae51ea0835900be9" name="a6d18336288f089a9ae51ea0835900be9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d18336288f089a9ae51ea0835900be9">&#9670;&#160;</a></span>argrelmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.argrelmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mode</em> = <code>'clip'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the relative minima of `data`.

Parameters
----------
data : ndarray
    Array in which to find the relative minima.
axis : int, optional
    Axis over which to select from `data`. Default is 0.
order : int, optional
    How many points on each side to use for the comparison
    to consider ``comparator(n, n+x)`` to be True.
mode : str, optional
    How the edges of the vector are treated.
    Available options are 'wrap' (wrap around) or 'clip' (treat overflow
    as the same as the last (or first) element).
    Default 'clip'. See numpy.take.

Returns
-------
extrema : tuple of ndarrays
    Indices of the minima in arrays of integers. ``extrema[k]`` is
    the array of indices of axis `k` of `data`. Note that the
    return value is a tuple even when `data` is 1-D.

See Also
--------
argrelextrema, argrelmax, find_peaks

Notes
-----
This function uses `argrelextrema` with np.less as comparator. Therefore, it
requires a strict inequality on both sides of a value to consider it a
minimum. This means flat minima (more than one sample wide) are not detected.
In case of 1-D `data` `find_peaks` can be used to detect all
local minima, including flat ones, by calling it with negated `data`.

.. versionadded:: 0.11.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import argrelmin
&gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])
&gt;&gt;&gt; argrelmin(x)
(array([1, 5]),)
&gt;&gt;&gt; y = np.array([[1, 2, 1, 2],
...               [2, 2, 0, 0],
...               [5, 3, 4, 4]])
...
&gt;&gt;&gt; argrelmin(y, axis=1)
(array([0, 2]), array([2, 1]))</pre> <div class="fragment"><div class="line"><span class="lineno">   81</span><span class="keyword">def </span>argrelmin(data, axis=0, order=1, mode=&#39;clip&#39;):</div>
<div class="line"><span class="lineno">   82</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    Calculate the relative minima of `data`.</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    data : ndarray</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">        Array in which to find the relative minima.</span></div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    axis : int, optional</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">        Axis over which to select from `data`. Default is 0.</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    order : int, optional</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        How many points on each side to use for the comparison</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">        to consider ``comparator(n, n+x)`` to be True.</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    mode : str, optional</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">        How the edges of the vector are treated.</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        Available options are &#39;wrap&#39; (wrap around) or &#39;clip&#39; (treat overflow</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        as the same as the last (or first) element).</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">        Default &#39;clip&#39;. See numpy.take.</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    extrema : tuple of ndarrays</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        Indices of the minima in arrays of integers. ``extrema[k]`` is</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        the array of indices of axis `k` of `data`. Note that the</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        return value is a tuple even when `data` is 1-D.</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    argrelextrema, argrelmax, find_peaks</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    This function uses `argrelextrema` with np.less as comparator. Therefore, it</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    requires a strict inequality on both sides of a value to consider it a</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    minimum. This means flat minima (more than one sample wide) are not detected.</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    In case of 1-D `data` `find_peaks` can be used to detect all</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    local minima, including flat ones, by calling it with negated `data`.</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import argrelmin</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([2, 1, 2, 3, 2, 0, 1, 0])</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    &gt;&gt;&gt; argrelmin(x)</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    (array([1, 5]),)</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    &gt;&gt;&gt; y = np.array([[1, 2, 1, 2],</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    ...               [2, 2, 0, 0],</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral">    ...               [5, 3, 4, 4]])</span></div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    &gt;&gt;&gt; argrelmin(y, axis=1)</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    (array([0, 2]), array([2, 1]))</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  135</span>    <span class="keywordflow">return</span> argrelextrema(data, np.less, axis, order, mode)</div>
<div class="line"><span class="lineno">  136</span> </div>
<div class="line"><span class="lineno">  137</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc47decb695a648b0281cd4bbc018cf4" name="abc47decb695a648b0281cd4bbc018cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc47decb695a648b0281cd4bbc018cf4">&#9670;&#160;</a></span>find_peaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.find_peaks </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>height</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>distance</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prominence</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wlen</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_height</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plateau_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find peaks inside a signal based on peak properties.

This function takes a 1-D array and finds all local maxima by
simple comparison of neighboring values. Optionally, a subset of these
peaks can be selected by specifying conditions for a peak's properties.

Parameters
----------
x : sequence
    A signal with peaks.
height : number or ndarray or sequence, optional
    Required height of peaks. Either a number, ``None``, an array matching
    `x` or a 2-element sequence of the former. The first element is
    always interpreted as the  minimal and the second, if supplied, as the
    maximal required height.
threshold : number or ndarray or sequence, optional
    Required threshold of peaks, the vertical distance to its neighboring
    samples. Either a number, ``None``, an array matching `x` or a
    2-element sequence of the former. The first element is always
    interpreted as the  minimal and the second, if supplied, as the maximal
    required threshold.
distance : number, optional
    Required minimal horizontal distance (&gt;= 1) in samples between
    neighbouring peaks. Smaller peaks are removed first until the condition
    is fulfilled for all remaining peaks.
prominence : number or ndarray or sequence, optional
    Required prominence of peaks. Either a number, ``None``, an array
    matching `x` or a 2-element sequence of the former. The first
    element is always interpreted as the  minimal and the second, if
    supplied, as the maximal required prominence.
width : number or ndarray or sequence, optional
    Required width of peaks in samples. Either a number, ``None``, an array
    matching `x` or a 2-element sequence of the former. The first
    element is always interpreted as the  minimal and the second, if
    supplied, as the maximal required width.
wlen : int, optional
    Used for calculation of the peaks prominences, thus it is only used if
    one of the arguments `prominence` or `width` is given. See argument
    `wlen` in `peak_prominences` for a full description of its effects.
rel_height : float, optional
    Used for calculation of the peaks width, thus it is only used if `width`
    is given. See argument  `rel_height` in `peak_widths` for a full
    description of its effects.
plateau_size : number or ndarray or sequence, optional
    Required size of the flat top of peaks in samples. Either a number,
    ``None``, an array matching `x` or a 2-element sequence of the former.
    The first element is always interpreted as the minimal and the second,
    if supplied as the maximal required plateau size.

    .. versionadded:: 1.2.0

Returns
-------
peaks : ndarray
    Indices of peaks in `x` that satisfy all given conditions.
properties : dict
    A dictionary containing properties of the returned peaks which were
    calculated as intermediate results during evaluation of the specified
    conditions:

    * 'peak_heights'
          If `height` is given, the height of each peak in `x`.
    * 'left_thresholds', 'right_thresholds'
          If `threshold` is given, these keys contain a peaks vertical
          distance to its neighbouring samples.
    * 'prominences', 'right_bases', 'left_bases'
          If `prominence` is given, these keys are accessible. See
          `peak_prominences` for a description of their content.
    * 'width_heights', 'left_ips', 'right_ips'
          If `width` is given, these keys are accessible. See `peak_widths`
          for a description of their content.
    * 'plateau_sizes', left_edges', 'right_edges'
          If `plateau_size` is given, these keys are accessible and contain
          the indices of a peak's edges (edges are still part of the
          plateau) and the calculated plateau sizes.

          .. versionadded:: 1.2.0

    To calculate and return properties without excluding peaks, provide the
    open interval ``(None, None)`` as a value to the appropriate argument
    (excluding `distance`).

Warns
-----
PeakPropertyWarning
    Raised if a peak's properties have unexpected values (see
    `peak_prominences` and `peak_widths`).

Warnings
--------
This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.

See Also
--------
find_peaks_cwt
    Find peaks using the wavelet transformation.
peak_prominences
    Directly calculate the prominence of peaks.
peak_widths
    Directly calculate the width of peaks.

Notes
-----
In the context of this function, a peak or local maximum is defined as any
sample whose two direct neighbours have a smaller amplitude. For flat peaks
(more than one sample of equal amplitude wide) the index of the middle
sample is returned (rounded down in case the number of samples is even).
For noisy signals the peak locations can be off because the noise might
change the position of local maxima. In those cases consider smoothing the
signal before searching for peaks or use other peak finding and fitting
methods (like `find_peaks_cwt`).

Some additional comments on specifying conditions:

* Almost all conditions (excluding `distance`) can be given as half-open or
  closed intervals, e.g., ``1`` or ``(1, None)`` defines the half-open
  interval :math:`[1, \\infty]` while ``(None, 1)`` defines the interval
  :math:`[-\\infty, 1]`. The open interval ``(None, None)`` can be specified
  as well, which returns the matching properties without exclusion of peaks.
* The border is always included in the interval used to select valid peaks.
* For several conditions the interval borders can be specified with
  arrays matching `x` in shape which enables dynamic constrains based on
  the sample position.
* The conditions are evaluated in the following order: `plateau_size`,
  `height`, `threshold`, `distance`, `prominence`, `width`. In most cases
  this order is the fastest one because faster operations are applied first
  to reduce the number of peaks that need to be evaluated later.
* While indices in `peaks` are guaranteed to be at least `distance` samples
  apart, edges of flat peaks may be closer than the allowed `distance`.
* Use `wlen` to reduce the time it takes to evaluate the conditions for
  `prominence` or `width` if `x` is large or has many local maxima
  (see `peak_prominences`).

.. versionadded:: 1.1.0

Examples
--------
To demonstrate this function's usage we use a signal `x` supplied with
SciPy (see `scipy.misc.electrocardiogram`). Let's find all peaks (local
maxima) in `x` whose amplitude lies above 0.

&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; from scipy.misc import electrocardiogram
&gt;&gt;&gt; from scipy.signal import find_peaks
&gt;&gt;&gt; x = electrocardiogram()[2000:4000]
&gt;&gt;&gt; peaks, _ = find_peaks(x, height=0)
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.plot(np.zeros_like(x), "--", color="gray")
&gt;&gt;&gt; plt.show()

We can select peaks below 0 with ``height=(None, 0)`` or use arrays matching
`x` in size to reflect a changing condition for different parts of the
signal.

&gt;&gt;&gt; border = np.sin(np.linspace(0, 3 * np.pi, x.size))
&gt;&gt;&gt; peaks, _ = find_peaks(x, height=(-border, border))
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(-border, "--", color="gray")
&gt;&gt;&gt; plt.plot(border, ":", color="gray")
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.show()

Another useful condition for periodic signals can be given with the
`distance` argument. In this case, we can easily select the positions of
QRS complexes within the electrocardiogram (ECG) by demanding a distance of
at least 150 samples.

&gt;&gt;&gt; peaks, _ = find_peaks(x, distance=150)
&gt;&gt;&gt; np.diff(peaks)
array([186, 180, 177, 171, 177, 169, 167, 164, 158, 162, 172])
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.show()

Especially for noisy signals peaks can be easily grouped by their
prominence (see `peak_prominences`). E.g., we can select all peaks except
for the mentioned QRS complexes by limiting the allowed prominence to 0.6.

&gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=(None, 0.6))
&gt;&gt;&gt; properties["prominences"].max()
0.5049999999999999
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.show()

And, finally, let's examine a different section of the ECG which contains
beat forms of different shape. To select only the atypical heart beats, we
combine two conditions: a minimal prominence of 1 and width of at least 20
samples.

&gt;&gt;&gt; x = electrocardiogram()[17000:18000]
&gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=1, width=20)
&gt;&gt;&gt; properties["prominences"], properties["widths"]
(array([1.495, 2.3  ]), array([36.93773946, 39.32723577]))
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.vlines(x=peaks, ymin=x[peaks] - properties["prominences"],
...            ymax = x[peaks], color = "C1")
&gt;&gt;&gt; plt.hlines(y=properties["width_heights"], xmin=properties["left_ips"],
...            xmax=properties["right_ips"], color = "C1")
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno">  725</span>               plateau_size=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  726</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">    Find peaks inside a signal based on peak properties.</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    This function takes a 1-D array and finds all local maxima by</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">    simple comparison of neighboring values. Optionally, a subset of these</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">    peaks can be selected by specifying conditions for a peak&#39;s properties.</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">    x : sequence</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        A signal with peaks.</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">    height : number or ndarray or sequence, optional</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        Required height of peaks. Either a number, ``None``, an array matching</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        `x` or a 2-element sequence of the former. The first element is</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        always interpreted as the  minimal and the second, if supplied, as the</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">        maximal required height.</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    threshold : number or ndarray or sequence, optional</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        Required threshold of peaks, the vertical distance to its neighboring</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        samples. Either a number, ``None``, an array matching `x` or a</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        2-element sequence of the former. The first element is always</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        interpreted as the  minimal and the second, if supplied, as the maximal</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        required threshold.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">    distance : number, optional</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">        Required minimal horizontal distance (&gt;= 1) in samples between</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">        neighbouring peaks. Smaller peaks are removed first until the condition</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">        is fulfilled for all remaining peaks.</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    prominence : number or ndarray or sequence, optional</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">        Required prominence of peaks. Either a number, ``None``, an array</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">        matching `x` or a 2-element sequence of the former. The first</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">        element is always interpreted as the  minimal and the second, if</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">        supplied, as the maximal required prominence.</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    width : number or ndarray or sequence, optional</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">        Required width of peaks in samples. Either a number, ``None``, an array</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        matching `x` or a 2-element sequence of the former. The first</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        element is always interpreted as the  minimal and the second, if</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        supplied, as the maximal required width.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral">    wlen : int, optional</span></div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        Used for calculation of the peaks prominences, thus it is only used if</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        one of the arguments `prominence` or `width` is given. See argument</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        `wlen` in `peak_prominences` for a full description of its effects.</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    rel_height : float, optional</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">        Used for calculation of the peaks width, thus it is only used if `width`</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        is given. See argument  `rel_height` in `peak_widths` for a full</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        description of its effects.</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    plateau_size : number or ndarray or sequence, optional</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">        Required size of the flat top of peaks in samples. Either a number,</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">        ``None``, an array matching `x` or a 2-element sequence of the former.</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">        The first element is always interpreted as the minimal and the second,</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">        if supplied as the maximal required plateau size.</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">        .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">    peaks : ndarray</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">        Indices of peaks in `x` that satisfy all given conditions.</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    properties : dict</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">        A dictionary containing properties of the returned peaks which were</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">        calculated as intermediate results during evaluation of the specified</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">        conditions:</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">        * &#39;peak_heights&#39;</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">              If `height` is given, the height of each peak in `x`.</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">        * &#39;left_thresholds&#39;, &#39;right_thresholds&#39;</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral">              If `threshold` is given, these keys contain a peaks vertical</span></div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">              distance to its neighbouring samples.</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        * &#39;prominences&#39;, &#39;right_bases&#39;, &#39;left_bases&#39;</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">              If `prominence` is given, these keys are accessible. See</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">              `peak_prominences` for a description of their content.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        * &#39;width_heights&#39;, &#39;left_ips&#39;, &#39;right_ips&#39;</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">              If `width` is given, these keys are accessible. See `peak_widths`</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">              for a description of their content.</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">        * &#39;plateau_sizes&#39;, left_edges&#39;, &#39;right_edges&#39;</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">              If `plateau_size` is given, these keys are accessible and contain</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">              the indices of a peak&#39;s edges (edges are still part of the</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">              plateau) and the calculated plateau sizes.</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">              .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">        To calculate and return properties without excluding peaks, provide the</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">        open interval ``(None, None)`` as a value to the appropriate argument</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        (excluding `distance`).</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    PeakPropertyWarning</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">        Raised if a peak&#39;s properties have unexpected values (see</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        `peak_prominences` and `peak_widths`).</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    Warnings</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    This function may return unexpected results for data containing NaNs. To</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral">    avoid this, NaNs should either be removed or replaced.</span></div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    find_peaks_cwt</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">        Find peaks using the wavelet transformation.</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    peak_prominences</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        Directly calculate the prominence of peaks.</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    peak_widths</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">        Directly calculate the width of peaks.</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    In the context of this function, a peak or local maximum is defined as any</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral">    sample whose two direct neighbours have a smaller amplitude. For flat peaks</span></div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    (more than one sample of equal amplitude wide) the index of the middle</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">    sample is returned (rounded down in case the number of samples is even).</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">    For noisy signals the peak locations can be off because the noise might</span></div>
<div class="line"><span class="lineno">  836</span><span class="stringliteral">    change the position of local maxima. In those cases consider smoothing the</span></div>
<div class="line"><span class="lineno">  837</span><span class="stringliteral">    signal before searching for peaks or use other peak finding and fitting</span></div>
<div class="line"><span class="lineno">  838</span><span class="stringliteral">    methods (like `find_peaks_cwt`).</span></div>
<div class="line"><span class="lineno">  839</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  840</span><span class="stringliteral">    Some additional comments on specifying conditions:</span></div>
<div class="line"><span class="lineno">  841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  842</span><span class="stringliteral">    * Almost all conditions (excluding `distance`) can be given as half-open or</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">      closed intervals, e.g., ``1`` or ``(1, None)`` defines the half-open</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral">      interval :math:`[1, \\infty]` while ``(None, 1)`` defines the interval</span></div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">      :math:`[-\\infty, 1]`. The open interval ``(None, None)`` can be specified</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">      as well, which returns the matching properties without exclusion of peaks.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral">    * The border is always included in the interval used to select valid peaks.</span></div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">    * For several conditions the interval borders can be specified with</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">      arrays matching `x` in shape which enables dynamic constrains based on</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">      the sample position.</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">    * The conditions are evaluated in the following order: `plateau_size`,</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral">      `height`, `threshold`, `distance`, `prominence`, `width`. In most cases</span></div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">      this order is the fastest one because faster operations are applied first</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">      to reduce the number of peaks that need to be evaluated later.</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">    * While indices in `peaks` are guaranteed to be at least `distance` samples</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">      apart, edges of flat peaks may be closer than the allowed `distance`.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral">    * Use `wlen` to reduce the time it takes to evaluate the conditions for</span></div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">      `prominence` or `width` if `x` is large or has many local maxima</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">      (see `peak_prominences`).</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    To demonstrate this function&#39;s usage we use a signal `x` supplied with</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    SciPy (see `scipy.misc.electrocardiogram`). Let&#39;s find all peaks (local</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral">    maxima) in `x` whose amplitude lies above 0.</span></div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.misc import electrocardiogram</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import find_peaks</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    &gt;&gt;&gt; x = electrocardiogram()[2000:4000]</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">    &gt;&gt;&gt; peaks, _ = find_peaks(x, height=0)</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(np.zeros_like(x), &quot;--&quot;, color=&quot;gray&quot;)</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    We can select peaks below 0 with ``height=(None, 0)`` or use arrays matching</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">    `x` in size to reflect a changing condition for different parts of the</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">    signal.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    &gt;&gt;&gt; border = np.sin(np.linspace(0, 3 * np.pi, x.size))</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">    &gt;&gt;&gt; peaks, _ = find_peaks(x, height=(-border, border))</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(-border, &quot;--&quot;, color=&quot;gray&quot;)</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(border, &quot;:&quot;, color=&quot;gray&quot;)</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    Another useful condition for periodic signals can be given with the</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    `distance` argument. In this case, we can easily select the positions of</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    QRS complexes within the electrocardiogram (ECG) by demanding a distance of</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">    at least 150 samples.</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    &gt;&gt;&gt; peaks, _ = find_peaks(x, distance=150)</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    &gt;&gt;&gt; np.diff(peaks)</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    array([186, 180, 177, 171, 177, 169, 167, 164, 158, 162, 172])</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Especially for noisy signals peaks can be easily grouped by their</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    prominence (see `peak_prominences`). E.g., we can select all peaks except</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    for the mentioned QRS complexes by limiting the allowed prominence to 0.6.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral">    &gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=(None, 0.6))</span></div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">    &gt;&gt;&gt; properties[&quot;prominences&quot;].max()</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">    0.5049999999999999</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    And, finally, let&#39;s examine a different section of the ECG which contains</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    beat forms of different shape. To select only the atypical heart beats, we</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral">    combine two conditions: a minimal prominence of 1 and width of at least 20</span></div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    samples.</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    &gt;&gt;&gt; x = electrocardiogram()[17000:18000]</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    &gt;&gt;&gt; peaks, properties = find_peaks(x, prominence=1, width=20)</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    &gt;&gt;&gt; properties[&quot;prominences&quot;], properties[&quot;widths&quot;]</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral">    (array([1.495, 2.3  ]), array([36.93773946, 39.32723577]))</span></div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    &gt;&gt;&gt; plt.vlines(x=peaks, ymin=x[peaks] - properties[&quot;prominences&quot;],</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    ...            ymax = x[peaks], color = &quot;C1&quot;)</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    &gt;&gt;&gt; plt.hlines(y=properties[&quot;width_heights&quot;], xmin=properties[&quot;left_ips&quot;],</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">    ...            xmax=properties[&quot;right_ips&quot;], color = &quot;C1&quot;)</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  931</span>    <span class="comment"># _argmaxima1d expects array of dtype &#39;float64&#39;</span></div>
<div class="line"><span class="lineno">  932</span>    x = _arg_x_as_expected(x)</div>
<div class="line"><span class="lineno">  933</span>    <span class="keywordflow">if</span> distance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> distance &lt; 1:</div>
<div class="line"><span class="lineno">  934</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;`distance` must be greater or equal to 1&#39;</span>)</div>
<div class="line"><span class="lineno">  935</span> </div>
<div class="line"><span class="lineno">  936</span>    peaks, left_edges, right_edges = _local_maxima_1d(x)</div>
<div class="line"><span class="lineno">  937</span>    properties = {}</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>    <span class="keywordflow">if</span> plateau_size <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  940</span>        <span class="comment"># Evaluate plateau size</span></div>
<div class="line"><span class="lineno">  941</span>        plateau_sizes = right_edges - left_edges + 1</div>
<div class="line"><span class="lineno">  942</span>        pmin, pmax = _unpack_condition_args(plateau_size, x, peaks)</div>
<div class="line"><span class="lineno">  943</span>        keep = _select_by_property(plateau_sizes, pmin, pmax)</div>
<div class="line"><span class="lineno">  944</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno">  945</span>        properties[<span class="stringliteral">&quot;plateau_sizes&quot;</span>] = plateau_sizes</div>
<div class="line"><span class="lineno">  946</span>        properties[<span class="stringliteral">&quot;left_edges&quot;</span>] = left_edges</div>
<div class="line"><span class="lineno">  947</span>        properties[<span class="stringliteral">&quot;right_edges&quot;</span>] = right_edges</div>
<div class="line"><span class="lineno">  948</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span>    <span class="keywordflow">if</span> height <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  951</span>        <span class="comment"># Evaluate height condition</span></div>
<div class="line"><span class="lineno">  952</span>        peak_heights = x[peaks]</div>
<div class="line"><span class="lineno">  953</span>        hmin, hmax = _unpack_condition_args(height, x, peaks)</div>
<div class="line"><span class="lineno">  954</span>        keep = _select_by_property(peak_heights, hmin, hmax)</div>
<div class="line"><span class="lineno">  955</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno">  956</span>        properties[<span class="stringliteral">&quot;peak_heights&quot;</span>] = peak_heights</div>
<div class="line"><span class="lineno">  957</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno">  958</span> </div>
<div class="line"><span class="lineno">  959</span>    <span class="keywordflow">if</span> threshold <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  960</span>        <span class="comment"># Evaluate threshold condition</span></div>
<div class="line"><span class="lineno">  961</span>        tmin, tmax = _unpack_condition_args(threshold, x, peaks)</div>
<div class="line"><span class="lineno">  962</span>        keep, left_thresholds, right_thresholds = _select_by_peak_threshold(</div>
<div class="line"><span class="lineno">  963</span>            x, peaks, tmin, tmax)</div>
<div class="line"><span class="lineno">  964</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno">  965</span>        properties[<span class="stringliteral">&quot;left_thresholds&quot;</span>] = left_thresholds</div>
<div class="line"><span class="lineno">  966</span>        properties[<span class="stringliteral">&quot;right_thresholds&quot;</span>] = right_thresholds</div>
<div class="line"><span class="lineno">  967</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span>    <span class="keywordflow">if</span> distance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  970</span>        <span class="comment"># Evaluate distance condition</span></div>
<div class="line"><span class="lineno">  971</span>        keep = _select_by_peak_distance(peaks, x[peaks], distance)</div>
<div class="line"><span class="lineno">  972</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno">  973</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>    <span class="keywordflow">if</span> prominence <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> width <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  976</span>        <span class="comment"># Calculate prominence (required for both conditions)</span></div>
<div class="line"><span class="lineno">  977</span>        wlen = _arg_wlen_as_expected(wlen)</div>
<div class="line"><span class="lineno">  978</span>        properties.update(zip(</div>
<div class="line"><span class="lineno">  979</span>            [<span class="stringliteral">&#39;prominences&#39;</span>, <span class="stringliteral">&#39;left_bases&#39;</span>, <span class="stringliteral">&#39;right_bases&#39;</span>],</div>
<div class="line"><span class="lineno">  980</span>            _peak_prominences(x, peaks, wlen=wlen)</div>
<div class="line"><span class="lineno">  981</span>        ))</div>
<div class="line"><span class="lineno">  982</span> </div>
<div class="line"><span class="lineno">  983</span>    <span class="keywordflow">if</span> prominence <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  984</span>        <span class="comment"># Evaluate prominence condition</span></div>
<div class="line"><span class="lineno">  985</span>        pmin, pmax = _unpack_condition_args(prominence, x, peaks)</div>
<div class="line"><span class="lineno">  986</span>        keep = _select_by_property(properties[<span class="stringliteral">&#39;prominences&#39;</span>], pmin, pmax)</div>
<div class="line"><span class="lineno">  987</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno">  988</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno">  989</span> </div>
<div class="line"><span class="lineno">  990</span>    <span class="keywordflow">if</span> width <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  991</span>        <span class="comment"># Calculate widths</span></div>
<div class="line"><span class="lineno">  992</span>        properties.update(zip(</div>
<div class="line"><span class="lineno">  993</span>            [<span class="stringliteral">&#39;widths&#39;</span>, <span class="stringliteral">&#39;width_heights&#39;</span>, <span class="stringliteral">&#39;left_ips&#39;</span>, <span class="stringliteral">&#39;right_ips&#39;</span>],</div>
<div class="line"><span class="lineno">  994</span>            _peak_widths(x, peaks, rel_height, properties[<span class="stringliteral">&#39;prominences&#39;</span>],</div>
<div class="line"><span class="lineno">  995</span>                         properties[<span class="stringliteral">&#39;left_bases&#39;</span>], properties[<span class="stringliteral">&#39;right_bases&#39;</span>])</div>
<div class="line"><span class="lineno">  996</span>        ))</div>
<div class="line"><span class="lineno">  997</span>        <span class="comment"># Evaluate width condition</span></div>
<div class="line"><span class="lineno">  998</span>        wmin, wmax = _unpack_condition_args(width, x, peaks)</div>
<div class="line"><span class="lineno">  999</span>        keep = _select_by_property(properties[<span class="stringliteral">&#39;widths&#39;</span>], wmin, wmax)</div>
<div class="line"><span class="lineno"> 1000</span>        peaks = peaks[keep]</div>
<div class="line"><span class="lineno"> 1001</span>        properties = {key: array[keep] <span class="keywordflow">for</span> key, array <span class="keywordflow">in</span> properties.items()}</div>
<div class="line"><span class="lineno"> 1002</span> </div>
<div class="line"><span class="lineno"> 1003</span>    <span class="keywordflow">return</span> peaks, properties</div>
<div class="line"><span class="lineno"> 1004</span> </div>
<div class="line"><span class="lineno"> 1005</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a965539740f1f0f0b9fdb5df09e03bf5e" name="a965539740f1f0f0b9fdb5df09e03bf5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965539740f1f0f0b9fdb5df09e03bf5e">&#9670;&#160;</a></span>find_peaks_cwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.find_peaks_cwt </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>widths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wavelet</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_distances</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gap_thresh</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_length</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_snr</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>noise_perc</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Find peaks in a 1-D array with wavelet transformation.

The general approach is to smooth `vector` by convolving it with
`wavelet(width)` for each width in `widths`. Relative maxima which
appear at enough length scales, and with sufficiently high SNR, are
accepted.

Parameters
----------
vector : ndarray
    1-D array in which to find the peaks.
widths : float or sequence
    Single width or 1-D array-like of widths to use for calculating
    the CWT matrix. In general,
    this range should cover the expected width of peaks of interest.
wavelet : callable, optional
    Should take two parameters and return a 1-D array to convolve
    with `vector`. The first parameter determines the number of points
    of the returned wavelet array, the second parameter is the scale
    (`width`) of the wavelet. Should be normalized and symmetric.
    Default is the ricker wavelet.
max_distances : ndarray, optional
    At each row, a ridge line is only connected if the relative max at
    row[n] is within ``max_distances[n]`` from the relative max at
    ``row[n+1]``.  Default value is ``widths/4``.
gap_thresh : float, optional
    If a relative maximum is not found within `max_distances`,
    there will be a gap. A ridge line is discontinued if there are more
    than `gap_thresh` points without connecting a new relative maximum.
    Default is the first value of the widths array i.e. widths[0].
min_length : int, optional
    Minimum length a ridge line needs to be acceptable.
    Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.
min_snr : float, optional
    Minimum SNR ratio. Default 1. The signal is the maximum CWT coefficient
    on the largest ridge line. The noise is `noise_perc` th percentile of
    datapoints contained within the same ridge line.
noise_perc : float, optional
    When calculating the noise floor, percentile of data points
    examined below which to consider noise. Calculated using
    `stats.scoreatpercentile`.  Default is 10.
window_size : int, optional
    Size of window to use to calculate noise floor.
    Default is ``cwt.shape[1] / 20``.

Returns
-------
peaks_indices : ndarray
    Indices of the locations in the `vector` where peaks were found.
    The list is sorted.

See Also
--------
cwt
    Continuous wavelet transform.
find_peaks
    Find peaks inside a signal based on peak properties.

Notes
-----
This approach was designed for finding sharp peaks among noisy data,
however with proper parameter selection it should function well for
different peak shapes.

The algorithm is as follows:
 1. Perform a continuous wavelet transform on `vector`, for the supplied
    `widths`. This is a convolution of `vector` with `wavelet(width)` for
    each width in `widths`. See `cwt`.
 2. Identify "ridge lines" in the cwt matrix. These are relative maxima
    at each row, connected across adjacent rows. See identify_ridge_lines
 3. Filter the ridge_lines using filter_ridge_lines.

.. versionadded:: 0.11.0

References
----------
.. [1] Bioinformatics (2006) 22 (17): 2059-2065.
   :doi:`10.1093/bioinformatics/btl355`

Examples
--------
&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; xs = np.arange(0, np.pi, 0.05)
&gt;&gt;&gt; data = np.sin(xs)
&gt;&gt;&gt; peakind = signal.find_peaks_cwt(data, np.arange(1,10))
&gt;&gt;&gt; peakind, xs[peakind], data[peakind]
([32], array([ 1.6]), array([ 0.9995736]))</pre> <div class="fragment"><div class="line"><span class="lineno"> 1192</span>                   min_snr=1, noise_perc=10, window_size=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 1193</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    Find peaks in a 1-D array with wavelet transformation.</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    The general approach is to smooth `vector` by convolving it with</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    `wavelet(width)` for each width in `widths`. Relative maxima which</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">    appear at enough length scales, and with sufficiently high SNR, are</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    accepted.</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    vector : ndarray</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">        1-D array in which to find the peaks.</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">    widths : float or sequence</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">        Single width or 1-D array-like of widths to use for calculating</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">        the CWT matrix. In general,</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">        this range should cover the expected width of peaks of interest.</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    wavelet : callable, optional</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">        Should take two parameters and return a 1-D array to convolve</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">        with `vector`. The first parameter determines the number of points</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">        of the returned wavelet array, the second parameter is the scale</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">        (`width`) of the wavelet. Should be normalized and symmetric.</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral">        Default is the ricker wavelet.</span></div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    max_distances : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral">        At each row, a ridge line is only connected if the relative max at</span></div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">        row[n] is within ``max_distances[n]`` from the relative max at</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">        ``row[n+1]``.  Default value is ``widths/4``.</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    gap_thresh : float, optional</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">        If a relative maximum is not found within `max_distances`,</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral">        there will be a gap. A ridge line is discontinued if there are more</span></div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">        than `gap_thresh` points without connecting a new relative maximum.</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral">        Default is the first value of the widths array i.e. widths[0].</span></div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    min_length : int, optional</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">        Minimum length a ridge line needs to be acceptable.</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">        Default is ``cwt.shape[0] / 4``, ie 1/4-th the number of widths.</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">    min_snr : float, optional</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">        Minimum SNR ratio. Default 1. The signal is the maximum CWT coefficient</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">        on the largest ridge line. The noise is `noise_perc` th percentile of</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">        datapoints contained within the same ridge line.</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">    noise_perc : float, optional</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">        When calculating the noise floor, percentile of data points</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">        examined below which to consider noise. Calculated using</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">        `stats.scoreatpercentile`.  Default is 10.</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">    window_size : int, optional</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">        Size of window to use to calculate noise floor.</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">        Default is ``cwt.shape[1] / 20``.</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    peaks_indices : ndarray</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral">        Indices of the locations in the `vector` where peaks were found.</span></div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">        The list is sorted.</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    cwt</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">        Continuous wavelet transform.</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral">    find_peaks</span></div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">        Find peaks inside a signal based on peak properties.</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    This approach was designed for finding sharp peaks among noisy data,</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    however with proper parameter selection it should function well for</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    different peak shapes.</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    The algorithm is as follows:</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">     1. Perform a continuous wavelet transform on `vector`, for the supplied</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral">        `widths`. This is a convolution of `vector` with `wavelet(width)` for</span></div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">        each width in `widths`. See `cwt`.</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral">     2. Identify &quot;ridge lines&quot; in the cwt matrix. These are relative maxima</span></div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">        at each row, connected across adjacent rows. See identify_ridge_lines</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">     3. Filter the ridge_lines using filter_ridge_lines.</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    .. versionadded:: 0.11.0</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    .. [1] Bioinformatics (2006) 22 (17): 2059-2065.</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">       :doi:`10.1093/bioinformatics/btl355`</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">    &gt;&gt;&gt; xs = np.arange(0, np.pi, 0.05)</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">    &gt;&gt;&gt; data = np.sin(xs)</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    &gt;&gt;&gt; peakind = signal.find_peaks_cwt(data, np.arange(1,10))</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    &gt;&gt;&gt; peakind, xs[peakind], data[peakind]</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">    ([32], array([ 1.6]), array([ 0.9995736]))</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1283</span>    widths = np.array(widths, copy=<span class="keyword">False</span>, ndmin=1)</div>
<div class="line"><span class="lineno"> 1284</span> </div>
<div class="line"><span class="lineno"> 1285</span>    <span class="keywordflow">if</span> gap_thresh <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1286</span>        gap_thresh = np.ceil(widths[0])</div>
<div class="line"><span class="lineno"> 1287</span>    <span class="keywordflow">if</span> max_distances <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1288</span>        max_distances = widths / 4.0</div>
<div class="line"><span class="lineno"> 1289</span>    <span class="keywordflow">if</span> wavelet <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1290</span>        wavelet = ricker</div>
<div class="line"><span class="lineno"> 1291</span> </div>
<div class="line"><span class="lineno"> 1292</span>    cwt_dat = cwt(vector, wavelet, widths)</div>
<div class="line"><span class="lineno"> 1293</span>    ridge_lines = _identify_ridge_lines(cwt_dat, max_distances, gap_thresh)</div>
<div class="line"><span class="lineno"> 1294</span>    filtered = _filter_ridge_lines(cwt_dat, ridge_lines, min_length=min_length,</div>
<div class="line"><span class="lineno"> 1295</span>                                   window_size=window_size, min_snr=min_snr,</div>
<div class="line"><span class="lineno"> 1296</span>                                   noise_perc=noise_perc)</div>
<div class="line"><span class="lineno"> 1297</span>    max_locs = np.asarray([x[1][0] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> filtered])</div>
<div class="line"><span class="lineno"> 1298</span>    max_locs.sort()</div>
<div class="line"><span class="lineno"> 1299</span> </div>
<div class="line"><span class="lineno"> 1300</span>    <span class="keywordflow">return</span> max_locs</div>
</div><!-- fragment -->
</div>
</div>
<a id="a74f439873f25cb41c1690628a3f15999" name="a74f439873f25cb41c1690628a3f15999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f439873f25cb41c1690628a3f15999">&#9670;&#160;</a></span>peak_prominences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.peak_prominences </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wlen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the prominence of each peak in a signal.

The prominence of a peak measures how much a peak stands out from the
surrounding baseline of the signal and is defined as the vertical distance
between the peak and its lowest contour line.

Parameters
----------
x : sequence
    A signal with peaks.
peaks : sequence
    Indices of peaks in `x`.
wlen : int, optional
    A window length in samples that optionally limits the evaluated area for
    each peak to a subset of `x`. The peak is always placed in the middle of
    the window therefore the given length is rounded up to the next odd
    integer. This parameter can speed up the calculation (see Notes).

Returns
-------
prominences : ndarray
    The calculated prominences for each peak in `peaks`.
left_bases, right_bases : ndarray
    The peaks' bases as indices in `x` to the left and right of each peak.
    The higher base of each pair is a peak's lowest contour line.

Raises
------
ValueError
    If a value in `peaks` is an invalid index for `x`.

Warns
-----
PeakPropertyWarning
    For indices in `peaks` that don't point to valid local maxima in `x`,
    the returned prominence will be 0 and this warning is raised. This
    also happens if `wlen` is smaller than the plateau size of a peak.

Warnings
--------
This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.

See Also
--------
find_peaks
    Find peaks inside a signal based on peak properties.
peak_widths
    Calculate the width of peaks.

Notes
-----
Strategy to compute a peak's prominence:

1. Extend a horizontal line from the current peak to the left and right
   until the line either reaches the window border (see `wlen`) or
   intersects the signal again at the slope of a higher peak. An
   intersection with a peak of the same height is ignored.
2. On each side find the minimal signal value within the interval defined
   above. These points are the peak's bases.
3. The higher one of the two bases marks the peak's lowest contour line. The
   prominence can then be calculated as the vertical difference between the
   peaks height itself and its lowest contour line.

Searching for the peak's bases can be slow for large `x` with periodic
behavior because large chunks or even the full signal need to be evaluated
for the first algorithmic step. This evaluation area can be limited with the
parameter `wlen` which restricts the algorithm to a window around the
current peak and can shorten the calculation time if the window length is
short in relation to `x`.
However, this may stop the algorithm from finding the true global contour
line if the peak's true bases are outside this window. Instead, a higher
contour line is found within the restricted window leading to a smaller
calculated prominence. In practice, this is only relevant for the highest set
of peaks in `x`. This behavior may even be used intentionally to calculate
"local" prominences.

.. versionadded:: 1.1.0

References
----------
.. [1] Wikipedia Article for Topographic Prominence:
   https://en.wikipedia.org/wiki/Topographic_prominence

Examples
--------
&gt;&gt;&gt; from scipy.signal import find_peaks, peak_prominences
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a test signal with two overlayed harmonics

&gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000)
&gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x)

Find all peaks and calculate prominences

&gt;&gt;&gt; peaks, _ = find_peaks(x)
&gt;&gt;&gt; prominences = peak_prominences(x, peaks)[0]
&gt;&gt;&gt; prominences
array([1.24159486, 0.47840168, 0.28470524, 3.10716793, 0.284603  ,
       0.47822491, 2.48340261, 0.47822491])

Calculate the height of each peak's contour line and plot the results

&gt;&gt;&gt; contour_heights = x[peaks] - prominences
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.vlines(x=peaks, ymin=contour_heights, ymax=x[peaks])
&gt;&gt;&gt; plt.show()

Let's evaluate a second example that demonstrates several edge cases for
one peak at index 5.

&gt;&gt;&gt; x = np.array([0, 1, 0, 3, 1, 3, 0, 4, 0])
&gt;&gt;&gt; peaks = np.array([5])
&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.show()
&gt;&gt;&gt; peak_prominences(x, peaks)  # -&gt; (prominences, left_bases, right_bases)
(array([3.]), array([2]), array([6]))

Note how the peak at index 3 of the same height is not considered as a
border while searching for the left base. Instead, two minima at 0 and 2
are found in which case the one closer to the evaluated peak is always
chosen. On the right side, however, the base must be placed at 6 because the
higher peak represents the right border to the evaluated area.

&gt;&gt;&gt; peak_prominences(x, peaks, wlen=3.1)
(array([2.]), array([4]), array([6]))

Here, we restricted the algorithm to a window from 3 to 7 (the length is 5
samples because `wlen` was rounded up to the next odd integer). Thus, the
only two candidates in the evaluated area are the two neighboring samples
and a smaller prominence is calculated.
</pre> <div class="fragment"><div class="line"><span class="lineno">  319</span><span class="keyword">def </span>peak_prominences(x, peaks, wlen=None):</div>
<div class="line"><span class="lineno">  320</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Calculate the prominence of each peak in a signal.</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    The prominence of a peak measures how much a peak stands out from the</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    surrounding baseline of the signal and is defined as the vertical distance</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">    between the peak and its lowest contour line.</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">    x : sequence</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        A signal with peaks.</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">    peaks : sequence</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        Indices of peaks in `x`.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    wlen : int, optional</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        A window length in samples that optionally limits the evaluated area for</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">        each peak to a subset of `x`. The peak is always placed in the middle of</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        the window therefore the given length is rounded up to the next odd</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">        integer. This parameter can speed up the calculation (see Notes).</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    prominences : ndarray</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">        The calculated prominences for each peak in `peaks`.</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    left_bases, right_bases : ndarray</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">        The peaks&#39; bases as indices in `x` to the left and right of each peak.</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">        The higher base of each pair is a peak&#39;s lowest contour line.</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral">        If a value in `peaks` is an invalid index for `x`.</span></div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    PeakPropertyWarning</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral">        For indices in `peaks` that don&#39;t point to valid local maxima in `x`,</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        the returned prominence will be 0 and this warning is raised. This</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        also happens if `wlen` is smaller than the plateau size of a peak.</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    Warnings</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    This function may return unexpected results for data containing NaNs. To</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">    avoid this, NaNs should either be removed or replaced.</span></div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral">    find_peaks</span></div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">        Find peaks inside a signal based on peak properties.</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral">    peak_widths</span></div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">        Calculate the width of peaks.</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral">    Strategy to compute a peak&#39;s prominence:</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    1. Extend a horizontal line from the current peak to the left and right</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">       until the line either reaches the window border (see `wlen`) or</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">       intersects the signal again at the slope of a higher peak. An</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">       intersection with a peak of the same height is ignored.</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">    2. On each side find the minimal signal value within the interval defined</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">       above. These points are the peak&#39;s bases.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    3. The higher one of the two bases marks the peak&#39;s lowest contour line. The</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">       prominence can then be calculated as the vertical difference between the</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">       peaks height itself and its lowest contour line.</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">    Searching for the peak&#39;s bases can be slow for large `x` with periodic</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral">    behavior because large chunks or even the full signal need to be evaluated</span></div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">    for the first algorithmic step. This evaluation area can be limited with the</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral">    parameter `wlen` which restricts the algorithm to a window around the</span></div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">    current peak and can shorten the calculation time if the window length is</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral">    short in relation to `x`.</span></div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">    However, this may stop the algorithm from finding the true global contour</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">    line if the peak&#39;s true bases are outside this window. Instead, a higher</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">    contour line is found within the restricted window leading to a smaller</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">    calculated prominence. In practice, this is only relevant for the highest set</span></div>
<div class="line"><span class="lineno">  395</span><span class="stringliteral">    of peaks in `x`. This behavior may even be used intentionally to calculate</span></div>
<div class="line"><span class="lineno">  396</span><span class="stringliteral">    &quot;local&quot; prominences.</span></div>
<div class="line"><span class="lineno">  397</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  398</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  400</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  401</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  402</span><span class="stringliteral">    .. [1] Wikipedia Article for Topographic Prominence:</span></div>
<div class="line"><span class="lineno">  403</span><span class="stringliteral">       https://en.wikipedia.org/wiki/Topographic_prominence</span></div>
<div class="line"><span class="lineno">  404</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  405</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  406</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  407</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import find_peaks, peak_prominences</span></div>
<div class="line"><span class="lineno">  408</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  410</span><span class="stringliteral">    Create a test signal with two overlayed harmonics</span></div>
<div class="line"><span class="lineno">  411</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  412</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000)</span></div>
<div class="line"><span class="lineno">  413</span><span class="stringliteral">    &gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x)</span></div>
<div class="line"><span class="lineno">  414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Find all peaks and calculate prominences</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    &gt;&gt;&gt; peaks, _ = find_peaks(x)</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    &gt;&gt;&gt; prominences = peak_prominences(x, peaks)[0]</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    &gt;&gt;&gt; prominences</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">    array([1.24159486, 0.47840168, 0.28470524, 3.10716793, 0.284603  ,</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">           0.47822491, 2.48340261, 0.47822491])</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    Calculate the height of each peak&#39;s contour line and plot the results</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral">    &gt;&gt;&gt; contour_heights = x[peaks] - prominences</span></div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    &gt;&gt;&gt; plt.vlines(x=peaks, ymin=contour_heights, ymax=x[peaks])</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral">    Let&#39;s evaluate a second example that demonstrates several edge cases for</span></div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    one peak at index 5.</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    &gt;&gt;&gt; x = np.array([0, 1, 0, 3, 1, 3, 0, 4, 0])</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    &gt;&gt;&gt; peaks = np.array([5])</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    &gt;&gt;&gt; peak_prominences(x, peaks)  # -&gt; (prominences, left_bases, right_bases)</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    (array([3.]), array([2]), array([6]))</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    Note how the peak at index 3 of the same height is not considered as a</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    border while searching for the left base. Instead, two minima at 0 and 2</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    are found in which case the one closer to the evaluated peak is always</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral">    chosen. On the right side, however, the base must be placed at 6 because the</span></div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    higher peak represents the right border to the evaluated area.</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    &gt;&gt;&gt; peak_prominences(x, peaks, wlen=3.1)</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral">    (array([2.]), array([4]), array([6]))</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    Here, we restricted the algorithm to a window from 3 to 7 (the length is 5</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    samples because `wlen` was rounded up to the next odd integer). Thus, the</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">    only two candidates in the evaluated area are the two neighboring samples</span></div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    and a smaller prominence is calculated.</span></div>
<div class="line"><span class="lineno">  455</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  456</span>    x = _arg_x_as_expected(x)</div>
<div class="line"><span class="lineno">  457</span>    peaks = _arg_peaks_as_expected(peaks)</div>
<div class="line"><span class="lineno">  458</span>    wlen = _arg_wlen_as_expected(wlen)</div>
<div class="line"><span class="lineno">  459</span>    <span class="keywordflow">return</span> _peak_prominences(x, peaks, wlen)</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a69fd0269f882b5937fe2cb4f48637241" name="a69fd0269f882b5937fe2cb4f48637241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69fd0269f882b5937fe2cb4f48637241">&#9670;&#160;</a></span>peak_widths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._peak_finding.peak_widths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>peaks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rel_height</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prominence_data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wlen</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the width of each peak in a signal.

This function calculates the width of a peak in samples at a relative
distance to the peak's height and prominence.

Parameters
----------
x : sequence
    A signal with peaks.
peaks : sequence
    Indices of peaks in `x`.
rel_height : float, optional
    Chooses the relative height at which the peak width is measured as a
    percentage of its prominence. 1.0 calculates the width of the peak at
    its lowest contour line while 0.5 evaluates at half the prominence
    height. Must be at least 0. See notes for further explanation.
prominence_data : tuple, optional
    A tuple of three arrays matching the output of `peak_prominences` when
    called with the same arguments `x` and `peaks`. This data are calculated
    internally if not provided.
wlen : int, optional
    A window length in samples passed to `peak_prominences` as an optional
    argument for internal calculation of `prominence_data`. This argument
    is ignored if `prominence_data` is given.

Returns
-------
widths : ndarray
    The widths for each peak in samples.
width_heights : ndarray
    The height of the contour lines at which the `widths` where evaluated.
left_ips, right_ips : ndarray
    Interpolated positions of left and right intersection points of a
    horizontal line at the respective evaluation height.

Raises
------
ValueError
    If `prominence_data` is supplied but doesn't satisfy the condition
    ``0 &lt;= left_base &lt;= peak &lt;= right_base &lt; x.shape[0]`` for each peak,
    has the wrong dtype, is not C-contiguous or does not have the same
    shape.

Warns
-----
PeakPropertyWarning
    Raised if any calculated width is 0. This may stem from the supplied
    `prominence_data` or if `rel_height` is set to 0.

Warnings
--------
This function may return unexpected results for data containing NaNs. To
avoid this, NaNs should either be removed or replaced.

See Also
--------
find_peaks
    Find peaks inside a signal based on peak properties.
peak_prominences
    Calculate the prominence of peaks.

Notes
-----
The basic algorithm to calculate a peak's width is as follows:

* Calculate the evaluation height :math:`h_{eval}` with the formula
  :math:`h_{eval} = h_{Peak} - P \\cdot R`, where :math:`h_{Peak}` is the
  height of the peak itself, :math:`P` is the peak's prominence and
  :math:`R` a positive ratio specified with the argument `rel_height`.
* Draw a horizontal line at the evaluation height to both sides, starting at
  the peak's current vertical position until the lines either intersect a
  slope, the signal border or cross the vertical position of the peak's
  base (see `peak_prominences` for an definition). For the first case,
  intersection with the signal, the true intersection point is estimated
  with linear interpolation.
* Calculate the width as the horizontal distance between the chosen
  endpoints on both sides. As a consequence of this the maximal possible
  width for each peak is the horizontal distance between its bases.

As shown above to calculate a peak's width its prominence and bases must be
known. You can supply these yourself with the argument `prominence_data`.
Otherwise, they are internally calculated (see `peak_prominences`).

.. versionadded:: 1.1.0

Examples
--------
&gt;&gt;&gt; from scipy.signal import chirp, find_peaks, peak_widths
&gt;&gt;&gt; import matplotlib.pyplot as plt

Create a test signal with two overlayed harmonics

&gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000)
&gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x)

Find all peaks and calculate their widths at the relative height of 0.5
(contour line at half the prominence height) and 1 (at the lowest contour
line at full prominence height).

&gt;&gt;&gt; peaks, _ = find_peaks(x)
&gt;&gt;&gt; results_half = peak_widths(x, peaks, rel_height=0.5)
&gt;&gt;&gt; results_half[0]  # widths
array([ 64.25172825,  41.29465463,  35.46943289, 104.71586081,
        35.46729324,  41.30429622, 181.93835853,  45.37078546])
&gt;&gt;&gt; results_full = peak_widths(x, peaks, rel_height=1)
&gt;&gt;&gt; results_full[0]  # widths
array([181.9396084 ,  72.99284945,  61.28657872, 373.84622694,
    61.78404617,  72.48822812, 253.09161876,  79.36860878])

Plot signal, peaks and contour lines at which the widths where calculated

&gt;&gt;&gt; plt.plot(x)
&gt;&gt;&gt; plt.plot(peaks, x[peaks], "x")
&gt;&gt;&gt; plt.hlines(*results_half[1:], color="C2")
&gt;&gt;&gt; plt.hlines(*results_full[1:], color="C3")
&gt;&gt;&gt; plt.show()
</pre> <div class="fragment"><div class="line"><span class="lineno">  462</span><span class="keyword">def </span>peak_widths(x, peaks, rel_height=0.5, prominence_data=None, wlen=None):</div>
<div class="line"><span class="lineno">  463</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral">    Calculate the width of each peak in a signal.</span></div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">    This function calculates the width of a peak in samples at a relative</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">    distance to the peak&#39;s height and prominence.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">    x : sequence</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral">        A signal with peaks.</span></div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">    peaks : sequence</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">        Indices of peaks in `x`.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral">    rel_height : float, optional</span></div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        Chooses the relative height at which the peak width is measured as a</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">        percentage of its prominence. 1.0 calculates the width of the peak at</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">        its lowest contour line while 0.5 evaluates at half the prominence</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">        height. Must be at least 0. See notes for further explanation.</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">    prominence_data : tuple, optional</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">        A tuple of three arrays matching the output of `peak_prominences` when</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">        called with the same arguments `x` and `peaks`. This data are calculated</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">        internally if not provided.</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">    wlen : int, optional</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        A window length in samples passed to `peak_prominences` as an optional</span></div>
<div class="line"><span class="lineno">  486</span><span class="stringliteral">        argument for internal calculation of `prominence_data`. This argument</span></div>
<div class="line"><span class="lineno">  487</span><span class="stringliteral">        is ignored if `prominence_data` is given.</span></div>
<div class="line"><span class="lineno">  488</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  489</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral">    widths : ndarray</span></div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">        The widths for each peak in samples.</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    width_heights : ndarray</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        The height of the contour lines at which the `widths` where evaluated.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">    left_ips, right_ips : ndarray</span></div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">        Interpolated positions of left and right intersection points of a</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">        horizontal line at the respective evaluation height.</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        If `prominence_data` is supplied but doesn&#39;t satisfy the condition</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        ``0 &lt;= left_base &lt;= peak &lt;= right_base &lt; x.shape[0]`` for each peak,</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        has the wrong dtype, is not C-contiguous or does not have the same</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        shape.</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">    Warns</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">    PeakPropertyWarning</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        Raised if any calculated width is 0. This may stem from the supplied</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        `prominence_data` or if `rel_height` is set to 0.</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">    Warnings</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">    This function may return unexpected results for data containing NaNs. To</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">    avoid this, NaNs should either be removed or replaced.</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">    find_peaks</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        Find peaks inside a signal based on peak properties.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    peak_prominences</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        Calculate the prominence of peaks.</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    The basic algorithm to calculate a peak&#39;s width is as follows:</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    * Calculate the evaluation height :math:`h_{eval}` with the formula</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">      :math:`h_{eval} = h_{Peak} - P \\cdot R`, where :math:`h_{Peak}` is the</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">      height of the peak itself, :math:`P` is the peak&#39;s prominence and</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">      :math:`R` a positive ratio specified with the argument `rel_height`.</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    * Draw a horizontal line at the evaluation height to both sides, starting at</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">      the peak&#39;s current vertical position until the lines either intersect a</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">      slope, the signal border or cross the vertical position of the peak&#39;s</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">      base (see `peak_prominences` for an definition). For the first case,</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">      intersection with the signal, the true intersection point is estimated</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">      with linear interpolation.</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    * Calculate the width as the horizontal distance between the chosen</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">      endpoints on both sides. As a consequence of this the maximal possible</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">      width for each peak is the horizontal distance between its bases.</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    As shown above to calculate a peak&#39;s width its prominence and bases must be</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    known. You can supply these yourself with the argument `prominence_data`.</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    Otherwise, they are internally calculated (see `peak_prominences`).</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import chirp, find_peaks, peak_widths</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    Create a test signal with two overlayed harmonics</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">    &gt;&gt;&gt; x = np.linspace(0, 6 * np.pi, 1000)</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">    &gt;&gt;&gt; x = np.sin(x) + 0.6 * np.sin(2.6 * x)</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">    Find all peaks and calculate their widths at the relative height of 0.5</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">    (contour line at half the prominence height) and 1 (at the lowest contour</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral">    line at full prominence height).</span></div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    &gt;&gt;&gt; peaks, _ = find_peaks(x)</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral">    &gt;&gt;&gt; results_half = peak_widths(x, peaks, rel_height=0.5)</span></div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">    &gt;&gt;&gt; results_half[0]  # widths</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">    array([ 64.25172825,  41.29465463,  35.46943289, 104.71586081,</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">            35.46729324,  41.30429622, 181.93835853,  45.37078546])</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral">    &gt;&gt;&gt; results_full = peak_widths(x, peaks, rel_height=1)</span></div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    &gt;&gt;&gt; results_full[0]  # widths</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral">    array([181.9396084 ,  72.99284945,  61.28657872, 373.84622694,</span></div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">        61.78404617,  72.48822812, 253.09161876,  79.36860878])</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    Plot signal, peaks and contour lines at which the widths where calculated</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(x)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(peaks, x[peaks], &quot;x&quot;)</span></div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    &gt;&gt;&gt; plt.hlines(*results_half[1:], color=&quot;C2&quot;)</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">    &gt;&gt;&gt; plt.hlines(*results_full[1:], color=&quot;C3&quot;)</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  581</span>    x = _arg_x_as_expected(x)</div>
<div class="line"><span class="lineno">  582</span>    peaks = _arg_peaks_as_expected(peaks)</div>
<div class="line"><span class="lineno">  583</span>    <span class="keywordflow">if</span> prominence_data <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  584</span>        <span class="comment"># Calculate prominence if not supplied and use wlen if supplied.</span></div>
<div class="line"><span class="lineno">  585</span>        wlen = _arg_wlen_as_expected(wlen)</div>
<div class="line"><span class="lineno">  586</span>        prominence_data = _peak_prominences(x, peaks, wlen)</div>
<div class="line"><span class="lineno">  587</span>    <span class="keywordflow">return</span> _peak_widths(x, peaks, rel_height, *prominence_data)</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
