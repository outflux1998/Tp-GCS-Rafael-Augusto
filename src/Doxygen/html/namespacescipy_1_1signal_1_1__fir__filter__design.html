<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: scipy.signal._fir_filter_design Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacescipy.html">scipy</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal.html">signal</a></li><li class="navelem"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html">_fir_filter_design</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scipy.signal._fir_filter_design Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9b6d9b077f47727a463a031e87df6327" id="r_a9b6d9b077f47727a463a031e87df6327"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a9b6d9b077f47727a463a031e87df6327">_get_fs</a> (fs, nyq)</td></tr>
<tr class="separator:a9b6d9b077f47727a463a031e87df6327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa1c6de0dbaf7aa0f1121be85ff1c3f" id="r_a3aa1c6de0dbaf7aa0f1121be85ff1c3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a3aa1c6de0dbaf7aa0f1121be85ff1c3f">kaiser_beta</a> (<a class="el" href="__blas__subroutines_8h.html#a4da0a64c77789ca4c8115aef76120fd2">a</a>)</td></tr>
<tr class="separator:a3aa1c6de0dbaf7aa0f1121be85ff1c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ac7cf55e5243fdc7cbac8b63108b0a" id="r_a50ac7cf55e5243fdc7cbac8b63108b0a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a50ac7cf55e5243fdc7cbac8b63108b0a">kaiser_atten</a> (numtaps, width)</td></tr>
<tr class="separator:a50ac7cf55e5243fdc7cbac8b63108b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3198c7e00ea036cdc733e5ff5b93dd3" id="r_ac3198c7e00ea036cdc733e5ff5b93dd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#ac3198c7e00ea036cdc733e5ff5b93dd3">kaiserord</a> (ripple, width)</td></tr>
<tr class="separator:ac3198c7e00ea036cdc733e5ff5b93dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e940213231a4c6a1271017ee67a9ab" id="r_a74e940213231a4c6a1271017ee67a9ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a74e940213231a4c6a1271017ee67a9ab">firwin</a> (numtaps, cutoff, width=None, window='hamming', pass_zero=True, scale=True, nyq=None, fs=None)</td></tr>
<tr class="separator:a74e940213231a4c6a1271017ee67a9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7877c78a419877dd794b26a3c807cd" id="r_a1f7877c78a419877dd794b26a3c807cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a1f7877c78a419877dd794b26a3c807cd">firwin2</a> (numtaps, freq, gain, nfreqs=None, window='hamming', nyq=None, antisymmetric=False, fs=None)</td></tr>
<tr class="separator:a1f7877c78a419877dd794b26a3c807cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a3ff237b9a0c641ef2dd402a0a7ee" id="r_a909a3ff237b9a0c641ef2dd402a0a7ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a909a3ff237b9a0c641ef2dd402a0a7ee">remez</a> (numtaps, bands, desired, weight=None, Hz=None, type='bandpass', maxiter=25, grid_density=16, fs=None)</td></tr>
<tr class="separator:a909a3ff237b9a0c641ef2dd402a0a7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e0f668c9d6f42ff759cbf31c99b92d" id="r_a30e0f668c9d6f42ff759cbf31c99b92d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a30e0f668c9d6f42ff759cbf31c99b92d">firls</a> (numtaps, bands, desired, weight=None, nyq=None, fs=None)</td></tr>
<tr class="separator:a30e0f668c9d6f42ff759cbf31c99b92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df677277b316465bef06cda54628ac1" id="r_a6df677277b316465bef06cda54628ac1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#a6df677277b316465bef06cda54628ac1">_dhtm</a> (mag)</td></tr>
<tr class="separator:a6df677277b316465bef06cda54628ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2de1b0b0595bd11e48606e002ec9542" id="r_ac2de1b0b0595bd11e48606e002ec9542"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacescipy_1_1signal_1_1__fir__filter__design.html#ac2de1b0b0595bd11e48606e002ec9542">minimum_phase</a> (<a class="el" href="__lapack__subroutines_8h.html#a866dc72abfeae882204974bec3220f3a">h</a>, method='homomorphic', n_fft=None)</td></tr>
<tr class="separator:ac2de1b0b0595bd11e48606e002ec9542"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Functions for FIR filter design.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a6df677277b316465bef06cda54628ac1" name="a6df677277b316465bef06cda54628ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df677277b316465bef06cda54628ac1">&#9670;&#160;</a></span>_dhtm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design._dhtm </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the modified 1-D discrete Hilbert transform

Parameters
----------
mag : ndarray
    The magnitude spectrum. Should be 1-D with an even length, and
    preferably a fast length for FFT/IFFT.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1069</span><span class="keyword">def </span>_dhtm(mag):</div>
<div class="line"><span class="lineno"> 1070</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the modified 1-D discrete Hilbert transform</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    mag : ndarray</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        The magnitude spectrum. Should be 1-D with an even length, and</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        preferably a fast length for FFT/IFFT.</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1078</span>    <span class="comment"># Adapted based on code by Niranjan Damera-Venkata,</span></div>
<div class="line"><span class="lineno"> 1079</span>    <span class="comment"># Brian L. Evans and Shawn R. McCaslin (see refs for `minimum_phase`)</span></div>
<div class="line"><span class="lineno"> 1080</span>    sig = np.zeros(len(mag))</div>
<div class="line"><span class="lineno"> 1081</span>    <span class="comment"># Leave Nyquist and DC at 0, knowing np.abs(fftfreq(N)[midpt]) == 0.5</span></div>
<div class="line"><span class="lineno"> 1082</span>    midpt = len(mag) // 2</div>
<div class="line"><span class="lineno"> 1083</span>    sig[1:midpt] = 1</div>
<div class="line"><span class="lineno"> 1084</span>    sig[midpt+1:] = -1</div>
<div class="line"><span class="lineno"> 1085</span>    <span class="comment"># eventually if we want to support complex filters, we will need a</span></div>
<div class="line"><span class="lineno"> 1086</span>    <span class="comment"># np.abs() on the mag inside the log, and should remove the .real</span></div>
<div class="line"><span class="lineno"> 1087</span>    recon = ifft(mag * np.exp(fft(sig * ifft(np.log(mag))))).real</div>
<div class="line"><span class="lineno"> 1088</span>    <span class="keywordflow">return</span> recon</div>
<div class="line"><span class="lineno"> 1089</span> </div>
<div class="line"><span class="lineno"> 1090</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9b6d9b077f47727a463a031e87df6327" name="a9b6d9b077f47727a463a031e87df6327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6d9b077f47727a463a031e87df6327">&#9670;&#160;</a></span>_get_fs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design._get_fs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nyq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Utility for replacing the argument 'nyq' (with default 1) with 'fs'.
</pre> <div class="fragment"><div class="line"><span class="lineno">   20</span><span class="keyword">def </span>_get_fs(fs, nyq):</div>
<div class="line"><span class="lineno">   21</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    Utility for replacing the argument &#39;nyq&#39; (with default 1) with &#39;fs&#39;.</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   24</span>    <span class="keywordflow">if</span> nyq <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> fs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   25</span>        fs = 2</div>
<div class="line"><span class="lineno">   26</span>    <span class="keywordflow">elif</span> nyq <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   27</span>        <span class="keywordflow">if</span> fs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   28</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Values cannot be given for both &#39;nyq&#39; and &#39;fs&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">   29</span>        fs = 2*nyq</div>
<div class="line"><span class="lineno">   30</span>    <span class="keywordflow">return</span> fs</div>
<div class="line"><span class="lineno">   31</span> </div>
<div class="line"><span class="lineno">   32</span> </div>
<div class="line"><span class="lineno">   33</span><span class="comment"># Some notes on function parameters:</span></div>
<div class="line"><span class="lineno">   34</span><span class="comment">#</span></div>
<div class="line"><span class="lineno">   35</span><span class="comment"># `cutoff` and `width` are given as numbers between 0 and 1.  These are</span></div>
<div class="line"><span class="lineno">   36</span><span class="comment"># relative frequencies, expressed as a fraction of the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">   37</span><span class="comment"># For example, if the Nyquist frequency is 2 KHz, then width=0.15 is a width</span></div>
<div class="line"><span class="lineno">   38</span><span class="comment"># of 300 Hz.</span></div>
<div class="line"><span class="lineno">   39</span><span class="comment">#</span></div>
<div class="line"><span class="lineno">   40</span><span class="comment"># The `order` of a FIR filter is one less than the number of taps.</span></div>
<div class="line"><span class="lineno">   41</span><span class="comment"># This is a potential source of confusion, so in the following code,</span></div>
<div class="line"><span class="lineno">   42</span><span class="comment"># we will always use the number of taps as the parameterization of</span></div>
<div class="line"><span class="lineno">   43</span><span class="comment"># the &#39;size&#39; of the filter. The &quot;number of taps&quot; means the number</span></div>
<div class="line"><span class="lineno">   44</span><span class="comment"># of coefficients, which is the same as the length of the impulse</span></div>
<div class="line"><span class="lineno">   45</span><span class="comment"># response of the filter.</span></div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a30e0f668c9d6f42ff759cbf31c99b92d" name="a30e0f668c9d6f42ff759cbf31c99b92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e0f668c9d6f42ff759cbf31c99b92d">&#9670;&#160;</a></span>firls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.firls </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numtaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nyq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">FIR filter design using least-squares error minimization.

Calculate the filter coefficients for the linear-phase finite
impulse response (FIR) filter which has the best approximation
to the desired frequency response described by `bands` and
`desired` in the least squares sense (i.e., the integral of the
weighted mean-squared error within the specified bands is
minimized).

Parameters
----------
numtaps : int
    The number of taps in the FIR filter. `numtaps` must be odd.
bands : array_like
    A monotonic nondecreasing sequence containing the band edges in
    Hz. All elements must be non-negative and less than or equal to
    the Nyquist frequency given by `nyq`.
desired : array_like
    A sequence the same size as `bands` containing the desired gain
    at the start and end point of each band.
weight : array_like, optional
    A relative weighting to give to each band region when solving
    the least squares problem. `weight` has to be half the size of
    `bands`.
nyq : float, optional
    *Deprecated. Use `fs` instead.*
    Nyquist frequency. Each frequency in `bands` must be between 0
    and `nyq` (inclusive). Default is 1.
fs : float, optional
    The sampling frequency of the signal. Each frequency in `bands`
    must be between 0 and ``fs/2`` (inclusive). Default is 2.

Returns
-------
coeffs : ndarray
    Coefficients of the optimal (in a least squares sense) FIR filter.

See also
--------
firwin
firwin2
minimum_phase
remez

Notes
-----
This implementation follows the algorithm given in [1]_.
As noted there, least squares design has multiple advantages:

    1. Optimal in a least-squares sense.
    2. Simple, non-iterative method.
    3. The general solution can obtained by solving a linear
       system of equations.
    4. Allows the use of a frequency dependent weighting function.

This function constructs a Type I linear phase FIR filter, which
contains an odd number of `coeffs` satisfying for :math:`n &lt; numtaps`:

.. math:: coeffs(n) = coeffs(numtaps - 1 - n)

The odd number of coefficients and filter symmetry avoid boundary
conditions that could otherwise occur at the Nyquist and 0 frequencies
(e.g., for Type II, III, or IV variants).

.. versionadded:: 0.18

References
----------
.. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares.
       OpenStax CNX. Aug 9, 2005.
       http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7

Examples
--------
We want to construct a band-pass filter. Note that the behavior in the
frequency ranges between our stop bands and pass bands is unspecified,
and thus may overshoot depending on the parameters of our filter:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fig, axs = plt.subplots(2)
&gt;&gt;&gt; fs = 10.0  # Hz
&gt;&gt;&gt; desired = (0, 0, 1, 1, 0, 0)
&gt;&gt;&gt; for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):
...     fir_firls = signal.firls(73, bands, desired, fs=fs)
...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs)
...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs)
...     hs = list()
...     ax = axs[bi]
...     for fir in (fir_firls, fir_remez, fir_firwin2):
...         freq, response = signal.freqz(fir)
...         hs.append(ax.semilogy(0.5*fs*freq/np.pi, np.abs(response))[0])
...     for band, gains in zip(zip(bands[::2], bands[1::2]),
...                            zip(desired[::2], desired[1::2])):
...         ax.semilogy(band, np.maximum(gains, 1e-7), 'k--', linewidth=2)
...     if bi == 0:
...         ax.legend(hs, ('firls', 'remez', 'firwin2'),
...                   loc='lower center', frameon=False)
...     else:
...         ax.set_xlabel('Frequency (Hz)')
...     ax.grid(True)
...     ax.set(title='Band-pass %d-%d Hz' % bands[2:4], ylabel='Magnitude')
...
&gt;&gt;&gt; fig.tight_layout()
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  857</span><span class="keyword">def </span>firls(numtaps, bands, desired, weight=None, nyq=None, fs=None):</div>
<div class="line"><span class="lineno">  858</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">    FIR filter design using least-squares error minimization.</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">    Calculate the filter coefficients for the linear-phase finite</span></div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">    impulse response (FIR) filter which has the best approximation</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">    to the desired frequency response described by `bands` and</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">    `desired` in the least squares sense (i.e., the integral of the</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">    weighted mean-squared error within the specified bands is</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">    minimized).</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">        The number of taps in the FIR filter. `numtaps` must be odd.</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">    bands : array_like</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">        A monotonic nondecreasing sequence containing the band edges in</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        Hz. All elements must be non-negative and less than or equal to</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        the Nyquist frequency given by `nyq`.</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">    desired : array_like</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral">        A sequence the same size as `bands` containing the desired gain</span></div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">        at the start and end point of each band.</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">    weight : array_like, optional</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">        A relative weighting to give to each band region when solving</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        the least squares problem. `weight` has to be half the size of</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        `bands`.</span></div>
<div class="line"><span class="lineno">  883</span><span class="stringliteral">    nyq : float, optional</span></div>
<div class="line"><span class="lineno">  884</span><span class="stringliteral">        *Deprecated. Use `fs` instead.*</span></div>
<div class="line"><span class="lineno">  885</span><span class="stringliteral">        Nyquist frequency. Each frequency in `bands` must be between 0</span></div>
<div class="line"><span class="lineno">  886</span><span class="stringliteral">        and `nyq` (inclusive). Default is 1.</span></div>
<div class="line"><span class="lineno">  887</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  888</span><span class="stringliteral">        The sampling frequency of the signal. Each frequency in `bands`</span></div>
<div class="line"><span class="lineno">  889</span><span class="stringliteral">        must be between 0 and ``fs/2`` (inclusive). Default is 2.</span></div>
<div class="line"><span class="lineno">  890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  891</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  892</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  893</span><span class="stringliteral">    coeffs : ndarray</span></div>
<div class="line"><span class="lineno">  894</span><span class="stringliteral">        Coefficients of the optimal (in a least squares sense) FIR filter.</span></div>
<div class="line"><span class="lineno">  895</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  896</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  897</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  898</span><span class="stringliteral">    firwin</span></div>
<div class="line"><span class="lineno">  899</span><span class="stringliteral">    firwin2</span></div>
<div class="line"><span class="lineno">  900</span><span class="stringliteral">    minimum_phase</span></div>
<div class="line"><span class="lineno">  901</span><span class="stringliteral">    remez</span></div>
<div class="line"><span class="lineno">  902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  903</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  904</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  905</span><span class="stringliteral">    This implementation follows the algorithm given in [1]_.</span></div>
<div class="line"><span class="lineno">  906</span><span class="stringliteral">    As noted there, least squares design has multiple advantages:</span></div>
<div class="line"><span class="lineno">  907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  908</span><span class="stringliteral">        1. Optimal in a least-squares sense.</span></div>
<div class="line"><span class="lineno">  909</span><span class="stringliteral">        2. Simple, non-iterative method.</span></div>
<div class="line"><span class="lineno">  910</span><span class="stringliteral">        3. The general solution can obtained by solving a linear</span></div>
<div class="line"><span class="lineno">  911</span><span class="stringliteral">           system of equations.</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        4. Allows the use of a frequency dependent weighting function.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">    This function constructs a Type I linear phase FIR filter, which</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">    contains an odd number of `coeffs` satisfying for :math:`n &lt; numtaps`:</span></div>
<div class="line"><span class="lineno">  916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  917</span><span class="stringliteral">    .. math:: coeffs(n) = coeffs(numtaps - 1 - n)</span></div>
<div class="line"><span class="lineno">  918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  919</span><span class="stringliteral">    The odd number of coefficients and filter symmetry avoid boundary</span></div>
<div class="line"><span class="lineno">  920</span><span class="stringliteral">    conditions that could otherwise occur at the Nyquist and 0 frequencies</span></div>
<div class="line"><span class="lineno">  921</span><span class="stringliteral">    (e.g., for Type II, III, or IV variants).</span></div>
<div class="line"><span class="lineno">  922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  923</span><span class="stringliteral">    .. versionadded:: 0.18</span></div>
<div class="line"><span class="lineno">  924</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  925</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  926</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  927</span><span class="stringliteral">    .. [1] Ivan Selesnick, Linear-Phase Fir Filter Design By Least Squares.</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">           OpenStax CNX. Aug 9, 2005.</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">           http://cnx.org/contents/eb1ecb35-03a9-4610-ba87-41cd771c95f2@7</span></div>
<div class="line"><span class="lineno">  930</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  931</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  932</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  933</span><span class="stringliteral">    We want to construct a band-pass filter. Note that the behavior in the</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">    frequency ranges between our stop bands and pass bands is unspecified,</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">    and thus may overshoot depending on the parameters of our filter:</span></div>
<div class="line"><span class="lineno">  936</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  937</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  938</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  939</span><span class="stringliteral">    &gt;&gt;&gt; fig, axs = plt.subplots(2)</span></div>
<div class="line"><span class="lineno">  940</span><span class="stringliteral">    &gt;&gt;&gt; fs = 10.0  # Hz</span></div>
<div class="line"><span class="lineno">  941</span><span class="stringliteral">    &gt;&gt;&gt; desired = (0, 0, 1, 1, 0, 0)</span></div>
<div class="line"><span class="lineno">  942</span><span class="stringliteral">    &gt;&gt;&gt; for bi, bands in enumerate(((0, 1, 2, 3, 4, 5), (0, 1, 2, 4, 4.5, 5))):</span></div>
<div class="line"><span class="lineno">  943</span><span class="stringliteral">    ...     fir_firls = signal.firls(73, bands, desired, fs=fs)</span></div>
<div class="line"><span class="lineno">  944</span><span class="stringliteral">    ...     fir_remez = signal.remez(73, bands, desired[::2], fs=fs)</span></div>
<div class="line"><span class="lineno">  945</span><span class="stringliteral">    ...     fir_firwin2 = signal.firwin2(73, bands, desired, fs=fs)</span></div>
<div class="line"><span class="lineno">  946</span><span class="stringliteral">    ...     hs = list()</span></div>
<div class="line"><span class="lineno">  947</span><span class="stringliteral">    ...     ax = axs[bi]</span></div>
<div class="line"><span class="lineno">  948</span><span class="stringliteral">    ...     for fir in (fir_firls, fir_remez, fir_firwin2):</span></div>
<div class="line"><span class="lineno">  949</span><span class="stringliteral">    ...         freq, response = signal.freqz(fir)</span></div>
<div class="line"><span class="lineno">  950</span><span class="stringliteral">    ...         hs.append(ax.semilogy(0.5*fs*freq/np.pi, np.abs(response))[0])</span></div>
<div class="line"><span class="lineno">  951</span><span class="stringliteral">    ...     for band, gains in zip(zip(bands[::2], bands[1::2]),</span></div>
<div class="line"><span class="lineno">  952</span><span class="stringliteral">    ...                            zip(desired[::2], desired[1::2])):</span></div>
<div class="line"><span class="lineno">  953</span><span class="stringliteral">    ...         ax.semilogy(band, np.maximum(gains, 1e-7), &#39;k--&#39;, linewidth=2)</span></div>
<div class="line"><span class="lineno">  954</span><span class="stringliteral">    ...     if bi == 0:</span></div>
<div class="line"><span class="lineno">  955</span><span class="stringliteral">    ...         ax.legend(hs, (&#39;firls&#39;, &#39;remez&#39;, &#39;firwin2&#39;),</span></div>
<div class="line"><span class="lineno">  956</span><span class="stringliteral">    ...                   loc=&#39;lower center&#39;, frameon=False)</span></div>
<div class="line"><span class="lineno">  957</span><span class="stringliteral">    ...     else:</span></div>
<div class="line"><span class="lineno">  958</span><span class="stringliteral">    ...         ax.set_xlabel(&#39;Frequency (Hz)&#39;)</span></div>
<div class="line"><span class="lineno">  959</span><span class="stringliteral">    ...     ax.grid(True)</span></div>
<div class="line"><span class="lineno">  960</span><span class="stringliteral">    ...     ax.set(title=&#39;Band-pass %d-%d Hz&#39; % bands[2:4], ylabel=&#39;Magnitude&#39;)</span></div>
<div class="line"><span class="lineno">  961</span><span class="stringliteral">    ...</span></div>
<div class="line"><span class="lineno">  962</span><span class="stringliteral">    &gt;&gt;&gt; fig.tight_layout()</span></div>
<div class="line"><span class="lineno">  963</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  964</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  965</span><span class="stringliteral">    &quot;&quot;&quot;</span>  <span class="comment"># noqa</span></div>
<div class="line"><span class="lineno">  966</span>    nyq = 0.5 * _get_fs(fs, nyq)</div>
<div class="line"><span class="lineno">  967</span> </div>
<div class="line"><span class="lineno">  968</span>    numtaps = int(numtaps)</div>
<div class="line"><span class="lineno">  969</span>    <span class="keywordflow">if</span> numtaps % 2 == 0 <span class="keywordflow">or</span> numtaps &lt; 1:</div>
<div class="line"><span class="lineno">  970</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;numtaps must be odd and &gt;= 1&quot;</span>)</div>
<div class="line"><span class="lineno">  971</span>    M = (numtaps-1) // 2</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    <span class="comment"># normalize bands 0-&gt;1 and make it 2 columns</span></div>
<div class="line"><span class="lineno">  974</span>    nyq = float(nyq)</div>
<div class="line"><span class="lineno">  975</span>    <span class="keywordflow">if</span> nyq &lt;= 0:</div>
<div class="line"><span class="lineno">  976</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;nyq must be positive, got %s &lt;= 0.&#39;</span> % nyq)</div>
<div class="line"><span class="lineno">  977</span>    bands = np.asarray(bands).flatten() / nyq</div>
<div class="line"><span class="lineno">  978</span>    <span class="keywordflow">if</span> len(bands) % 2 != 0:</div>
<div class="line"><span class="lineno">  979</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;bands must contain frequency pairs.&quot;</span>)</div>
<div class="line"><span class="lineno">  980</span>    <span class="keywordflow">if</span> (bands &lt; 0).any() <span class="keywordflow">or</span> (bands &gt; 1).any():</div>
<div class="line"><span class="lineno">  981</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;bands must be between 0 and 1 relative to Nyquist&quot;</span>)</div>
<div class="line"><span class="lineno">  982</span>    bands.shape = (-1, 2)</div>
<div class="line"><span class="lineno">  983</span> </div>
<div class="line"><span class="lineno">  984</span>    <span class="comment"># check remaining params</span></div>
<div class="line"><span class="lineno">  985</span>    desired = np.asarray(desired).flatten()</div>
<div class="line"><span class="lineno">  986</span>    <span class="keywordflow">if</span> bands.size != desired.size:</div>
<div class="line"><span class="lineno">  987</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;desired must have one entry per frequency, got %s &quot;</span></div>
<div class="line"><span class="lineno">  988</span>                         <span class="stringliteral">&quot;gains for %s frequencies.&quot;</span></div>
<div class="line"><span class="lineno">  989</span>                         % (desired.size, bands.size))</div>
<div class="line"><span class="lineno">  990</span>    desired.shape = (-1, 2)</div>
<div class="line"><span class="lineno">  991</span>    <span class="keywordflow">if</span> (np.diff(bands) &lt;= 0).any() <span class="keywordflow">or</span> (np.diff(bands[:, 0]) &lt; 0).any():</div>
<div class="line"><span class="lineno">  992</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;bands must be monotonically nondecreasing and have &quot;</span></div>
<div class="line"><span class="lineno">  993</span>                         <span class="stringliteral">&quot;width &gt; 0.&quot;</span>)</div>
<div class="line"><span class="lineno">  994</span>    <span class="keywordflow">if</span> (bands[:-1, 1] &gt; bands[1:, 0]).any():</div>
<div class="line"><span class="lineno">  995</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;bands must not overlap.&quot;</span>)</div>
<div class="line"><span class="lineno">  996</span>    <span class="keywordflow">if</span> (desired &lt; 0).any():</div>
<div class="line"><span class="lineno">  997</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;desired must be non-negative.&quot;</span>)</div>
<div class="line"><span class="lineno">  998</span>    <span class="keywordflow">if</span> weight <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  999</span>        weight = np.ones(len(desired))</div>
<div class="line"><span class="lineno"> 1000</span>    weight = np.asarray(weight).flatten()</div>
<div class="line"><span class="lineno"> 1001</span>    <span class="keywordflow">if</span> len(weight) != len(desired):</div>
<div class="line"><span class="lineno"> 1002</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;weight must be the same size as the number of &quot;</span></div>
<div class="line"><span class="lineno"> 1003</span>                         <span class="stringliteral">&quot;band pairs (%s).&quot;</span> % (len(bands),))</div>
<div class="line"><span class="lineno"> 1004</span>    <span class="keywordflow">if</span> (weight &lt; 0).any():</div>
<div class="line"><span class="lineno"> 1005</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;weight must be non-negative.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1006</span> </div>
<div class="line"><span class="lineno"> 1007</span>    <span class="comment"># Set up the linear matrix equation to be solved, Qa = b</span></div>
<div class="line"><span class="lineno"> 1008</span> </div>
<div class="line"><span class="lineno"> 1009</span>    <span class="comment"># We can express Q(k,n) = 0.5 Q1(k,n) + 0.5 Q2(k,n)</span></div>
<div class="line"><span class="lineno"> 1010</span>    <span class="comment"># where Q1(k,n)=q(k-n) and Q2(k,n)=q(k+n), i.e. a Toeplitz plus Hankel.</span></div>
<div class="line"><span class="lineno"> 1011</span> </div>
<div class="line"><span class="lineno"> 1012</span>    <span class="comment"># We omit the factor of 0.5 above, instead adding it during coefficient</span></div>
<div class="line"><span class="lineno"> 1013</span>    <span class="comment"># calculation.</span></div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1015</span>    <span class="comment"># We also omit the 1/π from both Q and b equations, as they cancel</span></div>
<div class="line"><span class="lineno"> 1016</span>    <span class="comment"># during solving.</span></div>
<div class="line"><span class="lineno"> 1017</span> </div>
<div class="line"><span class="lineno"> 1018</span>    <span class="comment"># We have that:</span></div>
<div class="line"><span class="lineno"> 1019</span>    <span class="comment">#     q(n) = 1/π ∫W(ω)cos(nω)dω (over 0-&gt;π)</span></div>
<div class="line"><span class="lineno"> 1020</span>    <span class="comment"># Using our nomalization ω=πf and with a constant weight W over each</span></div>
<div class="line"><span class="lineno"> 1021</span>    <span class="comment"># interval f1-&gt;f2 we get:</span></div>
<div class="line"><span class="lineno"> 1022</span>    <span class="comment">#     q(n) = W∫cos(πnf)df (0-&gt;1) = Wf sin(πnf)/πnf</span></div>
<div class="line"><span class="lineno"> 1023</span>    <span class="comment"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span></div>
<div class="line"><span class="lineno"> 1024</span>    n = np.arange(numtaps)[:, np.newaxis, np.newaxis]</div>
<div class="line"><span class="lineno"> 1025</span>    q = np.dot(np.diff(np.sinc(bands * n) * bands, axis=2)[:, :, 0], weight)</div>
<div class="line"><span class="lineno"> 1026</span> </div>
<div class="line"><span class="lineno"> 1027</span>    <span class="comment"># Now we assemble our sum of Toeplitz and Hankel</span></div>
<div class="line"><span class="lineno"> 1028</span>    Q1 = toeplitz(q[:M+1])</div>
<div class="line"><span class="lineno"> 1029</span>    Q2 = hankel(q[:M+1], q[M:])</div>
<div class="line"><span class="lineno"> 1030</span>    Q = Q1 + Q2</div>
<div class="line"><span class="lineno"> 1031</span> </div>
<div class="line"><span class="lineno"> 1032</span>    <span class="comment"># Now for b(n) we have that:</span></div>
<div class="line"><span class="lineno"> 1033</span>    <span class="comment">#     b(n) = 1/π ∫ W(ω)D(ω)cos(nω)dω (over 0-&gt;π)</span></div>
<div class="line"><span class="lineno"> 1034</span>    <span class="comment"># Using our normalization ω=πf and with a constant weight W over each</span></div>
<div class="line"><span class="lineno"> 1035</span>    <span class="comment"># interval and a linear term for D(ω) we get (over each f1-&gt;f2 interval):</span></div>
<div class="line"><span class="lineno"> 1036</span>    <span class="comment">#     b(n) = W ∫ (mf+c)cos(πnf)df</span></div>
<div class="line"><span class="lineno"> 1037</span>    <span class="comment">#          = f(mf+c)sin(πnf)/πnf + mf**2 cos(nπf)/(πnf)**2</span></div>
<div class="line"><span class="lineno"> 1038</span>    <span class="comment"># integrated over each f1-&gt;f2 pair (i.e., value at f2 - value at f1).</span></div>
<div class="line"><span class="lineno"> 1039</span>    n = n[:M + 1]  <span class="comment"># only need this many coefficients here</span></div>
<div class="line"><span class="lineno"> 1040</span>    <span class="comment"># Choose m and c such that we are at the start and end weights</span></div>
<div class="line"><span class="lineno"> 1041</span>    m = (np.diff(desired, axis=1) / np.diff(bands, axis=1))</div>
<div class="line"><span class="lineno"> 1042</span>    c = desired[:, [0]] - bands[:, [0]] * m</div>
<div class="line"><span class="lineno"> 1043</span>    b = bands * (m*bands + c) * np.sinc(bands * n)</div>
<div class="line"><span class="lineno"> 1044</span>    <span class="comment"># Use L&#39;Hospital&#39;s rule here for cos(nπf)/(πnf)**2 @ n=0</span></div>
<div class="line"><span class="lineno"> 1045</span>    b[0] -= m * bands * bands / 2.</div>
<div class="line"><span class="lineno"> 1046</span>    b[1:] += m * np.cos(n[1:] * np.pi * bands) / (np.pi * n[1:]) ** 2</div>
<div class="line"><span class="lineno"> 1047</span>    b = np.dot(np.diff(b, axis=2)[:, :, 0], weight)</div>
<div class="line"><span class="lineno"> 1048</span> </div>
<div class="line"><span class="lineno"> 1049</span>    <span class="comment"># Now we can solve the equation</span></div>
<div class="line"><span class="lineno"> 1050</span>    <span class="keywordflow">try</span>:  <span class="comment"># try the fast way</span></div>
<div class="line"><span class="lineno"> 1051</span>        <span class="keyword">with</span> warnings.catch_warnings(record=<span class="keyword">True</span>) <span class="keyword">as</span> w:</div>
<div class="line"><span class="lineno"> 1052</span>            warnings.simplefilter(<span class="stringliteral">&#39;always&#39;</span>)</div>
<div class="line"><span class="lineno"> 1053</span>            a = solve(Q, b, assume_a=<span class="stringliteral">&quot;pos&quot;</span>, check_finite=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1054</span>        <span class="keywordflow">for</span> ww <span class="keywordflow">in</span> w:</div>
<div class="line"><span class="lineno"> 1055</span>            <span class="keywordflow">if</span> (ww.category == LinAlgWarning <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno"> 1056</span>                    str(ww.message).startswith(<span class="stringliteral">&#39;Ill-conditioned matrix&#39;</span>)):</div>
<div class="line"><span class="lineno"> 1057</span>                <span class="keywordflow">raise</span> LinAlgError(str(ww.message))</div>
<div class="line"><span class="lineno"> 1058</span>    <span class="keywordflow">except</span> LinAlgError:  <span class="comment"># in case Q is rank deficient</span></div>
<div class="line"><span class="lineno"> 1059</span>        <span class="comment"># This is faster than pinvh, even though we don&#39;t explicitly use</span></div>
<div class="line"><span class="lineno"> 1060</span>        <span class="comment"># the symmetry here. gelsy was faster than gelsd and gelss in</span></div>
<div class="line"><span class="lineno"> 1061</span>        <span class="comment"># some non-exhaustive tests.</span></div>
<div class="line"><span class="lineno"> 1062</span>        a = lstsq(Q, b, lapack_driver=<span class="stringliteral">&#39;gelsy&#39;</span>)[0]</div>
<div class="line"><span class="lineno"> 1063</span> </div>
<div class="line"><span class="lineno"> 1064</span>    <span class="comment"># make coefficients symmetric (linear phase)</span></div>
<div class="line"><span class="lineno"> 1065</span>    coeffs = np.hstack((a[:0:-1], 2 * a[0], a[1:]))</div>
<div class="line"><span class="lineno"> 1066</span>    <span class="keywordflow">return</span> coeffs</div>
<div class="line"><span class="lineno"> 1067</span> </div>
<div class="line"><span class="lineno"> 1068</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a74e940213231a4c6a1271017ee67a9ab" name="a74e940213231a4c6a1271017ee67a9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e940213231a4c6a1271017ee67a9ab">&#9670;&#160;</a></span>firwin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.firwin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numtaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hamming'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pass_zero</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>scale</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nyq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">FIR filter design using the window method.

This function computes the coefficients of a finite impulse response
filter. The filter will have linear phase; it will be Type I if
`numtaps` is odd and Type II if `numtaps` is even.

Type II filters always have zero response at the Nyquist frequency, so a
ValueError exception is raised if firwin is called with `numtaps` even and
having a passband whose right end is at the Nyquist frequency.

Parameters
----------
numtaps : int
    Length of the filter (number of coefficients, i.e. the filter
    order + 1).  `numtaps` must be odd if a passband includes the
    Nyquist frequency.
cutoff : float or 1-D array_like
    Cutoff frequency of filter (expressed in the same units as `fs`)
    OR an array of cutoff frequencies (that is, band edges). In the
    latter case, the frequencies in `cutoff` should be positive and
    monotonically increasing between 0 and `fs/2`. The values 0 and
    `fs/2` must not be included in `cutoff`.
width : float or None, optional
    If `width` is not None, then assume it is the approximate width
    of the transition region (expressed in the same units as `fs`)
    for use in Kaiser FIR filter design. In this case, the `window`
    argument is ignored.
window : string or tuple of string and parameter values, optional
    Desired window to use. See `scipy.signal.get_window` for a list
    of windows and required parameters.
pass_zero : {True, False, 'bandpass', 'lowpass', 'highpass', 'bandstop'}, optional
    If True, the gain at the frequency 0 (i.e., the "DC gain") is 1.
    If False, the DC gain is 0. Can also be a string argument for the
    desired filter type (equivalent to ``btype`` in IIR design functions).

    .. versionadded:: 1.3.0
       Support for string arguments.
scale : bool, optional
    Set to True to scale the coefficients so that the frequency
    response is exactly unity at a certain frequency.
    That frequency is either:

    - 0 (DC) if the first passband starts at 0 (i.e. pass_zero
      is True)
    - `fs/2` (the Nyquist frequency) if the first passband ends at
      `fs/2` (i.e the filter is a single band highpass filter);
      center of first passband otherwise

nyq : float, optional
    *Deprecated. Use `fs` instead.* This is the Nyquist frequency.
    Each frequency in `cutoff` must be between 0 and `nyq`. Default
    is 1.
fs : float, optional
    The sampling frequency of the signal. Each frequency in `cutoff`
    must be between 0 and ``fs/2``.  Default is 2.

Returns
-------
h : (numtaps,) ndarray
    Coefficients of length `numtaps` FIR filter.

Raises
------
ValueError
    If any value in `cutoff` is less than or equal to 0 or greater
    than or equal to ``fs/2``, if the values in `cutoff` are not strictly
    monotonically increasing, or if `numtaps` is even but a passband
    includes the Nyquist frequency.

See Also
--------
firwin2
firls
minimum_phase
remez

Examples
--------
Low-pass from 0 to f:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; numtaps = 3
&gt;&gt;&gt; f = 0.1
&gt;&gt;&gt; signal.firwin(numtaps, f)
array([ 0.06799017,  0.86401967,  0.06799017])

Use a specific window function:

&gt;&gt;&gt; signal.firwin(numtaps, f, window='nuttall')
array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])

High-pass ('stop' from 0 to f):

&gt;&gt;&gt; signal.firwin(numtaps, f, pass_zero=False)
array([-0.00859313,  0.98281375, -0.00859313])

Band-pass:

&gt;&gt;&gt; f1, f2 = 0.1, 0.2
&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2], pass_zero=False)
array([ 0.06301614,  0.88770441,  0.06301614])

Band-stop:

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2])
array([-0.00801395,  1.0160279 , -0.00801395])

Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):

&gt;&gt;&gt; f3, f4 = 0.3, 0.4
&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4])
array([-0.01376344,  1.02752689, -0.01376344])

Multi-band (passbands are [f1, f2] and [f3,f4]):

&gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)
array([ 0.04890915,  0.91284326,  0.04890915])</pre> <div class="fragment"><div class="line"><span class="lineno">  263</span>           scale=<span class="keyword">True</span>, nyq=<span class="keywordtype">None</span>, fs=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  264</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  265</span><span class="stringliteral">    FIR filter design using the window method.</span></div>
<div class="line"><span class="lineno">  266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  267</span><span class="stringliteral">    This function computes the coefficients of a finite impulse response</span></div>
<div class="line"><span class="lineno">  268</span><span class="stringliteral">    filter. The filter will have linear phase; it will be Type I if</span></div>
<div class="line"><span class="lineno">  269</span><span class="stringliteral">    `numtaps` is odd and Type II if `numtaps` is even.</span></div>
<div class="line"><span class="lineno">  270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  271</span><span class="stringliteral">    Type II filters always have zero response at the Nyquist frequency, so a</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">    ValueError exception is raised if firwin is called with `numtaps` even and</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral">    having a passband whose right end is at the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">        Length of the filter (number of coefficients, i.e. the filter</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">        order + 1).  `numtaps` must be odd if a passband includes the</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">        Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">    cutoff : float or 1-D array_like</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">        Cutoff frequency of filter (expressed in the same units as `fs`)</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        OR an array of cutoff frequencies (that is, band edges). In the</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">        latter case, the frequencies in `cutoff` should be positive and</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">        monotonically increasing between 0 and `fs/2`. The values 0 and</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">        `fs/2` must not be included in `cutoff`.</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    width : float or None, optional</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        If `width` is not None, then assume it is the approximate width</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">        of the transition region (expressed in the same units as `fs`)</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral">        for use in Kaiser FIR filter design. In this case, the `window`</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        argument is ignored.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral">    window : string or tuple of string and parameter values, optional</span></div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        Desired window to use. See `scipy.signal.get_window` for a list</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        of windows and required parameters.</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">    pass_zero : {True, False, &#39;bandpass&#39;, &#39;lowpass&#39;, &#39;highpass&#39;, &#39;bandstop&#39;}, optional</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">        If True, the gain at the frequency 0 (i.e., the &quot;DC gain&quot;) is 1.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        If False, the DC gain is 0. Can also be a string argument for the</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">        desired filter type (equivalent to ``btype`` in IIR design functions).</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">        .. versionadded:: 1.3.0</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">           Support for string arguments.</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">    scale : bool, optional</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        Set to True to scale the coefficients so that the frequency</span></div>
<div class="line"><span class="lineno">  304</span><span class="stringliteral">        response is exactly unity at a certain frequency.</span></div>
<div class="line"><span class="lineno">  305</span><span class="stringliteral">        That frequency is either:</span></div>
<div class="line"><span class="lineno">  306</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  307</span><span class="stringliteral">        - 0 (DC) if the first passband starts at 0 (i.e. pass_zero</span></div>
<div class="line"><span class="lineno">  308</span><span class="stringliteral">          is True)</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        - `fs/2` (the Nyquist frequency) if the first passband ends at</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral">          `fs/2` (i.e the filter is a single band highpass filter);</span></div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">          center of first passband otherwise</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">    nyq : float, optional</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">        *Deprecated. Use `fs` instead.* This is the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        Each frequency in `cutoff` must be between 0 and `nyq`. Default</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">        is 1.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">        The sampling frequency of the signal. Each frequency in `cutoff`</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        must be between 0 and ``fs/2``.  Default is 2.</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    h : (numtaps,) ndarray</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">        Coefficients of length `numtaps` FIR filter.</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    Raises</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">    ------</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    ValueError</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        If any value in `cutoff` is less than or equal to 0 or greater</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        than or equal to ``fs/2``, if the values in `cutoff` are not strictly</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        monotonically increasing, or if `numtaps` is even but a passband</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral">        includes the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">    firwin2</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">    firls</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    minimum_phase</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    remez</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    Low-pass from 0 to f:</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  346</span><span class="stringliteral">    &gt;&gt;&gt; numtaps = 3</span></div>
<div class="line"><span class="lineno">  347</span><span class="stringliteral">    &gt;&gt;&gt; f = 0.1</span></div>
<div class="line"><span class="lineno">  348</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, f)</span></div>
<div class="line"><span class="lineno">  349</span><span class="stringliteral">    array([ 0.06799017,  0.86401967,  0.06799017])</span></div>
<div class="line"><span class="lineno">  350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  351</span><span class="stringliteral">    Use a specific window function:</span></div>
<div class="line"><span class="lineno">  352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  353</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, f, window=&#39;nuttall&#39;)</span></div>
<div class="line"><span class="lineno">  354</span><span class="stringliteral">    array([  3.56607041e-04,   9.99286786e-01,   3.56607041e-04])</span></div>
<div class="line"><span class="lineno">  355</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">    High-pass (&#39;stop&#39; from 0 to f):</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, f, pass_zero=False)</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">    array([-0.00859313,  0.98281375, -0.00859313])</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">    Band-pass:</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  363</span><span class="stringliteral">    &gt;&gt;&gt; f1, f2 = 0.1, 0.2</span></div>
<div class="line"><span class="lineno">  364</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2], pass_zero=False)</span></div>
<div class="line"><span class="lineno">  365</span><span class="stringliteral">    array([ 0.06301614,  0.88770441,  0.06301614])</span></div>
<div class="line"><span class="lineno">  366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  367</span><span class="stringliteral">    Band-stop:</span></div>
<div class="line"><span class="lineno">  368</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  369</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2])</span></div>
<div class="line"><span class="lineno">  370</span><span class="stringliteral">    array([-0.00801395,  1.0160279 , -0.00801395])</span></div>
<div class="line"><span class="lineno">  371</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  372</span><span class="stringliteral">    Multi-band (passbands are [0, f1], [f2, f3] and [f4, 1]):</span></div>
<div class="line"><span class="lineno">  373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">    &gt;&gt;&gt; f3, f4 = 0.3, 0.4</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4])</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral">    array([-0.01376344,  1.02752689, -0.01376344])</span></div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">    Multi-band (passbands are [f1, f2] and [f3,f4]):</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">    &gt;&gt;&gt; signal.firwin(numtaps, [f1, f2, f3, f4], pass_zero=False)</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral">    array([ 0.04890915,  0.91284326,  0.04890915])</span></div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">    &quot;&quot;&quot;</span>  <span class="comment"># noqa: E501</span></div>
<div class="line"><span class="lineno">  384</span>    <span class="comment"># The major enhancements to this function added in November 2010 were</span></div>
<div class="line"><span class="lineno">  385</span>    <span class="comment"># developed by Tom Krauss (see ticket #902).</span></div>
<div class="line"><span class="lineno">  386</span> </div>
<div class="line"><span class="lineno">  387</span>    nyq = 0.5 * _get_fs(fs, nyq)</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>    cutoff = np.atleast_1d(cutoff) / float(nyq)</div>
<div class="line"><span class="lineno">  390</span> </div>
<div class="line"><span class="lineno">  391</span>    <span class="comment"># Check for invalid input.</span></div>
<div class="line"><span class="lineno">  392</span>    <span class="keywordflow">if</span> cutoff.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  393</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;The cutoff argument must be at most &quot;</span></div>
<div class="line"><span class="lineno">  394</span>                         <span class="stringliteral">&quot;one-dimensional.&quot;</span>)</div>
<div class="line"><span class="lineno">  395</span>    <span class="keywordflow">if</span> cutoff.size == 0:</div>
<div class="line"><span class="lineno">  396</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;At least one cutoff frequency must be given.&quot;</span>)</div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">if</span> cutoff.min() &lt;= 0 <span class="keywordflow">or</span> cutoff.max() &gt;= 1:</div>
<div class="line"><span class="lineno">  398</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid cutoff frequency: frequencies must be &quot;</span></div>
<div class="line"><span class="lineno">  399</span>                         <span class="stringliteral">&quot;greater than 0 and less than fs/2.&quot;</span>)</div>
<div class="line"><span class="lineno">  400</span>    <span class="keywordflow">if</span> np.any(np.diff(cutoff) &lt;= 0):</div>
<div class="line"><span class="lineno">  401</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid cutoff frequencies: the frequencies &quot;</span></div>
<div class="line"><span class="lineno">  402</span>                         <span class="stringliteral">&quot;must be strictly increasing.&quot;</span>)</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>    <span class="keywordflow">if</span> width <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  405</span>        <span class="comment"># A width was given.  Find the beta parameter of the Kaiser window</span></div>
<div class="line"><span class="lineno">  406</span>        <span class="comment"># and set `window`.  This overrides the value of `window` passed in.</span></div>
<div class="line"><span class="lineno">  407</span>        atten = kaiser_atten(numtaps, float(width) / nyq)</div>
<div class="line"><span class="lineno">  408</span>        beta = kaiser_beta(atten)</div>
<div class="line"><span class="lineno">  409</span>        window = (<span class="stringliteral">&#39;kaiser&#39;</span>, beta)</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>    <span class="keywordflow">if</span> isinstance(pass_zero, str):</div>
<div class="line"><span class="lineno">  412</span>        <span class="keywordflow">if</span> pass_zero <span class="keywordflow">in</span> (<span class="stringliteral">&#39;bandstop&#39;</span>, <span class="stringliteral">&#39;lowpass&#39;</span>):</div>
<div class="line"><span class="lineno">  413</span>            <span class="keywordflow">if</span> pass_zero == <span class="stringliteral">&#39;lowpass&#39;</span>:</div>
<div class="line"><span class="lineno">  414</span>                <span class="keywordflow">if</span> cutoff.size != 1:</div>
<div class="line"><span class="lineno">  415</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;cutoff must have one element if &#39;</span></div>
<div class="line"><span class="lineno">  416</span>                                     <span class="stringliteral">&#39;pass_zero==&quot;lowpass&quot;, got %s&#39;</span></div>
<div class="line"><span class="lineno">  417</span>                                     % (cutoff.shape,))</div>
<div class="line"><span class="lineno">  418</span>            <span class="keywordflow">elif</span> cutoff.size &lt;= 1:</div>
<div class="line"><span class="lineno">  419</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;cutoff must have at least two elements if &#39;</span></div>
<div class="line"><span class="lineno">  420</span>                                 <span class="stringliteral">&#39;pass_zero==&quot;bandstop&quot;, got %s&#39;</span></div>
<div class="line"><span class="lineno">  421</span>                                 % (cutoff.shape,))</div>
<div class="line"><span class="lineno">  422</span>            pass_zero = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  423</span>        <span class="keywordflow">elif</span> pass_zero <span class="keywordflow">in</span> (<span class="stringliteral">&#39;bandpass&#39;</span>, <span class="stringliteral">&#39;highpass&#39;</span>):</div>
<div class="line"><span class="lineno">  424</span>            <span class="keywordflow">if</span> pass_zero == <span class="stringliteral">&#39;highpass&#39;</span>:</div>
<div class="line"><span class="lineno">  425</span>                <span class="keywordflow">if</span> cutoff.size != 1:</div>
<div class="line"><span class="lineno">  426</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;cutoff must have one element if &#39;</span></div>
<div class="line"><span class="lineno">  427</span>                                     <span class="stringliteral">&#39;pass_zero==&quot;highpass&quot;, got %s&#39;</span></div>
<div class="line"><span class="lineno">  428</span>                                     % (cutoff.shape,))</div>
<div class="line"><span class="lineno">  429</span>            <span class="keywordflow">elif</span> cutoff.size &lt;= 1:</div>
<div class="line"><span class="lineno">  430</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;cutoff must have at least two elements if &#39;</span></div>
<div class="line"><span class="lineno">  431</span>                                 <span class="stringliteral">&#39;pass_zero==&quot;bandpass&quot;, got %s&#39;</span></div>
<div class="line"><span class="lineno">  432</span>                                 % (cutoff.shape,))</div>
<div class="line"><span class="lineno">  433</span>            pass_zero = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  434</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  435</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;pass_zero must be True, False, &quot;bandpass&quot;, &#39;</span></div>
<div class="line"><span class="lineno">  436</span>                             <span class="stringliteral">&#39;&quot;lowpass&quot;, &quot;highpass&quot;, or &quot;bandstop&quot;, got &#39;</span></div>
<div class="line"><span class="lineno">  437</span>                             <span class="stringliteral">&#39;%s&#39;</span> % (pass_zero,))</div>
<div class="line"><span class="lineno">  438</span>    pass_zero = bool(operator.index(pass_zero))  <span class="comment"># ensure bool-like</span></div>
<div class="line"><span class="lineno">  439</span> </div>
<div class="line"><span class="lineno">  440</span>    pass_nyquist = bool(cutoff.size &amp; 1) ^ pass_zero</div>
<div class="line"><span class="lineno">  441</span>    <span class="keywordflow">if</span> pass_nyquist <span class="keywordflow">and</span> numtaps % 2 == 0:</div>
<div class="line"><span class="lineno">  442</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A filter with an even number of coefficients must &quot;</span></div>
<div class="line"><span class="lineno">  443</span>                         <span class="stringliteral">&quot;have zero response at the Nyquist frequency.&quot;</span>)</div>
<div class="line"><span class="lineno">  444</span> </div>
<div class="line"><span class="lineno">  445</span>    <span class="comment"># Insert 0 and/or 1 at the ends of cutoff so that the length of cutoff</span></div>
<div class="line"><span class="lineno">  446</span>    <span class="comment"># is even, and each pair in cutoff corresponds to passband.</span></div>
<div class="line"><span class="lineno">  447</span>    cutoff = np.hstack(([0.0] * pass_zero, cutoff, [1.0] * pass_nyquist))</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>    <span class="comment"># `bands` is a 2-D array; each row gives the left and right edges of</span></div>
<div class="line"><span class="lineno">  450</span>    <span class="comment"># a passband.</span></div>
<div class="line"><span class="lineno">  451</span>    bands = cutoff.reshape(-1, 2)</div>
<div class="line"><span class="lineno">  452</span> </div>
<div class="line"><span class="lineno">  453</span>    <span class="comment"># Build up the coefficients.</span></div>
<div class="line"><span class="lineno">  454</span>    alpha = 0.5 * (numtaps - 1)</div>
<div class="line"><span class="lineno">  455</span>    m = np.arange(0, numtaps) - alpha</div>
<div class="line"><span class="lineno">  456</span>    h = 0</div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">for</span> left, right <span class="keywordflow">in</span> bands:</div>
<div class="line"><span class="lineno">  458</span>        h += right * sinc(right * m)</div>
<div class="line"><span class="lineno">  459</span>        h -= left * sinc(left * m)</div>
<div class="line"><span class="lineno">  460</span> </div>
<div class="line"><span class="lineno">  461</span>    <span class="comment"># Get and apply the window function.</span></div>
<div class="line"><span class="lineno">  462</span>    <span class="keyword">from</span> .windows <span class="keyword">import</span> get_window</div>
<div class="line"><span class="lineno">  463</span>    win = get_window(window, numtaps, fftbins=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  464</span>    h *= win</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    <span class="comment"># Now handle scaling if desired.</span></div>
<div class="line"><span class="lineno">  467</span>    <span class="keywordflow">if</span> scale:</div>
<div class="line"><span class="lineno">  468</span>        <span class="comment"># Get the first passband.</span></div>
<div class="line"><span class="lineno">  469</span>        left, right = bands[0]</div>
<div class="line"><span class="lineno">  470</span>        <span class="keywordflow">if</span> left == 0:</div>
<div class="line"><span class="lineno">  471</span>            scale_frequency = 0.0</div>
<div class="line"><span class="lineno">  472</span>        <span class="keywordflow">elif</span> right == 1:</div>
<div class="line"><span class="lineno">  473</span>            scale_frequency = 1.0</div>
<div class="line"><span class="lineno">  474</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  475</span>            scale_frequency = 0.5 * (left + right)</div>
<div class="line"><span class="lineno">  476</span>        c = np.cos(np.pi * m * scale_frequency)</div>
<div class="line"><span class="lineno">  477</span>        s = np.sum(h * c)</div>
<div class="line"><span class="lineno">  478</span>        h /= s</div>
<div class="line"><span class="lineno">  479</span> </div>
<div class="line"><span class="lineno">  480</span>    <span class="keywordflow">return</span> h</div>
<div class="line"><span class="lineno">  481</span> </div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span><span class="comment"># Original version of firwin2 from scipy ticket #457, submitted by &quot;tash&quot;.</span></div>
<div class="line"><span class="lineno">  484</span><span class="comment">#</span></div>
<div class="line"><span class="lineno">  485</span><span class="comment"># Rewritten by Warren Weckesser, 2010.</span></div>
<div class="line"><span class="lineno">  486</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f7877c78a419877dd794b26a3c807cd" name="a1f7877c78a419877dd794b26a3c807cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7877c78a419877dd794b26a3c807cd">&#9670;&#160;</a></span>firwin2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.firwin2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numtaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nfreqs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>window</em> = <code>'hamming'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>nyq</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>antisymmetric</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">FIR filter design using the window method.

From the given frequencies `freq` and corresponding gains `gain`,
this function constructs an FIR filter with linear phase and
(approximately) the given frequency response.

Parameters
----------
numtaps : int
    The number of taps in the FIR filter.  `numtaps` must be less than
    `nfreqs`.
freq : array_like, 1-D
    The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being
    Nyquist.  The Nyquist frequency is half `fs`.
    The values in `freq` must be nondecreasing. A value can be repeated
    once to implement a discontinuity. The first value in `freq` must
    be 0, and the last value must be ``fs/2``. Values 0 and ``fs/2`` must
    not be repeated.
gain : array_like
    The filter gains at the frequency sampling points. Certain
    constraints to gain values, depending on the filter type, are applied,
    see Notes for details.
nfreqs : int, optional
    The size of the interpolation mesh used to construct the filter.
    For most efficient behavior, this should be a power of 2 plus 1
    (e.g, 129, 257, etc). The default is one more than the smallest
    power of 2 that is not less than `numtaps`. `nfreqs` must be greater
    than `numtaps`.
window : string or (string, float) or float, or None, optional
    Window function to use. Default is "hamming". See
    `scipy.signal.get_window` for the complete list of possible values.
    If None, no window function is applied.
nyq : float, optional
    *Deprecated. Use `fs` instead.* This is the Nyquist frequency.
    Each frequency in `freq` must be between 0 and `nyq`.  Default is 1.
antisymmetric : bool, optional
    Whether resulting impulse response is symmetric/antisymmetric.
    See Notes for more details.
fs : float, optional
    The sampling frequency of the signal. Each frequency in `cutoff`
    must be between 0 and ``fs/2``. Default is 2.

Returns
-------
taps : ndarray
    The filter coefficients of the FIR filter, as a 1-D array of length
    `numtaps`.

See also
--------
firls
firwin
minimum_phase
remez

Notes
-----
From the given set of frequencies and gains, the desired response is
constructed in the frequency domain. The inverse FFT is applied to the
desired response to create the associated convolution kernel, and the
first `numtaps` coefficients of this kernel, scaled by `window`, are
returned.

The FIR filter will have linear phase. The type of filter is determined by
the value of 'numtaps` and `antisymmetric` flag.
There are four possible combinations:

   - odd  `numtaps`, `antisymmetric` is False, type I filter is produced
   - even `numtaps`, `antisymmetric` is False, type II filter is produced
   - odd  `numtaps`, `antisymmetric` is True, type III filter is produced
   - even `numtaps`, `antisymmetric` is True, type IV filter is produced

Magnitude response of all but type I filters are subjects to following
constraints:

   - type II  -- zero at the Nyquist frequency
   - type III -- zero at zero and Nyquist frequencies
   - type IV  -- zero at zero frequency

.. versionadded:: 0.9.0

References
----------
.. [1] Oppenheim, A. V. and Schafer, R. W., "Discrete-Time Signal
   Processing", Prentice-Hall, Englewood Cliffs, New Jersey (1989).
   (See, for example, Section 7.4.)

.. [2] Smith, Steven W., "The Scientist and Engineer's Guide to Digital
   Signal Processing", Ch. 17. http://www.dspguide.com/ch17/1.htm

Examples
--------
A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and
that decreases linearly on [0.5, 1.0] from 1 to 0:

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])
&gt;&gt;&gt; print(taps[72:78])
[-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</pre> <div class="fragment"><div class="line"><span class="lineno">  488</span>            antisymmetric=<span class="keyword">False</span>, fs=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  489</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">    FIR filter design using the window method.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">    From the given frequencies `freq` and corresponding gains `gain`,</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">    this function constructs an FIR filter with linear phase and</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">    (approximately) the given frequency response.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  496</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  497</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  498</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">  499</span><span class="stringliteral">        The number of taps in the FIR filter.  `numtaps` must be less than</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        `nfreqs`.</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">    freq : array_like, 1-D</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        The frequency sampling points. Typically 0.0 to 1.0 with 1.0 being</span></div>
<div class="line"><span class="lineno">  503</span><span class="stringliteral">        Nyquist.  The Nyquist frequency is half `fs`.</span></div>
<div class="line"><span class="lineno">  504</span><span class="stringliteral">        The values in `freq` must be nondecreasing. A value can be repeated</span></div>
<div class="line"><span class="lineno">  505</span><span class="stringliteral">        once to implement a discontinuity. The first value in `freq` must</span></div>
<div class="line"><span class="lineno">  506</span><span class="stringliteral">        be 0, and the last value must be ``fs/2``. Values 0 and ``fs/2`` must</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        not be repeated.</span></div>
<div class="line"><span class="lineno">  508</span><span class="stringliteral">    gain : array_like</span></div>
<div class="line"><span class="lineno">  509</span><span class="stringliteral">        The filter gains at the frequency sampling points. Certain</span></div>
<div class="line"><span class="lineno">  510</span><span class="stringliteral">        constraints to gain values, depending on the filter type, are applied,</span></div>
<div class="line"><span class="lineno">  511</span><span class="stringliteral">        see Notes for details.</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">    nfreqs : int, optional</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral">        The size of the interpolation mesh used to construct the filter.</span></div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        For most efficient behavior, this should be a power of 2 plus 1</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        (e.g, 129, 257, etc). The default is one more than the smallest</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        power of 2 that is not less than `numtaps`. `nfreqs` must be greater</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">        than `numtaps`.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">    window : string or (string, float) or float, or None, optional</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">        Window function to use. Default is &quot;hamming&quot;. See</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        `scipy.signal.get_window` for the complete list of possible values.</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">        If None, no window function is applied.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">    nyq : float, optional</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">        *Deprecated. Use `fs` instead.* This is the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        Each frequency in `freq` must be between 0 and `nyq`.  Default is 1.</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    antisymmetric : bool, optional</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        Whether resulting impulse response is symmetric/antisymmetric.</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">        See Notes for more details.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">        The sampling frequency of the signal. Each frequency in `cutoff`</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        must be between 0 and ``fs/2``. Default is 2.</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">    taps : ndarray</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        The filter coefficients of the FIR filter, as a 1-D array of length</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        `numtaps`.</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    See also</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    firls</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    firwin</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    minimum_phase</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    remez</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    From the given set of frequencies and gains, the desired response is</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    constructed in the frequency domain. The inverse FFT is applied to the</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">    desired response to create the associated convolution kernel, and the</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral">    first `numtaps` coefficients of this kernel, scaled by `window`, are</span></div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">    returned.</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">    The FIR filter will have linear phase. The type of filter is determined by</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">    the value of &#39;numtaps` and `antisymmetric` flag.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">    There are four possible combinations:</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">       - odd  `numtaps`, `antisymmetric` is False, type I filter is produced</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">       - even `numtaps`, `antisymmetric` is False, type II filter is produced</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">       - odd  `numtaps`, `antisymmetric` is True, type III filter is produced</span></div>
<div class="line"><span class="lineno">  560</span><span class="stringliteral">       - even `numtaps`, `antisymmetric` is True, type IV filter is produced</span></div>
<div class="line"><span class="lineno">  561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  562</span><span class="stringliteral">    Magnitude response of all but type I filters are subjects to following</span></div>
<div class="line"><span class="lineno">  563</span><span class="stringliteral">    constraints:</span></div>
<div class="line"><span class="lineno">  564</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  565</span><span class="stringliteral">       - type II  -- zero at the Nyquist frequency</span></div>
<div class="line"><span class="lineno">  566</span><span class="stringliteral">       - type III -- zero at zero and Nyquist frequencies</span></div>
<div class="line"><span class="lineno">  567</span><span class="stringliteral">       - type IV  -- zero at zero frequency</span></div>
<div class="line"><span class="lineno">  568</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  569</span><span class="stringliteral">    .. versionadded:: 0.9.0</span></div>
<div class="line"><span class="lineno">  570</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  571</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  572</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  573</span><span class="stringliteral">    .. [1] Oppenheim, A. V. and Schafer, R. W., &quot;Discrete-Time Signal</span></div>
<div class="line"><span class="lineno">  574</span><span class="stringliteral">       Processing&quot;, Prentice-Hall, Englewood Cliffs, New Jersey (1989).</span></div>
<div class="line"><span class="lineno">  575</span><span class="stringliteral">       (See, for example, Section 7.4.)</span></div>
<div class="line"><span class="lineno">  576</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  577</span><span class="stringliteral">    .. [2] Smith, Steven W., &quot;The Scientist and Engineer&#39;s Guide to Digital</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">       Signal Processing&quot;, Ch. 17. http://www.dspguide.com/ch17/1.htm</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  580</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  581</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  582</span><span class="stringliteral">    A lowpass FIR filter with a response that is 1 on [0.0, 0.5], and</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">    that decreases linearly on [0.5, 1.0] from 1 to 0:</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">    &gt;&gt;&gt; taps = signal.firwin2(150, [0.0, 0.5, 1.0], [1.0, 1.0, 0.0])</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">    &gt;&gt;&gt; print(taps[72:78])</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">    [-0.02286961 -0.06362756  0.57310236  0.57310236 -0.06362756 -0.02286961]</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  591</span>    nyq = 0.5 * _get_fs(fs, nyq)</div>
<div class="line"><span class="lineno">  592</span> </div>
<div class="line"><span class="lineno">  593</span>    <span class="keywordflow">if</span> len(freq) != len(gain):</div>
<div class="line"><span class="lineno">  594</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;freq and gain must be of same length.&#39;</span>)</div>
<div class="line"><span class="lineno">  595</span> </div>
<div class="line"><span class="lineno">  596</span>    <span class="keywordflow">if</span> nfreqs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> numtaps &gt;= nfreqs:</div>
<div class="line"><span class="lineno">  597</span>        <span class="keywordflow">raise</span> ValueError((<span class="stringliteral">&#39;ntaps must be less than nfreqs, but firwin2 was &#39;</span></div>
<div class="line"><span class="lineno">  598</span>                          <span class="stringliteral">&#39;called with ntaps=%d and nfreqs=%s&#39;</span>) %</div>
<div class="line"><span class="lineno">  599</span>                         (numtaps, nfreqs))</div>
<div class="line"><span class="lineno">  600</span> </div>
<div class="line"><span class="lineno">  601</span>    <span class="keywordflow">if</span> freq[0] != 0 <span class="keywordflow">or</span> freq[-1] != nyq:</div>
<div class="line"><span class="lineno">  602</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;freq must start with 0 and end with fs/2.&#39;</span>)</div>
<div class="line"><span class="lineno">  603</span>    d = np.diff(freq)</div>
<div class="line"><span class="lineno">  604</span>    <span class="keywordflow">if</span> (d &lt; 0).any():</div>
<div class="line"><span class="lineno">  605</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;The values in freq must be nondecreasing.&#39;</span>)</div>
<div class="line"><span class="lineno">  606</span>    d2 = d[:-1] + d[1:]</div>
<div class="line"><span class="lineno">  607</span>    <span class="keywordflow">if</span> (d2 == 0).any():</div>
<div class="line"><span class="lineno">  608</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;A value in freq must not occur more than twice.&#39;</span>)</div>
<div class="line"><span class="lineno">  609</span>    <span class="keywordflow">if</span> freq[1] == 0:</div>
<div class="line"><span class="lineno">  610</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Value 0 must not be repeated in freq&#39;</span>)</div>
<div class="line"><span class="lineno">  611</span>    <span class="keywordflow">if</span> freq[-2] == nyq:</div>
<div class="line"><span class="lineno">  612</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Value fs/2 must not be repeated in freq&#39;</span>)</div>
<div class="line"><span class="lineno">  613</span> </div>
<div class="line"><span class="lineno">  614</span>    <span class="keywordflow">if</span> antisymmetric:</div>
<div class="line"><span class="lineno">  615</span>        <span class="keywordflow">if</span> numtaps % 2 == 0:</div>
<div class="line"><span class="lineno">  616</span>            ftype = 4</div>
<div class="line"><span class="lineno">  617</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  618</span>            ftype = 3</div>
<div class="line"><span class="lineno">  619</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  620</span>        <span class="keywordflow">if</span> numtaps % 2 == 0:</div>
<div class="line"><span class="lineno">  621</span>            ftype = 2</div>
<div class="line"><span class="lineno">  622</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  623</span>            ftype = 1</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>    <span class="keywordflow">if</span> ftype == 2 <span class="keywordflow">and</span> gain[-1] != 0.0:</div>
<div class="line"><span class="lineno">  626</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A Type II filter must have zero gain at the &quot;</span></div>
<div class="line"><span class="lineno">  627</span>                         <span class="stringliteral">&quot;Nyquist frequency.&quot;</span>)</div>
<div class="line"><span class="lineno">  628</span>    <span class="keywordflow">elif</span> ftype == 3 <span class="keywordflow">and</span> (gain[0] != 0.0 <span class="keywordflow">or</span> gain[-1] != 0.0):</div>
<div class="line"><span class="lineno">  629</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A Type III filter must have zero gain at zero &quot;</span></div>
<div class="line"><span class="lineno">  630</span>                         <span class="stringliteral">&quot;and Nyquist frequencies.&quot;</span>)</div>
<div class="line"><span class="lineno">  631</span>    <span class="keywordflow">elif</span> ftype == 4 <span class="keywordflow">and</span> gain[0] != 0.0:</div>
<div class="line"><span class="lineno">  632</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;A Type IV filter must have zero gain at zero &quot;</span></div>
<div class="line"><span class="lineno">  633</span>                         <span class="stringliteral">&quot;frequency.&quot;</span>)</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>    <span class="keywordflow">if</span> nfreqs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  636</span>        nfreqs = 1 + 2 ** int(ceil(log(numtaps, 2)))</div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span>    <span class="keywordflow">if</span> (d == 0).any():</div>
<div class="line"><span class="lineno">  639</span>        <span class="comment"># Tweak any repeated values in freq so that interp works.</span></div>
<div class="line"><span class="lineno">  640</span>        freq = np.array(freq, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  641</span>        eps = np.finfo(float).eps * nyq</div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">for</span> k <span class="keywordflow">in</span> range(len(freq) - 1):</div>
<div class="line"><span class="lineno">  643</span>            <span class="keywordflow">if</span> freq[k] == freq[k + 1]:</div>
<div class="line"><span class="lineno">  644</span>                freq[k] = freq[k] - eps</div>
<div class="line"><span class="lineno">  645</span>                freq[k + 1] = freq[k + 1] + eps</div>
<div class="line"><span class="lineno">  646</span>        <span class="comment"># Check if freq is strictly increasing after tweak</span></div>
<div class="line"><span class="lineno">  647</span>        d = np.diff(freq)</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">if</span> (d &lt;= 0).any():</div>
<div class="line"><span class="lineno">  649</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;freq cannot contain numbers that are too close &quot;</span></div>
<div class="line"><span class="lineno">  650</span>                             <span class="stringliteral">&quot;(within eps * (fs/2): &quot;</span></div>
<div class="line"><span class="lineno">  651</span>                             <span class="stringliteral">&quot;{}) to a repeated value&quot;</span>.format(eps))</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span>    <span class="comment"># Linearly interpolate the desired response on a uniform mesh `x`.</span></div>
<div class="line"><span class="lineno">  654</span>    x = np.linspace(0.0, nyq, nfreqs)</div>
<div class="line"><span class="lineno">  655</span>    fx = np.interp(x, freq, gain)</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span>    <span class="comment"># Adjust the phases of the coefficients so that the first `ntaps` of the</span></div>
<div class="line"><span class="lineno">  658</span>    <span class="comment"># inverse FFT are the desired filter coefficients.</span></div>
<div class="line"><span class="lineno">  659</span>    shift = np.exp(-(numtaps - 1) / 2. * 1.j * np.pi * x / nyq)</div>
<div class="line"><span class="lineno">  660</span>    <span class="keywordflow">if</span> ftype &gt; 2:</div>
<div class="line"><span class="lineno">  661</span>        shift *= 1j</div>
<div class="line"><span class="lineno">  662</span> </div>
<div class="line"><span class="lineno">  663</span>    fx2 = fx * shift</div>
<div class="line"><span class="lineno">  664</span> </div>
<div class="line"><span class="lineno">  665</span>    <span class="comment"># Use irfft to compute the inverse FFT.</span></div>
<div class="line"><span class="lineno">  666</span>    out_full = irfft(fx2)</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>    <span class="keywordflow">if</span> window <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  669</span>        <span class="comment"># Create the window to apply to the filter coefficients.</span></div>
<div class="line"><span class="lineno">  670</span>        <span class="keyword">from</span> .windows <span class="keyword">import</span> get_window</div>
<div class="line"><span class="lineno">  671</span>        wind = get_window(window, numtaps, fftbins=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  672</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  673</span>        wind = 1</div>
<div class="line"><span class="lineno">  674</span> </div>
<div class="line"><span class="lineno">  675</span>    <span class="comment"># Keep only the first `numtaps` coefficients in `out`, and multiply by</span></div>
<div class="line"><span class="lineno">  676</span>    <span class="comment"># the window.</span></div>
<div class="line"><span class="lineno">  677</span>    out = out_full[:numtaps] * wind</div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>    <span class="keywordflow">if</span> ftype == 3:</div>
<div class="line"><span class="lineno">  680</span>        out[out.size // 2] = 0.0</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span>    <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno">  683</span> </div>
<div class="line"><span class="lineno">  684</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50ac7cf55e5243fdc7cbac8b63108b0a" name="a50ac7cf55e5243fdc7cbac8b63108b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ac7cf55e5243fdc7cbac8b63108b0a">&#9670;&#160;</a></span>kaiser_atten()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.kaiser_atten </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numtaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the attenuation of a Kaiser FIR filter.

Given the number of taps `N` and the transition width `width`, compute the
attenuation `a` in dB, given by Kaiser's formula:

    a = 2.285 * (N - 1) * pi * width + 7.95

Parameters
----------
numtaps : int
    The number of taps in the FIR filter.
width : float
    The desired width of the transition region between passband and
    stopband (or, in general, at any discontinuity) for the filter,
    expressed as a fraction of the Nyquist frequency.

Returns
-------
a : float
    The attenuation of the ripple, in dB.

See Also
--------
kaiserord, kaiser_beta

Examples
--------
Suppose we want to design a FIR filter using the Kaiser window method
that will have 211 taps and a transition width of 9 Hz for a signal that
is sampled at 480 Hz. Expressed as a fraction of the Nyquist frequency,
the width is 9/(0.5*480) = 0.0375. The approximate attenuation (in dB)
is computed as follows:

&gt;&gt;&gt; from scipy.signal import kaiser_atten
&gt;&gt;&gt; kaiser_atten(211, 0.0375)
64.48099630593983</pre> <div class="fragment"><div class="line"><span class="lineno">   86</span><span class="keyword">def </span>kaiser_atten(numtaps, width):</div>
<div class="line"><span class="lineno">   87</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the attenuation of a Kaiser FIR filter.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Given the number of taps `N` and the transition width `width`, compute the</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    attenuation `a` in dB, given by Kaiser&#39;s formula:</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        a = 2.285 * (N - 1) * pi * width + 7.95</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral">        The number of taps in the FIR filter.</span></div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    width : float</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">        The desired width of the transition region between passband and</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">        stopband (or, in general, at any discontinuity) for the filter,</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        expressed as a fraction of the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    a : float</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        The attenuation of the ripple, in dB.</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    kaiserord, kaiser_beta</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    Suppose we want to design a FIR filter using the Kaiser window method</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    that will have 211 taps and a transition width of 9 Hz for a signal that</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    is sampled at 480 Hz. Expressed as a fraction of the Nyquist frequency,</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    the width is 9/(0.5*480) = 0.0375. The approximate attenuation (in dB)</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    is computed as follows:</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import kaiser_atten</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; kaiser_atten(211, 0.0375)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    64.48099630593983</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  125</span>    a = 2.285 * (numtaps - 1) * np.pi * width + 7.95</div>
<div class="line"><span class="lineno">  126</span>    <span class="keywordflow">return</span> a</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3aa1c6de0dbaf7aa0f1121be85ff1c3f" name="a3aa1c6de0dbaf7aa0f1121be85ff1c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa1c6de0dbaf7aa0f1121be85ff1c3f">&#9670;&#160;</a></span>kaiser_beta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.kaiser_beta </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the Kaiser parameter `beta`, given the attenuation `a`.

Parameters
----------
a : float
    The desired attenuation in the stopband and maximum ripple in
    the passband, in dB.  This should be a *positive* number.

Returns
-------
beta : float
    The `beta` parameter to be used in the formula for a Kaiser window.

References
----------
Oppenheim, Schafer, "Discrete-Time Signal Processing", p.475-476.

Examples
--------
Suppose we want to design a lowpass filter, with 65 dB attenuation
in the stop band.  The Kaiser window parameter to be used in the
window method is computed by ``kaiser_beta(65)``:

&gt;&gt;&gt; from scipy.signal import kaiser_beta
&gt;&gt;&gt; kaiser_beta(65)
6.20426</pre> <div class="fragment"><div class="line"><span class="lineno">   48</span><span class="keyword">def </span>kaiser_beta(a):</div>
<div class="line"><span class="lineno">   49</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the Kaiser parameter `beta`, given the attenuation `a`.</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   52</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   53</span><span class="stringliteral">    a : float</span></div>
<div class="line"><span class="lineno">   54</span><span class="stringliteral">        The desired attenuation in the stopband and maximum ripple in</span></div>
<div class="line"><span class="lineno">   55</span><span class="stringliteral">        the passband, in dB.  This should be a *positive* number.</span></div>
<div class="line"><span class="lineno">   56</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   57</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    beta : float</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral">        The `beta` parameter to be used in the formula for a Kaiser window.</span></div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, p.475-476.</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    Suppose we want to design a lowpass filter, with 65 dB attenuation</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    in the stop band.  The Kaiser window parameter to be used in the</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    window method is computed by ``kaiser_beta(65)``:</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import kaiser_beta</span></div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    &gt;&gt;&gt; kaiser_beta(65)</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    6.20426</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">if</span> a &gt; 50:</div>
<div class="line"><span class="lineno">   78</span>        beta = 0.1102 * (a - 8.7)</div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">elif</span> a &gt; 21:</div>
<div class="line"><span class="lineno">   80</span>        beta = 0.5842 * (a - 21) ** 0.4 + 0.07886 * (a - 21)</div>
<div class="line"><span class="lineno">   81</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   82</span>        beta = 0.0</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">return</span> beta</div>
<div class="line"><span class="lineno">   84</span> </div>
<div class="line"><span class="lineno">   85</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac3198c7e00ea036cdc733e5ff5b93dd3" name="ac3198c7e00ea036cdc733e5ff5b93dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3198c7e00ea036cdc733e5ff5b93dd3">&#9670;&#160;</a></span>kaiserord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.kaiserord </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ripple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine the filter window parameters for the Kaiser window method.

The parameters returned by this function are generally used to create
a finite impulse response filter using the window method, with either
`firwin` or `firwin2`.

Parameters
----------
ripple : float
    Upper bound for the deviation (in dB) of the magnitude of the
    filter's frequency response from that of the desired filter (not
    including frequencies in any transition intervals). That is, if w
    is the frequency expressed as a fraction of the Nyquist frequency,
    A(w) is the actual frequency response of the filter and D(w) is the
    desired frequency response, the design requirement is that::

        abs(A(w) - D(w))) &lt; 10**(-ripple/20)

    for 0 &lt;= w &lt;= 1 and w not in a transition interval.
width : float
    Width of transition region, normalized so that 1 corresponds to pi
    radians / sample. That is, the frequency is expressed as a fraction
    of the Nyquist frequency.

Returns
-------
numtaps : int
    The length of the Kaiser window.
beta : float
    The beta parameter for the Kaiser window.

See Also
--------
kaiser_beta, kaiser_atten

Notes
-----
There are several ways to obtain the Kaiser window:

- ``signal.windows.kaiser(numtaps, beta, sym=True)``
- ``signal.get_window(beta, numtaps)``
- ``signal.get_window(('kaiser', beta), numtaps)``

The empirical equations discovered by Kaiser are used.

References
----------
Oppenheim, Schafer, "Discrete-Time Signal Processing", pp.475-476.

Examples
--------
We will use the Kaiser window method to design a lowpass FIR filter
for a signal that is sampled at 1000 Hz.

We want at least 65 dB rejection in the stop band, and in the pass
band the gain should vary no more than 0.5%.

We want a cutoff frequency of 175 Hz, with a transition between the
pass band and the stop band of 24 Hz. That is, in the band [0, 163],
the gain varies no more than 0.5%, and in the band [187, 500], the
signal is attenuated by at least 65 dB.

&gt;&gt;&gt; from scipy.signal import kaiserord, firwin, freqz
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; fs = 1000.0
&gt;&gt;&gt; cutoff = 175
&gt;&gt;&gt; width = 24

The Kaiser method accepts just a single parameter to control the pass
band ripple and the stop band rejection, so we use the more restrictive
of the two. In this case, the pass band ripple is 0.005, or 46.02 dB,
so we will use 65 dB as the design parameter.

Use `kaiserord` to determine the length of the filter and the
parameter for the Kaiser window.

&gt;&gt;&gt; numtaps, beta = kaiserord(65, width/(0.5*fs))
&gt;&gt;&gt; numtaps
167
&gt;&gt;&gt; beta
6.20426

Use `firwin` to create the FIR filter.

&gt;&gt;&gt; taps = firwin(numtaps, cutoff, window=('kaiser', beta),
...               scale=False, nyq=0.5*fs)

Compute the frequency response of the filter.  ``w`` is the array of
frequencies, and ``h`` is the corresponding complex array of frequency
responses.

&gt;&gt;&gt; w, h = freqz(taps, worN=8000)
&gt;&gt;&gt; w *= 0.5*fs/np.pi  # Convert w to Hz.

Compute the deviation of the magnitude of the filter's response from
that of the ideal lowpass filter. Values in the transition region are
set to ``nan``, so they won't appear in the plot.

&gt;&gt;&gt; ideal = w &lt; cutoff  # The "ideal" frequency response.
&gt;&gt;&gt; deviation = np.abs(np.abs(h) - ideal)
&gt;&gt;&gt; deviation[(w &gt; cutoff - 0.5*width) &amp; (w &lt; cutoff + 0.5*width)] = np.nan

Plot the deviation. A close look at the left end of the stop band shows
that the requirement for 65 dB attenuation is violated in the first lobe
by about 0.125 dB. This is not unusual for the Kaiser window method.

&gt;&gt;&gt; plt.plot(w, 20*np.log10(np.abs(deviation)))
&gt;&gt;&gt; plt.xlim(0, 0.5*fs)
&gt;&gt;&gt; plt.ylim(-90, -60)
&gt;&gt;&gt; plt.grid(alpha=0.25)
&gt;&gt;&gt; plt.axhline(-65, color='r', ls='--', alpha=0.3)
&gt;&gt;&gt; plt.xlabel('Frequency (Hz)')
&gt;&gt;&gt; plt.ylabel('Deviation from ideal (dB)')
&gt;&gt;&gt; plt.title('Lowpass Filter Frequency Response')
&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  129</span><span class="keyword">def </span>kaiserord(ripple, width):</div>
<div class="line"><span class="lineno">  130</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    Determine the filter window parameters for the Kaiser window method.</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral">    The parameters returned by this function are generally used to create</span></div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    a finite impulse response filter using the window method, with either</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    `firwin` or `firwin2`.</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  138</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  139</span><span class="stringliteral">    ripple : float</span></div>
<div class="line"><span class="lineno">  140</span><span class="stringliteral">        Upper bound for the deviation (in dB) of the magnitude of the</span></div>
<div class="line"><span class="lineno">  141</span><span class="stringliteral">        filter&#39;s frequency response from that of the desired filter (not</span></div>
<div class="line"><span class="lineno">  142</span><span class="stringliteral">        including frequencies in any transition intervals). That is, if w</span></div>
<div class="line"><span class="lineno">  143</span><span class="stringliteral">        is the frequency expressed as a fraction of the Nyquist frequency,</span></div>
<div class="line"><span class="lineno">  144</span><span class="stringliteral">        A(w) is the actual frequency response of the filter and D(w) is the</span></div>
<div class="line"><span class="lineno">  145</span><span class="stringliteral">        desired frequency response, the design requirement is that::</span></div>
<div class="line"><span class="lineno">  146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">            abs(A(w) - D(w))) &lt; 10**(-ripple/20)</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">        for 0 &lt;= w &lt;= 1 and w not in a transition interval.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral">    width : float</span></div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">        Width of transition region, normalized so that 1 corresponds to pi</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">        radians / sample. That is, the frequency is expressed as a fraction</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">        of the Nyquist frequency.</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        The length of the Kaiser window.</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    beta : float</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        The beta parameter for the Kaiser window.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    kaiser_beta, kaiser_atten</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    There are several ways to obtain the Kaiser window:</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    - ``signal.windows.kaiser(numtaps, beta, sym=True)``</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    - ``signal.get_window(beta, numtaps)``</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    - ``signal.get_window((&#39;kaiser&#39;, beta), numtaps)``</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    The empirical equations discovered by Kaiser are used.</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral">    Oppenheim, Schafer, &quot;Discrete-Time Signal Processing&quot;, pp.475-476.</span></div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    We will use the Kaiser window method to design a lowpass FIR filter</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    for a signal that is sampled at 1000 Hz.</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    We want at least 65 dB rejection in the stop band, and in the pass</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    band the gain should vary no more than 0.5%.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    We want a cutoff frequency of 175 Hz, with a transition between the</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    pass band and the stop band of 24 Hz. That is, in the band [0, 163],</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    the gain varies no more than 0.5%, and in the band [187, 500], the</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    signal is attenuated by at least 65 dB.</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import kaiserord, firwin, freqz</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">    &gt;&gt;&gt; fs = 1000.0</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">    &gt;&gt;&gt; cutoff = 175</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">    &gt;&gt;&gt; width = 24</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">    The Kaiser method accepts just a single parameter to control the pass</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">    band ripple and the stop band rejection, so we use the more restrictive</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral">    of the two. In this case, the pass band ripple is 0.005, or 46.02 dB,</span></div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    so we will use 65 dB as the design parameter.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">    Use `kaiserord` to determine the length of the filter and the</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">    parameter for the Kaiser window.</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">    &gt;&gt;&gt; numtaps, beta = kaiserord(65, width/(0.5*fs))</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">    &gt;&gt;&gt; numtaps</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">    167</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">    &gt;&gt;&gt; beta</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">    6.20426</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">    Use `firwin` to create the FIR filter.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral">    &gt;&gt;&gt; taps = firwin(numtaps, cutoff, window=(&#39;kaiser&#39;, beta),</span></div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">    ...               scale=False, nyq=0.5*fs)</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral">    Compute the frequency response of the filter.  ``w`` is the array of</span></div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    frequencies, and ``h`` is the corresponding complex array of frequency</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    responses.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    &gt;&gt;&gt; w, h = freqz(taps, worN=8000)</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    &gt;&gt;&gt; w *= 0.5*fs/np.pi  # Convert w to Hz.</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    Compute the deviation of the magnitude of the filter&#39;s response from</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">    that of the ideal lowpass filter. Values in the transition region are</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    set to ``nan``, so they won&#39;t appear in the plot.</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    &gt;&gt;&gt; ideal = w &lt; cutoff  # The &quot;ideal&quot; frequency response.</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    &gt;&gt;&gt; deviation = np.abs(np.abs(h) - ideal)</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    &gt;&gt;&gt; deviation[(w &gt; cutoff - 0.5*width) &amp; (w &lt; cutoff + 0.5*width)] = np.nan</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Plot the deviation. A close look at the left end of the stop band shows</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    that the requirement for 65 dB attenuation is violated in the first lobe</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    by about 0.125 dB. This is not unusual for the Kaiser window method.</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    &gt;&gt;&gt; plt.plot(w, 20*np.log10(np.abs(deviation)))</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlim(0, 0.5*fs)</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylim(-90, -60)</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    &gt;&gt;&gt; plt.grid(alpha=0.25)</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    &gt;&gt;&gt; plt.axhline(-65, color=&#39;r&#39;, ls=&#39;--&#39;, alpha=0.3)</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    &gt;&gt;&gt; plt.xlabel(&#39;Frequency (Hz)&#39;)</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    &gt;&gt;&gt; plt.ylabel(&#39;Deviation from ideal (dB)&#39;)</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">    &gt;&gt;&gt; plt.title(&#39;Lowpass Filter Frequency Response&#39;)</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span>    A = abs(ripple)  <span class="comment"># in case somebody is confused as to what&#39;s meant</span></div>
<div class="line"><span class="lineno">  249</span>    <span class="keywordflow">if</span> A &lt; 8:</div>
<div class="line"><span class="lineno">  250</span>        <span class="comment"># Formula for N is not valid in this range.</span></div>
<div class="line"><span class="lineno">  251</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Requested maximum ripple attentuation %f is too &quot;</span></div>
<div class="line"><span class="lineno">  252</span>                         <span class="stringliteral">&quot;small for the Kaiser formula.&quot;</span> % A)</div>
<div class="line"><span class="lineno">  253</span>    beta = kaiser_beta(A)</div>
<div class="line"><span class="lineno">  254</span> </div>
<div class="line"><span class="lineno">  255</span>    <span class="comment"># Kaiser&#39;s formula (as given in Oppenheim and Schafer) is for the filter</span></div>
<div class="line"><span class="lineno">  256</span>    <span class="comment"># order, so we have to add 1 to get the number of taps.</span></div>
<div class="line"><span class="lineno">  257</span>    numtaps = (A - 7.95) / 2.285 / (np.pi * width) + 1</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>    <span class="keywordflow">return</span> int(ceil(numtaps)), beta</div>
<div class="line"><span class="lineno">  260</span> </div>
<div class="line"><span class="lineno">  261</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac2de1b0b0595bd11e48606e002ec9542" name="ac2de1b0b0595bd11e48606e002ec9542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2de1b0b0595bd11e48606e002ec9542">&#9670;&#160;</a></span>minimum_phase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.minimum_phase </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>'homomorphic'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n_fft</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert a linear-phase FIR filter to minimum phase

Parameters
----------
h : array
    Linear-phase FIR filter coefficients.
method : {'hilbert', 'homomorphic'}
    The method to use:

        'homomorphic' (default)
            This method [4]_ [5]_ works best with filters with an
            odd number of taps, and the resulting minimum phase filter
            will have a magnitude response that approximates the square
            root of the the original filter's magnitude response.

        'hilbert'
            This method [1]_ is designed to be used with equiripple
            filters (e.g., from `remez`) with unity or zero gain
            regions.

n_fft : int
    The number of points to use for the FFT. Should be at least a
    few times larger than the signal length (see Notes).

Returns
-------
h_minimum : array
    The minimum-phase version of the filter, with length
    ``(length(h) + 1) // 2``.

See Also
--------
firwin
firwin2
remez

Notes
-----
Both the Hilbert [1]_ or homomorphic [4]_ [5]_ methods require selection
of an FFT length to estimate the complex cepstrum of the filter.

In the case of the Hilbert method, the deviation from the ideal
spectrum ``epsilon`` is related to the number of stopband zeros
``n_stop`` and FFT length ``n_fft`` as::

    epsilon = 2. * n_stop / n_fft

For example, with 100 stopband zeros and a FFT length of 2048,
``epsilon = 0.0976``. If we conservatively assume that the number of
stopband zeros is one less than the filter length, we can take the FFT
length to be the next power of 2 that satisfies ``epsilon=0.01`` as::

    n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))

This gives reasonable results for both the Hilbert and homomorphic
methods, and gives the value used when ``n_fft=None``.

Alternative implementations exist for creating minimum-phase filters,
including zero inversion [2]_ and spectral factorization [3]_ [4]_.
For more information, see:

    http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters

Examples
--------
Create an optimal linear-phase filter, then convert it to minimum phase:

&gt;&gt;&gt; from scipy.signal import remez, minimum_phase, freqz, group_delay
&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; freq = [0, 0.2, 0.3, 1.0]
&gt;&gt;&gt; desired = [1, 0]
&gt;&gt;&gt; h_linear = remez(151, freq, desired, Hz=2.)

Convert it to minimum phase:

&gt;&gt;&gt; h_min_hom = minimum_phase(h_linear, method='homomorphic')
&gt;&gt;&gt; h_min_hil = minimum_phase(h_linear, method='hilbert')

Compare the three filters:

&gt;&gt;&gt; fig, axs = plt.subplots(4, figsize=(4, 8))
&gt;&gt;&gt; for h, style, color in zip((h_linear, h_min_hom, h_min_hil),
...                            ('-', '-', '--'), ('k', 'r', 'c')):
...     w, H = freqz(h)
...     w, gd = group_delay((h, 1))
...     w /= np.pi
...     axs[0].plot(h, color=color, linestyle=style)
...     axs[1].plot(w, np.abs(H), color=color, linestyle=style)
...     axs[2].plot(w, 20 * np.log10(np.abs(H)), color=color, linestyle=style)
...     axs[3].plot(w, gd, color=color, linestyle=style)
&gt;&gt;&gt; for ax in axs:
...     ax.grid(True, color='0.5')
...     ax.fill_between(freq[1:3], *ax.get_ylim(), color='#ffeeaa', zorder=1)
&gt;&gt;&gt; axs[0].set(xlim=[0, len(h_linear) - 1], ylabel='Amplitude', xlabel='Samples')
&gt;&gt;&gt; axs[1].legend(['Linear', 'Min-Hom', 'Min-Hil'], title='Phase')
&gt;&gt;&gt; for ax, ylim in zip(axs[1:], ([0, 1.1], [-150, 10], [-60, 60])):
...     ax.set(xlim=[0, 1], ylim=ylim, xlabel='Frequency')
&gt;&gt;&gt; axs[1].set(ylabel='Magnitude')
&gt;&gt;&gt; axs[2].set(ylabel='Magnitude (dB)')
&gt;&gt;&gt; axs[3].set(ylabel='Group delay')
&gt;&gt;&gt; plt.tight_layout()

References
----------
.. [1] N. Damera-Venkata and B. L. Evans, "Optimal design of real and
       complex minimum phase digital FIR filters," Acoustics, Speech,
       and Signal Processing, 1999. Proceedings., 1999 IEEE International
       Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.
       :doi:`10.1109/ICASSP.1999.756179`
.. [2] X. Chen and T. W. Parks, "Design of optimal minimum phase FIR
       filters by direct factorization," Signal Processing,
       vol. 10, no. 4, pp. 369-383, Jun. 1986.
.. [3] T. Saramaki, "Finite Impulse Response Filter Design," in
       Handbook for Digital Signal Processing, chapter 4,
       New York: Wiley-Interscience, 1993.
.. [4] J. S. Lim, Advanced Topics in Signal Processing.
       Englewood Cliffs, N.J.: Prentice Hall, 1988.
.. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck,
       "Discrete-Time Signal Processing," 2nd edition.
       Upper Saddle River, N.J.: Prentice Hall, 1999.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1091</span><span class="keyword">def </span>minimum_phase(h, method=&#39;homomorphic&#39;, n_fft=None):</div>
<div class="line"><span class="lineno"> 1092</span>    <span class="stringliteral">&quot;&quot;&quot;Convert a linear-phase FIR filter to minimum phase</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral">    h : array</span></div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">        Linear-phase FIR filter coefficients.</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    method : {&#39;hilbert&#39;, &#39;homomorphic&#39;}</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">        The method to use:</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">            &#39;homomorphic&#39; (default)</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">                This method [4]_ [5]_ works best with filters with an</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">                odd number of taps, and the resulting minimum phase filter</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">                will have a magnitude response that approximates the square</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">                root of the the original filter&#39;s magnitude response.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">            &#39;hilbert&#39;</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">                This method [1]_ is designed to be used with equiripple</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">                filters (e.g., from `remez`) with unity or zero gain</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">                regions.</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    n_fft : int</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">        The number of points to use for the FFT. Should be at least a</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">        few times larger than the signal length (see Notes).</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    h_minimum : array</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">        The minimum-phase version of the filter, with length</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">        ``(length(h) + 1) // 2``.</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    firwin</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">    firwin2</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    remez</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    Both the Hilbert [1]_ or homomorphic [4]_ [5]_ methods require selection</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    of an FFT length to estimate the complex cepstrum of the filter.</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    In the case of the Hilbert method, the deviation from the ideal</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    spectrum ``epsilon`` is related to the number of stopband zeros</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    ``n_stop`` and FFT length ``n_fft`` as::</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral">        epsilon = 2. * n_stop / n_fft</span></div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    For example, with 100 stopband zeros and a FFT length of 2048,</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    ``epsilon = 0.0976``. If we conservatively assume that the number of</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    stopband zeros is one less than the filter length, we can take the FFT</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    length to be the next power of 2 that satisfies ``epsilon=0.01`` as::</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">        n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    This gives reasonable results for both the Hilbert and homomorphic</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    methods, and gives the value used when ``n_fft=None``.</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    Alternative implementations exist for creating minimum-phase filters,</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral">    including zero inversion [2]_ and spectral factorization [3]_ [4]_.</span></div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    For more information, see:</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">        http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral">    Create an optimal linear-phase filter, then convert it to minimum phase:</span></div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral">    &gt;&gt;&gt; from scipy.signal import remez, minimum_phase, freqz, group_delay</span></div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    &gt;&gt;&gt; freq = [0, 0.2, 0.3, 1.0]</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    &gt;&gt;&gt; desired = [1, 0]</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    &gt;&gt;&gt; h_linear = remez(151, freq, desired, Hz=2.)</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral">    Convert it to minimum phase:</span></div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral">    &gt;&gt;&gt; h_min_hom = minimum_phase(h_linear, method=&#39;homomorphic&#39;)</span></div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    &gt;&gt;&gt; h_min_hil = minimum_phase(h_linear, method=&#39;hilbert&#39;)</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    Compare the three filters:</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral">    &gt;&gt;&gt; fig, axs = plt.subplots(4, figsize=(4, 8))</span></div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    &gt;&gt;&gt; for h, style, color in zip((h_linear, h_min_hom, h_min_hil),</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    ...                            (&#39;-&#39;, &#39;-&#39;, &#39;--&#39;), (&#39;k&#39;, &#39;r&#39;, &#39;c&#39;)):</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    ...     w, H = freqz(h)</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    ...     w, gd = group_delay((h, 1))</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    ...     w /= np.pi</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    ...     axs[0].plot(h, color=color, linestyle=style)</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral">    ...     axs[1].plot(w, np.abs(H), color=color, linestyle=style)</span></div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    ...     axs[2].plot(w, 20 * np.log10(np.abs(H)), color=color, linestyle=style)</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral">    ...     axs[3].plot(w, gd, color=color, linestyle=style)</span></div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    &gt;&gt;&gt; for ax in axs:</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    ...     ax.grid(True, color=&#39;0.5&#39;)</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    ...     ax.fill_between(freq[1:3], *ax.get_ylim(), color=&#39;#ffeeaa&#39;, zorder=1)</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    &gt;&gt;&gt; axs[0].set(xlim=[0, len(h_linear) - 1], ylabel=&#39;Amplitude&#39;, xlabel=&#39;Samples&#39;)</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    &gt;&gt;&gt; axs[1].legend([&#39;Linear&#39;, &#39;Min-Hom&#39;, &#39;Min-Hil&#39;], title=&#39;Phase&#39;)</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral">    &gt;&gt;&gt; for ax, ylim in zip(axs[1:], ([0, 1.1], [-150, 10], [-60, 60])):</span></div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    ...     ax.set(xlim=[0, 1], ylim=ylim, xlabel=&#39;Frequency&#39;)</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral">    &gt;&gt;&gt; axs[1].set(ylabel=&#39;Magnitude&#39;)</span></div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    &gt;&gt;&gt; axs[2].set(ylabel=&#39;Magnitude (dB)&#39;)</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    &gt;&gt;&gt; axs[3].set(ylabel=&#39;Group delay&#39;)</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    &gt;&gt;&gt; plt.tight_layout()</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral">    .. [1] N. Damera-Venkata and B. L. Evans, &quot;Optimal design of real and</span></div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">           complex minimum phase digital FIR filters,&quot; Acoustics, Speech,</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">           and Signal Processing, 1999. Proceedings., 1999 IEEE International</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">           Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">           :doi:`10.1109/ICASSP.1999.756179`</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    .. [2] X. Chen and T. W. Parks, &quot;Design of optimal minimum phase FIR</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">           filters by direct factorization,&quot; Signal Processing,</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">           vol. 10, no. 4, pp. 369-383, Jun. 1986.</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    .. [3] T. Saramaki, &quot;Finite Impulse Response Filter Design,&quot; in</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral">           Handbook for Digital Signal Processing, chapter 4,</span></div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">           New York: Wiley-Interscience, 1993.</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral">    .. [4] J. S. Lim, Advanced Topics in Signal Processing.</span></div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">           Englewood Cliffs, N.J.: Prentice Hall, 1988.</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    .. [5] A. V. Oppenheim, R. W. Schafer, and J. R. Buck,</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">           &quot;Discrete-Time Signal Processing,&quot; 2nd edition.</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">           Upper Saddle River, N.J.: Prentice Hall, 1999.</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &quot;&quot;&quot;</span>  <span class="comment"># noqa</span></div>
<div class="line"><span class="lineno"> 1213</span>    h = np.asarray(h)</div>
<div class="line"><span class="lineno"> 1214</span>    <span class="keywordflow">if</span> np.iscomplexobj(h):</div>
<div class="line"><span class="lineno"> 1215</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Complex filters not supported&#39;</span>)</div>
<div class="line"><span class="lineno"> 1216</span>    <span class="keywordflow">if</span> h.ndim != 1 <span class="keywordflow">or</span> h.size &lt;= 2:</div>
<div class="line"><span class="lineno"> 1217</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;h must be 1-D and at least 2 samples long&#39;</span>)</div>
<div class="line"><span class="lineno"> 1218</span>    n_half = len(h) // 2</div>
<div class="line"><span class="lineno"> 1219</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> np.allclose(h[-n_half:][::-1], h[:n_half]):</div>
<div class="line"><span class="lineno"> 1220</span>        warnings.warn(<span class="stringliteral">&#39;h does not appear to by symmetric, conversion may &#39;</span></div>
<div class="line"><span class="lineno"> 1221</span>                      <span class="stringliteral">&#39;fail&#39;</span>, RuntimeWarning)</div>
<div class="line"><span class="lineno"> 1222</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(method, str) <span class="keywordflow">or</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> \</div>
<div class="line"><span class="lineno"> 1223</span>            (<span class="stringliteral">&#39;homomorphic&#39;</span>, <span class="stringliteral">&#39;hilbert&#39;</span>,):</div>
<div class="line"><span class="lineno"> 1224</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;method must be &quot;homomorphic&quot; or &quot;hilbert&quot;, got %r&#39;</span></div>
<div class="line"><span class="lineno"> 1225</span>                         % (method,))</div>
<div class="line"><span class="lineno"> 1226</span>    <span class="keywordflow">if</span> n_fft <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1227</span>        n_fft = 2 ** int(np.ceil(np.log2(2 * (len(h) - 1) / 0.01)))</div>
<div class="line"><span class="lineno"> 1228</span>    n_fft = int(n_fft)</div>
<div class="line"><span class="lineno"> 1229</span>    <span class="keywordflow">if</span> n_fft &lt; len(h):</div>
<div class="line"><span class="lineno"> 1230</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;n_fft must be at least len(h)==%s&#39;</span> % len(h))</div>
<div class="line"><span class="lineno"> 1231</span>    <span class="keywordflow">if</span> method == <span class="stringliteral">&#39;hilbert&#39;</span>:</div>
<div class="line"><span class="lineno"> 1232</span>        w = np.arange(n_fft) * (2 * np.pi / n_fft * n_half)</div>
<div class="line"><span class="lineno"> 1233</span>        H = np.real(fft(h, n_fft) * np.exp(1j * w))</div>
<div class="line"><span class="lineno"> 1234</span>        dp = max(H) - 1</div>
<div class="line"><span class="lineno"> 1235</span>        ds = 0 - min(H)</div>
<div class="line"><span class="lineno"> 1236</span>        S = 4. / (np.sqrt(1+dp+ds) + np.sqrt(1-dp+ds)) ** 2</div>
<div class="line"><span class="lineno"> 1237</span>        H += ds</div>
<div class="line"><span class="lineno"> 1238</span>        H *= S</div>
<div class="line"><span class="lineno"> 1239</span>        H = np.sqrt(H, out=H)</div>
<div class="line"><span class="lineno"> 1240</span>        H += 1e-10  <span class="comment"># ensure that the log does not explode</span></div>
<div class="line"><span class="lineno"> 1241</span>        h_minimum = _dhtm(H)</div>
<div class="line"><span class="lineno"> 1242</span>    <span class="keywordflow">else</span>:  <span class="comment"># method == &#39;homomorphic&#39;</span></div>
<div class="line"><span class="lineno"> 1243</span>        <span class="comment"># zero-pad; calculate the DFT</span></div>
<div class="line"><span class="lineno"> 1244</span>        h_temp = np.abs(fft(h, n_fft))</div>
<div class="line"><span class="lineno"> 1245</span>        <span class="comment"># take 0.25*log(|H|**2) = 0.5*log(|H|)</span></div>
<div class="line"><span class="lineno"> 1246</span>        h_temp += 1e-7 * h_temp[h_temp &gt; 0].min()  <span class="comment"># don&#39;t let log blow up</span></div>
<div class="line"><span class="lineno"> 1247</span>        np.log(h_temp, out=h_temp)</div>
<div class="line"><span class="lineno"> 1248</span>        h_temp *= 0.5</div>
<div class="line"><span class="lineno"> 1249</span>        <span class="comment"># IDFT</span></div>
<div class="line"><span class="lineno"> 1250</span>        h_temp = ifft(h_temp).real</div>
<div class="line"><span class="lineno"> 1251</span>        <span class="comment"># multiply pointwise by the homomorphic filter</span></div>
<div class="line"><span class="lineno"> 1252</span>        <span class="comment"># lmin[n] = 2u[n] - d[n]</span></div>
<div class="line"><span class="lineno"> 1253</span>        win = np.zeros(n_fft)</div>
<div class="line"><span class="lineno"> 1254</span>        win[0] = 1</div>
<div class="line"><span class="lineno"> 1255</span>        stop = (len(h) + 1) // 2</div>
<div class="line"><span class="lineno"> 1256</span>        win[1:stop] = 2</div>
<div class="line"><span class="lineno"> 1257</span>        <span class="keywordflow">if</span> len(h) % 2:</div>
<div class="line"><span class="lineno"> 1258</span>            win[stop] = 1</div>
<div class="line"><span class="lineno"> 1259</span>        h_temp *= win</div>
<div class="line"><span class="lineno"> 1260</span>        h_temp = ifft(np.exp(fft(h_temp)))</div>
<div class="line"><span class="lineno"> 1261</span>        h_minimum = h_temp.real</div>
<div class="line"><span class="lineno"> 1262</span>    n_out = n_half + len(h) % 2</div>
<div class="line"><span class="lineno"> 1263</span>    <span class="keywordflow">return</span> h_minimum[:n_out]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a909a3ff237b9a0c641ef2dd402a0a7ee" name="a909a3ff237b9a0c641ef2dd402a0a7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909a3ff237b9a0c641ef2dd402a0a7ee">&#9670;&#160;</a></span>remez()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">scipy.signal._fir_filter_design.remez </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>numtaps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>desired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>weight</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Hz</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>type</em> = <code>'bandpass'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>maxiter</em> = <code>25</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>grid_density</em> = <code>16</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate the minimax optimal filter using the Remez exchange algorithm.

Calculate the filter-coefficients for the finite impulse response
(FIR) filter whose transfer function minimizes the maximum error
between the desired gain and the realized gain in the specified
frequency bands using the Remez exchange algorithm.

Parameters
----------
numtaps : int
    The desired number of taps in the filter. The number of taps is
    the number of terms in the filter, or the filter order plus one.
bands : array_like
    A monotonic sequence containing the band edges.
    All elements must be non-negative and less than half the sampling
    frequency as given by `fs`.
desired : array_like
    A sequence half the size of bands containing the desired gain
    in each of the specified bands.
weight : array_like, optional
    A relative weighting to give to each band region. The length of
    `weight` has to be half the length of `bands`.
Hz : scalar, optional
    *Deprecated.  Use `fs` instead.*
    The sampling frequency in Hz. Default is 1.
type : {'bandpass', 'differentiator', 'hilbert'}, optional
    The type of filter:

      * 'bandpass' : flat response in bands. This is the default.

      * 'differentiator' : frequency proportional response in bands.

      * 'hilbert' : filter with odd symmetry, that is, type III
                    (for even order) or type IV (for odd order)
                    linear phase filters.

maxiter : int, optional
    Maximum number of iterations of the algorithm. Default is 25.
grid_density : int, optional
    Grid density. The dense grid used in `remez` is of size
    ``(numtaps + 1) * grid_density``. Default is 16.
fs : float, optional
    The sampling frequency of the signal.  Default is 1.

Returns
-------
out : ndarray
    A rank-1 array containing the coefficients of the optimal
    (in a minimax sense) filter.

See Also
--------
firls
firwin
firwin2
minimum_phase

References
----------
.. [1] J. H. McClellan and T. W. Parks, "A unified approach to the
       design of optimum FIR linear phase digital filters",
       IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.
.. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, "A Computer
       Program for Designing Optimum FIR Linear Phase Digital
       Filters", IEEE Trans. Audio Electroacoust., vol. AU-21,
       pp. 506-525, 1973.

Examples
--------
In these examples `remez` gets used creating a bandpass, bandstop, lowpass
and highpass filter. The used parameters are the filter order, an array
with according frequency boundaries, the desired attenuation values and the
sampling frequency. Using `freqz` the corresponding frequency response
gets calculated and plotted.

&gt;&gt;&gt; from scipy import signal
&gt;&gt;&gt; import matplotlib.pyplot as plt

&gt;&gt;&gt; def plot_response(fs, w, h, title):
...     "Utility function to plot response functions"
...     fig = plt.figure()
...     ax = fig.add_subplot(111)
...     ax.plot(0.5*fs*w/np.pi, 20*np.log10(np.abs(h)))
...     ax.set_ylim(-40, 5)
...     ax.set_xlim(0, 0.5*fs)
...     ax.grid(True)
...     ax.set_xlabel('Frequency (Hz)')
...     ax.set_ylabel('Gain (dB)')
...     ax.set_title(title)

This example shows a steep low pass transition according to the small
transition width and high filter order:

&gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz
&gt;&gt;&gt; cutoff = 8000.0    # Desired cutoff frequency, Hz
&gt;&gt;&gt; trans_width = 100  # Width of transition from pass band to stop band, Hz
&gt;&gt;&gt; numtaps = 400      # Size of the FIR filter.
&gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], [1, 0], Hz=fs)
&gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)
&gt;&gt;&gt; plot_response(fs, w, h, "Low-pass Filter")

This example shows a high pass filter:

&gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz
&gt;&gt;&gt; cutoff = 2000.0    # Desired cutoff frequency, Hz
&gt;&gt;&gt; trans_width = 250  # Width of transition from pass band to stop band, Hz
&gt;&gt;&gt; numtaps = 125      # Size of the FIR filter.
&gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs],
...                     [0, 1], Hz=fs)
&gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)
&gt;&gt;&gt; plot_response(fs, w, h, "High-pass Filter")

For a signal sampled with 22 kHz a bandpass filter with a pass band of 2-5
kHz gets calculated using the Remez algorithm. The transition width is 260
Hz and the filter order 10:

&gt;&gt;&gt; fs = 22000.0         # Sample rate, Hz
&gt;&gt;&gt; band = [2000, 5000]  # Desired pass band, Hz
&gt;&gt;&gt; trans_width = 260    # Width of transition from pass band to stop band, Hz
&gt;&gt;&gt; numtaps = 10        # Size of the FIR filter.
&gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1],
...          band[1] + trans_width, 0.5*fs]
&gt;&gt;&gt; taps = signal.remez(numtaps, edges, [0, 1, 0], Hz=fs)
&gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)
&gt;&gt;&gt; plot_response(fs, w, h, "Band-pass Filter")

It can be seen that for this bandpass filter, the low order leads to higher
ripple and less steep transitions. There is very low attenuation in the
stop band and little overshoot in the pass band.  Of course the desired
gain can be better approximated with a higher filter order.

The next example shows a bandstop filter. Because of the high filter order
the transition is quite steep:

&gt;&gt;&gt; fs = 20000.0         # Sample rate, Hz
&gt;&gt;&gt; band = [6000, 8000]  # Desired stop band, Hz
&gt;&gt;&gt; trans_width = 200    # Width of transition from pass band to stop band, Hz
&gt;&gt;&gt; numtaps = 175        # Size of the FIR filter.
&gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1], band[1] + trans_width, 0.5*fs]
&gt;&gt;&gt; taps = signal.remez(numtaps, edges, [1, 0, 1], Hz=fs)
&gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)
&gt;&gt;&gt; plot_response(fs, w, h, "Band-stop Filter")

&gt;&gt;&gt; plt.show()</pre> <div class="fragment"><div class="line"><span class="lineno">  686</span>          maxiter=25, grid_density=16, fs=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  687</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">    Calculate the minimax optimal filter using the Remez exchange algorithm.</span></div>
<div class="line"><span class="lineno">  689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  690</span><span class="stringliteral">    Calculate the filter-coefficients for the finite impulse response</span></div>
<div class="line"><span class="lineno">  691</span><span class="stringliteral">    (FIR) filter whose transfer function minimizes the maximum error</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">    between the desired gain and the realized gain in the specified</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral">    frequency bands using the Remez exchange algorithm.</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">    numtaps : int</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        The desired number of taps in the filter. The number of taps is</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        the number of terms in the filter, or the filter order plus one.</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">    bands : array_like</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        A monotonic sequence containing the band edges.</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral">        All elements must be non-negative and less than half the sampling</span></div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        frequency as given by `fs`.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">    desired : array_like</span></div>
<div class="line"><span class="lineno">  705</span><span class="stringliteral">        A sequence half the size of bands containing the desired gain</span></div>
<div class="line"><span class="lineno">  706</span><span class="stringliteral">        in each of the specified bands.</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    weight : array_like, optional</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        A relative weighting to give to each band region. The length of</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">        `weight` has to be half the length of `bands`.</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    Hz : scalar, optional</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        *Deprecated.  Use `fs` instead.*</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        The sampling frequency in Hz. Default is 1.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">    type : {&#39;bandpass&#39;, &#39;differentiator&#39;, &#39;hilbert&#39;}, optional</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        The type of filter:</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">          * &#39;bandpass&#39; : flat response in bands. This is the default.</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">          * &#39;differentiator&#39; : frequency proportional response in bands.</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">          * &#39;hilbert&#39; : filter with odd symmetry, that is, type III</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">                        (for even order) or type IV (for odd order)</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">                        linear phase filters.</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">    maxiter : int, optional</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral">        Maximum number of iterations of the algorithm. Default is 25.</span></div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">    grid_density : int, optional</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">        Grid density. The dense grid used in `remez` is of size</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        ``(numtaps + 1) * grid_density``. Default is 16.</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">    fs : float, optional</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">        The sampling frequency of the signal.  Default is 1.</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">    out : ndarray</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">        A rank-1 array containing the coefficients of the optimal</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        (in a minimax sense) filter.</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">    firls</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral">    firwin</span></div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    firwin2</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    minimum_phase</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">    .. [1] J. H. McClellan and T. W. Parks, &quot;A unified approach to the</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral">           design of optimum FIR linear phase digital filters&quot;,</span></div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">           IEEE Trans. Circuit Theory, vol. CT-20, pp. 697-701, 1973.</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    .. [2] J. H. McClellan, T. W. Parks and L. R. Rabiner, &quot;A Computer</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">           Program for Designing Optimum FIR Linear Phase Digital</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">           Filters&quot;, IEEE Trans. Audio Electroacoust., vol. AU-21,</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">           pp. 506-525, 1973.</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    In these examples `remez` gets used creating a bandpass, bandstop, lowpass</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    and highpass filter. The used parameters are the filter order, an array</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">    with according frequency boundaries, the desired attenuation values and the</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    sampling frequency. Using `freqz` the corresponding frequency response</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    gets calculated and plotted.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    &gt;&gt;&gt; from scipy import signal</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    &gt;&gt;&gt; def plot_response(fs, w, h, title):</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    ...     &quot;Utility function to plot response functions&quot;</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">    ...     fig = plt.figure()</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    ...     ax = fig.add_subplot(111)</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    ...     ax.plot(0.5*fs*w/np.pi, 20*np.log10(np.abs(h)))</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    ...     ax.set_ylim(-40, 5)</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    ...     ax.set_xlim(0, 0.5*fs)</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    ...     ax.grid(True)</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    ...     ax.set_xlabel(&#39;Frequency (Hz)&#39;)</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    ...     ax.set_ylabel(&#39;Gain (dB)&#39;)</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    ...     ax.set_title(title)</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">    This example shows a steep low pass transition according to the small</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">    transition width and high filter order:</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">    &gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">    &gt;&gt;&gt; cutoff = 8000.0    # Desired cutoff frequency, Hz</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">    &gt;&gt;&gt; trans_width = 100  # Width of transition from pass band to stop band, Hz</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    &gt;&gt;&gt; numtaps = 400      # Size of the FIR filter.</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff, cutoff + trans_width, 0.5*fs], [1, 0], Hz=fs)</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Low-pass Filter&quot;)</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral">    This example shows a high pass filter:</span></div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    &gt;&gt;&gt; fs = 22050.0       # Sample rate, Hz</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">    &gt;&gt;&gt; cutoff = 2000.0    # Desired cutoff frequency, Hz</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    &gt;&gt;&gt; trans_width = 250  # Width of transition from pass band to stop band, Hz</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    &gt;&gt;&gt; numtaps = 125      # Size of the FIR filter.</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    &gt;&gt;&gt; taps = signal.remez(numtaps, [0, cutoff - trans_width, cutoff, 0.5*fs],</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    ...                     [0, 1], Hz=fs)</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span></div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;High-pass Filter&quot;)</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    For a signal sampled with 22 kHz a bandpass filter with a pass band of 2-5</span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">    kHz gets calculated using the Remez algorithm. The transition width is 260</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">    Hz and the filter order 10:</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">    &gt;&gt;&gt; fs = 22000.0         # Sample rate, Hz</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">    &gt;&gt;&gt; band = [2000, 5000]  # Desired pass band, Hz</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">    &gt;&gt;&gt; trans_width = 260    # Width of transition from pass band to stop band, Hz</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">    &gt;&gt;&gt; numtaps = 10        # Size of the FIR filter.</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1],</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    ...          band[1] + trans_width, 0.5*fs]</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [0, 1, 0], Hz=fs)</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Band-pass Filter&quot;)</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">    It can be seen that for this bandpass filter, the low order leads to higher</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    ripple and less steep transitions. There is very low attenuation in the</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">    stop band and little overshoot in the pass band.  Of course the desired</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">    gain can be better approximated with a higher filter order.</span></div>
<div class="line"><span class="lineno">  818</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  819</span><span class="stringliteral">    The next example shows a bandstop filter. Because of the high filter order</span></div>
<div class="line"><span class="lineno">  820</span><span class="stringliteral">    the transition is quite steep:</span></div>
<div class="line"><span class="lineno">  821</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  822</span><span class="stringliteral">    &gt;&gt;&gt; fs = 20000.0         # Sample rate, Hz</span></div>
<div class="line"><span class="lineno">  823</span><span class="stringliteral">    &gt;&gt;&gt; band = [6000, 8000]  # Desired stop band, Hz</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">    &gt;&gt;&gt; trans_width = 200    # Width of transition from pass band to stop band, Hz</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">    &gt;&gt;&gt; numtaps = 175        # Size of the FIR filter.</span></div>
<div class="line"><span class="lineno">  826</span><span class="stringliteral">    &gt;&gt;&gt; edges = [0, band[0] - trans_width, band[0], band[1], band[1] + trans_width, 0.5*fs]</span></div>
<div class="line"><span class="lineno">  827</span><span class="stringliteral">    &gt;&gt;&gt; taps = signal.remez(numtaps, edges, [1, 0, 1], Hz=fs)</span></div>
<div class="line"><span class="lineno">  828</span><span class="stringliteral">    &gt;&gt;&gt; w, h = signal.freqz(taps, [1], worN=2000)</span></div>
<div class="line"><span class="lineno">  829</span><span class="stringliteral">    &gt;&gt;&gt; plot_response(fs, w, h, &quot;Band-stop Filter&quot;)</span></div>
<div class="line"><span class="lineno">  830</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  831</span><span class="stringliteral">    &gt;&gt;&gt; plt.show()</span></div>
<div class="line"><span class="lineno">  832</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  833</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  834</span>    <span class="keywordflow">if</span> Hz <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> fs <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  835</span>        fs = 1.0</div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">elif</span> Hz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  837</span>        <span class="keywordflow">if</span> fs <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  838</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Values cannot be given for both &#39;Hz&#39; and &#39;fs&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">  839</span>        fs = Hz</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>    <span class="comment"># Convert type</span></div>
<div class="line"><span class="lineno">  842</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  843</span>        tnum = {<span class="stringliteral">&#39;bandpass&#39;</span>: 1, <span class="stringliteral">&#39;differentiator&#39;</span>: 2, <span class="stringliteral">&#39;hilbert&#39;</span>: 3}[type]</div>
<div class="line"><span class="lineno">  844</span>    <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  845</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Type must be &#39;bandpass&#39;, &#39;differentiator&#39;, &quot;</span></div>
<div class="line"><span class="lineno">  846</span>                         <span class="stringliteral">&quot;or &#39;hilbert&#39;&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  847</span> </div>
<div class="line"><span class="lineno">  848</span>    <span class="comment"># Convert weight</span></div>
<div class="line"><span class="lineno">  849</span>    <span class="keywordflow">if</span> weight <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  850</span>        weight = [1] * len(desired)</div>
<div class="line"><span class="lineno">  851</span> </div>
<div class="line"><span class="lineno">  852</span>    bands = np.asarray(bands).copy()</div>
<div class="line"><span class="lineno">  853</span>    <span class="keywordflow">return</span> _sigtools._remez(numtaps, bands, desired, weight, tnum, fs,</div>
<div class="line"><span class="lineno">  854</span>                           maxiter, grid_density)</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
