<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.einsumfunc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html">einsumfunc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.einsumfunc Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae0534658b323271137dcf34b25aa9fd9" id="r_ae0534658b323271137dcf34b25aa9fd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ae0534658b323271137dcf34b25aa9fd9">_flop_count</a> (idx_contraction, inner, num_terms, size_dictionary)</td></tr>
<tr class="separator:ae0534658b323271137dcf34b25aa9fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7ae66dbf87e0c7458651c801a55be" id="r_ac1a7ae66dbf87e0c7458651c801a55be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ac1a7ae66dbf87e0c7458651c801a55be">_compute_size_by_dict</a> (<a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>, idx_dict)</td></tr>
<tr class="separator:ac1a7ae66dbf87e0c7458651c801a55be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3420e845da6cf5b8182f741c364b6e2" id="r_ae3420e845da6cf5b8182f741c364b6e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ae3420e845da6cf5b8182f741c364b6e2">_find_contraction</a> (positions, input_sets, output_set)</td></tr>
<tr class="separator:ae3420e845da6cf5b8182f741c364b6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dff852d6519fc0dcb632d7bb51818ca" id="r_a9dff852d6519fc0dcb632d7bb51818ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a9dff852d6519fc0dcb632d7bb51818ca">_optimal_path</a> (input_sets, output_set, idx_dict, memory_limit)</td></tr>
<tr class="separator:a9dff852d6519fc0dcb632d7bb51818ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335083a29f87822424e8ac7e3bfb5060" id="r_a335083a29f87822424e8ac7e3bfb5060"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a335083a29f87822424e8ac7e3bfb5060">_parse_possible_contraction</a> (positions, input_sets, output_set, idx_dict, memory_limit, path_cost, naive_cost)</td></tr>
<tr class="separator:a335083a29f87822424e8ac7e3bfb5060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a948887a56e53d34d275ed795464d2" id="r_a67a948887a56e53d34d275ed795464d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a67a948887a56e53d34d275ed795464d2">_update_other_results</a> (results, best)</td></tr>
<tr class="separator:a67a948887a56e53d34d275ed795464d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1140adb40e3e09e6a4b291e3c9ddd8" id="r_a1b1140adb40e3e09e6a4b291e3c9ddd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a1b1140adb40e3e09e6a4b291e3c9ddd8">_greedy_path</a> (input_sets, output_set, idx_dict, memory_limit)</td></tr>
<tr class="separator:a1b1140adb40e3e09e6a4b291e3c9ddd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cd5849b0abe9fa455f46cf212c4ec7" id="r_ac5cd5849b0abe9fa455f46cf212c4ec7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ac5cd5849b0abe9fa455f46cf212c4ec7">_can_dot</a> (inputs, result, idx_removed)</td></tr>
<tr class="separator:ac5cd5849b0abe9fa455f46cf212c4ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a2d270997c04b34faf92b0b9d1291e" id="r_ad3a2d270997c04b34faf92b0b9d1291e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ad3a2d270997c04b34faf92b0b9d1291e">_parse_einsum_input</a> (operands)</td></tr>
<tr class="separator:ad3a2d270997c04b34faf92b0b9d1291e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fd339ad847f48ff8f68063597791d9" id="r_a73fd339ad847f48ff8f68063597791d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a73fd339ad847f48ff8f68063597791d9">_einsum_path_dispatcher</a> (*operands, optimize=None, einsum_call=None)</td></tr>
<tr class="separator:a73fd339ad847f48ff8f68063597791d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df65e48c50e2ec96f2e23ea69249a32" id="r_a8df65e48c50e2ec96f2e23ea69249a32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a8df65e48c50e2ec96f2e23ea69249a32">einsum_path</a> (*operands, optimize='greedy', einsum_call=False)</td></tr>
<tr class="separator:a8df65e48c50e2ec96f2e23ea69249a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e25c66a9ca3c319c62b9a171dd6e66c" id="r_a2e25c66a9ca3c319c62b9a171dd6e66c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a2e25c66a9ca3c319c62b9a171dd6e66c">_einsum_dispatcher</a> (*operands, out=None, optimize=None, **kwargs)</td></tr>
<tr class="separator:a2e25c66a9ca3c319c62b9a171dd6e66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40e071d1855e1ffe8dcb31e705fc095" id="r_af40e071d1855e1ffe8dcb31e705fc095"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#af40e071d1855e1ffe8dcb31e705fc095">einsum</a> (*operands, out=None, optimize=False, **kwargs)</td></tr>
<tr class="separator:af40e071d1855e1ffe8dcb31e705fc095"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a18a08d7e10c94d25799a8e1a57922e23" id="r_a18a08d7e10c94d25799a8e1a57922e23"><td class="memItemLeft" align="right" valign="top">str&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a18a08d7e10c94d25799a8e1a57922e23">einsum_symbols</a> = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</td></tr>
<tr class="separator:a18a08d7e10c94d25799a8e1a57922e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9434bd5793781fc806f488c58228d32" id="r_ae9434bd5793781fc806f488c58228d32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#ae9434bd5793781fc806f488c58228d32">einsum_symbols_set</a> = set(<a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a18a08d7e10c94d25799a8e1a57922e23">einsum_symbols</a>)</td></tr>
<tr class="separator:ae9434bd5793781fc806f488c58228d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Implementation of optimized einsum.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac5cd5849b0abe9fa455f46cf212c4ec7" name="ac5cd5849b0abe9fa455f46cf212c4ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cd5849b0abe9fa455f46cf212c4ec7">&#9670;&#160;</a></span>_can_dot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._can_dot </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_removed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Checks if we can use BLAS (np.tensordot) call and its beneficial to do so.

Parameters
----------
inputs : list of str
    Specifies the subscripts for summation.
result : str
    Resulting summation.
idx_removed : set
    Indices that are removed in the summation


Returns
-------
type : bool
    Returns true if BLAS should and can be used, else False

Notes
-----
If the operations is BLAS level 1 or 2 and is not already aligned
we default back to einsum as the memory movement to copy is more
costly than the operation itself.


Examples
--------

# Standard GEMM operation
&gt;&gt;&gt; _can_dot(['ij', 'jk'], 'ik', set('j'))
True

# Can use the standard BLAS, but requires odd data movement
&gt;&gt;&gt; _can_dot(['ijj', 'jk'], 'ik', set('j'))
False

# DDOT where the memory is not aligned
&gt;&gt;&gt; _can_dot(['ijk', 'ikj'], '', set('ijk'))
False</pre> <div class="fragment"><div class="line"><span class="lineno">  413</span><span class="keyword">def </span>_can_dot(inputs, result, idx_removed):</div>
<div class="line"><span class="lineno">  414</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  415</span><span class="stringliteral">    Checks if we can use BLAS (np.tensordot) call and its beneficial to do so.</span></div>
<div class="line"><span class="lineno">  416</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  417</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  418</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  419</span><span class="stringliteral">    inputs : list of str</span></div>
<div class="line"><span class="lineno">  420</span><span class="stringliteral">        Specifies the subscripts for summation.</span></div>
<div class="line"><span class="lineno">  421</span><span class="stringliteral">    result : str</span></div>
<div class="line"><span class="lineno">  422</span><span class="stringliteral">        Resulting summation.</span></div>
<div class="line"><span class="lineno">  423</span><span class="stringliteral">    idx_removed : set</span></div>
<div class="line"><span class="lineno">  424</span><span class="stringliteral">        Indices that are removed in the summation</span></div>
<div class="line"><span class="lineno">  425</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  427</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  428</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  429</span><span class="stringliteral">    type : bool</span></div>
<div class="line"><span class="lineno">  430</span><span class="stringliteral">        Returns true if BLAS should and can be used, else False</span></div>
<div class="line"><span class="lineno">  431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  432</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  433</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  434</span><span class="stringliteral">    If the operations is BLAS level 1 or 2 and is not already aligned</span></div>
<div class="line"><span class="lineno">  435</span><span class="stringliteral">    we default back to einsum as the memory movement to copy is more</span></div>
<div class="line"><span class="lineno">  436</span><span class="stringliteral">    costly than the operation itself.</span></div>
<div class="line"><span class="lineno">  437</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  438</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  439</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  440</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  442</span><span class="stringliteral">    # Standard GEMM operation</span></div>
<div class="line"><span class="lineno">  443</span><span class="stringliteral">    &gt;&gt;&gt; _can_dot([&#39;ij&#39;, &#39;jk&#39;], &#39;ik&#39;, set(&#39;j&#39;))</span></div>
<div class="line"><span class="lineno">  444</span><span class="stringliteral">    True</span></div>
<div class="line"><span class="lineno">  445</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  446</span><span class="stringliteral">    # Can use the standard BLAS, but requires odd data movement</span></div>
<div class="line"><span class="lineno">  447</span><span class="stringliteral">    &gt;&gt;&gt; _can_dot([&#39;ijj&#39;, &#39;jk&#39;], &#39;ik&#39;, set(&#39;j&#39;))</span></div>
<div class="line"><span class="lineno">  448</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  449</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">    # DDOT where the memory is not aligned</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">    &gt;&gt;&gt; _can_dot([&#39;ijk&#39;, &#39;ikj&#39;], &#39;&#39;, set(&#39;ijk&#39;))</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">    False</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  454</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>    <span class="comment"># All `dot` calls remove indices</span></div>
<div class="line"><span class="lineno">  457</span>    <span class="keywordflow">if</span> len(idx_removed) == 0:</div>
<div class="line"><span class="lineno">  458</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>    <span class="comment"># BLAS can only handle two operands</span></div>
<div class="line"><span class="lineno">  461</span>    <span class="keywordflow">if</span> len(inputs) != 2:</div>
<div class="line"><span class="lineno">  462</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  463</span> </div>
<div class="line"><span class="lineno">  464</span>    input_left, input_right = inputs</div>
<div class="line"><span class="lineno">  465</span> </div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">for</span> c <span class="keywordflow">in</span> set(input_left + input_right):</div>
<div class="line"><span class="lineno">  467</span>        <span class="comment"># can&#39;t deal with repeated indices on same input or more than 2 total</span></div>
<div class="line"><span class="lineno">  468</span>        nl, nr = input_left.count(c), input_right.count(c)</div>
<div class="line"><span class="lineno">  469</span>        <span class="keywordflow">if</span> (nl &gt; 1) <span class="keywordflow">or</span> (nr &gt; 1) <span class="keywordflow">or</span> (nl + nr &gt; 2):</div>
<div class="line"><span class="lineno">  470</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>        <span class="comment"># can&#39;t do implicit summation or dimension collapse e.g.</span></div>
<div class="line"><span class="lineno">  473</span>        <span class="comment">#     &quot;ab,bc-&gt;c&quot; (implicitly sum over &#39;a&#39;)</span></div>
<div class="line"><span class="lineno">  474</span>        <span class="comment">#     &quot;ab,ca-&gt;ca&quot; (take diagonal of &#39;a&#39;)</span></div>
<div class="line"><span class="lineno">  475</span>        <span class="keywordflow">if</span> nl + nr - 1 == int(c <span class="keywordflow">in</span> result):</div>
<div class="line"><span class="lineno">  476</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  477</span> </div>
<div class="line"><span class="lineno">  478</span>    <span class="comment"># Build a few temporaries</span></div>
<div class="line"><span class="lineno">  479</span>    set_left = set(input_left)</div>
<div class="line"><span class="lineno">  480</span>    set_right = set(input_right)</div>
<div class="line"><span class="lineno">  481</span>    keep_left = set_left - idx_removed</div>
<div class="line"><span class="lineno">  482</span>    keep_right = set_right - idx_removed</div>
<div class="line"><span class="lineno">  483</span>    rs = len(idx_removed)</div>
<div class="line"><span class="lineno">  484</span> </div>
<div class="line"><span class="lineno">  485</span>    <span class="comment"># At this point we are a DOT, GEMV, or GEMM operation</span></div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>    <span class="comment"># Handle inner products</span></div>
<div class="line"><span class="lineno">  488</span> </div>
<div class="line"><span class="lineno">  489</span>    <span class="comment"># DDOT with aligned data</span></div>
<div class="line"><span class="lineno">  490</span>    <span class="keywordflow">if</span> input_left == input_right:</div>
<div class="line"><span class="lineno">  491</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  492</span> </div>
<div class="line"><span class="lineno">  493</span>    <span class="comment"># DDOT without aligned data (better to use einsum)</span></div>
<div class="line"><span class="lineno">  494</span>    <span class="keywordflow">if</span> set_left == set_right:</div>
<div class="line"><span class="lineno">  495</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span>    <span class="comment"># Handle the 4 possible (aligned) GEMV or GEMM cases</span></div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>    <span class="comment"># GEMM or GEMV no transpose</span></div>
<div class="line"><span class="lineno">  500</span>    <span class="keywordflow">if</span> input_left[-rs:] == input_right[:rs]:</div>
<div class="line"><span class="lineno">  501</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span>    <span class="comment"># GEMM or GEMV transpose both</span></div>
<div class="line"><span class="lineno">  504</span>    <span class="keywordflow">if</span> input_left[:rs] == input_right[-rs:]:</div>
<div class="line"><span class="lineno">  505</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span>    <span class="comment"># GEMM or GEMV transpose right</span></div>
<div class="line"><span class="lineno">  508</span>    <span class="keywordflow">if</span> input_left[-rs:] == input_right[-rs:]:</div>
<div class="line"><span class="lineno">  509</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>    <span class="comment"># GEMM or GEMV transpose left</span></div>
<div class="line"><span class="lineno">  512</span>    <span class="keywordflow">if</span> input_left[:rs] == input_right[:rs]:</div>
<div class="line"><span class="lineno">  513</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  514</span> </div>
<div class="line"><span class="lineno">  515</span>    <span class="comment"># Einsum is faster than GEMV if we have to copy data</span></div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> keep_left <span class="keywordflow">or</span> <span class="keywordflow">not</span> keep_right:</div>
<div class="line"><span class="lineno">  517</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>    <span class="comment"># We are a matrix-matrix product, but we need to copy data</span></div>
<div class="line"><span class="lineno">  520</span>    <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  521</span> </div>
<div class="line"><span class="lineno">  522</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac1a7ae66dbf87e0c7458651c801a55be" name="ac1a7ae66dbf87e0c7458651c801a55be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a7ae66dbf87e0c7458651c801a55be">&#9670;&#160;</a></span>_compute_size_by_dict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._compute_size_by_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_dict</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes the product of the elements in indices based on the dictionary
idx_dict.

Parameters
----------
indices : iterable
    Indices to base the product on.
idx_dict : dictionary
    Dictionary of index sizes

Returns
-------
ret : int
    The resulting product.

Examples
--------
&gt;&gt;&gt; _compute_size_by_dict('abbc', {'a': 2, 'b':3, 'c':5})
90</pre> <div class="fragment"><div class="line"><span class="lineno">   56</span><span class="keyword">def </span>_compute_size_by_dict(indices, idx_dict):</div>
<div class="line"><span class="lineno">   57</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   58</span><span class="stringliteral">    Computes the product of the elements in indices based on the dictionary</span></div>
<div class="line"><span class="lineno">   59</span><span class="stringliteral">    idx_dict.</span></div>
<div class="line"><span class="lineno">   60</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   61</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   62</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   63</span><span class="stringliteral">    indices : iterable</span></div>
<div class="line"><span class="lineno">   64</span><span class="stringliteral">        Indices to base the product on.</span></div>
<div class="line"><span class="lineno">   65</span><span class="stringliteral">    idx_dict : dictionary</span></div>
<div class="line"><span class="lineno">   66</span><span class="stringliteral">        Dictionary of index sizes</span></div>
<div class="line"><span class="lineno">   67</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   68</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   69</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   70</span><span class="stringliteral">    ret : int</span></div>
<div class="line"><span class="lineno">   71</span><span class="stringliteral">        The resulting product.</span></div>
<div class="line"><span class="lineno">   72</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   73</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   74</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   75</span><span class="stringliteral">    &gt;&gt;&gt; _compute_size_by_dict(&#39;abbc&#39;, {&#39;a&#39;: 2, &#39;b&#39;:3, &#39;c&#39;:5})</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    90</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   79</span>    ret = 1</div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> indices:</div>
<div class="line"><span class="lineno">   81</span>        ret *= idx_dict[i]</div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">return</span> ret</div>
<div class="line"><span class="lineno">   83</span> </div>
<div class="line"><span class="lineno">   84</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e25c66a9ca3c319c62b9a171dd6e66c" name="a2e25c66a9ca3c319c62b9a171dd6e66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e25c66a9ca3c319c62b9a171dd6e66c">&#9670;&#160;</a></span>_einsum_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._einsum_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1001</span><span class="keyword">def </span>_einsum_dispatcher(*operands, out=None, optimize=None, **kwargs):</div>
<div class="line"><span class="lineno"> 1002</span>    <span class="comment"># Arguably we dispatch on more arguments than we really should; see note in</span></div>
<div class="line"><span class="lineno"> 1003</span>    <span class="comment"># _einsum_path_dispatcher for why.</span></div>
<div class="line"><span class="lineno"> 1004</span>    <span class="keywordflow">yield</span> <span class="keyword">from</span> operands</div>
<div class="line"><span class="lineno"> 1005</span>    <span class="keywordflow">yield</span> out</div>
<div class="line"><span class="lineno"> 1006</span> </div>
<div class="line"><span class="lineno"> 1007</span> </div>
<div class="line"><span class="lineno"> 1008</span><span class="comment"># Rewrite einsum to handle different cases</span></div>
<div class="line"><span class="lineno"> 1009</span><span class="preprocessor">@array_function_dispatch(_einsum_dispatcher, module=&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="a73fd339ad847f48ff8f68063597791d9" name="a73fd339ad847f48ff8f68063597791d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fd339ad847f48ff8f68063597791d9">&#9670;&#160;</a></span>_einsum_path_dispatcher()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._einsum_path_dispatcher </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>einsum_call</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  696</span><span class="keyword">def </span>_einsum_path_dispatcher(*operands, optimize=None, einsum_call=None):</div>
<div class="line"><span class="lineno">  697</span>    <span class="comment"># NOTE: technically, we should only dispatch on array-like arguments, not</span></div>
<div class="line"><span class="lineno">  698</span>    <span class="comment"># subscripts (given as strings). But separating operands into</span></div>
<div class="line"><span class="lineno">  699</span>    <span class="comment"># arrays/subscripts is a little tricky/slow (given einsum&#39;s two supported</span></div>
<div class="line"><span class="lineno">  700</span>    <span class="comment"># signatures), so as a practical shortcut we dispatch on everything.</span></div>
<div class="line"><span class="lineno">  701</span>    <span class="comment"># Strings will be ignored for dispatching since they don&#39;t define</span></div>
<div class="line"><span class="lineno">  702</span>    <span class="comment"># __array_function__.</span></div>
<div class="line"><span class="lineno">  703</span>    <span class="keywordflow">return</span> operands</div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span> </div>
<div class="line"><span class="lineno">  706</span><span class="preprocessor">@array_function_dispatch(_einsum_path_dispatcher, module=&#39;numpy&#39;)</span></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3420e845da6cf5b8182f741c364b6e2" name="ae3420e845da6cf5b8182f741c364b6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3420e845da6cf5b8182f741c364b6e2">&#9670;&#160;</a></span>_find_contraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._find_contraction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Finds the contraction for a given set of input and output sets.

Parameters
----------
positions : iterable
    Integer positions of terms used in the contraction.
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript

Returns
-------
new_result : set
    The indices of the resulting contraction
remaining : list
    List of sets that have not been contracted, the new set is appended to
    the end of this list
idx_removed : set
    Indices removed from the entire contraction
idx_contraction : set
    The indices used in the current contraction

Examples
--------

# A simple dot product test case
&gt;&gt;&gt; pos = (0, 1)
&gt;&gt;&gt; isets = [set('ab'), set('bc')]
&gt;&gt;&gt; oset = set('ac')
&gt;&gt;&gt; _find_contraction(pos, isets, oset)
({'a', 'c'}, [{'a', 'c'}], {'b'}, {'a', 'b', 'c'})

# A more complex case with additional terms in the contraction
&gt;&gt;&gt; pos = (0, 2)
&gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')]
&gt;&gt;&gt; oset = set('ac')
&gt;&gt;&gt; _find_contraction(pos, isets, oset)
({'a', 'c'}, [{'a', 'c'}, {'a', 'c'}], {'b', 'd'}, {'a', 'b', 'c', 'd'})
</pre> <div class="fragment"><div class="line"><span class="lineno">   85</span><span class="keyword">def </span>_find_contraction(positions, input_sets, output_set):</div>
<div class="line"><span class="lineno">   86</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    Finds the contraction for a given set of input and output sets.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   89</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   90</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   91</span><span class="stringliteral">    positions : iterable</span></div>
<div class="line"><span class="lineno">   92</span><span class="stringliteral">        Integer positions of terms used in the contraction.</span></div>
<div class="line"><span class="lineno">   93</span><span class="stringliteral">    input_sets : list</span></div>
<div class="line"><span class="lineno">   94</span><span class="stringliteral">        List of sets that represent the lhs side of the einsum subscript</span></div>
<div class="line"><span class="lineno">   95</span><span class="stringliteral">    output_set : set</span></div>
<div class="line"><span class="lineno">   96</span><span class="stringliteral">        Set that represents the rhs side of the overall einsum subscript</span></div>
<div class="line"><span class="lineno">   97</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   98</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   99</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    new_result : set</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral">        The indices of the resulting contraction</span></div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    remaining : list</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">        List of sets that have not been contracted, the new set is appended to</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">        the end of this list</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">    idx_removed : set</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral">        Indices removed from the entire contraction</span></div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    idx_contraction : set</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        The indices used in the current contraction</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    # A simple dot product test case</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    &gt;&gt;&gt; pos = (0, 1)</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    &gt;&gt;&gt; isets = [set(&#39;ab&#39;), set(&#39;bc&#39;)]</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">    &gt;&gt;&gt; oset = set(&#39;ac&#39;)</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">    &gt;&gt;&gt; _find_contraction(pos, isets, oset)</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">    ({&#39;a&#39;, &#39;c&#39;}, [{&#39;a&#39;, &#39;c&#39;}], {&#39;b&#39;}, {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;})</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  120</span><span class="stringliteral">    # A more complex case with additional terms in the contraction</span></div>
<div class="line"><span class="lineno">  121</span><span class="stringliteral">    &gt;&gt;&gt; pos = (0, 2)</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    &gt;&gt;&gt; isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral">    &gt;&gt;&gt; oset = set(&#39;ac&#39;)</span></div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    &gt;&gt;&gt; _find_contraction(pos, isets, oset)</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    ({&#39;a&#39;, &#39;c&#39;}, [{&#39;a&#39;, &#39;c&#39;}, {&#39;a&#39;, &#39;c&#39;}], {&#39;b&#39;, &#39;d&#39;}, {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;})</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>    idx_contract = set()</div>
<div class="line"><span class="lineno">  129</span>    idx_remain = output_set.copy()</div>
<div class="line"><span class="lineno">  130</span>    remaining = []</div>
<div class="line"><span class="lineno">  131</span>    <span class="keywordflow">for</span> ind, value <span class="keywordflow">in</span> enumerate(input_sets):</div>
<div class="line"><span class="lineno">  132</span>        <span class="keywordflow">if</span> ind <span class="keywordflow">in</span> positions:</div>
<div class="line"><span class="lineno">  133</span>            idx_contract |= value</div>
<div class="line"><span class="lineno">  134</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  135</span>            remaining.append(value)</div>
<div class="line"><span class="lineno">  136</span>            idx_remain |= value</div>
<div class="line"><span class="lineno">  137</span> </div>
<div class="line"><span class="lineno">  138</span>    new_result = idx_remain &amp; idx_contract</div>
<div class="line"><span class="lineno">  139</span>    idx_removed = (idx_contract - new_result)</div>
<div class="line"><span class="lineno">  140</span>    remaining.append(new_result)</div>
<div class="line"><span class="lineno">  141</span> </div>
<div class="line"><span class="lineno">  142</span>    <span class="keywordflow">return</span> (new_result, remaining, idx_removed, idx_contract)</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0534658b323271137dcf34b25aa9fd9" name="ae0534658b323271137dcf34b25aa9fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0534658b323271137dcf34b25aa9fd9">&#9670;&#160;</a></span>_flop_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._flop_count </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_contraction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num_terms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>size_dictionary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes the number of FLOPS in the contraction.

Parameters
----------
idx_contraction : iterable
    The indices involved in the contraction
inner : bool
    Does this contraction require an inner product?
num_terms : int
    The number of terms in a contraction
size_dictionary : dict
    The size of each of the indices in idx_contraction

Returns
-------
flop_count : int
    The total number of FLOPS required for the contraction.

Examples
--------

&gt;&gt;&gt; _flop_count('abc', False, 1, {'a': 2, 'b':3, 'c':5})
30

&gt;&gt;&gt; _flop_count('abc', True, 2, {'a': 2, 'b':3, 'c':5})
60</pre> <div class="fragment"><div class="line"><span class="lineno">   18</span><span class="keyword">def </span>_flop_count(idx_contraction, inner, num_terms, size_dictionary):</div>
<div class="line"><span class="lineno">   19</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   20</span><span class="stringliteral">    Computes the number of FLOPS in the contraction.</span></div>
<div class="line"><span class="lineno">   21</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   22</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   23</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   24</span><span class="stringliteral">    idx_contraction : iterable</span></div>
<div class="line"><span class="lineno">   25</span><span class="stringliteral">        The indices involved in the contraction</span></div>
<div class="line"><span class="lineno">   26</span><span class="stringliteral">    inner : bool</span></div>
<div class="line"><span class="lineno">   27</span><span class="stringliteral">        Does this contraction require an inner product?</span></div>
<div class="line"><span class="lineno">   28</span><span class="stringliteral">    num_terms : int</span></div>
<div class="line"><span class="lineno">   29</span><span class="stringliteral">        The number of terms in a contraction</span></div>
<div class="line"><span class="lineno">   30</span><span class="stringliteral">    size_dictionary : dict</span></div>
<div class="line"><span class="lineno">   31</span><span class="stringliteral">        The size of each of the indices in idx_contraction</span></div>
<div class="line"><span class="lineno">   32</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   33</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral">    flop_count : int</span></div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">        The total number of FLOPS required for the contraction.</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral">    &gt;&gt;&gt; _flop_count(&#39;abc&#39;, False, 1, {&#39;a&#39;: 2, &#39;b&#39;:3, &#39;c&#39;:5})</span></div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral">    &gt;&gt;&gt; _flop_count(&#39;abc&#39;, True, 2, {&#39;a&#39;: 2, &#39;b&#39;:3, &#39;c&#39;:5})</span></div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    60</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   48</span> </div>
<div class="line"><span class="lineno">   49</span>    overall_size = _compute_size_by_dict(idx_contraction, size_dictionary)</div>
<div class="line"><span class="lineno">   50</span>    op_factor = max(1, num_terms - 1)</div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">if</span> inner:</div>
<div class="line"><span class="lineno">   52</span>        op_factor += 1</div>
<div class="line"><span class="lineno">   53</span> </div>
<div class="line"><span class="lineno">   54</span>    <span class="keywordflow">return</span> overall_size * op_factor</div>
<div class="line"><span class="lineno">   55</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1b1140adb40e3e09e6a4b291e3c9ddd8" name="a1b1140adb40e3e09e6a4b291e3c9ddd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1140adb40e3e09e6a4b291e3c9ddd8">&#9670;&#160;</a></span>_greedy_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._greedy_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memory_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Finds the path by contracting the best pair until the input list is
exhausted. The best pair is found by minimizing the tuple
``(-prod(indices_removed), cost)``.  What this amounts to is prioritizing
matrix multiplication or inner product operations, then Hadamard like
operations, and finally outer operations. Outer products are limited by
``memory_limit``. This algorithm scales cubically with respect to the
number of elements in the list ``input_sets``.

Parameters
----------
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript
idx_dict : dictionary
    Dictionary of index sizes
memory_limit : int
    The maximum number of elements in a temporary array

Returns
-------
path : list
    The greedy contraction order within the memory limit constraint.

Examples
--------
&gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')]
&gt;&gt;&gt; oset = set()
&gt;&gt;&gt; idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4}
&gt;&gt;&gt; _greedy_path(isets, oset, idx_sizes, 5000)
[(0, 2), (0, 1)]
</pre> <div class="fragment"><div class="line"><span class="lineno">  312</span><span class="keyword">def </span>_greedy_path(input_sets, output_set, idx_dict, memory_limit):</div>
<div class="line"><span class="lineno">  313</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">    Finds the path by contracting the best pair until the input list is</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">    exhausted. The best pair is found by minimizing the tuple</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">    ``(-prod(indices_removed), cost)``.  What this amounts to is prioritizing</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">    matrix multiplication or inner product operations, then Hadamard like</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">    operations, and finally outer operations. Outer products are limited by</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">    ``memory_limit``. This algorithm scales cubically with respect to the</span></div>
<div class="line"><span class="lineno">  320</span><span class="stringliteral">    number of elements in the list ``input_sets``.</span></div>
<div class="line"><span class="lineno">  321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  322</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  323</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  324</span><span class="stringliteral">    input_sets : list</span></div>
<div class="line"><span class="lineno">  325</span><span class="stringliteral">        List of sets that represent the lhs side of the einsum subscript</span></div>
<div class="line"><span class="lineno">  326</span><span class="stringliteral">    output_set : set</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        Set that represents the rhs side of the overall einsum subscript</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">    idx_dict : dictionary</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral">        Dictionary of index sizes</span></div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">    memory_limit : int</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        The maximum number of elements in a temporary array</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral">    path : list</span></div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        The greedy contraction order within the memory limit constraint.</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  339</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  340</span><span class="stringliteral">    &gt;&gt;&gt; isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span></div>
<div class="line"><span class="lineno">  341</span><span class="stringliteral">    &gt;&gt;&gt; oset = set()</span></div>
<div class="line"><span class="lineno">  342</span><span class="stringliteral">    &gt;&gt;&gt; idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span></div>
<div class="line"><span class="lineno">  343</span><span class="stringliteral">    &gt;&gt;&gt; _greedy_path(isets, oset, idx_sizes, 5000)</span></div>
<div class="line"><span class="lineno">  344</span><span class="stringliteral">    [(0, 2), (0, 1)]</span></div>
<div class="line"><span class="lineno">  345</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  346</span> </div>
<div class="line"><span class="lineno">  347</span>    <span class="comment"># Handle trivial cases that leaked through</span></div>
<div class="line"><span class="lineno">  348</span>    <span class="keywordflow">if</span> len(input_sets) == 1:</div>
<div class="line"><span class="lineno">  349</span>        <span class="keywordflow">return</span> [(0,)]</div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">elif</span> len(input_sets) == 2:</div>
<div class="line"><span class="lineno">  351</span>        <span class="keywordflow">return</span> [(0, 1)]</div>
<div class="line"><span class="lineno">  352</span> </div>
<div class="line"><span class="lineno">  353</span>    <span class="comment"># Build up a naive cost</span></div>
<div class="line"><span class="lineno">  354</span>    contract = _find_contraction(range(len(input_sets)), input_sets, output_set)</div>
<div class="line"><span class="lineno">  355</span>    idx_result, new_input_sets, idx_removed, idx_contract = contract</div>
<div class="line"><span class="lineno">  356</span>    naive_cost = _flop_count(idx_contract, idx_removed, len(input_sets), idx_dict)</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>    <span class="comment"># Initially iterate over all pairs</span></div>
<div class="line"><span class="lineno">  359</span>    comb_iter = itertools.combinations(range(len(input_sets)), 2)</div>
<div class="line"><span class="lineno">  360</span>    known_contractions = []</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>    path_cost = 0</div>
<div class="line"><span class="lineno">  363</span>    path = []</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>    <span class="keywordflow">for</span> iteration <span class="keywordflow">in</span> range(len(input_sets) - 1):</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>        <span class="comment"># Iterate over all pairs on first step, only previously found pairs on subsequent steps</span></div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">for</span> positions <span class="keywordflow">in</span> comb_iter:</div>
<div class="line"><span class="lineno">  369</span> </div>
<div class="line"><span class="lineno">  370</span>            <span class="comment"># Always initially ignore outer products</span></div>
<div class="line"><span class="lineno">  371</span>            <span class="keywordflow">if</span> input_sets[positions[0]].isdisjoint(input_sets[positions[1]]):</div>
<div class="line"><span class="lineno">  372</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>            result = _parse_possible_contraction(positions, input_sets, output_set, idx_dict, memory_limit, path_cost,</div>
<div class="line"><span class="lineno">  375</span>                                                 naive_cost)</div>
<div class="line"><span class="lineno">  376</span>            <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  377</span>                known_contractions.append(result)</div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>        <span class="comment"># If we do not have a inner contraction, rescan pairs including outer products</span></div>
<div class="line"><span class="lineno">  380</span>        <span class="keywordflow">if</span> len(known_contractions) == 0:</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span>            <span class="comment"># Then check the outer products</span></div>
<div class="line"><span class="lineno">  383</span>            <span class="keywordflow">for</span> positions <span class="keywordflow">in</span> itertools.combinations(range(len(input_sets)), 2):</div>
<div class="line"><span class="lineno">  384</span>                result = _parse_possible_contraction(positions, input_sets, output_set, idx_dict, memory_limit,</div>
<div class="line"><span class="lineno">  385</span>                                                     path_cost, naive_cost)</div>
<div class="line"><span class="lineno">  386</span>                <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  387</span>                    known_contractions.append(result)</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>            <span class="comment"># If we still did not find any remaining contractions, default back to einsum like behavior</span></div>
<div class="line"><span class="lineno">  390</span>            <span class="keywordflow">if</span> len(known_contractions) == 0:</div>
<div class="line"><span class="lineno">  391</span>                path.append(tuple(range(len(input_sets))))</div>
<div class="line"><span class="lineno">  392</span>                <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>        <span class="comment"># Sort based on first index</span></div>
<div class="line"><span class="lineno">  395</span>        best = min(known_contractions, key=<span class="keyword">lambda</span> x: x[0])</div>
<div class="line"><span class="lineno">  396</span> </div>
<div class="line"><span class="lineno">  397</span>        <span class="comment"># Now propagate as many unused contractions as possible to next iteration</span></div>
<div class="line"><span class="lineno">  398</span>        known_contractions = _update_other_results(known_contractions, best)</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>        <span class="comment"># Next iteration only compute contractions with the new tensor</span></div>
<div class="line"><span class="lineno">  401</span>        <span class="comment"># All other contractions have been accounted for</span></div>
<div class="line"><span class="lineno">  402</span>        input_sets = best[2]</div>
<div class="line"><span class="lineno">  403</span>        new_tensor_pos = len(input_sets) - 1</div>
<div class="line"><span class="lineno">  404</span>        comb_iter = ((i, new_tensor_pos) <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(new_tensor_pos))</div>
<div class="line"><span class="lineno">  405</span> </div>
<div class="line"><span class="lineno">  406</span>        <span class="comment"># Update path and total cost</span></div>
<div class="line"><span class="lineno">  407</span>        path.append(best[1])</div>
<div class="line"><span class="lineno">  408</span>        path_cost += best[0][1]</div>
<div class="line"><span class="lineno">  409</span> </div>
<div class="line"><span class="lineno">  410</span>    <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9dff852d6519fc0dcb632d7bb51818ca" name="a9dff852d6519fc0dcb632d7bb51818ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dff852d6519fc0dcb632d7bb51818ca">&#9670;&#160;</a></span>_optimal_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._optimal_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memory_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Computes all possible pair contractions, sieves the results based
on ``memory_limit`` and returns the lowest cost path. This algorithm
scales factorial with respect to the elements in the list ``input_sets``.

Parameters
----------
input_sets : list
    List of sets that represent the lhs side of the einsum subscript
output_set : set
    Set that represents the rhs side of the overall einsum subscript
idx_dict : dictionary
    Dictionary of index sizes
memory_limit : int
    The maximum number of elements in a temporary array

Returns
-------
path : list
    The optimal contraction order within the memory limit constraint.

Examples
--------
&gt;&gt;&gt; isets = [set('abd'), set('ac'), set('bdc')]
&gt;&gt;&gt; oset = set()
&gt;&gt;&gt; idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4}
&gt;&gt;&gt; _optimal_path(isets, oset, idx_sizes, 5000)
[(0, 2), (0, 1)]
</pre> <div class="fragment"><div class="line"><span class="lineno">  145</span><span class="keyword">def </span>_optimal_path(input_sets, output_set, idx_dict, memory_limit):</div>
<div class="line"><span class="lineno">  146</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  147</span><span class="stringliteral">    Computes all possible pair contractions, sieves the results based</span></div>
<div class="line"><span class="lineno">  148</span><span class="stringliteral">    on ``memory_limit`` and returns the lowest cost path. This algorithm</span></div>
<div class="line"><span class="lineno">  149</span><span class="stringliteral">    scales factorial with respect to the elements in the list ``input_sets``.</span></div>
<div class="line"><span class="lineno">  150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  151</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  152</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  153</span><span class="stringliteral">    input_sets : list</span></div>
<div class="line"><span class="lineno">  154</span><span class="stringliteral">        List of sets that represent the lhs side of the einsum subscript</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral">    output_set : set</span></div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">        Set that represents the rhs side of the overall einsum subscript</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    idx_dict : dictionary</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">        Dictionary of index sizes</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    memory_limit : int</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">        The maximum number of elements in a temporary array</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    path : list</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">        The optimal contraction order within the memory limit constraint.</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral">    &gt;&gt;&gt; isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span></div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    &gt;&gt;&gt; oset = set()</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral">    &gt;&gt;&gt; idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span></div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    &gt;&gt;&gt; _optimal_path(isets, oset, idx_sizes, 5000)</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral">    [(0, 2), (0, 1)]</span></div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>    full_results = [(0, [], input_sets)]</div>
<div class="line"><span class="lineno">  177</span>    <span class="keywordflow">for</span> iteration <span class="keywordflow">in</span> range(len(input_sets) - 1):</div>
<div class="line"><span class="lineno">  178</span>        iter_results = []</div>
<div class="line"><span class="lineno">  179</span> </div>
<div class="line"><span class="lineno">  180</span>        <span class="comment"># Compute all unique pairs</span></div>
<div class="line"><span class="lineno">  181</span>        <span class="keywordflow">for</span> curr <span class="keywordflow">in</span> full_results:</div>
<div class="line"><span class="lineno">  182</span>            cost, positions, remaining = curr</div>
<div class="line"><span class="lineno">  183</span>            <span class="keywordflow">for</span> con <span class="keywordflow">in</span> itertools.combinations(range(len(input_sets) - iteration), 2):</div>
<div class="line"><span class="lineno">  184</span> </div>
<div class="line"><span class="lineno">  185</span>                <span class="comment"># Find the contraction</span></div>
<div class="line"><span class="lineno">  186</span>                cont = _find_contraction(con, remaining, output_set)</div>
<div class="line"><span class="lineno">  187</span>                new_result, new_input_sets, idx_removed, idx_contract = cont</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>                <span class="comment"># Sieve the results based on memory_limit</span></div>
<div class="line"><span class="lineno">  190</span>                new_size = _compute_size_by_dict(new_result, idx_dict)</div>
<div class="line"><span class="lineno">  191</span>                <span class="keywordflow">if</span> new_size &gt; memory_limit:</div>
<div class="line"><span class="lineno">  192</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>                <span class="comment"># Build (total_cost, positions, indices_remaining)</span></div>
<div class="line"><span class="lineno">  195</span>                total_cost =  cost + _flop_count(idx_contract, idx_removed, len(con), idx_dict)</div>
<div class="line"><span class="lineno">  196</span>                new_pos = positions + [con]</div>
<div class="line"><span class="lineno">  197</span>                iter_results.append((total_cost, new_pos, new_input_sets))</div>
<div class="line"><span class="lineno">  198</span> </div>
<div class="line"><span class="lineno">  199</span>        <span class="comment"># Update combinatorial list, if we did not find anything return best</span></div>
<div class="line"><span class="lineno">  200</span>        <span class="comment"># path + remaining contractions</span></div>
<div class="line"><span class="lineno">  201</span>        <span class="keywordflow">if</span> iter_results:</div>
<div class="line"><span class="lineno">  202</span>            full_results = iter_results</div>
<div class="line"><span class="lineno">  203</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  204</span>            path = min(full_results, key=<span class="keyword">lambda</span> x: x[0])[1]</div>
<div class="line"><span class="lineno">  205</span>            path += [tuple(range(len(input_sets) - iteration))]</div>
<div class="line"><span class="lineno">  206</span>            <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  207</span> </div>
<div class="line"><span class="lineno">  208</span>    <span class="comment"># If we have not found anything return single einsum contraction</span></div>
<div class="line"><span class="lineno">  209</span>    <span class="keywordflow">if</span> len(full_results) == 0:</div>
<div class="line"><span class="lineno">  210</span>        <span class="keywordflow">return</span> [tuple(range(len(input_sets)))]</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>    path = min(full_results, key=<span class="keyword">lambda</span> x: x[0])[1]</div>
<div class="line"><span class="lineno">  213</span>    <span class="keywordflow">return</span> path</div>
<div class="line"><span class="lineno">  214</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad3a2d270997c04b34faf92b0b9d1291e" name="ad3a2d270997c04b34faf92b0b9d1291e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a2d270997c04b34faf92b0b9d1291e">&#9670;&#160;</a></span>_parse_einsum_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._parse_einsum_input </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>operands</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">A reproduction of einsum c side einsum parsing in python.

Returns
-------
input_strings : str
    Parsed input strings
output_string : str
    Parsed output string
operands : list of array_like
    The operands to use in the numpy contraction

Examples
--------
The operand list is simplified to reduce printing:

&gt;&gt;&gt; np.random.seed(123)
&gt;&gt;&gt; a = np.random.rand(4, 4)
&gt;&gt;&gt; b = np.random.rand(4, 4, 4)
&gt;&gt;&gt; _parse_einsum_input(('...a,...a-&gt;...', a, b))
('za,xza', 'xz', [a, b]) # may vary

&gt;&gt;&gt; _parse_einsum_input((a, [Ellipsis, 0], b, [Ellipsis, 0]))
('za,xza', 'xz', [a, b]) # may vary
</pre> <div class="fragment"><div class="line"><span class="lineno">  523</span><span class="keyword">def </span>_parse_einsum_input(operands):</div>
<div class="line"><span class="lineno">  524</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">    A reproduction of einsum c side einsum parsing in python.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">    input_strings : str</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral">        Parsed input strings</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    output_string : str</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        Parsed output string</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">    operands : list of array_like</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral">        The operands to use in the numpy contraction</span></div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral">    The operand list is simplified to reduce printing:</span></div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral">    &gt;&gt;&gt; np.random.seed(123)</span></div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.rand(4, 4)</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.rand(4, 4, 4)</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">    &gt;&gt;&gt; _parse_einsum_input((&#39;...a,...a-&gt;...&#39;, a, b))</span></div>
<div class="line"><span class="lineno">  544</span><span class="stringliteral">    (&#39;za,xza&#39;, &#39;xz&#39;, [a, b]) # may vary</span></div>
<div class="line"><span class="lineno">  545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  546</span><span class="stringliteral">    &gt;&gt;&gt; _parse_einsum_input((a, [Ellipsis, 0], b, [Ellipsis, 0]))</span></div>
<div class="line"><span class="lineno">  547</span><span class="stringliteral">    (&#39;za,xza&#39;, &#39;xz&#39;, [a, b]) # may vary</span></div>
<div class="line"><span class="lineno">  548</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span> </div>
<div class="line"><span class="lineno">  550</span>    <span class="keywordflow">if</span> len(operands) == 0:</div>
<div class="line"><span class="lineno">  551</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;No input operands&quot;</span>)</div>
<div class="line"><span class="lineno">  552</span> </div>
<div class="line"><span class="lineno">  553</span>    <span class="keywordflow">if</span> isinstance(operands[0], str):</div>
<div class="line"><span class="lineno">  554</span>        subscripts = operands[0].replace(<span class="stringliteral">&quot; &quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  555</span>        operands = [asanyarray(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> operands[1:]]</div>
<div class="line"><span class="lineno">  556</span> </div>
<div class="line"><span class="lineno">  557</span>        <span class="comment"># Ensure all characters are valid</span></div>
<div class="line"><span class="lineno">  558</span>        <span class="keywordflow">for</span> s <span class="keywordflow">in</span> subscripts:</div>
<div class="line"><span class="lineno">  559</span>            <span class="keywordflow">if</span> s <span class="keywordflow">in</span> <span class="stringliteral">&#39;.,-&gt;&#39;</span>:</div>
<div class="line"><span class="lineno">  560</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  561</span>            <span class="keywordflow">if</span> s <span class="keywordflow">not</span> <span class="keywordflow">in</span> einsum_symbols:</div>
<div class="line"><span class="lineno">  562</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Character %s is not a valid symbol.&quot;</span> % s)</div>
<div class="line"><span class="lineno">  563</span> </div>
<div class="line"><span class="lineno">  564</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  565</span>        tmp_operands = list(operands)</div>
<div class="line"><span class="lineno">  566</span>        operand_list = []</div>
<div class="line"><span class="lineno">  567</span>        subscript_list = []</div>
<div class="line"><span class="lineno">  568</span>        <span class="keywordflow">for</span> p <span class="keywordflow">in</span> range(len(operands) // 2):</div>
<div class="line"><span class="lineno">  569</span>            operand_list.append(tmp_operands.pop(0))</div>
<div class="line"><span class="lineno">  570</span>            subscript_list.append(tmp_operands.pop(0))</div>
<div class="line"><span class="lineno">  571</span> </div>
<div class="line"><span class="lineno">  572</span>        output_list = tmp_operands[-1] <span class="keywordflow">if</span> len(tmp_operands) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  573</span>        operands = [asanyarray(v) <span class="keywordflow">for</span> v <span class="keywordflow">in</span> operand_list]</div>
<div class="line"><span class="lineno">  574</span>        subscripts = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  575</span>        last = len(subscript_list) - 1</div>
<div class="line"><span class="lineno">  576</span>        <span class="keywordflow">for</span> num, sub <span class="keywordflow">in</span> enumerate(subscript_list):</div>
<div class="line"><span class="lineno">  577</span>            <span class="keywordflow">for</span> s <span class="keywordflow">in</span> sub:</div>
<div class="line"><span class="lineno">  578</span>                <span class="keywordflow">if</span> s <span class="keywordflow">is</span> Ellipsis:</div>
<div class="line"><span class="lineno">  579</span>                    subscripts += <span class="stringliteral">&quot;...&quot;</span></div>
<div class="line"><span class="lineno">  580</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  581</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  582</span>                        s = operator.index(s)</div>
<div class="line"><span class="lineno">  583</span>                    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  584</span>                        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;For this input type lists must contain &quot;</span></div>
<div class="line"><span class="lineno">  585</span>                                        <span class="stringliteral">&quot;either int or Ellipsis&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  586</span>                    subscripts += einsum_symbols[s]</div>
<div class="line"><span class="lineno">  587</span>            <span class="keywordflow">if</span> num != last:</div>
<div class="line"><span class="lineno">  588</span>                subscripts += <span class="stringliteral">&quot;,&quot;</span></div>
<div class="line"><span class="lineno">  589</span> </div>
<div class="line"><span class="lineno">  590</span>        <span class="keywordflow">if</span> output_list <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  591</span>            subscripts += <span class="stringliteral">&quot;-&gt;&quot;</span></div>
<div class="line"><span class="lineno">  592</span>            <span class="keywordflow">for</span> s <span class="keywordflow">in</span> output_list:</div>
<div class="line"><span class="lineno">  593</span>                <span class="keywordflow">if</span> s <span class="keywordflow">is</span> Ellipsis:</div>
<div class="line"><span class="lineno">  594</span>                    subscripts += <span class="stringliteral">&quot;...&quot;</span></div>
<div class="line"><span class="lineno">  595</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  596</span>                    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  597</span>                        s = operator.index(s)</div>
<div class="line"><span class="lineno">  598</span>                    <span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  599</span>                        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;For this input type lists must contain &quot;</span></div>
<div class="line"><span class="lineno">  600</span>                                        <span class="stringliteral">&quot;either int or Ellipsis&quot;</span>) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  601</span>                    subscripts += einsum_symbols[s]</div>
<div class="line"><span class="lineno">  602</span>    <span class="comment"># Check for proper &quot;-&gt;&quot;</span></div>
<div class="line"><span class="lineno">  603</span>    <span class="keywordflow">if</span> (<span class="stringliteral">&quot;-&quot;</span> <span class="keywordflow">in</span> subscripts) <span class="keywordflow">or</span> (<span class="stringliteral">&quot;&gt;&quot;</span> <span class="keywordflow">in</span> subscripts):</div>
<div class="line"><span class="lineno">  604</span>        invalid = (subscripts.count(<span class="stringliteral">&quot;-&quot;</span>) &gt; 1) <span class="keywordflow">or</span> (subscripts.count(<span class="stringliteral">&quot;&gt;&quot;</span>) &gt; 1)</div>
<div class="line"><span class="lineno">  605</span>        <span class="keywordflow">if</span> invalid <span class="keywordflow">or</span> (subscripts.count(<span class="stringliteral">&quot;-&gt;&quot;</span>) != 1):</div>
<div class="line"><span class="lineno">  606</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Subscripts can only contain one &#39;-&gt;&#39;.&quot;</span>)</div>
<div class="line"><span class="lineno">  607</span> </div>
<div class="line"><span class="lineno">  608</span>    <span class="comment"># Parse ellipses</span></div>
<div class="line"><span class="lineno">  609</span>    <span class="keywordflow">if</span> <span class="stringliteral">&quot;.&quot;</span> <span class="keywordflow">in</span> subscripts:</div>
<div class="line"><span class="lineno">  610</span>        used = subscripts.replace(<span class="stringliteral">&quot;.&quot;</span>, <span class="stringliteral">&quot;&quot;</span>).replace(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;&quot;</span>).replace(<span class="stringliteral">&quot;-&gt;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  611</span>        unused = list(einsum_symbols_set - set(used))</div>
<div class="line"><span class="lineno">  612</span>        ellipse_inds = <span class="stringliteral">&quot;&quot;</span>.join(unused)</div>
<div class="line"><span class="lineno">  613</span>        longest = 0</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;-&gt;&quot;</span> <span class="keywordflow">in</span> subscripts:</div>
<div class="line"><span class="lineno">  616</span>            input_tmp, output_sub = subscripts.split(<span class="stringliteral">&quot;-&gt;&quot;</span>)</div>
<div class="line"><span class="lineno">  617</span>            split_subscripts = input_tmp.split(<span class="stringliteral">&quot;,&quot;</span>)</div>
<div class="line"><span class="lineno">  618</span>            out_sub = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  619</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  620</span>            split_subscripts = subscripts.split(<span class="stringliteral">&#39;,&#39;</span>)</div>
<div class="line"><span class="lineno">  621</span>            out_sub = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>        <span class="keywordflow">for</span> num, sub <span class="keywordflow">in</span> enumerate(split_subscripts):</div>
<div class="line"><span class="lineno">  624</span>            <span class="keywordflow">if</span> <span class="stringliteral">&quot;.&quot;</span> <span class="keywordflow">in</span> sub:</div>
<div class="line"><span class="lineno">  625</span>                <span class="keywordflow">if</span> (sub.count(<span class="stringliteral">&quot;.&quot;</span>) != 3) <span class="keywordflow">or</span> (sub.count(<span class="stringliteral">&quot;...&quot;</span>) != 1):</div>
<div class="line"><span class="lineno">  626</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid Ellipses.&quot;</span>)</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>                <span class="comment"># Take into account numerical values</span></div>
<div class="line"><span class="lineno">  629</span>                <span class="keywordflow">if</span> operands[num].shape == ():</div>
<div class="line"><span class="lineno">  630</span>                    ellipse_count = 0</div>
<div class="line"><span class="lineno">  631</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  632</span>                    ellipse_count = max(operands[num].ndim, 1)</div>
<div class="line"><span class="lineno">  633</span>                    ellipse_count -= (len(sub) - 3)</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>                <span class="keywordflow">if</span> ellipse_count &gt; longest:</div>
<div class="line"><span class="lineno">  636</span>                    longest = ellipse_count</div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span>                <span class="keywordflow">if</span> ellipse_count &lt; 0:</div>
<div class="line"><span class="lineno">  639</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Ellipses lengths do not match.&quot;</span>)</div>
<div class="line"><span class="lineno">  640</span>                <span class="keywordflow">elif</span> ellipse_count == 0:</div>
<div class="line"><span class="lineno">  641</span>                    split_subscripts[num] = sub.replace(<span class="stringliteral">&#39;...&#39;</span>, <span class="stringliteral">&#39;&#39;</span>)</div>
<div class="line"><span class="lineno">  642</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  643</span>                    rep_inds = ellipse_inds[-ellipse_count:]</div>
<div class="line"><span class="lineno">  644</span>                    split_subscripts[num] = sub.replace(<span class="stringliteral">&#39;...&#39;</span>, rep_inds)</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>        subscripts = <span class="stringliteral">&quot;,&quot;</span>.join(split_subscripts)</div>
<div class="line"><span class="lineno">  647</span>        <span class="keywordflow">if</span> longest == 0:</div>
<div class="line"><span class="lineno">  648</span>            out_ellipse = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  650</span>            out_ellipse = ellipse_inds[-longest:]</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">if</span> out_sub:</div>
<div class="line"><span class="lineno">  653</span>            subscripts += <span class="stringliteral">&quot;-&gt;&quot;</span> + output_sub.replace(<span class="stringliteral">&quot;...&quot;</span>, out_ellipse)</div>
<div class="line"><span class="lineno">  654</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  655</span>            <span class="comment"># Special care for outputless ellipses</span></div>
<div class="line"><span class="lineno">  656</span>            output_subscript = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  657</span>            tmp_subscripts = subscripts.replace(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  658</span>            <span class="keywordflow">for</span> s <span class="keywordflow">in</span> sorted(set(tmp_subscripts)):</div>
<div class="line"><span class="lineno">  659</span>                <span class="keywordflow">if</span> s <span class="keywordflow">not</span> <span class="keywordflow">in</span> (einsum_symbols):</div>
<div class="line"><span class="lineno">  660</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Character %s is not a valid symbol.&quot;</span> % s)</div>
<div class="line"><span class="lineno">  661</span>                <span class="keywordflow">if</span> tmp_subscripts.count(s) == 1:</div>
<div class="line"><span class="lineno">  662</span>                    output_subscript += s</div>
<div class="line"><span class="lineno">  663</span>            normal_inds = <span class="stringliteral">&#39;&#39;</span>.join(sorted(set(output_subscript) -</div>
<div class="line"><span class="lineno">  664</span>                                         set(out_ellipse)))</div>
<div class="line"><span class="lineno">  665</span> </div>
<div class="line"><span class="lineno">  666</span>            subscripts += <span class="stringliteral">&quot;-&gt;&quot;</span> + out_ellipse + normal_inds</div>
<div class="line"><span class="lineno">  667</span> </div>
<div class="line"><span class="lineno">  668</span>    <span class="comment"># Build output string if does not exist</span></div>
<div class="line"><span class="lineno">  669</span>    <span class="keywordflow">if</span> <span class="stringliteral">&quot;-&gt;&quot;</span> <span class="keywordflow">in</span> subscripts:</div>
<div class="line"><span class="lineno">  670</span>        input_subscripts, output_subscript = subscripts.split(<span class="stringliteral">&quot;-&gt;&quot;</span>)</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  672</span>        input_subscripts = subscripts</div>
<div class="line"><span class="lineno">  673</span>        <span class="comment"># Build output subscripts</span></div>
<div class="line"><span class="lineno">  674</span>        tmp_subscripts = subscripts.replace(<span class="stringliteral">&quot;,&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno">  675</span>        output_subscript = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno">  676</span>        <span class="keywordflow">for</span> s <span class="keywordflow">in</span> sorted(set(tmp_subscripts)):</div>
<div class="line"><span class="lineno">  677</span>            <span class="keywordflow">if</span> s <span class="keywordflow">not</span> <span class="keywordflow">in</span> einsum_symbols:</div>
<div class="line"><span class="lineno">  678</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Character %s is not a valid symbol.&quot;</span> % s)</div>
<div class="line"><span class="lineno">  679</span>            <span class="keywordflow">if</span> tmp_subscripts.count(s) == 1:</div>
<div class="line"><span class="lineno">  680</span>                output_subscript += s</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span>    <span class="comment"># Make sure output subscripts are in the input</span></div>
<div class="line"><span class="lineno">  683</span>    <span class="keywordflow">for</span> char <span class="keywordflow">in</span> output_subscript:</div>
<div class="line"><span class="lineno">  684</span>        <span class="keywordflow">if</span> char <span class="keywordflow">not</span> <span class="keywordflow">in</span> input_subscripts:</div>
<div class="line"><span class="lineno">  685</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Output character %s did not appear in the input&quot;</span></div>
<div class="line"><span class="lineno">  686</span>                             % char)</div>
<div class="line"><span class="lineno">  687</span> </div>
<div class="line"><span class="lineno">  688</span>    <span class="comment"># Make sure number operands is equivalent to the number of terms</span></div>
<div class="line"><span class="lineno">  689</span>    <span class="keywordflow">if</span> len(input_subscripts.split(<span class="stringliteral">&#39;,&#39;</span>)) != len(operands):</div>
<div class="line"><span class="lineno">  690</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Number of einsum subscripts must be equal to the &quot;</span></div>
<div class="line"><span class="lineno">  691</span>                         <span class="stringliteral">&quot;number of operands.&quot;</span>)</div>
<div class="line"><span class="lineno">  692</span> </div>
<div class="line"><span class="lineno">  693</span>    <span class="keywordflow">return</span> (input_subscripts, output_subscript, operands)</div>
<div class="line"><span class="lineno">  694</span> </div>
<div class="line"><span class="lineno">  695</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a335083a29f87822424e8ac7e3bfb5060" name="a335083a29f87822424e8ac7e3bfb5060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335083a29f87822424e8ac7e3bfb5060">&#9670;&#160;</a></span>_parse_possible_contraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._parse_possible_contraction </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>input_sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>output_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>idx_dict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memory_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>naive_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute the cost (removed size + flops) and resultant indices for
performing the contraction specified by ``positions``.

Parameters
----------
positions : tuple of int
    The locations of the proposed tensors to contract.
input_sets : list of sets
    The indices found on each tensors.
output_set : set
    The output indices of the expression.
idx_dict : dict
    Mapping of each index to its size.
memory_limit : int
    The total allowed size for an intermediary tensor.
path_cost : int
    The contraction cost so far.
naive_cost : int
    The cost of the unoptimized expression.

Returns
-------
cost : (int, int)
    A tuple containing the size of any indices removed, and the flop cost.
positions : tuple of int
    The locations of the proposed tensors to contract.
new_input_sets : list of sets
    The resulting new list of indices if this proposed contraction is performed.</pre> <div class="fragment"><div class="line"><span class="lineno">  215</span><span class="keyword">def </span>_parse_possible_contraction(positions, input_sets, output_set, idx_dict, memory_limit, path_cost, naive_cost):</div>
<div class="line"><span class="lineno">  216</span>    <span class="stringliteral">&quot;&quot;&quot;Compute the cost (removed size + flops) and resultant indices for</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">    performing the contraction specified by ``positions``.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral">    positions : tuple of int</span></div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">        The locations of the proposed tensors to contract.</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">    input_sets : list of sets</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        The indices found on each tensors.</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">    output_set : set</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        The output indices of the expression.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral">    idx_dict : dict</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">        Mapping of each index to its size.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    memory_limit : int</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        The total allowed size for an intermediary tensor.</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">    path_cost : int</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        The contraction cost so far.</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    naive_cost : int</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">        The cost of the unoptimized expression.</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">    cost : (int, int)</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        A tuple containing the size of any indices removed, and the flop cost.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    positions : tuple of int</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        The locations of the proposed tensors to contract.</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">    new_input_sets : list of sets</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        The resulting new list of indices if this proposed contraction is performed.</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  246</span> </div>
<div class="line"><span class="lineno">  247</span>    <span class="comment"># Find the contraction</span></div>
<div class="line"><span class="lineno">  248</span>    contract = _find_contraction(positions, input_sets, output_set)</div>
<div class="line"><span class="lineno">  249</span>    idx_result, new_input_sets, idx_removed, idx_contract = contract</div>
<div class="line"><span class="lineno">  250</span> </div>
<div class="line"><span class="lineno">  251</span>    <span class="comment"># Sieve the results based on memory_limit</span></div>
<div class="line"><span class="lineno">  252</span>    new_size = _compute_size_by_dict(idx_result, idx_dict)</div>
<div class="line"><span class="lineno">  253</span>    <span class="keywordflow">if</span> new_size &gt; memory_limit:</div>
<div class="line"><span class="lineno">  254</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  255</span> </div>
<div class="line"><span class="lineno">  256</span>    <span class="comment"># Build sort tuple</span></div>
<div class="line"><span class="lineno">  257</span>    old_sizes = (_compute_size_by_dict(input_sets[p], idx_dict) <span class="keywordflow">for</span> p <span class="keywordflow">in</span> positions)</div>
<div class="line"><span class="lineno">  258</span>    removed_size = sum(old_sizes) - new_size</div>
<div class="line"><span class="lineno">  259</span> </div>
<div class="line"><span class="lineno">  260</span>    <span class="comment"># NB: removed_size used to be just the size of any removed indices i.e.:</span></div>
<div class="line"><span class="lineno">  261</span>    <span class="comment">#     helpers.compute_size_by_dict(idx_removed, idx_dict)</span></div>
<div class="line"><span class="lineno">  262</span>    cost = _flop_count(idx_contract, idx_removed, len(positions), idx_dict)</div>
<div class="line"><span class="lineno">  263</span>    sort = (-removed_size, cost)</div>
<div class="line"><span class="lineno">  264</span> </div>
<div class="line"><span class="lineno">  265</span>    <span class="comment"># Sieve based on total cost as well</span></div>
<div class="line"><span class="lineno">  266</span>    <span class="keywordflow">if</span> (path_cost + cost) &gt; naive_cost:</div>
<div class="line"><span class="lineno">  267</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  268</span> </div>
<div class="line"><span class="lineno">  269</span>    <span class="comment"># Add contraction to possible choices</span></div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">return</span> [sort, positions, new_input_sets]</div>
<div class="line"><span class="lineno">  271</span> </div>
<div class="line"><span class="lineno">  272</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a67a948887a56e53d34d275ed795464d2" name="a67a948887a56e53d34d275ed795464d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a948887a56e53d34d275ed795464d2">&#9670;&#160;</a></span>_update_other_results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc._update_other_results </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>best</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Update the positions and provisional input_sets of ``results`` based on
performing the contraction result ``best``. Remove any involving the tensors
contracted.

Parameters
----------
results : list
    List of contraction results produced by ``_parse_possible_contraction``.
best : list
    The best contraction of ``results`` i.e. the one that will be performed.

Returns
-------
mod_results : list
    The list of modified results, updated with outcome of ``best`` contraction.
</pre> <div class="fragment"><div class="line"><span class="lineno">  273</span><span class="keyword">def </span>_update_other_results(results, best):</div>
<div class="line"><span class="lineno">  274</span>    <span class="stringliteral">&quot;&quot;&quot;Update the positions and provisional input_sets of ``results`` based on</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">    performing the contraction result ``best``. Remove any involving the tensors</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">    contracted.</span></div>
<div class="line"><span class="lineno">  277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  278</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  279</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    results : list</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral">        List of contraction results produced by ``_parse_possible_contraction``.</span></div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    best : list</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">        The best contraction of ``results`` i.e. the one that will be performed.</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    mod_results : list</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">        The list of modified results, updated with outcome of ``best`` contraction.</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  290</span> </div>
<div class="line"><span class="lineno">  291</span>    best_con = best[1]</div>
<div class="line"><span class="lineno">  292</span>    bx, by = best_con</div>
<div class="line"><span class="lineno">  293</span>    mod_results = []</div>
<div class="line"><span class="lineno">  294</span> </div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">for</span> cost, (x, y), con_sets <span class="keywordflow">in</span> results:</div>
<div class="line"><span class="lineno">  296</span> </div>
<div class="line"><span class="lineno">  297</span>        <span class="comment"># Ignore results involving tensors just contracted</span></div>
<div class="line"><span class="lineno">  298</span>        <span class="keywordflow">if</span> x <span class="keywordflow">in</span> best_con <span class="keywordflow">or</span> y <span class="keywordflow">in</span> best_con:</div>
<div class="line"><span class="lineno">  299</span>            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>        <span class="comment"># Update the input_sets</span></div>
<div class="line"><span class="lineno">  302</span>        del con_sets[by - int(by &gt; x) - int(by &gt; y)]</div>
<div class="line"><span class="lineno">  303</span>        del con_sets[bx - int(bx &gt; x) - int(bx &gt; y)]</div>
<div class="line"><span class="lineno">  304</span>        con_sets.insert(-1, best[2][-1])</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>        <span class="comment"># Update the position indices</span></div>
<div class="line"><span class="lineno">  307</span>        mod_con = x - int(x &gt; bx) - int(x &gt; by), y - int(y &gt; bx) - int(y &gt; by)</div>
<div class="line"><span class="lineno">  308</span>        mod_results.append((cost, mod_con, con_sets))</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>    <span class="keywordflow">return</span> mod_results</div>
<div class="line"><span class="lineno">  311</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af40e071d1855e1ffe8dcb31e705fc095" name="af40e071d1855e1ffe8dcb31e705fc095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40e071d1855e1ffe8dcb31e705fc095">&#9670;&#160;</a></span>einsum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc.einsum </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">einsum(subscripts, *operands, out=None, dtype=None, order='K',
       casting='safe', optimize=False)

Evaluates the Einstein summation convention on the operands.

Using the Einstein summation convention, many common multi-dimensional,
linear algebraic array operations can be represented in a simple fashion.
In *implicit* mode `einsum` computes these values.

In *explicit* mode, `einsum` provides further flexibility to compute
other array operations that might not be considered classical Einstein
summation operations, by disabling, or forcing summation over specified
subscript labels.

See the notes and examples for clarification.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation as comma separated list of
    subscript labels. An implicit (classical Einstein summation)
    calculation is performed unless the explicit indicator '-&gt;' is
    included as well as subscript labels of the precise output form.
operands : list of array_like
    These are the arrays for the operation.
out : ndarray, optional
    If provided, the calculation is done into this array.
dtype : {data-type, None}, optional
    If provided, forces the calculation to use the data type specified.
    Note that you may have to also give a more liberal `casting`
    parameter to allow the conversions. Default is None.
order : {'C', 'F', 'A', 'K'}, optional
    Controls the memory layout of the output. 'C' means it should
    be C contiguous. 'F' means it should be Fortran contiguous,
    'A' means it should be 'F' if the inputs are all 'F', 'C' otherwise.
    'K' means it should be as close to the layout as the inputs as
    is possible, including arbitrarily permuted axes.
    Default is 'K'.
casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
    Controls what kind of data casting may occur.  Setting this to
    'unsafe' is not recommended, as it can adversely affect accumulations.

      * 'no' means the data types should not be cast at all.
      * 'equiv' means only byte-order changes are allowed.
      * 'safe' means only casts which can preserve values are allowed.
      * 'same_kind' means only safe casts or casts within a kind,
        like float64 to float32, are allowed.
      * 'unsafe' means any data conversions may be done.

    Default is 'safe'.
optimize : {False, True, 'greedy', 'optimal'}, optional
    Controls if intermediate optimization should occur. No optimization
    will occur if False and True will default to the 'greedy' algorithm.
    Also accepts an explicit contraction list from the ``np.einsum_path``
    function. See ``np.einsum_path`` for more details. Defaults to False.

Returns
-------
output : ndarray
    The calculation based on the Einstein summation convention.

See Also
--------
einsum_path, dot, inner, outer, tensordot, linalg.multi_dot
einops :
    similar verbose interface is provided by
    `einops &lt;https://github.com/arogozhnikov/einops&gt;`_ package to cover
    additional operations: transpose, reshape/flatten, repeat/tile,
    squeeze/unsqueeze and reductions.
opt_einsum :
    `opt_einsum &lt;https://optimized-einsum.readthedocs.io/en/stable/&gt;`_
    optimizes contraction order for einsum-like expressions
    in backend-agnostic manner.

Notes
-----
.. versionadded:: 1.6.0

The Einstein summation convention can be used to compute
many multi-dimensional, linear algebraic array operations. `einsum`
provides a succinct way of representing these.

A non-exhaustive list of these operations,
which can be computed by `einsum`, is shown below along with examples:

* Trace of an array, :py:func:`numpy.trace`.
* Return a diagonal, :py:func:`numpy.diag`.
* Array axis summations, :py:func:`numpy.sum`.
* Transpositions and permutations, :py:func:`numpy.transpose`.
* Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.
* Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.
* Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.
* Tensor contractions, :py:func:`numpy.tensordot`.
* Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.

The subscripts string is a comma-separated list of subscript labels,
where each label refers to a dimension of the corresponding operand.
Whenever a label is repeated it is summed, so ``np.einsum('i,i', a, b)``
is equivalent to :py:func:`np.inner(a,b) &lt;numpy.inner&gt;`. If a label
appears only once, it is not summed, so ``np.einsum('i', a)`` produces a
view of ``a`` with no changes. A further example ``np.einsum('ij,jk', a, b)``
describes traditional matrix multiplication and is equivalent to
:py:func:`np.matmul(a,b) &lt;numpy.matmul&gt;`. Repeated subscript labels in one
operand take the diagonal. For example, ``np.einsum('ii', a)`` is equivalent
to :py:func:`np.trace(a) &lt;numpy.trace&gt;`.

In *implicit mode*, the chosen subscripts are important
since the axes of the output are reordered alphabetically.  This
means that ``np.einsum('ij', a)`` doesn't affect a 2D array, while
``np.einsum('ji', a)`` takes its transpose. Additionally,
``np.einsum('ij,jk', a, b)`` returns a matrix multiplication, while,
``np.einsum('ij,jh', a, b)`` returns the transpose of the
multiplication since subscript 'h' precedes subscript 'i'.

In *explicit mode* the output can be directly controlled by
specifying output subscript labels.  This requires the
identifier '-&gt;' as well as the list of output subscript labels.
This feature increases the flexibility of the function since
summing can be disabled or forced when required. The call
``np.einsum('i-&gt;', a)`` is like :py:func:`np.sum(a, axis=-1) &lt;numpy.sum&gt;`,
and ``np.einsum('ii-&gt;i', a)`` is like :py:func:`np.diag(a) &lt;numpy.diag&gt;`.
The difference is that `einsum` does not allow broadcasting by default.
Additionally ``np.einsum('ij,jh-&gt;ih', a, b)`` directly specifies the
order of the output subscript labels and therefore returns matrix
multiplication, unlike the example above in implicit mode.

To enable and control broadcasting, use an ellipsis.  Default
NumPy-style broadcasting is done by adding an ellipsis
to the left of each term, like ``np.einsum('...ii-&gt;...i', a)``.
To take the trace along the first and last axes,
you can do ``np.einsum('i...i', a)``, or to do a matrix-matrix
product with the left-most indices instead of rightmost, one can do
``np.einsum('ij...,jk...-&gt;ik...', a, b)``.

When there is only one operand, no axes are summed, and no output
parameter is provided, a view into the operand is returned instead
of a new array.  Thus, taking the diagonal as ``np.einsum('ii-&gt;i', a)``
produces a view (changed in version 1.10.0).

`einsum` also provides an alternative way to provide the subscripts
and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.
If the output shape is not provided in this format `einsum` will be
calculated in implicit mode, otherwise it will be performed explicitly.
The examples below have corresponding `einsum` calls with the two
parameter methods.

.. versionadded:: 1.10.0

Views returned from einsum are now writeable whenever the input array
is writeable. For example, ``np.einsum('ijk...-&gt;kji...', a)`` will now
have the same effect as :py:func:`np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;`
and ``np.einsum('ii-&gt;i', a)`` will return a writeable view of the diagonal
of a 2D array.

.. versionadded:: 1.12.0

Added the ``optimize`` argument which will optimize the contraction order
of an einsum expression. For a contraction with three or more operands this
can greatly increase the computational efficiency at the cost of a larger
memory footprint during computation.

Typically a 'greedy' algorithm is applied which empirical tests have shown
returns the optimal path in the majority of cases. In some cases 'optimal'
will return the superlative path through a more expensive, exhaustive search.
For iterative calculations it may be advisable to calculate the optimal path
once and reuse that path by supplying it as an argument. An example is given
below.

See :py:func:`numpy.einsum_path` for more details.

Examples
--------
&gt;&gt;&gt; a = np.arange(25).reshape(5,5)
&gt;&gt;&gt; b = np.arange(5)
&gt;&gt;&gt; c = np.arange(6).reshape(2,3)

Trace of a matrix:

&gt;&gt;&gt; np.einsum('ii', a)
60
&gt;&gt;&gt; np.einsum(a, [0,0])
60
&gt;&gt;&gt; np.trace(a)
60

Extract the diagonal (requires explicit form):

&gt;&gt;&gt; np.einsum('ii-&gt;i', a)
array([ 0,  6, 12, 18, 24])
&gt;&gt;&gt; np.einsum(a, [0,0], [0])
array([ 0,  6, 12, 18, 24])
&gt;&gt;&gt; np.diag(a)
array([ 0,  6, 12, 18, 24])

Sum over an axis (requires explicit form):

&gt;&gt;&gt; np.einsum('ij-&gt;i', a)
array([ 10,  35,  60,  85, 110])
&gt;&gt;&gt; np.einsum(a, [0,1], [0])
array([ 10,  35,  60,  85, 110])
&gt;&gt;&gt; np.sum(a, axis=1)
array([ 10,  35,  60,  85, 110])

For higher dimensional arrays summing a single axis can be done with ellipsis:

&gt;&gt;&gt; np.einsum('...j-&gt;...', a)
array([ 10,  35,  60,  85, 110])
&gt;&gt;&gt; np.einsum(a, [Ellipsis,1], [Ellipsis])
array([ 10,  35,  60,  85, 110])

Compute a matrix transpose, or reorder any number of axes:

&gt;&gt;&gt; np.einsum('ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
&gt;&gt;&gt; np.einsum('ij-&gt;ji', c)
array([[0, 3],
       [1, 4],
       [2, 5]])
&gt;&gt;&gt; np.einsum(c, [1,0])
array([[0, 3],
       [1, 4],
       [2, 5]])
&gt;&gt;&gt; np.transpose(c)
array([[0, 3],
       [1, 4],
       [2, 5]])

Vector inner products:

&gt;&gt;&gt; np.einsum('i,i', b, b)
30
&gt;&gt;&gt; np.einsum(b, [0], b, [0])
30
&gt;&gt;&gt; np.inner(b,b)
30

Matrix vector multiplication:

&gt;&gt;&gt; np.einsum('ij,j', a, b)
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.einsum(a, [0,1], b, [1])
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.dot(a, b)
array([ 30,  80, 130, 180, 230])
&gt;&gt;&gt; np.einsum('...j,j', a, b)
array([ 30,  80, 130, 180, 230])

Broadcasting and scalar multiplication:

&gt;&gt;&gt; np.einsum('..., ...', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
&gt;&gt;&gt; np.einsum(',ij', 3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])
&gt;&gt;&gt; np.einsum(3, [Ellipsis], c, [Ellipsis])
array([[ 0,  3,  6],
       [ 9, 12, 15]])
&gt;&gt;&gt; np.multiply(3, c)
array([[ 0,  3,  6],
       [ 9, 12, 15]])

Vector outer product:

&gt;&gt;&gt; np.einsum('i,j', np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
&gt;&gt;&gt; np.einsum(np.arange(2)+1, [0], b, [1])
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])
&gt;&gt;&gt; np.outer(np.arange(2)+1, b)
array([[0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8]])

Tensor contraction:

&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)
&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)
&gt;&gt;&gt; np.einsum('ijk,jil-&gt;kl', a, b)
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
&gt;&gt;&gt; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])
&gt;&gt;&gt; np.tensordot(a,b, axes=([1,0],[0,1]))
array([[4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.]])

Writeable returned arrays (since version 1.10.0):

&gt;&gt;&gt; a = np.zeros((3, 3))
&gt;&gt;&gt; np.einsum('ii-&gt;i', a)[:] = 1
&gt;&gt;&gt; a
array([[1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.]])

Example of ellipsis use:

&gt;&gt;&gt; a = np.arange(6).reshape((3,2))
&gt;&gt;&gt; b = np.arange(12).reshape((4,3))
&gt;&gt;&gt; np.einsum('ki,jk-&gt;ij', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
&gt;&gt;&gt; np.einsum('ki,...k-&gt;i...', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])
&gt;&gt;&gt; np.einsum('k...,jk', a, b)
array([[10, 28, 46, 64],
       [13, 40, 67, 94]])

Chained array operations. For more complicated contractions, speed ups
might be achieved by repeatedly computing a 'greedy' path or pre-computing the
'optimal' path and repeatedly applying it, using an
`einsum_path` insertion (since version 1.12.0). Performance improvements can be
particularly significant with larger arrays:

&gt;&gt;&gt; a = np.ones(64).reshape(2,4,8)

Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)

&gt;&gt;&gt; for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a)

Sub-optimal `einsum` (due to repeated path calculation time): ~330ms

&gt;&gt;&gt; for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')

Greedy `einsum` (faster optimal path approximation): ~160ms

&gt;&gt;&gt; for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy')

Optimal `einsum` (best usage pattern in some use cases): ~110ms

&gt;&gt;&gt; path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0]
&gt;&gt;&gt; for iteration in range(500):
...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path)</pre> <div class="fragment"><div class="line"><span class="lineno"> 1010</span><span class="keyword">def </span>einsum(*operands, out=None, optimize=False, **kwargs):</div>
<div class="line"><span class="lineno"> 1011</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1012</span><span class="stringliteral">    einsum(subscripts, *operands, out=None, dtype=None, order=&#39;K&#39;,</span></div>
<div class="line"><span class="lineno"> 1013</span><span class="stringliteral">           casting=&#39;safe&#39;, optimize=False)</span></div>
<div class="line"><span class="lineno"> 1014</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1015</span><span class="stringliteral">    Evaluates the Einstein summation convention on the operands.</span></div>
<div class="line"><span class="lineno"> 1016</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1017</span><span class="stringliteral">    Using the Einstein summation convention, many common multi-dimensional,</span></div>
<div class="line"><span class="lineno"> 1018</span><span class="stringliteral">    linear algebraic array operations can be represented in a simple fashion.</span></div>
<div class="line"><span class="lineno"> 1019</span><span class="stringliteral">    In *implicit* mode `einsum` computes these values.</span></div>
<div class="line"><span class="lineno"> 1020</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1021</span><span class="stringliteral">    In *explicit* mode, `einsum` provides further flexibility to compute</span></div>
<div class="line"><span class="lineno"> 1022</span><span class="stringliteral">    other array operations that might not be considered classical Einstein</span></div>
<div class="line"><span class="lineno"> 1023</span><span class="stringliteral">    summation operations, by disabling, or forcing summation over specified</span></div>
<div class="line"><span class="lineno"> 1024</span><span class="stringliteral">    subscript labels.</span></div>
<div class="line"><span class="lineno"> 1025</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1026</span><span class="stringliteral">    See the notes and examples for clarification.</span></div>
<div class="line"><span class="lineno"> 1027</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1028</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno"> 1029</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno"> 1030</span><span class="stringliteral">    subscripts : str</span></div>
<div class="line"><span class="lineno"> 1031</span><span class="stringliteral">        Specifies the subscripts for summation as comma separated list of</span></div>
<div class="line"><span class="lineno"> 1032</span><span class="stringliteral">        subscript labels. An implicit (classical Einstein summation)</span></div>
<div class="line"><span class="lineno"> 1033</span><span class="stringliteral">        calculation is performed unless the explicit indicator &#39;-&gt;&#39; is</span></div>
<div class="line"><span class="lineno"> 1034</span><span class="stringliteral">        included as well as subscript labels of the precise output form.</span></div>
<div class="line"><span class="lineno"> 1035</span><span class="stringliteral">    operands : list of array_like</span></div>
<div class="line"><span class="lineno"> 1036</span><span class="stringliteral">        These are the arrays for the operation.</span></div>
<div class="line"><span class="lineno"> 1037</span><span class="stringliteral">    out : ndarray, optional</span></div>
<div class="line"><span class="lineno"> 1038</span><span class="stringliteral">        If provided, the calculation is done into this array.</span></div>
<div class="line"><span class="lineno"> 1039</span><span class="stringliteral">    dtype : {data-type, None}, optional</span></div>
<div class="line"><span class="lineno"> 1040</span><span class="stringliteral">        If provided, forces the calculation to use the data type specified.</span></div>
<div class="line"><span class="lineno"> 1041</span><span class="stringliteral">        Note that you may have to also give a more liberal `casting`</span></div>
<div class="line"><span class="lineno"> 1042</span><span class="stringliteral">        parameter to allow the conversions. Default is None.</span></div>
<div class="line"><span class="lineno"> 1043</span><span class="stringliteral">    order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1044</span><span class="stringliteral">        Controls the memory layout of the output. &#39;C&#39; means it should</span></div>
<div class="line"><span class="lineno"> 1045</span><span class="stringliteral">        be C contiguous. &#39;F&#39; means it should be Fortran contiguous,</span></div>
<div class="line"><span class="lineno"> 1046</span><span class="stringliteral">        &#39;A&#39; means it should be &#39;F&#39; if the inputs are all &#39;F&#39;, &#39;C&#39; otherwise.</span></div>
<div class="line"><span class="lineno"> 1047</span><span class="stringliteral">        &#39;K&#39; means it should be as close to the layout as the inputs as</span></div>
<div class="line"><span class="lineno"> 1048</span><span class="stringliteral">        is possible, including arbitrarily permuted axes.</span></div>
<div class="line"><span class="lineno"> 1049</span><span class="stringliteral">        Default is &#39;K&#39;.</span></div>
<div class="line"><span class="lineno"> 1050</span><span class="stringliteral">    casting : {&#39;no&#39;, &#39;equiv&#39;, &#39;safe&#39;, &#39;same_kind&#39;, &#39;unsafe&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1051</span><span class="stringliteral">        Controls what kind of data casting may occur.  Setting this to</span></div>
<div class="line"><span class="lineno"> 1052</span><span class="stringliteral">        &#39;unsafe&#39; is not recommended, as it can adversely affect accumulations.</span></div>
<div class="line"><span class="lineno"> 1053</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1054</span><span class="stringliteral">          * &#39;no&#39; means the data types should not be cast at all.</span></div>
<div class="line"><span class="lineno"> 1055</span><span class="stringliteral">          * &#39;equiv&#39; means only byte-order changes are allowed.</span></div>
<div class="line"><span class="lineno"> 1056</span><span class="stringliteral">          * &#39;safe&#39; means only casts which can preserve values are allowed.</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">          * &#39;same_kind&#39; means only safe casts or casts within a kind,</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral">            like float64 to float32, are allowed.</span></div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">          * &#39;unsafe&#39; means any data conversions may be done.</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral">        Default is &#39;safe&#39;.</span></div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">    optimize : {False, True, &#39;greedy&#39;, &#39;optimal&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        Controls if intermediate optimization should occur. No optimization</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        will occur if False and True will default to the &#39;greedy&#39; algorithm.</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">        Also accepts an explicit contraction list from the ``np.einsum_path``</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">        function. See ``np.einsum_path`` for more details. Defaults to False.</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">    output : ndarray</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">        The calculation based on the Einstein summation convention.</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">    einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">    einops :</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">        similar verbose interface is provided by</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        `einops &lt;https://github.com/arogozhnikov/einops&gt;`_ package to cover</span></div>
<div class="line"><span class="lineno"> 1079</span><span class="stringliteral">        additional operations: transpose, reshape/flatten, repeat/tile,</span></div>
<div class="line"><span class="lineno"> 1080</span><span class="stringliteral">        squeeze/unsqueeze and reductions.</span></div>
<div class="line"><span class="lineno"> 1081</span><span class="stringliteral">    opt_einsum :</span></div>
<div class="line"><span class="lineno"> 1082</span><span class="stringliteral">        `opt_einsum &lt;https://optimized-einsum.readthedocs.io/en/stable/&gt;`_</span></div>
<div class="line"><span class="lineno"> 1083</span><span class="stringliteral">        optimizes contraction order for einsum-like expressions</span></div>
<div class="line"><span class="lineno"> 1084</span><span class="stringliteral">        in backend-agnostic manner.</span></div>
<div class="line"><span class="lineno"> 1085</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1086</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno"> 1087</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno"> 1088</span><span class="stringliteral">    .. versionadded:: 1.6.0</span></div>
<div class="line"><span class="lineno"> 1089</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1090</span><span class="stringliteral">    The Einstein summation convention can be used to compute</span></div>
<div class="line"><span class="lineno"> 1091</span><span class="stringliteral">    many multi-dimensional, linear algebraic array operations. `einsum`</span></div>
<div class="line"><span class="lineno"> 1092</span><span class="stringliteral">    provides a succinct way of representing these.</span></div>
<div class="line"><span class="lineno"> 1093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1094</span><span class="stringliteral">    A non-exhaustive list of these operations,</span></div>
<div class="line"><span class="lineno"> 1095</span><span class="stringliteral">    which can be computed by `einsum`, is shown below along with examples:</span></div>
<div class="line"><span class="lineno"> 1096</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1097</span><span class="stringliteral">    * Trace of an array, :py:func:`numpy.trace`.</span></div>
<div class="line"><span class="lineno"> 1098</span><span class="stringliteral">    * Return a diagonal, :py:func:`numpy.diag`.</span></div>
<div class="line"><span class="lineno"> 1099</span><span class="stringliteral">    * Array axis summations, :py:func:`numpy.sum`.</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral">    * Transpositions and permutations, :py:func:`numpy.transpose`.</span></div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">    * Matrix multiplication and dot product, :py:func:`numpy.matmul` :py:func:`numpy.dot`.</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">    * Vector inner and outer products, :py:func:`numpy.inner` :py:func:`numpy.outer`.</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">    * Broadcasting, element-wise and scalar multiplication, :py:func:`numpy.multiply`.</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">    * Tensor contractions, :py:func:`numpy.tensordot`.</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">    * Chained array operations, in efficient calculation order, :py:func:`numpy.einsum_path`.</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">    The subscripts string is a comma-separated list of subscript labels,</span></div>
<div class="line"><span class="lineno"> 1108</span><span class="stringliteral">    where each label refers to a dimension of the corresponding operand.</span></div>
<div class="line"><span class="lineno"> 1109</span><span class="stringliteral">    Whenever a label is repeated it is summed, so ``np.einsum(&#39;i,i&#39;, a, b)``</span></div>
<div class="line"><span class="lineno"> 1110</span><span class="stringliteral">    is equivalent to :py:func:`np.inner(a,b) &lt;numpy.inner&gt;`. If a label</span></div>
<div class="line"><span class="lineno"> 1111</span><span class="stringliteral">    appears only once, it is not summed, so ``np.einsum(&#39;i&#39;, a)`` produces a</span></div>
<div class="line"><span class="lineno"> 1112</span><span class="stringliteral">    view of ``a`` with no changes. A further example ``np.einsum(&#39;ij,jk&#39;, a, b)``</span></div>
<div class="line"><span class="lineno"> 1113</span><span class="stringliteral">    describes traditional matrix multiplication and is equivalent to</span></div>
<div class="line"><span class="lineno"> 1114</span><span class="stringliteral">    :py:func:`np.matmul(a,b) &lt;numpy.matmul&gt;`. Repeated subscript labels in one</span></div>
<div class="line"><span class="lineno"> 1115</span><span class="stringliteral">    operand take the diagonal. For example, ``np.einsum(&#39;ii&#39;, a)`` is equivalent</span></div>
<div class="line"><span class="lineno"> 1116</span><span class="stringliteral">    to :py:func:`np.trace(a) &lt;numpy.trace&gt;`.</span></div>
<div class="line"><span class="lineno"> 1117</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1118</span><span class="stringliteral">    In *implicit mode*, the chosen subscripts are important</span></div>
<div class="line"><span class="lineno"> 1119</span><span class="stringliteral">    since the axes of the output are reordered alphabetically.  This</span></div>
<div class="line"><span class="lineno"> 1120</span><span class="stringliteral">    means that ``np.einsum(&#39;ij&#39;, a)`` doesn&#39;t affect a 2D array, while</span></div>
<div class="line"><span class="lineno"> 1121</span><span class="stringliteral">    ``np.einsum(&#39;ji&#39;, a)`` takes its transpose. Additionally,</span></div>
<div class="line"><span class="lineno"> 1122</span><span class="stringliteral">    ``np.einsum(&#39;ij,jk&#39;, a, b)`` returns a matrix multiplication, while,</span></div>
<div class="line"><span class="lineno"> 1123</span><span class="stringliteral">    ``np.einsum(&#39;ij,jh&#39;, a, b)`` returns the transpose of the</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral">    multiplication since subscript &#39;h&#39; precedes subscript &#39;i&#39;.</span></div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">    In *explicit mode* the output can be directly controlled by</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">    specifying output subscript labels.  This requires the</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">    identifier &#39;-&gt;&#39; as well as the list of output subscript labels.</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">    This feature increases the flexibility of the function since</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">    summing can be disabled or forced when required. The call</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">    ``np.einsum(&#39;i-&gt;&#39;, a)`` is like :py:func:`np.sum(a, axis=-1) &lt;numpy.sum&gt;`,</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">    and ``np.einsum(&#39;ii-&gt;i&#39;, a)`` is like :py:func:`np.diag(a) &lt;numpy.diag&gt;`.</span></div>
<div class="line"><span class="lineno"> 1133</span><span class="stringliteral">    The difference is that `einsum` does not allow broadcasting by default.</span></div>
<div class="line"><span class="lineno"> 1134</span><span class="stringliteral">    Additionally ``np.einsum(&#39;ij,jh-&gt;ih&#39;, a, b)`` directly specifies the</span></div>
<div class="line"><span class="lineno"> 1135</span><span class="stringliteral">    order of the output subscript labels and therefore returns matrix</span></div>
<div class="line"><span class="lineno"> 1136</span><span class="stringliteral">    multiplication, unlike the example above in implicit mode.</span></div>
<div class="line"><span class="lineno"> 1137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1138</span><span class="stringliteral">    To enable and control broadcasting, use an ellipsis.  Default</span></div>
<div class="line"><span class="lineno"> 1139</span><span class="stringliteral">    NumPy-style broadcasting is done by adding an ellipsis</span></div>
<div class="line"><span class="lineno"> 1140</span><span class="stringliteral">    to the left of each term, like ``np.einsum(&#39;...ii-&gt;...i&#39;, a)``.</span></div>
<div class="line"><span class="lineno"> 1141</span><span class="stringliteral">    To take the trace along the first and last axes,</span></div>
<div class="line"><span class="lineno"> 1142</span><span class="stringliteral">    you can do ``np.einsum(&#39;i...i&#39;, a)``, or to do a matrix-matrix</span></div>
<div class="line"><span class="lineno"> 1143</span><span class="stringliteral">    product with the left-most indices instead of rightmost, one can do</span></div>
<div class="line"><span class="lineno"> 1144</span><span class="stringliteral">    ``np.einsum(&#39;ij...,jk...-&gt;ik...&#39;, a, b)``.</span></div>
<div class="line"><span class="lineno"> 1145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1146</span><span class="stringliteral">    When there is only one operand, no axes are summed, and no output</span></div>
<div class="line"><span class="lineno"> 1147</span><span class="stringliteral">    parameter is provided, a view into the operand is returned instead</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">    of a new array.  Thus, taking the diagonal as ``np.einsum(&#39;ii-&gt;i&#39;, a)``</span></div>
<div class="line"><span class="lineno"> 1149</span><span class="stringliteral">    produces a view (changed in version 1.10.0).</span></div>
<div class="line"><span class="lineno"> 1150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1151</span><span class="stringliteral">    `einsum` also provides an alternative way to provide the subscripts</span></div>
<div class="line"><span class="lineno"> 1152</span><span class="stringliteral">    and operands as ``einsum(op0, sublist0, op1, sublist1, ..., [sublistout])``.</span></div>
<div class="line"><span class="lineno"> 1153</span><span class="stringliteral">    If the output shape is not provided in this format `einsum` will be</span></div>
<div class="line"><span class="lineno"> 1154</span><span class="stringliteral">    calculated in implicit mode, otherwise it will be performed explicitly.</span></div>
<div class="line"><span class="lineno"> 1155</span><span class="stringliteral">    The examples below have corresponding `einsum` calls with the two</span></div>
<div class="line"><span class="lineno"> 1156</span><span class="stringliteral">    parameter methods.</span></div>
<div class="line"><span class="lineno"> 1157</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1158</span><span class="stringliteral">    .. versionadded:: 1.10.0</span></div>
<div class="line"><span class="lineno"> 1159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1160</span><span class="stringliteral">    Views returned from einsum are now writeable whenever the input array</span></div>
<div class="line"><span class="lineno"> 1161</span><span class="stringliteral">    is writeable. For example, ``np.einsum(&#39;ijk...-&gt;kji...&#39;, a)`` will now</span></div>
<div class="line"><span class="lineno"> 1162</span><span class="stringliteral">    have the same effect as :py:func:`np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;`</span></div>
<div class="line"><span class="lineno"> 1163</span><span class="stringliteral">    and ``np.einsum(&#39;ii-&gt;i&#39;, a)`` will return a writeable view of the diagonal</span></div>
<div class="line"><span class="lineno"> 1164</span><span class="stringliteral">    of a 2D array.</span></div>
<div class="line"><span class="lineno"> 1165</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1166</span><span class="stringliteral">    .. versionadded:: 1.12.0</span></div>
<div class="line"><span class="lineno"> 1167</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1168</span><span class="stringliteral">    Added the ``optimize`` argument which will optimize the contraction order</span></div>
<div class="line"><span class="lineno"> 1169</span><span class="stringliteral">    of an einsum expression. For a contraction with three or more operands this</span></div>
<div class="line"><span class="lineno"> 1170</span><span class="stringliteral">    can greatly increase the computational efficiency at the cost of a larger</span></div>
<div class="line"><span class="lineno"> 1171</span><span class="stringliteral">    memory footprint during computation.</span></div>
<div class="line"><span class="lineno"> 1172</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1173</span><span class="stringliteral">    Typically a &#39;greedy&#39; algorithm is applied which empirical tests have shown</span></div>
<div class="line"><span class="lineno"> 1174</span><span class="stringliteral">    returns the optimal path in the majority of cases. In some cases &#39;optimal&#39;</span></div>
<div class="line"><span class="lineno"> 1175</span><span class="stringliteral">    will return the superlative path through a more expensive, exhaustive search.</span></div>
<div class="line"><span class="lineno"> 1176</span><span class="stringliteral">    For iterative calculations it may be advisable to calculate the optimal path</span></div>
<div class="line"><span class="lineno"> 1177</span><span class="stringliteral">    once and reuse that path by supplying it as an argument. An example is given</span></div>
<div class="line"><span class="lineno"> 1178</span><span class="stringliteral">    below.</span></div>
<div class="line"><span class="lineno"> 1179</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1180</span><span class="stringliteral">    See :py:func:`numpy.einsum_path` for more details.</span></div>
<div class="line"><span class="lineno"> 1181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1182</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno"> 1183</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno"> 1184</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(25).reshape(5,5)</span></div>
<div class="line"><span class="lineno"> 1185</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(5)</span></div>
<div class="line"><span class="lineno"> 1186</span><span class="stringliteral">    &gt;&gt;&gt; c = np.arange(6).reshape(2,3)</span></div>
<div class="line"><span class="lineno"> 1187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1188</span><span class="stringliteral">    Trace of a matrix:</span></div>
<div class="line"><span class="lineno"> 1189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1190</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ii&#39;, a)</span></div>
<div class="line"><span class="lineno"> 1191</span><span class="stringliteral">    60</span></div>
<div class="line"><span class="lineno"> 1192</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [0,0])</span></div>
<div class="line"><span class="lineno"> 1193</span><span class="stringliteral">    60</span></div>
<div class="line"><span class="lineno"> 1194</span><span class="stringliteral">    &gt;&gt;&gt; np.trace(a)</span></div>
<div class="line"><span class="lineno"> 1195</span><span class="stringliteral">    60</span></div>
<div class="line"><span class="lineno"> 1196</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1197</span><span class="stringliteral">    Extract the diagonal (requires explicit form):</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ii-&gt;i&#39;, a)</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">    array([ 0,  6, 12, 18, 24])</span></div>
<div class="line"><span class="lineno"> 1201</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [0,0], [0])</span></div>
<div class="line"><span class="lineno"> 1202</span><span class="stringliteral">    array([ 0,  6, 12, 18, 24])</span></div>
<div class="line"><span class="lineno"> 1203</span><span class="stringliteral">    &gt;&gt;&gt; np.diag(a)</span></div>
<div class="line"><span class="lineno"> 1204</span><span class="stringliteral">    array([ 0,  6, 12, 18, 24])</span></div>
<div class="line"><span class="lineno"> 1205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1206</span><span class="stringliteral">    Sum over an axis (requires explicit form):</span></div>
<div class="line"><span class="lineno"> 1207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1208</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ij-&gt;i&#39;, a)</span></div>
<div class="line"><span class="lineno"> 1209</span><span class="stringliteral">    array([ 10,  35,  60,  85, 110])</span></div>
<div class="line"><span class="lineno"> 1210</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [0,1], [0])</span></div>
<div class="line"><span class="lineno"> 1211</span><span class="stringliteral">    array([ 10,  35,  60,  85, 110])</span></div>
<div class="line"><span class="lineno"> 1212</span><span class="stringliteral">    &gt;&gt;&gt; np.sum(a, axis=1)</span></div>
<div class="line"><span class="lineno"> 1213</span><span class="stringliteral">    array([ 10,  35,  60,  85, 110])</span></div>
<div class="line"><span class="lineno"> 1214</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1215</span><span class="stringliteral">    For higher dimensional arrays summing a single axis can be done with ellipsis:</span></div>
<div class="line"><span class="lineno"> 1216</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1217</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;...j-&gt;...&#39;, a)</span></div>
<div class="line"><span class="lineno"> 1218</span><span class="stringliteral">    array([ 10,  35,  60,  85, 110])</span></div>
<div class="line"><span class="lineno"> 1219</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [Ellipsis,1], [Ellipsis])</span></div>
<div class="line"><span class="lineno"> 1220</span><span class="stringliteral">    array([ 10,  35,  60,  85, 110])</span></div>
<div class="line"><span class="lineno"> 1221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1222</span><span class="stringliteral">    Compute a matrix transpose, or reorder any number of axes:</span></div>
<div class="line"><span class="lineno"> 1223</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1224</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ji&#39;, c)</span></div>
<div class="line"><span class="lineno"> 1225</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1226</span><span class="stringliteral">           [1, 4],</span></div>
<div class="line"><span class="lineno"> 1227</span><span class="stringliteral">           [2, 5]])</span></div>
<div class="line"><span class="lineno"> 1228</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ij-&gt;ji&#39;, c)</span></div>
<div class="line"><span class="lineno"> 1229</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1230</span><span class="stringliteral">           [1, 4],</span></div>
<div class="line"><span class="lineno"> 1231</span><span class="stringliteral">           [2, 5]])</span></div>
<div class="line"><span class="lineno"> 1232</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(c, [1,0])</span></div>
<div class="line"><span class="lineno"> 1233</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1234</span><span class="stringliteral">           [1, 4],</span></div>
<div class="line"><span class="lineno"> 1235</span><span class="stringliteral">           [2, 5]])</span></div>
<div class="line"><span class="lineno"> 1236</span><span class="stringliteral">    &gt;&gt;&gt; np.transpose(c)</span></div>
<div class="line"><span class="lineno"> 1237</span><span class="stringliteral">    array([[0, 3],</span></div>
<div class="line"><span class="lineno"> 1238</span><span class="stringliteral">           [1, 4],</span></div>
<div class="line"><span class="lineno"> 1239</span><span class="stringliteral">           [2, 5]])</span></div>
<div class="line"><span class="lineno"> 1240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1241</span><span class="stringliteral">    Vector inner products:</span></div>
<div class="line"><span class="lineno"> 1242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1243</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;i,i&#39;, b, b)</span></div>
<div class="line"><span class="lineno"> 1244</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno"> 1245</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(b, [0], b, [0])</span></div>
<div class="line"><span class="lineno"> 1246</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno"> 1247</span><span class="stringliteral">    &gt;&gt;&gt; np.inner(b,b)</span></div>
<div class="line"><span class="lineno"> 1248</span><span class="stringliteral">    30</span></div>
<div class="line"><span class="lineno"> 1249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1250</span><span class="stringliteral">    Matrix vector multiplication:</span></div>
<div class="line"><span class="lineno"> 1251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1252</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ij,j&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1253</span><span class="stringliteral">    array([ 30,  80, 130, 180, 230])</span></div>
<div class="line"><span class="lineno"> 1254</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [0,1], b, [1])</span></div>
<div class="line"><span class="lineno"> 1255</span><span class="stringliteral">    array([ 30,  80, 130, 180, 230])</span></div>
<div class="line"><span class="lineno"> 1256</span><span class="stringliteral">    &gt;&gt;&gt; np.dot(a, b)</span></div>
<div class="line"><span class="lineno"> 1257</span><span class="stringliteral">    array([ 30,  80, 130, 180, 230])</span></div>
<div class="line"><span class="lineno"> 1258</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;...j,j&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1259</span><span class="stringliteral">    array([ 30,  80, 130, 180, 230])</span></div>
<div class="line"><span class="lineno"> 1260</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1261</span><span class="stringliteral">    Broadcasting and scalar multiplication:</span></div>
<div class="line"><span class="lineno"> 1262</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1263</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;..., ...&#39;, 3, c)</span></div>
<div class="line"><span class="lineno"> 1264</span><span class="stringliteral">    array([[ 0,  3,  6],</span></div>
<div class="line"><span class="lineno"> 1265</span><span class="stringliteral">           [ 9, 12, 15]])</span></div>
<div class="line"><span class="lineno"> 1266</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;,ij&#39;, 3, c)</span></div>
<div class="line"><span class="lineno"> 1267</span><span class="stringliteral">    array([[ 0,  3,  6],</span></div>
<div class="line"><span class="lineno"> 1268</span><span class="stringliteral">           [ 9, 12, 15]])</span></div>
<div class="line"><span class="lineno"> 1269</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(3, [Ellipsis], c, [Ellipsis])</span></div>
<div class="line"><span class="lineno"> 1270</span><span class="stringliteral">    array([[ 0,  3,  6],</span></div>
<div class="line"><span class="lineno"> 1271</span><span class="stringliteral">           [ 9, 12, 15]])</span></div>
<div class="line"><span class="lineno"> 1272</span><span class="stringliteral">    &gt;&gt;&gt; np.multiply(3, c)</span></div>
<div class="line"><span class="lineno"> 1273</span><span class="stringliteral">    array([[ 0,  3,  6],</span></div>
<div class="line"><span class="lineno"> 1274</span><span class="stringliteral">           [ 9, 12, 15]])</span></div>
<div class="line"><span class="lineno"> 1275</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1276</span><span class="stringliteral">    Vector outer product:</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;i,j&#39;, np.arange(2)+1, b)</span></div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">    array([[0, 1, 2, 3, 4],</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral">           [0, 2, 4, 6, 8]])</span></div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(np.arange(2)+1, [0], b, [1])</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">    array([[0, 1, 2, 3, 4],</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">           [0, 2, 4, 6, 8]])</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">    &gt;&gt;&gt; np.outer(np.arange(2)+1, b)</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">    array([[0, 1, 2, 3, 4],</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">           [0, 2, 4, 6, 8]])</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral">    Tensor contraction:</span></div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ijk,jil-&gt;kl&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral">    array([[4400., 4730.],</span></div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">           [4532., 4874.],</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">           [4664., 5018.],</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral">           [4796., 5162.],</span></div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">           [4928., 5306.]])</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">    array([[4400., 4730.],</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">           [4532., 4874.],</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral">           [4664., 5018.],</span></div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">           [4796., 5162.],</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">           [4928., 5306.]])</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">    &gt;&gt;&gt; np.tensordot(a,b, axes=([1,0],[0,1]))</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">    array([[4400., 4730.],</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">           [4532., 4874.],</span></div>
<div class="line"><span class="lineno"> 1307</span><span class="stringliteral">           [4664., 5018.],</span></div>
<div class="line"><span class="lineno"> 1308</span><span class="stringliteral">           [4796., 5162.],</span></div>
<div class="line"><span class="lineno"> 1309</span><span class="stringliteral">           [4928., 5306.]])</span></div>
<div class="line"><span class="lineno"> 1310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1311</span><span class="stringliteral">    Writeable returned arrays (since version 1.10.0):</span></div>
<div class="line"><span class="lineno"> 1312</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1313</span><span class="stringliteral">    &gt;&gt;&gt; a = np.zeros((3, 3))</span></div>
<div class="line"><span class="lineno"> 1314</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ii-&gt;i&#39;, a)[:] = 1</span></div>
<div class="line"><span class="lineno"> 1315</span><span class="stringliteral">    &gt;&gt;&gt; a</span></div>
<div class="line"><span class="lineno"> 1316</span><span class="stringliteral">    array([[1., 0., 0.],</span></div>
<div class="line"><span class="lineno"> 1317</span><span class="stringliteral">           [0., 1., 0.],</span></div>
<div class="line"><span class="lineno"> 1318</span><span class="stringliteral">           [0., 0., 1.]])</span></div>
<div class="line"><span class="lineno"> 1319</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1320</span><span class="stringliteral">    Example of ellipsis use:</span></div>
<div class="line"><span class="lineno"> 1321</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1322</span><span class="stringliteral">    &gt;&gt;&gt; a = np.arange(6).reshape((3,2))</span></div>
<div class="line"><span class="lineno"> 1323</span><span class="stringliteral">    &gt;&gt;&gt; b = np.arange(12).reshape((4,3))</span></div>
<div class="line"><span class="lineno"> 1324</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ki,jk-&gt;ij&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1325</span><span class="stringliteral">    array([[10, 28, 46, 64],</span></div>
<div class="line"><span class="lineno"> 1326</span><span class="stringliteral">           [13, 40, 67, 94]])</span></div>
<div class="line"><span class="lineno"> 1327</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;ki,...k-&gt;i...&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1328</span><span class="stringliteral">    array([[10, 28, 46, 64],</span></div>
<div class="line"><span class="lineno"> 1329</span><span class="stringliteral">           [13, 40, 67, 94]])</span></div>
<div class="line"><span class="lineno"> 1330</span><span class="stringliteral">    &gt;&gt;&gt; np.einsum(&#39;k...,jk&#39;, a, b)</span></div>
<div class="line"><span class="lineno"> 1331</span><span class="stringliteral">    array([[10, 28, 46, 64],</span></div>
<div class="line"><span class="lineno"> 1332</span><span class="stringliteral">           [13, 40, 67, 94]])</span></div>
<div class="line"><span class="lineno"> 1333</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1334</span><span class="stringliteral">    Chained array operations. For more complicated contractions, speed ups</span></div>
<div class="line"><span class="lineno"> 1335</span><span class="stringliteral">    might be achieved by repeatedly computing a &#39;greedy&#39; path or pre-computing the</span></div>
<div class="line"><span class="lineno"> 1336</span><span class="stringliteral">    &#39;optimal&#39; path and repeatedly applying it, using an</span></div>
<div class="line"><span class="lineno"> 1337</span><span class="stringliteral">    `einsum_path` insertion (since version 1.12.0). Performance improvements can be</span></div>
<div class="line"><span class="lineno"> 1338</span><span class="stringliteral">    particularly significant with larger arrays:</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">    &gt;&gt;&gt; a = np.ones(64).reshape(2,4,8)</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">    Basic `einsum`: ~1520ms  (benchmarked on 3.1GHz Intel i5.)</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1344</span><span class="stringliteral">    &gt;&gt;&gt; for iteration in range(500):</span></div>
<div class="line"><span class="lineno"> 1345</span><span class="stringliteral">    ...     _ = np.einsum(&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;,a,a,a,a,a)</span></div>
<div class="line"><span class="lineno"> 1346</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1347</span><span class="stringliteral">    Sub-optimal `einsum` (due to repeated path calculation time): ~330ms</span></div>
<div class="line"><span class="lineno"> 1348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1349</span><span class="stringliteral">    &gt;&gt;&gt; for iteration in range(500):</span></div>
<div class="line"><span class="lineno"> 1350</span><span class="stringliteral">    ...     _ = np.einsum(&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;,a,a,a,a,a, optimize=&#39;optimal&#39;)</span></div>
<div class="line"><span class="lineno"> 1351</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">    Greedy `einsum` (faster optimal path approximation): ~160ms</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1354</span><span class="stringliteral">    &gt;&gt;&gt; for iteration in range(500):</span></div>
<div class="line"><span class="lineno"> 1355</span><span class="stringliteral">    ...     _ = np.einsum(&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;,a,a,a,a,a, optimize=&#39;greedy&#39;)</span></div>
<div class="line"><span class="lineno"> 1356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1357</span><span class="stringliteral">    Optimal `einsum` (best usage pattern in some use cases): ~110ms</span></div>
<div class="line"><span class="lineno"> 1358</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1359</span><span class="stringliteral">    &gt;&gt;&gt; path = np.einsum_path(&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;,a,a,a,a,a, optimize=&#39;optimal&#39;)[0]</span></div>
<div class="line"><span class="lineno"> 1360</span><span class="stringliteral">    &gt;&gt;&gt; for iteration in range(500):</span></div>
<div class="line"><span class="lineno"> 1361</span><span class="stringliteral">    ...     _ = np.einsum(&#39;ijk,ilm,njm,nlk,abc-&gt;&#39;,a,a,a,a,a, optimize=path)</span></div>
<div class="line"><span class="lineno"> 1362</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1363</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1364</span>    <span class="comment"># Special handling if out is specified</span></div>
<div class="line"><span class="lineno"> 1365</span>    specified_out = out <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1366</span> </div>
<div class="line"><span class="lineno"> 1367</span>    <span class="comment"># If no optimization, run pure einsum</span></div>
<div class="line"><span class="lineno"> 1368</span>    <span class="keywordflow">if</span> optimize <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno"> 1369</span>        <span class="keywordflow">if</span> specified_out:</div>
<div class="line"><span class="lineno"> 1370</span>            kwargs[<span class="stringliteral">&#39;out&#39;</span>] = out</div>
<div class="line"><span class="lineno"> 1371</span>        <span class="keywordflow">return</span> c_einsum(*operands, **kwargs)</div>
<div class="line"><span class="lineno"> 1372</span> </div>
<div class="line"><span class="lineno"> 1373</span>    <span class="comment"># Check the kwargs to avoid a more cryptic error later, without having to</span></div>
<div class="line"><span class="lineno"> 1374</span>    <span class="comment"># repeat default values here</span></div>
<div class="line"><span class="lineno"> 1375</span>    valid_einsum_kwargs = [<span class="stringliteral">&#39;dtype&#39;</span>, <span class="stringliteral">&#39;order&#39;</span>, <span class="stringliteral">&#39;casting&#39;</span>]</div>
<div class="line"><span class="lineno"> 1376</span>    unknown_kwargs = [k <span class="keywordflow">for</span> (k, v) <span class="keywordflow">in</span> kwargs.items() <span class="keywordflow">if</span></div>
<div class="line"><span class="lineno"> 1377</span>                      k <span class="keywordflow">not</span> <span class="keywordflow">in</span> valid_einsum_kwargs]</div>
<div class="line"><span class="lineno"> 1378</span>    <span class="keywordflow">if</span> len(unknown_kwargs):</div>
<div class="line"><span class="lineno"> 1379</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Did not understand the following kwargs: %s&quot;</span></div>
<div class="line"><span class="lineno"> 1380</span>                        % unknown_kwargs)</div>
<div class="line"><span class="lineno"> 1381</span> </div>
<div class="line"><span class="lineno"> 1382</span>    <span class="comment"># Build the contraction list and operand</span></div>
<div class="line"><span class="lineno"> 1383</span>    operands, contraction_list = einsum_path(*operands, optimize=optimize,</div>
<div class="line"><span class="lineno"> 1384</span>                                             einsum_call=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1385</span> </div>
<div class="line"><span class="lineno"> 1386</span>    <span class="comment"># Handle order kwarg for output array, c_einsum allows mixed case</span></div>
<div class="line"><span class="lineno"> 1387</span>    output_order = kwargs.pop(<span class="stringliteral">&#39;order&#39;</span>, <span class="stringliteral">&#39;K&#39;</span>)</div>
<div class="line"><span class="lineno"> 1388</span>    <span class="keywordflow">if</span> output_order.upper() == <span class="stringliteral">&#39;A&#39;</span>:</div>
<div class="line"><span class="lineno"> 1389</span>        <span class="keywordflow">if</span> all(arr.flags.f_contiguous <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> operands):</div>
<div class="line"><span class="lineno"> 1390</span>            output_order = <span class="stringliteral">&#39;F&#39;</span></div>
<div class="line"><span class="lineno"> 1391</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1392</span>            output_order = <span class="stringliteral">&#39;C&#39;</span></div>
<div class="line"><span class="lineno"> 1393</span> </div>
<div class="line"><span class="lineno"> 1394</span>    <span class="comment"># Start contraction loop</span></div>
<div class="line"><span class="lineno"> 1395</span>    <span class="keywordflow">for</span> num, contraction <span class="keywordflow">in</span> enumerate(contraction_list):</div>
<div class="line"><span class="lineno"> 1396</span>        inds, idx_rm, einsum_str, remaining, blas = contraction</div>
<div class="line"><span class="lineno"> 1397</span>        tmp_operands = [operands.pop(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> inds]</div>
<div class="line"><span class="lineno"> 1398</span> </div>
<div class="line"><span class="lineno"> 1399</span>        <span class="comment"># Do we need to deal with the output?</span></div>
<div class="line"><span class="lineno"> 1400</span>        handle_out = specified_out <span class="keywordflow">and</span> ((num + 1) == len(contraction_list))</div>
<div class="line"><span class="lineno"> 1401</span> </div>
<div class="line"><span class="lineno"> 1402</span>        <span class="comment"># Call tensordot if still possible</span></div>
<div class="line"><span class="lineno"> 1403</span>        <span class="keywordflow">if</span> blas:</div>
<div class="line"><span class="lineno"> 1404</span>            <span class="comment"># Checks have already been handled</span></div>
<div class="line"><span class="lineno"> 1405</span>            input_str, results_index = einsum_str.split(<span class="stringliteral">&#39;-&gt;&#39;</span>)</div>
<div class="line"><span class="lineno"> 1406</span>            input_left, input_right = input_str.split(<span class="stringliteral">&#39;,&#39;</span>)</div>
<div class="line"><span class="lineno"> 1407</span> </div>
<div class="line"><span class="lineno"> 1408</span>            tensor_result = input_left + input_right</div>
<div class="line"><span class="lineno"> 1409</span>            <span class="keywordflow">for</span> s <span class="keywordflow">in</span> idx_rm:</div>
<div class="line"><span class="lineno"> 1410</span>                tensor_result = tensor_result.replace(s, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1411</span> </div>
<div class="line"><span class="lineno"> 1412</span>            <span class="comment"># Find indices to contract over</span></div>
<div class="line"><span class="lineno"> 1413</span>            left_pos, right_pos = [], []</div>
<div class="line"><span class="lineno"> 1414</span>            <span class="keywordflow">for</span> s <span class="keywordflow">in</span> sorted(idx_rm):</div>
<div class="line"><span class="lineno"> 1415</span>                left_pos.append(input_left.find(s))</div>
<div class="line"><span class="lineno"> 1416</span>                right_pos.append(input_right.find(s))</div>
<div class="line"><span class="lineno"> 1417</span> </div>
<div class="line"><span class="lineno"> 1418</span>            <span class="comment"># Contract!</span></div>
<div class="line"><span class="lineno"> 1419</span>            new_view = tensordot(*tmp_operands, axes=(tuple(left_pos), tuple(right_pos)))</div>
<div class="line"><span class="lineno"> 1420</span> </div>
<div class="line"><span class="lineno"> 1421</span>            <span class="comment"># Build a new view if needed</span></div>
<div class="line"><span class="lineno"> 1422</span>            <span class="keywordflow">if</span> (tensor_result != results_index) <span class="keywordflow">or</span> handle_out:</div>
<div class="line"><span class="lineno"> 1423</span>                <span class="keywordflow">if</span> handle_out:</div>
<div class="line"><span class="lineno"> 1424</span>                    kwargs[<span class="stringliteral">&quot;out&quot;</span>] = out</div>
<div class="line"><span class="lineno"> 1425</span>                new_view = c_einsum(tensor_result + <span class="stringliteral">&#39;-&gt;&#39;</span> + results_index, new_view, **kwargs)</div>
<div class="line"><span class="lineno"> 1426</span> </div>
<div class="line"><span class="lineno"> 1427</span>        <span class="comment"># Call einsum</span></div>
<div class="line"><span class="lineno"> 1428</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1429</span>            <span class="comment"># If out was specified</span></div>
<div class="line"><span class="lineno"> 1430</span>            <span class="keywordflow">if</span> handle_out:</div>
<div class="line"><span class="lineno"> 1431</span>                kwargs[<span class="stringliteral">&quot;out&quot;</span>] = out</div>
<div class="line"><span class="lineno"> 1432</span> </div>
<div class="line"><span class="lineno"> 1433</span>            <span class="comment"># Do the contraction</span></div>
<div class="line"><span class="lineno"> 1434</span>            new_view = c_einsum(einsum_str, *tmp_operands, **kwargs)</div>
<div class="line"><span class="lineno"> 1435</span> </div>
<div class="line"><span class="lineno"> 1436</span>        <span class="comment"># Append new items and dereference what we can</span></div>
<div class="line"><span class="lineno"> 1437</span>        operands.append(new_view)</div>
<div class="line"><span class="lineno"> 1438</span>        del tmp_operands, new_view</div>
<div class="line"><span class="lineno"> 1439</span> </div>
<div class="line"><span class="lineno"> 1440</span>    <span class="keywordflow">if</span> specified_out:</div>
<div class="line"><span class="lineno"> 1441</span>        <span class="keywordflow">return</span> out</div>
<div class="line"><span class="lineno"> 1442</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1443</span>        <span class="keywordflow">return</span> asanyarray(operands[0], order=output_order)</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8df65e48c50e2ec96f2e23ea69249a32" name="a8df65e48c50e2ec96f2e23ea69249a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df65e48c50e2ec96f2e23ea69249a32">&#9670;&#160;</a></span>einsum_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc.einsum_path </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>optimize</em> = <code>'greedy'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>einsum_call</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">einsum_path(subscripts, *operands, optimize='greedy')

Evaluates the lowest cost contraction order for an einsum expression by
considering the creation of intermediate arrays.

Parameters
----------
subscripts : str
    Specifies the subscripts for summation.
*operands : list of array_like
    These are the arrays for the operation.
optimize : {bool, list, tuple, 'greedy', 'optimal'}
    Choose the type of path. If a tuple is provided, the second argument is
    assumed to be the maximum intermediate size created. If only a single
    argument is provided the largest input or output array size is used
    as a maximum intermediate size.

    * if a list is given that starts with ``einsum_path``, uses this as the
      contraction path
    * if False no optimization is taken
    * if True defaults to the 'greedy' algorithm
    * 'optimal' An algorithm that combinatorially explores all possible
      ways of contracting the listed tensors and choosest the least costly
      path. Scales exponentially with the number of terms in the
      contraction.
    * 'greedy' An algorithm that chooses the best pair contraction
      at each step. Effectively, this algorithm searches the largest inner,
      Hadamard, and then outer products at each step. Scales cubically with
      the number of terms in the contraction. Equivalent to the 'optimal'
      path for most contractions.

    Default is 'greedy'.

Returns
-------
path : list of tuples
    A list representation of the einsum path.
string_repr : str
    A printable representation of the einsum path.

Notes
-----
The resulting path indicates which terms of the input contraction should be
contracted first, the result of this contraction is then appended to the
end of the contraction list. This list can then be iterated over until all
intermediate contractions are complete.

See Also
--------
einsum, linalg.multi_dot

Examples
--------

We can begin with a chain dot example. In this case, it is optimal to
contract the ``b`` and ``c`` tensors first as represented by the first
element of the path ``(1, 2)``. The resulting tensor is added to the end
of the contraction and the remaining contraction ``(0, 1)`` is then
completed.

&gt;&gt;&gt; np.random.seed(123)
&gt;&gt;&gt; a = np.random.rand(2, 2)
&gt;&gt;&gt; b = np.random.rand(2, 5)
&gt;&gt;&gt; c = np.random.rand(5, 2)
&gt;&gt;&gt; path_info = np.einsum_path('ij,jk,kl-&gt;il', a, b, c, optimize='greedy')
&gt;&gt;&gt; print(path_info[0])
['einsum_path', (1, 2), (0, 1)]
&gt;&gt;&gt; print(path_info[1])
  Complete contraction:  ij,jk,kl-&gt;il # may vary
         Naive scaling:  4
     Optimized scaling:  3
      Naive FLOP count:  1.600e+02
  Optimized FLOP count:  5.600e+01
   Theoretical speedup:  2.857
  Largest intermediate:  4.000e+00 elements
-------------------------------------------------------------------------
scaling                  current                                remaining
-------------------------------------------------------------------------
   3                   kl,jk-&gt;jl                                ij,jl-&gt;il
   3                   jl,ij-&gt;il                                   il-&gt;il


A more complex index transformation example.

&gt;&gt;&gt; I = np.random.rand(10, 10, 10, 10)
&gt;&gt;&gt; C = np.random.rand(10, 10)
&gt;&gt;&gt; path_info = np.einsum_path('ea,fb,abcd,gc,hd-&gt;efgh', C, C, I, C, C,
...                            optimize='greedy')

&gt;&gt;&gt; print(path_info[0])
['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]
&gt;&gt;&gt; print(path_info[1]) 
  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary
         Naive scaling:  8
     Optimized scaling:  5
      Naive FLOP count:  8.000e+08
  Optimized FLOP count:  8.000e+05
   Theoretical speedup:  1000.000
  Largest intermediate:  1.000e+04 elements
--------------------------------------------------------------------------
scaling                  current                                remaining
--------------------------------------------------------------------------
   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh
   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh
   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh
   5               defg,hd-&gt;efgh                               efgh-&gt;efgh
</pre> <div class="fragment"><div class="line"><span class="lineno">  707</span><span class="keyword">def </span>einsum_path(*operands, optimize=&#39;greedy&#39;, einsum_call=False):</div>
<div class="line"><span class="lineno">  708</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    einsum_path(subscripts, *operands, optimize=&#39;greedy&#39;)</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">    Evaluates the lowest cost contraction order for an einsum expression by</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">    considering the creation of intermediate arrays.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  715</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  716</span><span class="stringliteral">    subscripts : str</span></div>
<div class="line"><span class="lineno">  717</span><span class="stringliteral">        Specifies the subscripts for summation.</span></div>
<div class="line"><span class="lineno">  718</span><span class="stringliteral">    *operands : list of array_like</span></div>
<div class="line"><span class="lineno">  719</span><span class="stringliteral">        These are the arrays for the operation.</span></div>
<div class="line"><span class="lineno">  720</span><span class="stringliteral">    optimize : {bool, list, tuple, &#39;greedy&#39;, &#39;optimal&#39;}</span></div>
<div class="line"><span class="lineno">  721</span><span class="stringliteral">        Choose the type of path. If a tuple is provided, the second argument is</span></div>
<div class="line"><span class="lineno">  722</span><span class="stringliteral">        assumed to be the maximum intermediate size created. If only a single</span></div>
<div class="line"><span class="lineno">  723</span><span class="stringliteral">        argument is provided the largest input or output array size is used</span></div>
<div class="line"><span class="lineno">  724</span><span class="stringliteral">        as a maximum intermediate size.</span></div>
<div class="line"><span class="lineno">  725</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  726</span><span class="stringliteral">        * if a list is given that starts with ``einsum_path``, uses this as the</span></div>
<div class="line"><span class="lineno">  727</span><span class="stringliteral">          contraction path</span></div>
<div class="line"><span class="lineno">  728</span><span class="stringliteral">        * if False no optimization is taken</span></div>
<div class="line"><span class="lineno">  729</span><span class="stringliteral">        * if True defaults to the &#39;greedy&#39; algorithm</span></div>
<div class="line"><span class="lineno">  730</span><span class="stringliteral">        * &#39;optimal&#39; An algorithm that combinatorially explores all possible</span></div>
<div class="line"><span class="lineno">  731</span><span class="stringliteral">          ways of contracting the listed tensors and choosest the least costly</span></div>
<div class="line"><span class="lineno">  732</span><span class="stringliteral">          path. Scales exponentially with the number of terms in the</span></div>
<div class="line"><span class="lineno">  733</span><span class="stringliteral">          contraction.</span></div>
<div class="line"><span class="lineno">  734</span><span class="stringliteral">        * &#39;greedy&#39; An algorithm that chooses the best pair contraction</span></div>
<div class="line"><span class="lineno">  735</span><span class="stringliteral">          at each step. Effectively, this algorithm searches the largest inner,</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">          Hadamard, and then outer products at each step. Scales cubically with</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral">          the number of terms in the contraction. Equivalent to the &#39;optimal&#39;</span></div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">          path for most contractions.</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        Default is &#39;greedy&#39;.</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">    path : list of tuples</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">        A list representation of the einsum path.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">    string_repr : str</span></div>
<div class="line"><span class="lineno">  747</span><span class="stringliteral">        A printable representation of the einsum path.</span></div>
<div class="line"><span class="lineno">  748</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  749</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  750</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  751</span><span class="stringliteral">    The resulting path indicates which terms of the input contraction should be</span></div>
<div class="line"><span class="lineno">  752</span><span class="stringliteral">    contracted first, the result of this contraction is then appended to the</span></div>
<div class="line"><span class="lineno">  753</span><span class="stringliteral">    end of the contraction list. This list can then be iterated over until all</span></div>
<div class="line"><span class="lineno">  754</span><span class="stringliteral">    intermediate contractions are complete.</span></div>
<div class="line"><span class="lineno">  755</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  756</span><span class="stringliteral">    See Also</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral">    einsum, linalg.multi_dot</span></div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">    Examples</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">    --------</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">    We can begin with a chain dot example. In this case, it is optimal to</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">    contract the ``b`` and ``c`` tensors first as represented by the first</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">    element of the path ``(1, 2)``. The resulting tensor is added to the end</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">    of the contraction and the remaining contraction ``(0, 1)`` is then</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">    completed.</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">    &gt;&gt;&gt; np.random.seed(123)</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">    &gt;&gt;&gt; a = np.random.rand(2, 2)</span></div>
<div class="line"><span class="lineno">  771</span><span class="stringliteral">    &gt;&gt;&gt; b = np.random.rand(2, 5)</span></div>
<div class="line"><span class="lineno">  772</span><span class="stringliteral">    &gt;&gt;&gt; c = np.random.rand(5, 2)</span></div>
<div class="line"><span class="lineno">  773</span><span class="stringliteral">    &gt;&gt;&gt; path_info = np.einsum_path(&#39;ij,jk,kl-&gt;il&#39;, a, b, c, optimize=&#39;greedy&#39;)</span></div>
<div class="line"><span class="lineno">  774</span><span class="stringliteral">    &gt;&gt;&gt; print(path_info[0])</span></div>
<div class="line"><span class="lineno">  775</span><span class="stringliteral">    [&#39;einsum_path&#39;, (1, 2), (0, 1)]</span></div>
<div class="line"><span class="lineno">  776</span><span class="stringliteral">    &gt;&gt;&gt; print(path_info[1])</span></div>
<div class="line"><span class="lineno">  777</span><span class="stringliteral">      Complete contraction:  ij,jk,kl-&gt;il # may vary</span></div>
<div class="line"><span class="lineno">  778</span><span class="stringliteral">             Naive scaling:  4</span></div>
<div class="line"><span class="lineno">  779</span><span class="stringliteral">         Optimized scaling:  3</span></div>
<div class="line"><span class="lineno">  780</span><span class="stringliteral">          Naive FLOP count:  1.600e+02</span></div>
<div class="line"><span class="lineno">  781</span><span class="stringliteral">      Optimized FLOP count:  5.600e+01</span></div>
<div class="line"><span class="lineno">  782</span><span class="stringliteral">       Theoretical speedup:  2.857</span></div>
<div class="line"><span class="lineno">  783</span><span class="stringliteral">      Largest intermediate:  4.000e+00 elements</span></div>
<div class="line"><span class="lineno">  784</span><span class="stringliteral">    -------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  785</span><span class="stringliteral">    scaling                  current                                remaining</span></div>
<div class="line"><span class="lineno">  786</span><span class="stringliteral">    -------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  787</span><span class="stringliteral">       3                   kl,jk-&gt;jl                                ij,jl-&gt;il</span></div>
<div class="line"><span class="lineno">  788</span><span class="stringliteral">       3                   jl,ij-&gt;il                                   il-&gt;il</span></div>
<div class="line"><span class="lineno">  789</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  791</span><span class="stringliteral">    A more complex index transformation example.</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral">    &gt;&gt;&gt; I = np.random.rand(10, 10, 10, 10)</span></div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">    &gt;&gt;&gt; C = np.random.rand(10, 10)</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">    &gt;&gt;&gt; path_info = np.einsum_path(&#39;ea,fb,abcd,gc,hd-&gt;efgh&#39;, C, C, I, C, C,</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">    ...                            optimize=&#39;greedy&#39;)</span></div>
<div class="line"><span class="lineno">  797</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  798</span><span class="stringliteral">    &gt;&gt;&gt; print(path_info[0])</span></div>
<div class="line"><span class="lineno">  799</span><span class="stringliteral">    [&#39;einsum_path&#39;, (0, 2), (0, 3), (0, 2), (0, 1)]</span></div>
<div class="line"><span class="lineno">  800</span><span class="stringliteral">    &gt;&gt;&gt; print(path_info[1]) </span></div>
<div class="line"><span class="lineno">  801</span><span class="stringliteral">      Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary</span></div>
<div class="line"><span class="lineno">  802</span><span class="stringliteral">             Naive scaling:  8</span></div>
<div class="line"><span class="lineno">  803</span><span class="stringliteral">         Optimized scaling:  5</span></div>
<div class="line"><span class="lineno">  804</span><span class="stringliteral">          Naive FLOP count:  8.000e+08</span></div>
<div class="line"><span class="lineno">  805</span><span class="stringliteral">      Optimized FLOP count:  8.000e+05</span></div>
<div class="line"><span class="lineno">  806</span><span class="stringliteral">       Theoretical speedup:  1000.000</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">      Largest intermediate:  1.000e+04 elements</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">    --------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">    scaling                  current                                remaining</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral">    --------------------------------------------------------------------------</span></div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">       5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral">       5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh</span></div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">       5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">       5               defg,hd-&gt;efgh                               efgh-&gt;efgh</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  816</span> </div>
<div class="line"><span class="lineno">  817</span>    <span class="comment"># Figure out what the path really is</span></div>
<div class="line"><span class="lineno">  818</span>    path_type = optimize</div>
<div class="line"><span class="lineno">  819</span>    <span class="keywordflow">if</span> path_type <span class="keywordflow">is</span> <span class="keyword">True</span>:</div>
<div class="line"><span class="lineno">  820</span>        path_type = <span class="stringliteral">&#39;greedy&#39;</span></div>
<div class="line"><span class="lineno">  821</span>    <span class="keywordflow">if</span> path_type <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  822</span>        path_type = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  823</span> </div>
<div class="line"><span class="lineno">  824</span>    explicit_einsum_path = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  825</span>    memory_limit = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  826</span> </div>
<div class="line"><span class="lineno">  827</span>    <span class="comment"># No optimization or a named path algorithm</span></div>
<div class="line"><span class="lineno">  828</span>    <span class="keywordflow">if</span> (path_type <span class="keywordflow">is</span> <span class="keyword">False</span>) <span class="keywordflow">or</span> isinstance(path_type, str):</div>
<div class="line"><span class="lineno">  829</span>        <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno">  830</span> </div>
<div class="line"><span class="lineno">  831</span>    <span class="comment"># Given an explicit path</span></div>
<div class="line"><span class="lineno">  832</span>    <span class="keywordflow">elif</span> len(path_type) <span class="keywordflow">and</span> (path_type[0] == <span class="stringliteral">&#39;einsum_path&#39;</span>):</div>
<div class="line"><span class="lineno">  833</span>        explicit_einsum_path = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  834</span> </div>
<div class="line"><span class="lineno">  835</span>    <span class="comment"># Path tuple with memory limit</span></div>
<div class="line"><span class="lineno">  836</span>    <span class="keywordflow">elif</span> ((len(path_type) == 2) <span class="keywordflow">and</span> isinstance(path_type[0], str) <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  837</span>            isinstance(path_type[1], (int, float))):</div>
<div class="line"><span class="lineno">  838</span>        memory_limit = int(path_type[1])</div>
<div class="line"><span class="lineno">  839</span>        path_type = path_type[0]</div>
<div class="line"><span class="lineno">  840</span> </div>
<div class="line"><span class="lineno">  841</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  842</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Did not understand the path: %s&quot;</span> % str(path_type))</div>
<div class="line"><span class="lineno">  843</span> </div>
<div class="line"><span class="lineno">  844</span>    <span class="comment"># Hidden option, only einsum should call this</span></div>
<div class="line"><span class="lineno">  845</span>    einsum_call_arg = einsum_call</div>
<div class="line"><span class="lineno">  846</span> </div>
<div class="line"><span class="lineno">  847</span>    <span class="comment"># Python side parsing</span></div>
<div class="line"><span class="lineno">  848</span>    input_subscripts, output_subscript, operands = _parse_einsum_input(operands)</div>
<div class="line"><span class="lineno">  849</span> </div>
<div class="line"><span class="lineno">  850</span>    <span class="comment"># Build a few useful list and sets</span></div>
<div class="line"><span class="lineno">  851</span>    input_list = input_subscripts.split(<span class="stringliteral">&#39;,&#39;</span>)</div>
<div class="line"><span class="lineno">  852</span>    input_sets = [set(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> input_list]</div>
<div class="line"><span class="lineno">  853</span>    output_set = set(output_subscript)</div>
<div class="line"><span class="lineno">  854</span>    indices = set(input_subscripts.replace(<span class="stringliteral">&#39;,&#39;</span>, <span class="stringliteral">&#39;&#39;</span>))</div>
<div class="line"><span class="lineno">  855</span> </div>
<div class="line"><span class="lineno">  856</span>    <span class="comment"># Get length of each unique dimension and ensure all dimensions are correct</span></div>
<div class="line"><span class="lineno">  857</span>    dimension_dict = {}</div>
<div class="line"><span class="lineno">  858</span>    broadcast_indices = [[] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> range(len(input_list))]</div>
<div class="line"><span class="lineno">  859</span>    <span class="keywordflow">for</span> tnum, term <span class="keywordflow">in</span> enumerate(input_list):</div>
<div class="line"><span class="lineno">  860</span>        sh = operands[tnum].shape</div>
<div class="line"><span class="lineno">  861</span>        <span class="keywordflow">if</span> len(sh) != len(term):</div>
<div class="line"><span class="lineno">  862</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Einstein sum subscript %s does not contain the &quot;</span></div>
<div class="line"><span class="lineno">  863</span>                             <span class="stringliteral">&quot;correct number of indices for operand %d.&quot;</span></div>
<div class="line"><span class="lineno">  864</span>                             % (input_subscripts[tnum], tnum))</div>
<div class="line"><span class="lineno">  865</span>        <span class="keywordflow">for</span> cnum, char <span class="keywordflow">in</span> enumerate(term):</div>
<div class="line"><span class="lineno">  866</span>            dim = sh[cnum]</div>
<div class="line"><span class="lineno">  867</span> </div>
<div class="line"><span class="lineno">  868</span>            <span class="comment"># Build out broadcast indices</span></div>
<div class="line"><span class="lineno">  869</span>            <span class="keywordflow">if</span> dim == 1:</div>
<div class="line"><span class="lineno">  870</span>                broadcast_indices[tnum].append(char)</div>
<div class="line"><span class="lineno">  871</span> </div>
<div class="line"><span class="lineno">  872</span>            <span class="keywordflow">if</span> char <span class="keywordflow">in</span> dimension_dict.keys():</div>
<div class="line"><span class="lineno">  873</span>                <span class="comment"># For broadcasting cases we always want the largest dim size</span></div>
<div class="line"><span class="lineno">  874</span>                <span class="keywordflow">if</span> dimension_dict[char] == 1:</div>
<div class="line"><span class="lineno">  875</span>                    dimension_dict[char] = dim</div>
<div class="line"><span class="lineno">  876</span>                <span class="keywordflow">elif</span> dim <span class="keywordflow">not</span> <span class="keywordflow">in</span> (1, dimension_dict[char]):</div>
<div class="line"><span class="lineno">  877</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Size of label &#39;%s&#39; for operand %d (%d) &quot;</span></div>
<div class="line"><span class="lineno">  878</span>                                     <span class="stringliteral">&quot;does not match previous terms (%d).&quot;</span></div>
<div class="line"><span class="lineno">  879</span>                                     % (char, tnum, dimension_dict[char], dim))</div>
<div class="line"><span class="lineno">  880</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  881</span>                dimension_dict[char] = dim</div>
<div class="line"><span class="lineno">  882</span> </div>
<div class="line"><span class="lineno">  883</span>    <span class="comment"># Convert broadcast inds to sets</span></div>
<div class="line"><span class="lineno">  884</span>    broadcast_indices = [set(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> broadcast_indices]</div>
<div class="line"><span class="lineno">  885</span> </div>
<div class="line"><span class="lineno">  886</span>    <span class="comment"># Compute size of each input array plus the output array</span></div>
<div class="line"><span class="lineno">  887</span>    size_list = [_compute_size_by_dict(term, dimension_dict)</div>
<div class="line"><span class="lineno">  888</span>                 <span class="keywordflow">for</span> term <span class="keywordflow">in</span> input_list + [output_subscript]]</div>
<div class="line"><span class="lineno">  889</span>    max_size = max(size_list)</div>
<div class="line"><span class="lineno">  890</span> </div>
<div class="line"><span class="lineno">  891</span>    <span class="keywordflow">if</span> memory_limit <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  892</span>        memory_arg = max_size</div>
<div class="line"><span class="lineno">  893</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  894</span>        memory_arg = memory_limit</div>
<div class="line"><span class="lineno">  895</span> </div>
<div class="line"><span class="lineno">  896</span>    <span class="comment"># Compute naive cost</span></div>
<div class="line"><span class="lineno">  897</span>    <span class="comment"># This isn&#39;t quite right, need to look into exactly how einsum does this</span></div>
<div class="line"><span class="lineno">  898</span>    inner_product = (sum(len(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> input_sets) - len(indices)) &gt; 0</div>
<div class="line"><span class="lineno">  899</span>    naive_cost = _flop_count(indices, inner_product, len(input_list), dimension_dict)</div>
<div class="line"><span class="lineno">  900</span> </div>
<div class="line"><span class="lineno">  901</span>    <span class="comment"># Compute the path</span></div>
<div class="line"><span class="lineno">  902</span>    <span class="keywordflow">if</span> explicit_einsum_path:</div>
<div class="line"><span class="lineno">  903</span>        path = path_type[1:]</div>
<div class="line"><span class="lineno">  904</span>    <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  905</span>        (path_type <span class="keywordflow">is</span> <span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  906</span>        <span class="keywordflow">or</span> (len(input_list) <span class="keywordflow">in</span> [1, 2])</div>
<div class="line"><span class="lineno">  907</span>        <span class="keywordflow">or</span> (indices == output_set)</div>
<div class="line"><span class="lineno">  908</span>    ):</div>
<div class="line"><span class="lineno">  909</span>        <span class="comment"># Nothing to be optimized, leave it to einsum</span></div>
<div class="line"><span class="lineno">  910</span>        path = [tuple(range(len(input_list)))]</div>
<div class="line"><span class="lineno">  911</span>    <span class="keywordflow">elif</span> path_type == <span class="stringliteral">&quot;greedy&quot;</span>:</div>
<div class="line"><span class="lineno">  912</span>        path = _greedy_path(input_sets, output_set, dimension_dict, memory_arg)</div>
<div class="line"><span class="lineno">  913</span>    <span class="keywordflow">elif</span> path_type == <span class="stringliteral">&quot;optimal&quot;</span>:</div>
<div class="line"><span class="lineno">  914</span>        path = _optimal_path(input_sets, output_set, dimension_dict, memory_arg)</div>
<div class="line"><span class="lineno">  915</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  916</span>        <span class="keywordflow">raise</span> KeyError(<span class="stringliteral">&quot;Path name %s not found&quot;</span>, path_type)</div>
<div class="line"><span class="lineno">  917</span> </div>
<div class="line"><span class="lineno">  918</span>    cost_list, scale_list, size_list, contraction_list = [], [], [], []</div>
<div class="line"><span class="lineno">  919</span> </div>
<div class="line"><span class="lineno">  920</span>    <span class="comment"># Build contraction tuple (positions, gemm, einsum_str, remaining)</span></div>
<div class="line"><span class="lineno">  921</span>    <span class="keywordflow">for</span> cnum, contract_inds <span class="keywordflow">in</span> enumerate(path):</div>
<div class="line"><span class="lineno">  922</span>        <span class="comment"># Make sure we remove inds from right to left</span></div>
<div class="line"><span class="lineno">  923</span>        contract_inds = tuple(sorted(list(contract_inds), reverse=<span class="keyword">True</span>))</div>
<div class="line"><span class="lineno">  924</span> </div>
<div class="line"><span class="lineno">  925</span>        contract = _find_contraction(contract_inds, input_sets, output_set)</div>
<div class="line"><span class="lineno">  926</span>        out_inds, input_sets, idx_removed, idx_contract = contract</div>
<div class="line"><span class="lineno">  927</span> </div>
<div class="line"><span class="lineno">  928</span>        cost = _flop_count(idx_contract, idx_removed, len(contract_inds), dimension_dict)</div>
<div class="line"><span class="lineno">  929</span>        cost_list.append(cost)</div>
<div class="line"><span class="lineno">  930</span>        scale_list.append(len(idx_contract))</div>
<div class="line"><span class="lineno">  931</span>        size_list.append(_compute_size_by_dict(out_inds, dimension_dict))</div>
<div class="line"><span class="lineno">  932</span> </div>
<div class="line"><span class="lineno">  933</span>        bcast = set()</div>
<div class="line"><span class="lineno">  934</span>        tmp_inputs = []</div>
<div class="line"><span class="lineno">  935</span>        <span class="keywordflow">for</span> x <span class="keywordflow">in</span> contract_inds:</div>
<div class="line"><span class="lineno">  936</span>            tmp_inputs.append(input_list.pop(x))</div>
<div class="line"><span class="lineno">  937</span>            bcast |= broadcast_indices.pop(x)</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>        new_bcast_inds = bcast - idx_removed</div>
<div class="line"><span class="lineno">  940</span> </div>
<div class="line"><span class="lineno">  941</span>        <span class="comment"># If we&#39;re broadcasting, nix blas</span></div>
<div class="line"><span class="lineno">  942</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(idx_removed &amp; bcast):</div>
<div class="line"><span class="lineno">  943</span>            do_blas = _can_dot(tmp_inputs, out_inds, idx_removed)</div>
<div class="line"><span class="lineno">  944</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  945</span>            do_blas = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  946</span> </div>
<div class="line"><span class="lineno">  947</span>        <span class="comment"># Last contraction</span></div>
<div class="line"><span class="lineno">  948</span>        <span class="keywordflow">if</span> (cnum - len(path)) == -1:</div>
<div class="line"><span class="lineno">  949</span>            idx_result = output_subscript</div>
<div class="line"><span class="lineno">  950</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  951</span>            sort_result = [(dimension_dict[ind], ind) <span class="keywordflow">for</span> ind <span class="keywordflow">in</span> out_inds]</div>
<div class="line"><span class="lineno">  952</span>            idx_result = <span class="stringliteral">&quot;&quot;</span>.join([x[1] <span class="keywordflow">for</span> x <span class="keywordflow">in</span> sorted(sort_result)])</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span>        input_list.append(idx_result)</div>
<div class="line"><span class="lineno">  955</span>        broadcast_indices.append(new_bcast_inds)</div>
<div class="line"><span class="lineno">  956</span>        einsum_str = <span class="stringliteral">&quot;,&quot;</span>.join(tmp_inputs) + <span class="stringliteral">&quot;-&gt;&quot;</span> + idx_result</div>
<div class="line"><span class="lineno">  957</span> </div>
<div class="line"><span class="lineno">  958</span>        contraction = (contract_inds, idx_removed, einsum_str, input_list[:], do_blas)</div>
<div class="line"><span class="lineno">  959</span>        contraction_list.append(contraction)</div>
<div class="line"><span class="lineno">  960</span> </div>
<div class="line"><span class="lineno">  961</span>    opt_cost = sum(cost_list) + 1</div>
<div class="line"><span class="lineno">  962</span> </div>
<div class="line"><span class="lineno">  963</span>    <span class="keywordflow">if</span> len(input_list) != 1:</div>
<div class="line"><span class="lineno">  964</span>        <span class="comment"># Explicit &quot;einsum_path&quot; is usually trusted, but we detect this kind of</span></div>
<div class="line"><span class="lineno">  965</span>        <span class="comment"># mistake in order to prevent from returning an intermediate value.</span></div>
<div class="line"><span class="lineno">  966</span>        <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno">  967</span>            <span class="stringliteral">&quot;Invalid einsum_path is specified: {} more operands has to be &quot;</span></div>
<div class="line"><span class="lineno">  968</span>            <span class="stringliteral">&quot;contracted.&quot;</span>.format(len(input_list) - 1))</div>
<div class="line"><span class="lineno">  969</span> </div>
<div class="line"><span class="lineno">  970</span>    <span class="keywordflow">if</span> einsum_call_arg:</div>
<div class="line"><span class="lineno">  971</span>        <span class="keywordflow">return</span> (operands, contraction_list)</div>
<div class="line"><span class="lineno">  972</span> </div>
<div class="line"><span class="lineno">  973</span>    <span class="comment"># Return the path along with a nice string representation</span></div>
<div class="line"><span class="lineno">  974</span>    overall_contraction = input_subscripts + <span class="stringliteral">&quot;-&gt;&quot;</span> + output_subscript</div>
<div class="line"><span class="lineno">  975</span>    header = (<span class="stringliteral">&quot;scaling&quot;</span>, <span class="stringliteral">&quot;current&quot;</span>, <span class="stringliteral">&quot;remaining&quot;</span>)</div>
<div class="line"><span class="lineno">  976</span> </div>
<div class="line"><span class="lineno">  977</span>    speedup = naive_cost / opt_cost</div>
<div class="line"><span class="lineno">  978</span>    max_i = max(size_list)</div>
<div class="line"><span class="lineno">  979</span> </div>
<div class="line"><span class="lineno">  980</span>    path_print  = <span class="stringliteral">&quot;  Complete contraction:  %s\n&quot;</span> % overall_contraction</div>
<div class="line"><span class="lineno">  981</span>    path_print += <span class="stringliteral">&quot;         Naive scaling:  %d\n&quot;</span> % len(indices)</div>
<div class="line"><span class="lineno">  982</span>    path_print += <span class="stringliteral">&quot;     Optimized scaling:  %d\n&quot;</span> % max(scale_list)</div>
<div class="line"><span class="lineno">  983</span>    path_print += <span class="stringliteral">&quot;      Naive FLOP count:  %.3e\n&quot;</span> % naive_cost</div>
<div class="line"><span class="lineno">  984</span>    path_print += <span class="stringliteral">&quot;  Optimized FLOP count:  %.3e\n&quot;</span> % opt_cost</div>
<div class="line"><span class="lineno">  985</span>    path_print += <span class="stringliteral">&quot;   Theoretical speedup:  %3.3f\n&quot;</span> % speedup</div>
<div class="line"><span class="lineno">  986</span>    path_print += <span class="stringliteral">&quot;  Largest intermediate:  %.3e elements\n&quot;</span> % max_i</div>
<div class="line"><span class="lineno">  987</span>    path_print += <span class="stringliteral">&quot;-&quot;</span> * 74 + <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line"><span class="lineno">  988</span>    path_print += <span class="stringliteral">&quot;%6s %24s %40s\n&quot;</span> % header</div>
<div class="line"><span class="lineno">  989</span>    path_print += <span class="stringliteral">&quot;-&quot;</span> * 74</div>
<div class="line"><span class="lineno">  990</span> </div>
<div class="line"><span class="lineno">  991</span>    <span class="keywordflow">for</span> n, contraction <span class="keywordflow">in</span> enumerate(contraction_list):</div>
<div class="line"><span class="lineno">  992</span>        inds, idx_rm, einsum_str, remaining, blas = contraction</div>
<div class="line"><span class="lineno">  993</span>        remaining_str = <span class="stringliteral">&quot;,&quot;</span>.join(remaining) + <span class="stringliteral">&quot;-&gt;&quot;</span> + output_subscript</div>
<div class="line"><span class="lineno">  994</span>        path_run = (scale_list[n], einsum_str, remaining_str)</div>
<div class="line"><span class="lineno">  995</span>        path_print += <span class="stringliteral">&quot;\n%4d    %24s %40s&quot;</span> % path_run</div>
<div class="line"><span class="lineno">  996</span> </div>
<div class="line"><span class="lineno">  997</span>    path = [<span class="stringliteral">&#39;einsum_path&#39;</span>] + path</div>
<div class="line"><span class="lineno">  998</span>    <span class="keywordflow">return</span> (path, path_print)</div>
<div class="line"><span class="lineno">  999</span> </div>
<div class="line"><span class="lineno"> 1000</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a18a08d7e10c94d25799a8e1a57922e23" name="a18a08d7e10c94d25799a8e1a57922e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18a08d7e10c94d25799a8e1a57922e23">&#9670;&#160;</a></span>einsum_symbols</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">str numpy.core.einsumfunc.einsum_symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9434bd5793781fc806f488c58228d32" name="ae9434bd5793781fc806f488c58228d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9434bd5793781fc806f488c58228d32">&#9670;&#160;</a></span>einsum_symbols_set</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.einsumfunc.einsum_symbols_set = set(<a class="el" href="namespacenumpy_1_1core_1_1einsumfunc.html#a18a08d7e10c94d25799a8e1a57922e23">einsum_symbols</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
