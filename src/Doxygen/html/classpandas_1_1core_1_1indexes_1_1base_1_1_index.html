<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.indexes.base.Index Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1indexes.html">indexes</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html">base</a></li><li class="navelem"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#properties">Properties</a> &#124;
<a href="classpandas_1_1core_1_1indexes_1_1base_1_1_index-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.indexes.base.Index Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for pandas.core.indexes.base.Index:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classpandas_1_1core_1_1indexes_1_1base_1_1_index.png" usemap="#pandas.core.indexes.base.Index_map" alt=""/>
  <map id="pandas.core.indexes.base.Index_map" name="pandas.core.indexes.base.Index_map">
<area href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html" alt="pandas.core.base.IndexOpsMixin" shape="rect" coords="567,56,935,80"/>
<area href="classpandas_1_1core_1_1base_1_1_pandas_object.html" alt="pandas.core.base.PandasObject" shape="rect" coords="945,56,1313,80"/>
<area href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html" alt="pandas.core.arraylike.OpsMixin" shape="rect" coords="567,0,935,24"/>
<area href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html" alt="pandas.core.accessor.DirNamesMixin" shape="rect" coords="945,0,1313,24"/>
<area href="classpandas_1_1core_1_1indexes_1_1extension_1_1_extension_index.html" alt="pandas.core.indexes.extension.ExtensionIndex" shape="rect" coords="378,168,746,192"/>
<area href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html" alt="pandas.core.indexes.multi.MultiIndex" shape="rect" coords="756,168,1124,192"/>
<area href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html" alt="pandas.core.indexes.numeric.NumericIndex" shape="rect" coords="1323,168,1691,192"/>
<area href="classpandas_1_1core_1_1indexes_1_1extension_1_1_n_d_array_backed_extension_index.html" alt="pandas.core.indexes.extension.NDArrayBackedExtensionIndex" shape="rect" coords="189,224,557,248"/>
<area href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html" alt="pandas.core.indexes.interval.IntervalIndex" shape="rect" coords="567,224,935,248"/>
<area href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_float64_index.html" alt="pandas.core.indexes.numeric.Float64Index" shape="rect" coords="945,224,1313,248"/>
<area href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_integer_index.html" alt="pandas.core.indexes.numeric.IntegerIndex" shape="rect" coords="1323,224,1691,248"/>
<area href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html" alt="pandas.core.indexes.range.RangeIndex" shape="rect" coords="1701,224,2069,248"/>
<area href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html" alt="pandas.core.indexes.category.CategoricalIndex" shape="rect" coords="0,280,368,304"/>
<area href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html" alt="pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin" shape="rect" coords="378,280,746,304"/>
<area href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_int64_index.html" alt="pandas.core.indexes.numeric.Int64Index" shape="rect" coords="1134,280,1502,304"/>
<area href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_u_int64_index.html" alt="pandas.core.indexes.numeric.UInt64Index" shape="rect" coords="1512,280,1880,304"/>
<area href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html" alt="pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin" shape="rect" coords="189,336,557,360"/>
<area href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html" alt="pandas.core.indexes.period.PeriodIndex" shape="rect" coords="567,336,935,360"/>
<area href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html" alt="pandas.core.indexes.datetimes.DatetimeIndex" shape="rect" coords="0,392,368,416"/>
<area href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html" alt="pandas.core.indexes.timedeltas.TimedeltaIndex" shape="rect" coords="378,392,746,416"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1fb6b348defa931b9543581955a35d1b" id="r_a1fb6b348defa931b9543581955a35d1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a1fb6b348defa931b9543581955a35d1b">__new__</a> (cls, data=None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>=None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f9ce0340d28fefd8934989df2681722">copy</a>=False, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None, tupleize_cols=True, **kwargs)</td></tr>
<tr class="separator:a1fb6b348defa931b9543581955a35d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8742fa5bd6250a1bc5ae3be7c139f570" id="r_a8742fa5bd6250a1bc5ae3be7c139f570"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8742fa5bd6250a1bc5ae3be7c139f570">asi8</a> (self)</td></tr>
<tr class="separator:a8742fa5bd6250a1bc5ae3be7c139f570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd960d46f2c19b3672210af966a0d5f" id="r_abbd960d46f2c19b3672210af966a0d5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abbd960d46f2c19b3672210af966a0d5f">is_</a> (self, other)</td></tr>
<tr class="separator:abbd960d46f2c19b3672210af966a0d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c75c1fa745494cfc6f3e5a81392c81" id="r_a47c75c1fa745494cfc6f3e5a81392c81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a47c75c1fa745494cfc6f3e5a81392c81">__len__</a> (self)</td></tr>
<tr class="separator:a47c75c1fa745494cfc6f3e5a81392c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52343e9e9a3aab236fa2227714459739" id="r_a52343e9e9a3aab236fa2227714459739"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a52343e9e9a3aab236fa2227714459739">__array__</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>=None)</td></tr>
<tr class="separator:a52343e9e9a3aab236fa2227714459739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46041d6654fda153af5f0c607043bbc" id="r_ae46041d6654fda153af5f0c607043bbc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae46041d6654fda153af5f0c607043bbc">__array_ufunc__</a> (self, np.ufunc <a class="el" href="structufunc.html">ufunc</a>, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> method, *inputs, **kwargs)</td></tr>
<tr class="separator:ae46041d6654fda153af5f0c607043bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0045ef17048a0f4eea8d37fee1b1707" id="r_af0045ef17048a0f4eea8d37fee1b1707"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af0045ef17048a0f4eea8d37fee1b1707">__array_wrap__</a> (self, result, context=None)</td></tr>
<tr class="separator:af0045ef17048a0f4eea8d37fee1b1707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ddb1903b411542fb12a8eadd1cbf14" id="r_a59ddb1903b411542fb12a8eadd1cbf14"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a59ddb1903b411542fb12a8eadd1cbf14">dtype</a> (self)</td></tr>
<tr class="separator:a59ddb1903b411542fb12a8eadd1cbf14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63697423c8bd64935ff3fcb7f9b9c704" id="r_a63697423c8bd64935ff3fcb7f9b9c704"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a63697423c8bd64935ff3fcb7f9b9c704">ravel</a> (self, <a class="el" href="__lapack__subroutines_8h.html#a9993259f1ab17738593f079acd0507d9">order</a>=&quot;C&quot;)</td></tr>
<tr class="separator:a63697423c8bd64935ff3fcb7f9b9c704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab772a111da653666c2456e4ad06e4011" id="r_ab772a111da653666c2456e4ad06e4011"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab772a111da653666c2456e4ad06e4011">view</a> (self, cls=None)</td></tr>
<tr class="separator:ab772a111da653666c2456e4ad06e4011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a248f0c2a5875cdd3e5ab34220dc34950" id="r_a248f0c2a5875cdd3e5ab34220dc34950"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a248f0c2a5875cdd3e5ab34220dc34950">astype</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f9ce0340d28fefd8934989df2681722">copy</a>=True)</td></tr>
<tr class="separator:a248f0c2a5875cdd3e5ab34220dc34950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acae5a2f01a74e5510fba2a0d958c58" id="r_a4acae5a2f01a74e5510fba2a0d958c58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4acae5a2f01a74e5510fba2a0d958c58">take</a> (self, indices, int axis=0, bool allow_fill=True, fill_value=None, **kwargs)</td></tr>
<tr class="separator:a4acae5a2f01a74e5510fba2a0d958c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d018340edd883764366684191d07bec" id="r_a0d018340edd883764366684191d07bec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0d018340edd883764366684191d07bec">repeat</a> (self, repeats, axis=None)</td></tr>
<tr class="separator:a0d018340edd883764366684191d07bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9ce0340d28fefd8934989df2681722" id="r_a6f9ce0340d28fefd8934989df2681722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f9ce0340d28fefd8934989df2681722">copy</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, Hashable|None <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None, bool deep=False, Dtype|None <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>=None, Sequence[Hashable]|None <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aeb583e3bb8a437f0d1a6fb0b82510359">names</a>=None)</td></tr>
<tr class="separator:a6f9ce0340d28fefd8934989df2681722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f2c34b78c4f428a0a3ae1fa1fbe3f4" id="r_a63f2c34b78c4f428a0a3ae1fa1fbe3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a63f2c34b78c4f428a0a3ae1fa1fbe3f4">__copy__</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, **kwargs)</td></tr>
<tr class="separator:a63f2c34b78c4f428a0a3ae1fa1fbe3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360f6c3cc0ffe7e2dd96fcc2593905b2" id="r_a360f6c3cc0ffe7e2dd96fcc2593905b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a360f6c3cc0ffe7e2dd96fcc2593905b2">__deepcopy__</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, memo=None)</td></tr>
<tr class="separator:a360f6c3cc0ffe7e2dd96fcc2593905b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4df78e1853b3851a41a2e404d2cba7" id="r_afe4df78e1853b3851a41a2e404d2cba7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#afe4df78e1853b3851a41a2e404d2cba7">__repr__</a> (self)</td></tr>
<tr class="separator:afe4df78e1853b3851a41a2e404d2cba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af499fd538f621f813b9334cef63bb4" id="r_a4af499fd538f621f813b9334cef63bb4"><td class="memItemLeft" align="right" valign="top">list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4af499fd538f621f813b9334cef63bb4">format</a> (self, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=False, Callable|None formatter=None, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> na_rep=&quot;NaN&quot;)</td></tr>
<tr class="separator:a4af499fd538f621f813b9334cef63bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510319047221a98c0711ab2c7143d3a5" id="r_a510319047221a98c0711ab2c7143d3a5"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a510319047221a98c0711ab2c7143d3a5">to_native_types</a> (self, slicer=None, **kwargs)</td></tr>
<tr class="separator:a510319047221a98c0711ab2c7143d3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114ff045cc2d8a50f2394e1162f11c6" id="r_a0114ff045cc2d8a50f2394e1162f11c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0114ff045cc2d8a50f2394e1162f11c6">to_flat_index</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self)</td></tr>
<tr class="separator:a0114ff045cc2d8a50f2394e1162f11c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71c5a6568f71daad5207d82f6a4ae24" id="r_ae71c5a6568f71daad5207d82f6a4ae24"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae71c5a6568f71daad5207d82f6a4ae24">to_series</a> (self, index=None, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None)</td></tr>
<tr class="separator:ae71c5a6568f71daad5207d82f6a4ae24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d82e4535ac4015c47bfde741f81c36" id="r_a54d82e4535ac4015c47bfde741f81c36"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a54d82e4535ac4015c47bfde741f81c36">to_frame</a> (self, bool index=True, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=lib.no_default)</td></tr>
<tr class="separator:a54d82e4535ac4015c47bfde741f81c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979e8567cfbe07a32d0f53107d24892c" id="r_a979e8567cfbe07a32d0f53107d24892c"><td class="memItemLeft" align="right" valign="top">Hashable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a979e8567cfbe07a32d0f53107d24892c">name</a> (self)</td></tr>
<tr class="separator:a979e8567cfbe07a32d0f53107d24892c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605b2a0ca7b7735a13cc7db6d790d49a" id="r_a605b2a0ca7b7735a13cc7db6d790d49a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a605b2a0ca7b7735a13cc7db6d790d49a">name</a> (self, Hashable value)</td></tr>
<tr class="separator:a605b2a0ca7b7735a13cc7db6d790d49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6ae31c0ddc828de69ebdfb0184f509" id="r_a0f6ae31c0ddc828de69ebdfb0184f509"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0f6ae31c0ddc828de69ebdfb0184f509">set_names</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aeb583e3bb8a437f0d1a6fb0b82510359">names</a>, level=None, bool inplace=False)</td></tr>
<tr class="separator:a0f6ae31c0ddc828de69ebdfb0184f509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929c0b566c56a9b6f3af237f33590ae6" id="r_a929c0b566c56a9b6f3af237f33590ae6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a929c0b566c56a9b6f3af237f33590ae6">rename</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>, inplace=False)</td></tr>
<tr class="separator:a929c0b566c56a9b6f3af237f33590ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0097bb44007439e46044fa7ef902c8" id="r_add0097bb44007439e46044fa7ef902c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#add0097bb44007439e46044fa7ef902c8">nlevels</a> (self)</td></tr>
<tr class="separator:add0097bb44007439e46044fa7ef902c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2796389d83ddd71eb4ab883440fe92ee" id="r_a2796389d83ddd71eb4ab883440fe92ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2796389d83ddd71eb4ab883440fe92ee">sortlevel</a> (self, level=None, ascending=True, sort_remaining=None)</td></tr>
<tr class="separator:a2796389d83ddd71eb4ab883440fe92ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae48a1cd410ee175df42645d47ba596b" id="r_aae48a1cd410ee175df42645d47ba596b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aae48a1cd410ee175df42645d47ba596b">droplevel</a> (self, level=0)</td></tr>
<tr class="separator:aae48a1cd410ee175df42645d47ba596b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db5340ed49b3a98f4d9c8d71ff185d1" id="r_a8db5340ed49b3a98f4d9c8d71ff185d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8db5340ed49b3a98f4d9c8d71ff185d1">is_monotonic</a> (self)</td></tr>
<tr class="separator:a8db5340ed49b3a98f4d9c8d71ff185d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b8a90f3bb4fd121aa68ce876f03901" id="r_a52b8a90f3bb4fd121aa68ce876f03901"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a52b8a90f3bb4fd121aa68ce876f03901">is_monotonic_increasing</a> (self)</td></tr>
<tr class="separator:a52b8a90f3bb4fd121aa68ce876f03901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51889270cdfc9b14c65f016f1c077a6d" id="r_a51889270cdfc9b14c65f016f1c077a6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a51889270cdfc9b14c65f016f1c077a6d">is_monotonic_decreasing</a> (self)</td></tr>
<tr class="separator:a51889270cdfc9b14c65f016f1c077a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a561a56933b9b4d2f641a8c20052c9d64" id="r_a561a56933b9b4d2f641a8c20052c9d64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a561a56933b9b4d2f641a8c20052c9d64">is_unique</a> (self)</td></tr>
<tr class="separator:a561a56933b9b4d2f641a8c20052c9d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c61640fa376eeca9c49deb83154c97" id="r_ad4c61640fa376eeca9c49deb83154c97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad4c61640fa376eeca9c49deb83154c97">has_duplicates</a> (self)</td></tr>
<tr class="separator:ad4c61640fa376eeca9c49deb83154c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058ecbb1133fb00a575c2b475935996b" id="r_a058ecbb1133fb00a575c2b475935996b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a058ecbb1133fb00a575c2b475935996b">is_boolean</a> (self)</td></tr>
<tr class="separator:a058ecbb1133fb00a575c2b475935996b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41724f23783dc0ff8427ce141539b88d" id="r_a41724f23783dc0ff8427ce141539b88d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a41724f23783dc0ff8427ce141539b88d">is_integer</a> (self)</td></tr>
<tr class="separator:a41724f23783dc0ff8427ce141539b88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5617ac233bbb693188e32114b469db82" id="r_a5617ac233bbb693188e32114b469db82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5617ac233bbb693188e32114b469db82">is_floating</a> (self)</td></tr>
<tr class="separator:a5617ac233bbb693188e32114b469db82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3a3d0393d53c0cd227e205b07718e4" id="r_aef3a3d0393d53c0cd227e205b07718e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aef3a3d0393d53c0cd227e205b07718e4">is_numeric</a> (self)</td></tr>
<tr class="separator:aef3a3d0393d53c0cd227e205b07718e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408521f8b4a1b63413f1ec3d2ce85c22" id="r_a408521f8b4a1b63413f1ec3d2ce85c22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a408521f8b4a1b63413f1ec3d2ce85c22">is_object</a> (self)</td></tr>
<tr class="separator:a408521f8b4a1b63413f1ec3d2ce85c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f2a24053b72b85f81ff7a52c493a74" id="r_a37f2a24053b72b85f81ff7a52c493a74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a37f2a24053b72b85f81ff7a52c493a74">is_categorical</a> (self)</td></tr>
<tr class="separator:a37f2a24053b72b85f81ff7a52c493a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977c91d9f1d44004e703a64d9aa1956f" id="r_a977c91d9f1d44004e703a64d9aa1956f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a977c91d9f1d44004e703a64d9aa1956f">is_interval</a> (self)</td></tr>
<tr class="separator:a977c91d9f1d44004e703a64d9aa1956f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab3ba2bda01f4ea001008a0af26974fa" id="r_aab3ba2bda01f4ea001008a0af26974fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aab3ba2bda01f4ea001008a0af26974fa">is_mixed</a> (self)</td></tr>
<tr class="separator:aab3ba2bda01f4ea001008a0af26974fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142be584fc0bb24c9f076fa8d23297a2" id="r_a142be584fc0bb24c9f076fa8d23297a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a142be584fc0bb24c9f076fa8d23297a2">holds_integer</a> (self)</td></tr>
<tr class="separator:a142be584fc0bb24c9f076fa8d23297a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a22dc88869208aa9ebe329128d4db9b" id="r_a3a22dc88869208aa9ebe329128d4db9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3a22dc88869208aa9ebe329128d4db9b">inferred_type</a> (self)</td></tr>
<tr class="separator:a3a22dc88869208aa9ebe329128d4db9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc7c1977c20ef5871adc456cfdd05e1" id="r_abcc7c1977c20ef5871adc456cfdd05e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abcc7c1977c20ef5871adc456cfdd05e1">is_all_dates</a> (self)</td></tr>
<tr class="separator:abcc7c1977c20ef5871adc456cfdd05e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfd79b0578b7b441e3081804d4335c" id="r_a44cfd79b0578b7b441e3081804d4335c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a44cfd79b0578b7b441e3081804d4335c">__reduce__</a> (self)</td></tr>
<tr class="separator:a44cfd79b0578b7b441e3081804d4335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5adc82ea31ab153a79bbd7ab3a6ce13" id="r_af5adc82ea31ab153a79bbd7ab3a6ce13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af5adc82ea31ab153a79bbd7ab3a6ce13">hasnans</a> (self)</td></tr>
<tr class="separator:af5adc82ea31ab153a79bbd7ab3a6ce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb4a4fc94bfe6bad9e0df500a5919c2" id="r_a4fb4a4fc94bfe6bad9e0df500a5919c2"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4fb4a4fc94bfe6bad9e0df500a5919c2">isna</a> (self)</td></tr>
<tr class="separator:a4fb4a4fc94bfe6bad9e0df500a5919c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9b00f5246b0879baaf10e730d7a21a" id="r_aba9b00f5246b0879baaf10e730d7a21a"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aba9b00f5246b0879baaf10e730d7a21a">notna</a> (self)</td></tr>
<tr class="separator:aba9b00f5246b0879baaf10e730d7a21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468b626b7f95c07b7742e7e8af832491" id="r_a468b626b7f95c07b7742e7e8af832491"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a468b626b7f95c07b7742e7e8af832491">fillna</a> (self, value=None, downcast=None)</td></tr>
<tr class="separator:a468b626b7f95c07b7742e7e8af832491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a16b6957c9c008ada0dce2238ab892" id="r_a90a16b6957c9c008ada0dce2238ab892"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a90a16b6957c9c008ada0dce2238ab892">dropna</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=&quot;any&quot;)</td></tr>
<tr class="separator:a90a16b6957c9c008ada0dce2238ab892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f22b33fc0d79997f4625ff43718ec0c" id="r_a2f22b33fc0d79997f4625ff43718ec0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2f22b33fc0d79997f4625ff43718ec0c">unique</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, Hashable|None level=None)</td></tr>
<tr class="separator:a2f22b33fc0d79997f4625ff43718ec0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5276b67d16571148394cec488bb5218" id="r_ae5276b67d16571148394cec488bb5218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae5276b67d16571148394cec488bb5218">drop_duplicates</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>|bool keep=&quot;first&quot;)</td></tr>
<tr class="separator:ae5276b67d16571148394cec488bb5218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0914a1dee40aecf965b677264f3d0bf" id="r_aa0914a1dee40aecf965b677264f3d0bf"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa0914a1dee40aecf965b677264f3d0bf">duplicated</a> (self, Literal[&quot;first&quot;, &quot;last&quot;, False] keep=&quot;first&quot;)</td></tr>
<tr class="separator:aa0914a1dee40aecf965b677264f3d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071a604a18a4ed8c36d964ac9bf99d4" id="r_aa071a604a18a4ed8c36d964ac9bf99d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa071a604a18a4ed8c36d964ac9bf99d4">__iadd__</a> (self, other)</td></tr>
<tr class="separator:aa071a604a18a4ed8c36d964ac9bf99d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad63922c7e09f3cdbf5a3e47cca09663" id="r_aad63922c7e09f3cdbf5a3e47cca09663"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aad63922c7e09f3cdbf5a3e47cca09663">__and__</a> (self, other)</td></tr>
<tr class="separator:aad63922c7e09f3cdbf5a3e47cca09663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678f6982af4066ac39285c3b1306f18" id="r_a5678f6982af4066ac39285c3b1306f18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5678f6982af4066ac39285c3b1306f18">__or__</a> (self, other)</td></tr>
<tr class="separator:a5678f6982af4066ac39285c3b1306f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad70735ac023f3c913ed054dba4005d3" id="r_aad70735ac023f3c913ed054dba4005d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aad70735ac023f3c913ed054dba4005d3">__xor__</a> (self, other)</td></tr>
<tr class="separator:aad70735ac023f3c913ed054dba4005d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf8f10e1bac6784ac6fa9d64b2a577" id="r_a8abf8f10e1bac6784ac6fa9d64b2a577"><td class="memItemLeft" align="right" valign="top">NoReturn&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8abf8f10e1bac6784ac6fa9d64b2a577">__nonzero__</a> (self)</td></tr>
<tr class="separator:a8abf8f10e1bac6784ac6fa9d64b2a577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18c8c90884dde0f8aa296919c0ebfa6" id="r_af18c8c90884dde0f8aa296919c0ebfa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af18c8c90884dde0f8aa296919c0ebfa6">union</a> (self, other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=None)</td></tr>
<tr class="separator:af18c8c90884dde0f8aa296919c0ebfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665bcdaee23489dfc2b62b98e31e465d" id="r_a665bcdaee23489dfc2b62b98e31e465d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a665bcdaee23489dfc2b62b98e31e465d">intersection</a> (self, other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=False)</td></tr>
<tr class="separator:a665bcdaee23489dfc2b62b98e31e465d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd8f9301b393845459728bd7364f456" id="r_afdd8f9301b393845459728bd7364f456"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#afdd8f9301b393845459728bd7364f456">difference</a> (self, other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=None)</td></tr>
<tr class="separator:afdd8f9301b393845459728bd7364f456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fe656490ff335d108334eb8d1cde3c" id="r_a14fe656490ff335d108334eb8d1cde3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a14fe656490ff335d108334eb8d1cde3c">symmetric_difference</a> (self, other, result_name=None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=None)</td></tr>
<tr class="separator:a14fe656490ff335d108334eb8d1cde3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4558511f6c65512766f5bde05fad2d3" id="r_ac4558511f6c65512766f5bde05fad2d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac4558511f6c65512766f5bde05fad2d3">get_loc</a> (self, key, method=None, tolerance=None)</td></tr>
<tr class="separator:ac4558511f6c65512766f5bde05fad2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ed8d6401e9429eb9ee365f636cffbe" id="r_ac8ed8d6401e9429eb9ee365f636cffbe"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac8ed8d6401e9429eb9ee365f636cffbe">get_indexer</a> (self, target, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>|None method=None, int|None limit=None, tolerance=None)</td></tr>
<tr class="separator:ac8ed8d6401e9429eb9ee365f636cffbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49df0503460de6359ea6f35fdea3181" id="r_aa49df0503460de6359ea6f35fdea3181"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa49df0503460de6359ea6f35fdea3181">reindex</a> (self, target, method=None, level=None, limit=None, tolerance=None)</td></tr>
<tr class="separator:aa49df0503460de6359ea6f35fdea3181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb127469563520eedc2c96f4a66dc63" id="r_aedb127469563520eedc2c96f4a66dc63"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aedb127469563520eedc2c96f4a66dc63">join</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, *<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=..., Level level=..., Literal[True] return_indexers, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=...)</td></tr>
<tr class="separator:aedb127469563520eedc2c96f4a66dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd35900072816ec401542e67d521656" id="r_a8dd35900072816ec401542e67d521656"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8dd35900072816ec401542e67d521656">join</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, *<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=..., Level level=..., Literal[False] return_indexers=..., bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=...)</td></tr>
<tr class="separator:a8dd35900072816ec401542e67d521656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8620d33cd791d4eba5a75975089a3dc" id="r_ae8620d33cd791d4eba5a75975089a3dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae8620d33cd791d4eba5a75975089a3dc">join</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, *<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=..., Level level=..., bool return_indexers=..., bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=...)</td></tr>
<tr class="separator:ae8620d33cd791d4eba5a75975089a3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f31319518966aa33ff864e5d6809516" id="r_a5f31319518966aa33ff864e5d6809516"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5f31319518966aa33ff864e5d6809516">join</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=&quot;left&quot;, Level level=None, bool return_indexers=False, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=False)</td></tr>
<tr class="separator:a5f31319518966aa33ff864e5d6809516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b355d17e64e3584619d1a87c6689d6" id="r_a80b355d17e64e3584619d1a87c6689d6"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a80b355d17e64e3584619d1a87c6689d6">values</a> (self)</td></tr>
<tr class="separator:a80b355d17e64e3584619d1a87c6689d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86763b57a92347e7e25c9e645f4d493" id="r_ab86763b57a92347e7e25c9e645f4d493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab86763b57a92347e7e25c9e645f4d493">array</a> (self)</td></tr>
<tr class="separator:ab86763b57a92347e7e25c9e645f4d493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3b04e914bd501a99cd79acfe983ecb" id="r_aae3b04e914bd501a99cd79acfe983ecb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aae3b04e914bd501a99cd79acfe983ecb">memory_usage</a> (self, bool deep=False)</td></tr>
<tr class="separator:aae3b04e914bd501a99cd79acfe983ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286cea8fd60b36ec217693030aed9012" id="r_a286cea8fd60b36ec217693030aed9012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a286cea8fd60b36ec217693030aed9012">where</a> (self, cond, other=None)</td></tr>
<tr class="separator:a286cea8fd60b36ec217693030aed9012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c7f637a502c2af3df7fa122c2e8ffd" id="r_ad7c7f637a502c2af3df7fa122c2e8ffd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad7c7f637a502c2af3df7fa122c2e8ffd">is_type_compatible</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> kind)</td></tr>
<tr class="separator:ad7c7f637a502c2af3df7fa122c2e8ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91c2c62afd0c05eac52f7bc65194d11" id="r_ac91c2c62afd0c05eac52f7bc65194d11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac91c2c62afd0c05eac52f7bc65194d11">__contains__</a> (self, Any key)</td></tr>
<tr class="separator:ac91c2c62afd0c05eac52f7bc65194d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa228e11c6f166ce8ac16e7db3d5f8ef3" id="r_aa228e11c6f166ce8ac16e7db3d5f8ef3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa228e11c6f166ce8ac16e7db3d5f8ef3">__setitem__</a> (self, key, value)</td></tr>
<tr class="separator:aa228e11c6f166ce8ac16e7db3d5f8ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d26282329403b0e729dcc9f3eb56c9b" id="r_a5d26282329403b0e729dcc9f3eb56c9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5d26282329403b0e729dcc9f3eb56c9b">__getitem__</a> (self, key)</td></tr>
<tr class="separator:a5d26282329403b0e729dcc9f3eb56c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee2c8e131d63fadda0d417782b9e306" id="r_a2ee2c8e131d63fadda0d417782b9e306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2ee2c8e131d63fadda0d417782b9e306">append</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|Sequence[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>] other)</td></tr>
<tr class="separator:a2ee2c8e131d63fadda0d417782b9e306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73e5369a94a97ee0a7947c9d3c95cba" id="r_ae73e5369a94a97ee0a7947c9d3c95cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae73e5369a94a97ee0a7947c9d3c95cba">putmask</a> (self, mask, value)</td></tr>
<tr class="separator:ae73e5369a94a97ee0a7947c9d3c95cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de144ee709375fcee0626bdf60f54bd" id="r_a9de144ee709375fcee0626bdf60f54bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9de144ee709375fcee0626bdf60f54bd">equals</a> (self, Any other)</td></tr>
<tr class="separator:a9de144ee709375fcee0626bdf60f54bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a6fe0b02e66409348958e182dfa973" id="r_a60a6fe0b02e66409348958e182dfa973"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a60a6fe0b02e66409348958e182dfa973">identical</a> (self, other)</td></tr>
<tr class="separator:a60a6fe0b02e66409348958e182dfa973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214a050164c108fe178a8711d8f82de0" id="r_a214a050164c108fe178a8711d8f82de0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a214a050164c108fe178a8711d8f82de0">asof</a> (self, label)</td></tr>
<tr class="separator:a214a050164c108fe178a8711d8f82de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d907b39f89f0a02c61dfd3e7d609f7f" id="r_a1d907b39f89f0a02c61dfd3e7d609f7f"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a1d907b39f89f0a02c61dfd3e7d609f7f">asof_locs</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a286cea8fd60b36ec217693030aed9012">where</a>, npt.NDArray[np.bool_] mask)</td></tr>
<tr class="separator:a1d907b39f89f0a02c61dfd3e7d609f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514e382098f15b8b7a9041b76c65fcf9" id="r_a514e382098f15b8b7a9041b76c65fcf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a514e382098f15b8b7a9041b76c65fcf9">sort_values</a> (self, bool return_indexer=False, bool ascending=True, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> na_position=&quot;last&quot;, Callable|None key=None)</td></tr>
<tr class="separator:a514e382098f15b8b7a9041b76c65fcf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65dd03a5291f205bda3867d89e7fd1a8" id="r_a65dd03a5291f205bda3867d89e7fd1a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a65dd03a5291f205bda3867d89e7fd1a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa437b90ba8ed1fa0e98499dd531553b" id="r_aaa437b90ba8ed1fa0e98499dd531553b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aaa437b90ba8ed1fa0e98499dd531553b">shift</a> (self, periods=1, freq=None)</td></tr>
<tr class="separator:aaa437b90ba8ed1fa0e98499dd531553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30771e43e0bb0649a29944416361354e" id="r_a30771e43e0bb0649a29944416361354e"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a30771e43e0bb0649a29944416361354e">argsort</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a30771e43e0bb0649a29944416361354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3addf078ac693c762d0075e1d2d5ee6" id="r_ab3addf078ac693c762d0075e1d2d5ee6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab3addf078ac693c762d0075e1d2d5ee6">get_value</a> (self, Series series, key)</td></tr>
<tr class="separator:ab3addf078ac693c762d0075e1d2d5ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f86e4c407fa32badff6a06444a1b02" id="r_a08f86e4c407fa32badff6a06444a1b02"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a08f86e4c407fa32badff6a06444a1b02">set_value</a> (self, arr, key, value)</td></tr>
<tr class="separator:a08f86e4c407fa32badff6a06444a1b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb228f0a8f17ec6541bbce50ef934c59" id="r_abb228f0a8f17ec6541bbce50ef934c59"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abb228f0a8f17ec6541bbce50ef934c59">get_indexer_non_unique</a> (self, target)</td></tr>
<tr class="separator:abb228f0a8f17ec6541bbce50ef934c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad01cb4764f92e08a6c7047b7f8a9dd" id="r_a6ad01cb4764f92e08a6c7047b7f8a9dd"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6ad01cb4764f92e08a6c7047b7f8a9dd">get_indexer_for</a> (self, target)</td></tr>
<tr class="separator:a6ad01cb4764f92e08a6c7047b7f8a9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbf5d5324d7161721ced420d788a1dc" id="r_a4bbf5d5324d7161721ced420d788a1dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1io_1_1formats_1_1printing_1_1_pretty_dict.html">PrettyDict</a>[Hashable, np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4bbf5d5324d7161721ced420d788a1dc">groupby</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a>)</td></tr>
<tr class="separator:a4bbf5d5324d7161721ced420d788a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d81e57a458584d71ccfb16a034ba7ec" id="r_a7d81e57a458584d71ccfb16a034ba7ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7d81e57a458584d71ccfb16a034ba7ec">map</a> (self, mapper, na_action=None)</td></tr>
<tr class="separator:a7d81e57a458584d71ccfb16a034ba7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e4887bf57bd655762834e00c60383f" id="r_ad4e4887bf57bd655762834e00c60383f"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad4e4887bf57bd655762834e00c60383f">isin</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a>, level=None)</td></tr>
<tr class="separator:ad4e4887bf57bd655762834e00c60383f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ff9e39c42982dba799539a4c7a2e83" id="r_aa6ff9e39c42982dba799539a4c7a2e83"><td class="memItemLeft" align="right" valign="top">slice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa6ff9e39c42982dba799539a4c7a2e83">slice_indexer</a> (self, Hashable|None start=None, Hashable|None end=None, int|None step=None, kind=no_default)</td></tr>
<tr class="separator:aa6ff9e39c42982dba799539a4c7a2e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982caf9e7632d89dafc1dc0ecc987f2f" id="r_a982caf9e7632d89dafc1dc0ecc987f2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a982caf9e7632d89dafc1dc0ecc987f2f">get_slice_bound</a> (self, label, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>, kind=no_default)</td></tr>
<tr class="separator:a982caf9e7632d89dafc1dc0ecc987f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac2625ecfe9f2ace46206b38bf3b27f" id="r_a2ac2625ecfe9f2ace46206b38bf3b27f"><td class="memItemLeft" align="right" valign="top">tuple[int, int]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2ac2625ecfe9f2ace46206b38bf3b27f">slice_locs</a> (self, start=None, end=None, step=None, kind=no_default)</td></tr>
<tr class="separator:a2ac2625ecfe9f2ace46206b38bf3b27f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eedeb5284d87e3fecc39569f41a9215" id="r_a0eedeb5284d87e3fecc39569f41a9215"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0eedeb5284d87e3fecc39569f41a9215">delete</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, loc)</td></tr>
<tr class="separator:a0eedeb5284d87e3fecc39569f41a9215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aec3bcd721454a1ffbb8f5a0c2176a" id="r_ad5aec3bcd721454a1ffbb8f5a0c2176a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad5aec3bcd721454a1ffbb8f5a0c2176a">insert</a> (self, int loc, <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#ad26cf8379249657f5c3ede3a278f167e">item</a>)</td></tr>
<tr class="separator:ad5aec3bcd721454a1ffbb8f5a0c2176a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2baa3f9a3d9eddf303486451eb684d4" id="r_af2baa3f9a3d9eddf303486451eb684d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af2baa3f9a3d9eddf303486451eb684d4">drop</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|np.ndarray|Iterable[Hashable] labels, IgnoreRaise errors=&quot;raise&quot;)</td></tr>
<tr class="separator:af2baa3f9a3d9eddf303486451eb684d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61054f98e40a4bfa12ad1ecc02a31f80" id="r_a61054f98e40a4bfa12ad1ecc02a31f80"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a61054f98e40a4bfa12ad1ecc02a31f80">__abs__</a> (self)</td></tr>
<tr class="separator:a61054f98e40a4bfa12ad1ecc02a31f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf2969db9ed738ba76d637645e482488" id="r_aaf2969db9ed738ba76d637645e482488"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aaf2969db9ed738ba76d637645e482488">__neg__</a> (self)</td></tr>
<tr class="separator:aaf2969db9ed738ba76d637645e482488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20f4d0a401404a43d90b2440d0e3f9d" id="r_ab20f4d0a401404a43d90b2440d0e3f9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab20f4d0a401404a43d90b2440d0e3f9d">__pos__</a> (self)</td></tr>
<tr class="separator:ab20f4d0a401404a43d90b2440d0e3f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7d754151ec7bae0ba0ad4f46e9f31e" id="r_a5d7d754151ec7bae0ba0ad4f46e9f31e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5d7d754151ec7bae0ba0ad4f46e9f31e">__invert__</a> (self)</td></tr>
<tr class="separator:a5d7d754151ec7bae0ba0ad4f46e9f31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c586e90e1ab6c1e34300a34332ca133" id="r_a0c586e90e1ab6c1e34300a34332ca133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0c586e90e1ab6c1e34300a34332ca133">any</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a0c586e90e1ab6c1e34300a34332ca133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ffd70e57719759d79af18daac4d57" id="r_a121ffd70e57719759d79af18daac4d57"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a121ffd70e57719759d79af18daac4d57">all</a> (self, *args, **kwargs)</td></tr>
<tr class="separator:a121ffd70e57719759d79af18daac4d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433c9db70e4dd1a08f551919f606dcc0" id="r_a433c9db70e4dd1a08f551919f606dcc0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a433c9db70e4dd1a08f551919f606dcc0">argmin</a> (self, axis=None, skipna=True, *args, **kwargs)</td></tr>
<tr class="separator:a433c9db70e4dd1a08f551919f606dcc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3613bddbc636b51c8de715b6035d16b" id="r_ae3613bddbc636b51c8de715b6035d16b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae3613bddbc636b51c8de715b6035d16b">argmax</a> (self, axis=None, skipna=True, *args, **kwargs)</td></tr>
<tr class="separator:ae3613bddbc636b51c8de715b6035d16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3f856f0483747a90463a07a060073" id="r_a49b3f856f0483747a90463a07a060073"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a49b3f856f0483747a90463a07a060073">min</a> (self, axis=None, skipna=True, *args, **kwargs)</td></tr>
<tr class="separator:a49b3f856f0483747a90463a07a060073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413e9a58c5415feb5962d3640e1ed3f5" id="r_a413e9a58c5415feb5962d3640e1ed3f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a413e9a58c5415feb5962d3640e1ed3f5">max</a> (self, axis=None, skipna=True, *args, **kwargs)</td></tr>
<tr class="separator:a413e9a58c5415feb5962d3640e1ed3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d01a0b717b64937123a99e01a7f624" id="r_ad4d01a0b717b64937123a99e01a7f624"><td class="memItemLeft" align="right" valign="top">Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad4d01a0b717b64937123a99e01a7f624">shape</a> (self)</td></tr>
<tr class="separator:ad4d01a0b717b64937123a99e01a7f624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
<tr class="memitem:ab0a0e81c708bf369d4bf6acd51f85bf2 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_ab0a0e81c708bf369d4bf6acd51f85bf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1base.html#af46e08b5cdbd558877d2c1450dd3370e">_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#ab0a0e81c708bf369d4bf6acd51f85bf2">transpose</a> (<a class="el" href="namespacepandas_1_1core_1_1base.html#af46e08b5cdbd558877d2c1450dd3370e">_T</a> self, *args, **kwargs)</td></tr>
<tr class="separator:ab0a0e81c708bf369d4bf6acd51f85bf2 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa871e8c40f4d97dcf5bdc12f521977 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a5aa871e8c40f4d97dcf5bdc12f521977"><td class="memItemLeft" align="right" valign="top">Literal[1]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a5aa871e8c40f4d97dcf5bdc12f521977">ndim</a> (self)</td></tr>
<tr class="separator:a5aa871e8c40f4d97dcf5bdc12f521977 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26cf8379249657f5c3ede3a278f167e inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_ad26cf8379249657f5c3ede3a278f167e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#ad26cf8379249657f5c3ede3a278f167e">item</a> (self)</td></tr>
<tr class="separator:ad26cf8379249657f5c3ede3a278f167e inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6098c848406e4150b6ecb3e1288539 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a8d6098c848406e4150b6ecb3e1288539"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a8d6098c848406e4150b6ecb3e1288539">nbytes</a> (self)</td></tr>
<tr class="separator:a8d6098c848406e4150b6ecb3e1288539 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a76f6d895de8524672cd61185800dd inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a90a76f6d895de8524672cd61185800dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a90a76f6d895de8524672cd61185800dd">size</a> (self)</td></tr>
<tr class="separator:a90a76f6d895de8524672cd61185800dd inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cab97466d34bec20dfc5d60a010d69 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a16cab97466d34bec20dfc5d60a010d69"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a16cab97466d34bec20dfc5d60a010d69">to_numpy</a> (self, npt.DTypeLike|None <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a2396ceae5c47c65c95ca5ddfd5e09ea1">dtype</a>=None, bool copy=False, object na_value=lib.no_default, **kwargs)</td></tr>
<tr class="separator:a16cab97466d34bec20dfc5d60a010d69 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845520bda45bd3eb1bc7923005dc4a59 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a845520bda45bd3eb1bc7923005dc4a59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a845520bda45bd3eb1bc7923005dc4a59">empty</a> (self)</td></tr>
<tr class="separator:a845520bda45bd3eb1bc7923005dc4a59 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f3e1049febee1b63d3527c90f2df6e inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a36f3e1049febee1b63d3527c90f2df6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a36f3e1049febee1b63d3527c90f2df6e">tolist</a> (self)</td></tr>
<tr class="separator:a36f3e1049febee1b63d3527c90f2df6e inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601b8a78b35a7b233f7f9437f7e8873c inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a601b8a78b35a7b233f7f9437f7e8873c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a601b8a78b35a7b233f7f9437f7e8873c">__iter__</a> (self)</td></tr>
<tr class="separator:a601b8a78b35a7b233f7f9437f7e8873c inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa4b1a82452aedc9dcfed672ded124b inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a8fa4b1a82452aedc9dcfed672ded124b"><td class="memItemLeft" align="right" valign="top">Series&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a8fa4b1a82452aedc9dcfed672ded124b">value_counts</a> (self, bool normalize=False, bool sort=True, bool ascending=False, bins=None, bool dropna=True)</td></tr>
<tr class="separator:a8fa4b1a82452aedc9dcfed672ded124b inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6838adf8b05711b15f3779b9eda21680 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a6838adf8b05711b15f3779b9eda21680"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a6838adf8b05711b15f3779b9eda21680">nunique</a> (self, bool dropna=True)</td></tr>
<tr class="separator:a6838adf8b05711b15f3779b9eda21680 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9476ef31361ff382e80a0407975c3d inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a4f9476ef31361ff382e80a0407975c3d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a4f9476ef31361ff382e80a0407975c3d">factorize</a> (self, bool sort=False, int|lib.NoDefault na_sentinel=lib.no_default, bool|lib.NoDefault use_na_sentinel=lib.no_default)</td></tr>
<tr class="separator:a4f9476ef31361ff382e80a0407975c3d inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5428207b33bd015a51a2236d44ac1d83 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a5428207b33bd015a51a2236d44ac1d83"><td class="memItemLeft" align="right" valign="top">np.intp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a5428207b33bd015a51a2236d44ac1d83">searchsorted</a> (self, ScalarLike_co value, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=..., NumpySorter sorter=...)</td></tr>
<tr class="separator:a5428207b33bd015a51a2236d44ac1d83 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a118e230479dd0997886681282d931c71 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a118e230479dd0997886681282d931c71"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a118e230479dd0997886681282d931c71">searchsorted</a> (self, npt.ArrayLike|<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> value, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=..., NumpySorter sorter=...)</td></tr>
<tr class="separator:a118e230479dd0997886681282d931c71 inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac42388892dacf228c68fb13aefbff2a inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_aac42388892dacf228c68fb13aefbff2a"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|np.intp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#aac42388892dacf228c68fb13aefbff2a">searchsorted</a> (self, NumpyValueArrayLike|<a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> value, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=&quot;left&quot;, NumpySorter sorter=None)</td></tr>
<tr class="separator:aac42388892dacf228c68fb13aefbff2a inherit pub_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html">pandas.core.arraylike.OpsMixin</a></td></tr>
<tr class="memitem:aa7dbda9f1c66cf76595ce57dcc0fac54 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_aa7dbda9f1c66cf76595ce57dcc0fac54"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#aa7dbda9f1c66cf76595ce57dcc0fac54">__eq__</a> (self, other)</td></tr>
<tr class="separator:aa7dbda9f1c66cf76595ce57dcc0fac54 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4048790ee93211974ade73a387b85183 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a4048790ee93211974ade73a387b85183"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a4048790ee93211974ade73a387b85183">__ne__</a> (self, other)</td></tr>
<tr class="separator:a4048790ee93211974ade73a387b85183 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b5bc7ebe225eb2c332ac0e34f1cbcf inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a88b5bc7ebe225eb2c332ac0e34f1cbcf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a88b5bc7ebe225eb2c332ac0e34f1cbcf">__lt__</a> (self, other)</td></tr>
<tr class="separator:a88b5bc7ebe225eb2c332ac0e34f1cbcf inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9954b19d06d226d67e6eee656c221 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a1fb9954b19d06d226d67e6eee656c221"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a1fb9954b19d06d226d67e6eee656c221">__le__</a> (self, other)</td></tr>
<tr class="separator:a1fb9954b19d06d226d67e6eee656c221 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef15914d9a0253393be48690ea675992 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_aef15914d9a0253393be48690ea675992"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#aef15914d9a0253393be48690ea675992">__gt__</a> (self, other)</td></tr>
<tr class="separator:aef15914d9a0253393be48690ea675992 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8ce2011ec0aadb7372039e1608eba4 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a2b8ce2011ec0aadb7372039e1608eba4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a2b8ce2011ec0aadb7372039e1608eba4">__ge__</a> (self, other)</td></tr>
<tr class="separator:a2b8ce2011ec0aadb7372039e1608eba4 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e77cbdf2f38bfdb83ace804ea20ced0 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a2e77cbdf2f38bfdb83ace804ea20ced0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a2e77cbdf2f38bfdb83ace804ea20ced0">__rand__</a> (self, other)</td></tr>
<tr class="separator:a2e77cbdf2f38bfdb83ace804ea20ced0 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d74998fd536eff8bf3f3e0d6d5f701 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_ae0d74998fd536eff8bf3f3e0d6d5f701"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#ae0d74998fd536eff8bf3f3e0d6d5f701">__ror__</a> (self, other)</td></tr>
<tr class="separator:ae0d74998fd536eff8bf3f3e0d6d5f701 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850ad88429bb2a5ca6eeaa63c336ad25 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a850ad88429bb2a5ca6eeaa63c336ad25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a850ad88429bb2a5ca6eeaa63c336ad25">__rxor__</a> (self, other)</td></tr>
<tr class="separator:a850ad88429bb2a5ca6eeaa63c336ad25 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c22f95e0cd7ee8a7b120acab4e439d inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a61c22f95e0cd7ee8a7b120acab4e439d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a61c22f95e0cd7ee8a7b120acab4e439d">__add__</a> (self, other)</td></tr>
<tr class="separator:a61c22f95e0cd7ee8a7b120acab4e439d inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1749c3d4c8b28281d96e7b6752805161 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a1749c3d4c8b28281d96e7b6752805161"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a1749c3d4c8b28281d96e7b6752805161">__radd__</a> (self, other)</td></tr>
<tr class="separator:a1749c3d4c8b28281d96e7b6752805161 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530308a195ed046ea3b57b49aa5dc1cb inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a530308a195ed046ea3b57b49aa5dc1cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a530308a195ed046ea3b57b49aa5dc1cb">__sub__</a> (self, other)</td></tr>
<tr class="separator:a530308a195ed046ea3b57b49aa5dc1cb inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea4ad72b7184c02ffbcb49217bcf371 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_adea4ad72b7184c02ffbcb49217bcf371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#adea4ad72b7184c02ffbcb49217bcf371">__rsub__</a> (self, other)</td></tr>
<tr class="separator:adea4ad72b7184c02ffbcb49217bcf371 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaeba591ccf102fe7fd562299a98e39 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a0aaeba591ccf102fe7fd562299a98e39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a0aaeba591ccf102fe7fd562299a98e39">__mul__</a> (self, other)</td></tr>
<tr class="separator:a0aaeba591ccf102fe7fd562299a98e39 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75617a82657744ed737b29cc498c23dc inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a75617a82657744ed737b29cc498c23dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a75617a82657744ed737b29cc498c23dc">__rmul__</a> (self, other)</td></tr>
<tr class="separator:a75617a82657744ed737b29cc498c23dc inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92786c1d5ab1809272ad49eff00c0c5b inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a92786c1d5ab1809272ad49eff00c0c5b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a92786c1d5ab1809272ad49eff00c0c5b">__truediv__</a> (self, other)</td></tr>
<tr class="separator:a92786c1d5ab1809272ad49eff00c0c5b inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c7c07ac901bd2c2f67d37945f71c30 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a01c7c07ac901bd2c2f67d37945f71c30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a01c7c07ac901bd2c2f67d37945f71c30">__rtruediv__</a> (self, other)</td></tr>
<tr class="separator:a01c7c07ac901bd2c2f67d37945f71c30 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd31516ad01b317e6d79ad24864d951e inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_abd31516ad01b317e6d79ad24864d951e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#abd31516ad01b317e6d79ad24864d951e">__floordiv__</a> (self, other)</td></tr>
<tr class="separator:abd31516ad01b317e6d79ad24864d951e inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b64ac68d1e5b0a5d96c7c0bafcc6fa inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a21b64ac68d1e5b0a5d96c7c0bafcc6fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a21b64ac68d1e5b0a5d96c7c0bafcc6fa">__rfloordiv__</a> (self, other)</td></tr>
<tr class="separator:a21b64ac68d1e5b0a5d96c7c0bafcc6fa inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86c75d82a6d5cae136e71de32273da inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_aba86c75d82a6d5cae136e71de32273da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#aba86c75d82a6d5cae136e71de32273da">__mod__</a> (self, other)</td></tr>
<tr class="separator:aba86c75d82a6d5cae136e71de32273da inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b2527d317bc9127bdea4611a2736c4 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a78b2527d317bc9127bdea4611a2736c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a78b2527d317bc9127bdea4611a2736c4">__rmod__</a> (self, other)</td></tr>
<tr class="separator:a78b2527d317bc9127bdea4611a2736c4 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad676a95128673f1d0ed16d7e728bc0fb inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_ad676a95128673f1d0ed16d7e728bc0fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#ad676a95128673f1d0ed16d7e728bc0fb">__divmod__</a> (self, other)</td></tr>
<tr class="separator:ad676a95128673f1d0ed16d7e728bc0fb inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2259cd23f5d2d14ba583be122cf965 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a1a2259cd23f5d2d14ba583be122cf965"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a1a2259cd23f5d2d14ba583be122cf965">__rdivmod__</a> (self, other)</td></tr>
<tr class="separator:a1a2259cd23f5d2d14ba583be122cf965 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c8db3a3dca6a12501985ddc7975b04 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_ab3c8db3a3dca6a12501985ddc7975b04"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#ab3c8db3a3dca6a12501985ddc7975b04">__pow__</a> (self, other)</td></tr>
<tr class="separator:ab3c8db3a3dca6a12501985ddc7975b04 inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66b3dc52d16d5713fd37072010f69bc inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_ab66b3dc52d16d5713fd37072010f69bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#ab66b3dc52d16d5713fd37072010f69bc">__rpow__</a> (self, other)</td></tr>
<tr class="separator:ab66b3dc52d16d5713fd37072010f69bc inherit pub_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:ad5b15e942fb2d2dcfb12fa1667404aeb inherit pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_ad5b15e942fb2d2dcfb12fa1667404aeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#ad5b15e942fb2d2dcfb12fa1667404aeb">__sizeof__</a> (self)</td></tr>
<tr class="separator:ad5b15e942fb2d2dcfb12fa1667404aeb inherit pub_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:ac86361dc5b262c58dcdf818d410136e4 inherit pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_ac86361dc5b262c58dcdf818d410136e4"><td class="memItemLeft" align="right" valign="top">list[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#ac86361dc5b262c58dcdf818d410136e4">__dir__</a> (self)</td></tr>
<tr class="separator:ac86361dc5b262c58dcdf818d410136e4 inherit pub_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad59caf1a94a85baf8bf557179f7f3a56" id="r_ad59caf1a94a85baf8bf557179f7f3a56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad59caf1a94a85baf8bf557179f7f3a56">nlevels</a></td></tr>
<tr class="separator:ad59caf1a94a85baf8bf557179f7f3a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f0dd01f7221293308ad6cc8d05f842" id="r_a89f0dd01f7221293308ad6cc8d05f842"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a></td></tr>
<tr class="separator:a89f0dd01f7221293308ad6cc8d05f842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082a4e5f6d9ebe6b049f8e600c7b9ca1" id="r_a082a4e5f6d9ebe6b049f8e600c7b9ca1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a082a4e5f6d9ebe6b049f8e600c7b9ca1">inferred_type</a></td></tr>
<tr class="separator:a082a4e5f6d9ebe6b049f8e600c7b9ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94270472703ead5d5c3b3695c0a5e993" id="r_a94270472703ead5d5c3b3695c0a5e993"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a94270472703ead5d5c3b3695c0a5e993">categories</a></td></tr>
<tr class="separator:a94270472703ead5d5c3b3695c0a5e993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff207e0d287fb46016e9beb32ef8c28" id="r_a3ff207e0d287fb46016e9beb32ef8c28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a></td></tr>
<tr class="separator:a3ff207e0d287fb46016e9beb32ef8c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644cfdf7877cdf1c4bfd5dab621586bd" id="r_a644cfdf7877cdf1c4bfd5dab621586bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a></td></tr>
<tr class="separator:a644cfdf7877cdf1c4bfd5dab621586bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5d2aa158db3fb9863d50f4cc731a02" id="r_a9d5d2aa158db3fb9863d50f4cc731a02"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9d5d2aa158db3fb9863d50f4cc731a02">hasnans</a></td></tr>
<tr class="separator:a9d5d2aa158db3fb9863d50f4cc731a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d050d983339a26ec4a5e1623de2c9e8" id="r_a2d050d983339a26ec4a5e1623de2c9e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2d050d983339a26ec4a5e1623de2c9e8">dtypes</a></td></tr>
<tr class="separator:a2d050d983339a26ec4a5e1623de2c9e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89499184bef657d1692356012545f1f6" id="r_a89499184bef657d1692356012545f1f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89499184bef657d1692356012545f1f6">tz</a></td></tr>
<tr class="separator:a89499184bef657d1692356012545f1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a09dc54c97265b31bbbe2b25730d404e0" id="r_a09dc54c97265b31bbbe2b25730d404e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a09dc54c97265b31bbbe2b25730d404e0">str</a> = <a class="el" href="classpandas_1_1core_1_1accessor_1_1_cached_accessor.html">CachedAccessor</a>(&quot;str&quot;, <a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html">StringMethods</a>)</td></tr>
<tr class="separator:a09dc54c97265b31bbbe2b25730d404e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3491922d3e3feb92c84c6677c076613" id="r_ad3491922d3e3feb92c84c6677c076613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad3491922d3e3feb92c84c6677c076613">get_level_values</a> = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abd2bf62078de48efb3f4262354d47eb8">_get_level_values</a></td></tr>
<tr class="separator:ad3491922d3e3feb92c84c6677c076613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df08ca45336f952d726a61ecbad99f0" id="r_a9df08ca45336f952d726a61ecbad99f0"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9df08ca45336f952d726a61ecbad99f0">isnull</a> = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4fb4a4fc94bfe6bad9e0df500a5919c2">isna</a></td></tr>
<tr class="separator:a9df08ca45336f952d726a61ecbad99f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60673e509ddd0884ec45dcc00dad6f6d" id="r_a60673e509ddd0884ec45dcc00dad6f6d"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a60673e509ddd0884ec45dcc00dad6f6d">notnull</a> = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aba9b00f5246b0879baaf10e730d7a21a">notna</a></td></tr>
<tr class="separator:a60673e509ddd0884ec45dcc00dad6f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
<tr class="memitem:a3a2ae53de0e0ab1edc70eb7ffb96261e inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a3a2ae53de0e0ab1edc70eb7ffb96261e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a3a2ae53de0e0ab1edc70eb7ffb96261e">to_list</a> = <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a36f3e1049febee1b63d3527c90f2df6e">tolist</a></td></tr>
<tr class="separator:a3a2ae53de0e0ab1edc70eb7ffb96261e inherit pub_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae6aecd6b620f811505f8135165f968df" id="r_ae6aecd6b620f811505f8135165f968df"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae6aecd6b620f811505f8135165f968df">_left_indexer_unique</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> other)</td></tr>
<tr class="separator:ae6aecd6b620f811505f8135165f968df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4c0f371f842e4f648a4493e82a4876" id="r_a0d4c0f371f842e4f648a4493e82a4876"><td class="memItemLeft" align="right" valign="top">tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0d4c0f371f842e4f648a4493e82a4876">_left_indexer</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> other)</td></tr>
<tr class="separator:a0d4c0f371f842e4f648a4493e82a4876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ca572c49a5cc3ec520dfebd4983021" id="r_a93ca572c49a5cc3ec520dfebd4983021"><td class="memItemLeft" align="right" valign="top">tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a93ca572c49a5cc3ec520dfebd4983021">_inner_indexer</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> other)</td></tr>
<tr class="separator:a93ca572c49a5cc3ec520dfebd4983021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b2b2f079c4d21f246f8e5af2b27b70" id="r_a10b2b2f079c4d21f246f8e5af2b27b70"><td class="memItemLeft" align="right" valign="top">tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a10b2b2f079c4d21f246f8e5af2b27b70">_outer_indexer</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> other)</td></tr>
<tr class="separator:a10b2b2f079c4d21f246f8e5af2b27b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6deaeab0d9868a2a560ebe4fab9ddbb" id="r_af6deaeab0d9868a2a560ebe4fab9ddbb"><td class="memItemLeft" align="right" valign="top">type[libindex.IndexEngine]|type[libindex.ExtensionEngine]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af6deaeab0d9868a2a560ebe4fab9ddbb">_engine_type</a> (self)</td></tr>
<tr class="separator:af6deaeab0d9868a2a560ebe4fab9ddbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff8f1403380dc6043d0d4a7331b2630" id="r_a4ff8f1403380dc6043d0d4a7331b2630"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4ff8f1403380dc6043d0d4a7331b2630">_ensure_array</a> (cls, data, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f9ce0340d28fefd8934989df2681722">copy</a>)</td></tr>
<tr class="separator:a4ff8f1403380dc6043d0d4a7331b2630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629d3a5311ce5e1fba41ee355543048c" id="r_a629d3a5311ce5e1fba41ee355543048c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a629d3a5311ce5e1fba41ee355543048c">_dtype_to_subclass</a> (cls, DtypeObj <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>)</td></tr>
<tr class="separator:a629d3a5311ce5e1fba41ee355543048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39d842c3e375fd53ee600305fb84a14" id="r_ac39d842c3e375fd53ee600305fb84a14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac39d842c3e375fd53ee600305fb84a14">_simple_new</a> (type[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>] cls, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a>, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None)</td></tr>
<tr class="separator:ac39d842c3e375fd53ee600305fb84a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0226fde4b5097ec6291b2303fa4bd13" id="r_ab0226fde4b5097ec6291b2303fa4bd13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab0226fde4b5097ec6291b2303fa4bd13">_with_infer</a> (cls, *args, **kwargs)</td></tr>
<tr class="separator:ab0226fde4b5097ec6291b2303fa4bd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ea6e83ccdc78314b900763b6975ba4" id="r_aa6ea6e83ccdc78314b900763b6975ba4"><td class="memItemLeft" align="right" valign="top">type[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa6ea6e83ccdc78314b900763b6975ba4">_constructor</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self)</td></tr>
<tr class="separator:aa6ea6e83ccdc78314b900763b6975ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad194c288c817df9ef68a9bf1ee74b7e4" id="r_ad194c288c817df9ef68a9bf1ee74b7e4"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad194c288c817df9ef68a9bf1ee74b7e4">_maybe_check_unique</a> (self)</td></tr>
<tr class="separator:ad194c288c817df9ef68a9bf1ee74b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629955f0f921bb0239bb27cfde0fed0c" id="r_a629955f0f921bb0239bb27cfde0fed0c"><td class="memItemLeft" align="right" valign="top">DataFrame&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a629955f0f921bb0239bb27cfde0fed0c">_format_duplicate_message</a> (self)</td></tr>
<tr class="separator:a629955f0f921bb0239bb27cfde0fed0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eca673aa878c46872d0002cf4611961" id="r_a9eca673aa878c46872d0002cf4611961"><td class="memItemLeft" align="right" valign="top">dict[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>, Any]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9eca673aa878c46872d0002cf4611961">_get_attributes_dict</a> (self)</td></tr>
<tr class="separator:a9eca673aa878c46872d0002cf4611961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204b0034440abde8761bc75b20bf2fdb" id="r_a204b0034440abde8761bc75b20bf2fdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a204b0034440abde8761bc75b20bf2fdb">_shallow_copy</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a>, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=no_default)</td></tr>
<tr class="separator:a204b0034440abde8761bc75b20bf2fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179fbf5b8be4cfd6e4d32da55baf90b7" id="r_a179fbf5b8be4cfd6e4d32da55baf90b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a179fbf5b8be4cfd6e4d32da55baf90b7">_view</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self)</td></tr>
<tr class="separator:a179fbf5b8be4cfd6e4d32da55baf90b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fe9bfb3c4fc2fc503230d33f37f9b7" id="r_a17fe9bfb3c4fc2fc503230d33f37f9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a17fe9bfb3c4fc2fc503230d33f37f9b7">_rename</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>)</td></tr>
<tr class="separator:a17fe9bfb3c4fc2fc503230d33f37f9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a00092020db82b9221f95f166811794" id="r_a6a00092020db82b9221f95f166811794"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6a00092020db82b9221f95f166811794">_reset_identity</a> (self)</td></tr>
<tr class="separator:a6a00092020db82b9221f95f166811794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4633c74b11623eed428e252ec0cb2efb" id="r_a4633c74b11623eed428e252ec0cb2efb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4633c74b11623eed428e252ec0cb2efb">_cleanup</a> (self)</td></tr>
<tr class="separator:a4633c74b11623eed428e252ec0cb2efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddaf9c7d5c4941a72958f7fe072eb49" id="r_adddaf9c7d5c4941a72958f7fe072eb49"><td class="memItemLeft" align="right" valign="top">libindex.IndexEngine|libindex.ExtensionEngine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#adddaf9c7d5c4941a72958f7fe072eb49">_engine</a> (self)</td></tr>
<tr class="separator:adddaf9c7d5c4941a72958f7fe072eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0acfcf7fe9c2fa9b5a12c755987f5d4" id="r_ad0acfcf7fe9c2fa9b5a12c755987f5d4"><td class="memItemLeft" align="right" valign="top">set[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad0acfcf7fe9c2fa9b5a12c755987f5d4">_dir_additions_for_owner</a> (self)</td></tr>
<tr class="separator:ad0acfcf7fe9c2fa9b5a12c755987f5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2cf6513da88477dce050c2c76cbebf" id="r_acb2cf6513da88477dce050c2c76cbebf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#acb2cf6513da88477dce050c2c76cbebf">_maybe_disallow_fill</a> (self, bool allow_fill, fill_value, indices)</td></tr>
<tr class="separator:acb2cf6513da88477dce050c2c76cbebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4233dfd966c60ca04fc4c81615f1ef5" id="r_ac4233dfd966c60ca04fc4c81615f1ef5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac4233dfd966c60ca04fc4c81615f1ef5">_format_space</a> (self)</td></tr>
<tr class="separator:ac4233dfd966c60ca04fc4c81615f1ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b25124939f709f533e3868ee62063" id="r_a202b25124939f709f533e3868ee62063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a202b25124939f709f533e3868ee62063">_formatter_func</a> (self)</td></tr>
<tr class="separator:a202b25124939f709f533e3868ee62063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc15063a8e586643bcaa63067f2c73b6" id="r_acc15063a8e586643bcaa63067f2c73b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#acc15063a8e586643bcaa63067f2c73b6">_format_data</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None)</td></tr>
<tr class="separator:acc15063a8e586643bcaa63067f2c73b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca193f3f8c77e60f4ef1058b73e4723" id="r_acca193f3f8c77e60f4ef1058b73e4723"><td class="memItemLeft" align="right" valign="top">list[tuple[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>|int|bool|None]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#acca193f3f8c77e60f4ef1058b73e4723">_format_attrs</a> (self)</td></tr>
<tr class="separator:acca193f3f8c77e60f4ef1058b73e4723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74a8f24bce4a71581de0183908ac05" id="r_aad74a8f24bce4a71581de0183908ac05"><td class="memItemLeft" align="right" valign="top">Hashable|Sequence[Hashable]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aad74a8f24bce4a71581de0183908ac05">_get_level_names</a> (self)</td></tr>
<tr class="separator:aad74a8f24bce4a71581de0183908ac05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952037d426cfd039f15b10bf9621c75e" id="r_a952037d426cfd039f15b10bf9621c75e"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a952037d426cfd039f15b10bf9621c75e">_mpl_repr</a> (self)</td></tr>
<tr class="separator:a952037d426cfd039f15b10bf9621c75e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01addbe09d0e78da36c825968c819c44" id="r_a01addbe09d0e78da36c825968c819c44"><td class="memItemLeft" align="right" valign="top">list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a01addbe09d0e78da36c825968c819c44">_format_with_header</a> (self, list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>] header, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> na_rep)</td></tr>
<tr class="separator:a01addbe09d0e78da36c825968c819c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fb228b5af28fdd5e72c75f449fa76e" id="r_a68fb228b5af28fdd5e72c75f449fa76e"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.object_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a68fb228b5af28fdd5e72c75f449fa76e">_format_native_types</a> (self, *na_rep=&quot;&quot;, quoting=None, **kwargs)</td></tr>
<tr class="separator:a68fb228b5af28fdd5e72c75f449fa76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480dee6a00f852534deaef4a82216bc0" id="r_a480dee6a00f852534deaef4a82216bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a480dee6a00f852534deaef4a82216bc0">_summary</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None)</td></tr>
<tr class="separator:a480dee6a00f852534deaef4a82216bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03721b134ec56c1dd0d644a65adf4a04" id="r_a03721b134ec56c1dd0d644a65adf4a04"><td class="memItemLeft" align="right" valign="top">list[Hashable]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a03721b134ec56c1dd0d644a65adf4a04">_validate_names</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>=None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aeb583e3bb8a437f0d1a6fb0b82510359">names</a>=None, bool deep=False)</td></tr>
<tr class="separator:a03721b134ec56c1dd0d644a65adf4a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5998822b15a152247780496b590ca3" id="r_a8f5998822b15a152247780496b590ca3"><td class="memItemLeft" align="right" valign="top">list[Hashable]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8f5998822b15a152247780496b590ca3">_get_default_index_names</a> (self, Hashable|Sequence[Hashable]|None <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aeb583e3bb8a437f0d1a6fb0b82510359">names</a>=None, default=None)</td></tr>
<tr class="separator:a8f5998822b15a152247780496b590ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81701ab0c850457a0738bf314235a92" id="r_af81701ab0c850457a0738bf314235a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1frozen_1_1_frozen_list.html">FrozenList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af81701ab0c850457a0738bf314235a92">_get_names</a> (self)</td></tr>
<tr class="separator:af81701ab0c850457a0738bf314235a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5698e03a836f4b2113d3002def90aba7" id="r_a5698e03a836f4b2113d3002def90aba7"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5698e03a836f4b2113d3002def90aba7">_set_names</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a644cfdf7877cdf1c4bfd5dab621586bd">values</a>, *level=None)</td></tr>
<tr class="separator:a5698e03a836f4b2113d3002def90aba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9776b9d20de2e575f790a31645421d1f" id="r_a9776b9d20de2e575f790a31645421d1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9776b9d20de2e575f790a31645421d1f">_sort_levels_monotonic</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self)</td></tr>
<tr class="separator:a9776b9d20de2e575f790a31645421d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a560cee64a9c2336cbfc21a12f7b20a0a" id="r_a560cee64a9c2336cbfc21a12f7b20a0a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a560cee64a9c2336cbfc21a12f7b20a0a">_validate_index_level</a> (self, level)</td></tr>
<tr class="separator:a560cee64a9c2336cbfc21a12f7b20a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b018146ec534a533393886c622b03f" id="r_aa3b018146ec534a533393886c622b03f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa3b018146ec534a533393886c622b03f">_get_level_number</a> (self, level)</td></tr>
<tr class="separator:aa3b018146ec534a533393886c622b03f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2bf62078de48efb3f4262354d47eb8" id="r_abd2bf62078de48efb3f4262354d47eb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abd2bf62078de48efb3f4262354d47eb8">_get_level_values</a> (self, level)</td></tr>
<tr class="separator:abd2bf62078de48efb3f4262354d47eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba53652f5d091601943c1eb7fdd3104" id="r_a5ba53652f5d091601943c1eb7fdd3104"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5ba53652f5d091601943c1eb7fdd3104">_drop_level_numbers</a> (self, list[int] levnums)</td></tr>
<tr class="separator:a5ba53652f5d091601943c1eb7fdd3104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee45df7b7191adb95d620b3019e3c4c2" id="r_aee45df7b7191adb95d620b3019e3c4c2"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.signedinteger]|None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aee45df7b7191adb95d620b3019e3c4c2">_get_grouper_for_level</a> (self, mapper, *level=None, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a90a16b6957c9c008ada0dce2238ab892">dropna</a>=True)</td></tr>
<tr class="separator:aee45df7b7191adb95d620b3019e3c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d6f304bd067838816fec557c043494" id="r_a19d6f304bd067838816fec557c043494"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a19d6f304bd067838816fec557c043494">_can_hold_na</a> (self)</td></tr>
<tr class="separator:a19d6f304bd067838816fec557c043494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb64ce356d6fff06e13334f633e7d77" id="r_a4cb64ce356d6fff06e13334f633e7d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4cb64ce356d6fff06e13334f633e7d77">_is_strictly_monotonic_increasing</a> (self)</td></tr>
<tr class="separator:a4cb64ce356d6fff06e13334f633e7d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97bc69d6e2c85c57ae7512b6dd46dac" id="r_ac97bc69d6e2c85c57ae7512b6dd46dac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac97bc69d6e2c85c57ae7512b6dd46dac">_is_strictly_monotonic_decreasing</a> (self)</td></tr>
<tr class="separator:ac97bc69d6e2c85c57ae7512b6dd46dac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749df7c9e493acf44522ea1924f9977e" id="r_a749df7c9e493acf44522ea1924f9977e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a749df7c9e493acf44522ea1924f9977e">_is_all_dates</a> (self)</td></tr>
<tr class="separator:a749df7c9e493acf44522ea1924f9977e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f250b7f81a755751bbd21552280cb" id="r_af77f250b7f81a755751bbd21552280cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af77f250b7f81a755751bbd21552280cb">_is_multi</a> (self)</td></tr>
<tr class="separator:af77f250b7f81a755751bbd21552280cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001ebbd18228d72fe0125bc591150f12" id="r_a001ebbd18228d72fe0125bc591150f12"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a001ebbd18228d72fe0125bc591150f12">_na_value</a> (self)</td></tr>
<tr class="separator:a001ebbd18228d72fe0125bc591150f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074ef758fd37bd994d42affa8eb14e1" id="r_a5074ef758fd37bd994d42affa8eb14e1"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5074ef758fd37bd994d42affa8eb14e1">_isnan</a> (self)</td></tr>
<tr class="separator:a5074ef758fd37bd994d42affa8eb14e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3589059df55a436cad79f92c939fe3e0" id="r_a3589059df55a436cad79f92c939fe3e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3589059df55a436cad79f92c939fe3e0">_get_reconciled_name_object</a> (self, other)</td></tr>
<tr class="separator:a3589059df55a436cad79f92c939fe3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a7cf0d7a2efb6c00041591d9b1d893" id="r_ae4a7cf0d7a2efb6c00041591d9b1d893"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae4a7cf0d7a2efb6c00041591d9b1d893">_validate_sort_keyword</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>)</td></tr>
<tr class="separator:ae4a7cf0d7a2efb6c00041591d9b1d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2bde2e76c59ae03b175974ad9ca0a68" id="r_ab2bde2e76c59ae03b175974ad9ca0a68"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab2bde2e76c59ae03b175974ad9ca0a68">_deprecate_dti_setop</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> setop)</td></tr>
<tr class="separator:ab2bde2e76c59ae03b175974ad9ca0a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfddd70684cefa1ba1d124cd10e3076e" id="r_adfddd70684cefa1ba1d124cd10e3076e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#adfddd70684cefa1ba1d124cd10e3076e">_union</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>)</td></tr>
<tr class="separator:adfddd70684cefa1ba1d124cd10e3076e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0b7261fabb47a29f6b60e2a1ac0410" id="r_a8b0b7261fabb47a29f6b60e2a1ac0410"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8b0b7261fabb47a29f6b60e2a1ac0410">_wrap_setop_result</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, result)</td></tr>
<tr class="separator:a8b0b7261fabb47a29f6b60e2a1ac0410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1dfc88fbeb99c226342f877fa78ef8" id="r_a4f1dfc88fbeb99c226342f877fa78ef8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4f1dfc88fbeb99c226342f877fa78ef8">_intersection</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>=False)</td></tr>
<tr class="separator:a4f1dfc88fbeb99c226342f877fa78ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ced146253c50f98f41f5dcda11adab" id="r_a14ced146253c50f98f41f5dcda11adab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a14ced146253c50f98f41f5dcda11adab">_wrap_intersection_result</a> (self, other, result)</td></tr>
<tr class="separator:a14ced146253c50f98f41f5dcda11adab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa3b456101c443a1d9d233362ecff6d" id="r_a8fa3b456101c443a1d9d233362ecff6d"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8fa3b456101c443a1d9d233362ecff6d">_intersection_via_get_indexer</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>)</td></tr>
<tr class="separator:a8fa3b456101c443a1d9d233362ecff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94cb17285aaf55f8698618459c6428d" id="r_ac94cb17285aaf55f8698618459c6428d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac94cb17285aaf55f8698618459c6428d">_difference</a> (self, other, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>)</td></tr>
<tr class="separator:ac94cb17285aaf55f8698618459c6428d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caa5b52504728b3d35953c5d737c360" id="r_a0caa5b52504728b3d35953c5d737c360"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0caa5b52504728b3d35953c5d737c360">_wrap_difference_result</a> (self, other, result)</td></tr>
<tr class="separator:a0caa5b52504728b3d35953c5d737c360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756bbd00cb2e91dee75415821bed194" id="r_a3756bbd00cb2e91dee75415821bed194"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3756bbd00cb2e91dee75415821bed194">_assert_can_do_setop</a> (self, other)</td></tr>
<tr class="separator:a3756bbd00cb2e91dee75415821bed194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a398c4f33e1e09478d869810f80cbd9" id="r_a6a398c4f33e1e09478d869810f80cbd9"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, Hashable]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6a398c4f33e1e09478d869810f80cbd9">_convert_can_do_setop</a> (self, other)</td></tr>
<tr class="separator:a6a398c4f33e1e09478d869810f80cbd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671476cb3d6481c661b74083146acf82" id="r_a671476cb3d6481c661b74083146acf82"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a671476cb3d6481c661b74083146acf82">_get_indexer</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>|None method=None, int|None limit=None, tolerance=None)</td></tr>
<tr class="separator:a671476cb3d6481c661b74083146acf82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556f72b484804d2e4fb98872fe8cd28d" id="r_a556f72b484804d2e4fb98872fe8cd28d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a556f72b484804d2e4fb98872fe8cd28d">_should_partial_index</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target)</td></tr>
<tr class="separator:a556f72b484804d2e4fb98872fe8cd28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a997a952ffa381fe0f1acf6eeb089a4cb" id="r_a997a952ffa381fe0f1acf6eeb089a4cb"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a997a952ffa381fe0f1acf6eeb089a4cb">_check_indexing_method</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>|None method, int|None limit=None, tolerance=None)</td></tr>
<tr class="separator:a997a952ffa381fe0f1acf6eeb089a4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b462fbc8b21347e64de5e344f3a4fd" id="r_ab1b462fbc8b21347e64de5e344f3a4fd"><td class="memItemLeft" align="right" valign="top">np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab1b462fbc8b21347e64de5e344f3a4fd">_convert_tolerance</a> (self, tolerance, np.ndarray|<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target)</td></tr>
<tr class="separator:ab1b462fbc8b21347e64de5e344f3a4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1679fd8983b7bc7a29ddaf44589c31b" id="r_ab1679fd8983b7bc7a29ddaf44589c31b"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab1679fd8983b7bc7a29ddaf44589c31b">_get_fill_indexer</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> method, int|None limit=None, tolerance=None)</td></tr>
<tr class="separator:ab1679fd8983b7bc7a29ddaf44589c31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43628cb90529c4f4cb0deef3c106efd" id="r_ab43628cb90529c4f4cb0deef3c106efd"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab43628cb90529c4f4cb0deef3c106efd">_get_fill_indexer_searchsorted</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> method, int|None limit=None)</td></tr>
<tr class="separator:ab43628cb90529c4f4cb0deef3c106efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2c573ca77ab831bb9875eaf1e563cb" id="r_abc2c573ca77ab831bb9875eaf1e563cb"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abc2c573ca77ab831bb9875eaf1e563cb">_get_nearest_indexer</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, int|None limit, tolerance)</td></tr>
<tr class="separator:abc2c573ca77ab831bb9875eaf1e563cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e3a94192f742df330bf1d46fba8418" id="r_a57e3a94192f742df330bf1d46fba8418"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a57e3a94192f742df330bf1d46fba8418">_filter_indexer_tolerance</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, npt.NDArray[np.intp] indexer, tolerance)</td></tr>
<tr class="separator:a57e3a94192f742df330bf1d46fba8418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7b01f337a2084acb72ba3031655bf31" id="r_aa7b01f337a2084acb72ba3031655bf31"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa7b01f337a2084acb72ba3031655bf31">_difference_compat</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, npt.NDArray[np.intp] indexer)</td></tr>
<tr class="separator:aa7b01f337a2084acb72ba3031655bf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1caf1b7990e119a3b7bb782b1ca79441" id="r_a1caf1b7990e119a3b7bb782b1ca79441"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a1caf1b7990e119a3b7bb782b1ca79441">_validate_positional_slice</a> (self, slice key)</td></tr>
<tr class="separator:a1caf1b7990e119a3b7bb782b1ca79441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c447b67bf7e9340e5ac0933f610c6" id="r_ab44c447b67bf7e9340e5ac0933f610c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab44c447b67bf7e9340e5ac0933f610c6">_convert_slice_indexer</a> (self, slice key, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> kind, bool is_frame=False)</td></tr>
<tr class="separator:ab44c447b67bf7e9340e5ac0933f610c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad82f8d6e9a81927746223680392e963" id="r_aad82f8d6e9a81927746223680392e963"><td class="memItemLeft" align="right" valign="top">TypeError&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aad82f8d6e9a81927746223680392e963">_invalid_indexer</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> form, key)</td></tr>
<tr class="separator:aad82f8d6e9a81927746223680392e963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ece674a4d44b8d9911200613d7055a" id="r_a94ece674a4d44b8d9911200613d7055a"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a94ece674a4d44b8d9911200613d7055a">_validate_can_reindex</a> (self, np.ndarray indexer)</td></tr>
<tr class="separator:a94ece674a4d44b8d9911200613d7055a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5ae02ff44cc3fea269f5e0b18ab4ac" id="r_a1e5ae02ff44cc3fea269f5e0b18ab4ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a1e5ae02ff44cc3fea269f5e0b18ab4ac">_wrap_reindex_result</a> (self, target, indexer, bool preserve_names)</td></tr>
<tr class="separator:a1e5ae02ff44cc3fea269f5e0b18ab4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7fc0e3783f3e1eba4e7705da4e5756" id="r_afa7fc0e3783f3e1eba4e7705da4e5756"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#afa7fc0e3783f3e1eba4e7705da4e5756">_maybe_preserve_names</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, bool preserve_names)</td></tr>
<tr class="separator:afa7fc0e3783f3e1eba4e7705da4e5756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae532208b79d7ee99b9822ac88609c0ef" id="r_ae532208b79d7ee99b9822ac88609c0ef"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp], npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae532208b79d7ee99b9822ac88609c0ef">_reindex_non_unique</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target)</td></tr>
<tr class="separator:ae532208b79d7ee99b9822ac88609c0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a2c821734309500dfbbe57aa563576" id="r_ae4a2c821734309500dfbbe57aa563576"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ae4a2c821734309500dfbbe57aa563576">_join_via_get_indexer</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a65dd03a5291f205bda3867d89e7fd1a8">sort</a>)</td></tr>
<tr class="separator:ae4a2c821734309500dfbbe57aa563576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999711e5ae0747c4e4dd3c006c15c4c0" id="r_a999711e5ae0747c4e4dd3c006c15c4c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a999711e5ae0747c4e4dd3c006c15c4c0">_join_multi</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how)</td></tr>
<tr class="separator:a999711e5ae0747c4e4dd3c006c15c4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec14555c344e7feb0b4effc2991fbbd8" id="r_aec14555c344e7feb0b4effc2991fbbd8"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aec14555c344e7feb0b4effc2991fbbd8">_join_non_unique</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=&quot;left&quot;)</td></tr>
<tr class="separator:aec14555c344e7feb0b4effc2991fbbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326f8dccb9cd9c74c6443f048452fac7" id="r_a326f8dccb9cd9c74c6443f048452fac7"><td class="memItemLeft" align="right" valign="top">tuple[MultiIndex, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a326f8dccb9cd9c74c6443f048452fac7">_join_level</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, level, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=&quot;left&quot;, bool keep_order=True)</td></tr>
<tr class="separator:a326f8dccb9cd9c74c6443f048452fac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8430c69ac1343b875b2e1205b05bec" id="r_a8e8430c69ac1343b875b2e1205b05bec"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp]|None, npt.NDArray[np.intp]|None]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8e8430c69ac1343b875b2e1205b05bec">_join_monotonic</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> how=&quot;left&quot;)</td></tr>
<tr class="separator:a8e8430c69ac1343b875b2e1205b05bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983c4be44ea9df7a5273011c5706cf72" id="r_a983c4be44ea9df7a5273011c5706cf72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a983c4be44ea9df7a5273011c5706cf72">_wrap_joined_index</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, ArrayLike joined, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> other)</td></tr>
<tr class="separator:a983c4be44ea9df7a5273011c5706cf72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6320aea954549ca0240d8eac57452c9c" id="r_a6320aea954549ca0240d8eac57452c9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6320aea954549ca0240d8eac57452c9c">_can_use_libjoin</a> (self)</td></tr>
<tr class="separator:a6320aea954549ca0240d8eac57452c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98d209ccf5775ff7e012345413d4b8b" id="r_ac98d209ccf5775ff7e012345413d4b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>|np.ndarray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac98d209ccf5775ff7e012345413d4b8b">_values</a> (self)</td></tr>
<tr class="separator:ac98d209ccf5775ff7e012345413d4b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50097696e9d23abe7c8616a2530c38a5" id="r_a50097696e9d23abe7c8616a2530c38a5"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a50097696e9d23abe7c8616a2530c38a5">_get_engine_target</a> (self)</td></tr>
<tr class="separator:a50097696e9d23abe7c8616a2530c38a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4370524ecf6a1869e8c1148c3c2c5267" id="r_a4370524ecf6a1869e8c1148c3c2c5267"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4370524ecf6a1869e8c1148c3c2c5267">_from_join_target</a> (self, np.ndarray result)</td></tr>
<tr class="separator:a4370524ecf6a1869e8c1148c3c2c5267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1d16c2d614fd1262a4e918e39eaaac" id="r_a8e1d16c2d614fd1262a4e918e39eaaac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8e1d16c2d614fd1262a4e918e39eaaac">_scalar_data_error</a> (cls, data)</td></tr>
<tr class="separator:a8e1d16c2d614fd1262a4e918e39eaaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f65ecaa6cd031c127c61065dbfda34f" id="r_a5f65ecaa6cd031c127c61065dbfda34f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5f65ecaa6cd031c127c61065dbfda34f">_string_data_error</a> (cls, data)</td></tr>
<tr class="separator:a5f65ecaa6cd031c127c61065dbfda34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c39830f88371a4bbda4a182fe34e73" id="r_aa5c39830f88371a4bbda4a182fe34e73"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa5c39830f88371a4bbda4a182fe34e73">_validate_fill_value</a> (self, value)</td></tr>
<tr class="separator:aa5c39830f88371a4bbda4a182fe34e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f6899ca731408a1e44e4aecfba2212" id="r_a35f6899ca731408a1e44e4aecfba2212"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a35f6899ca731408a1e44e4aecfba2212">_require_scalar</a> (self, value)</td></tr>
<tr class="separator:a35f6899ca731408a1e44e4aecfba2212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6589dfe5acc663da458a789eea9a612e" id="r_a6589dfe5acc663da458a789eea9a612e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6589dfe5acc663da458a789eea9a612e">_is_memory_usage_qualified</a> (self)</td></tr>
<tr class="separator:a6589dfe5acc663da458a789eea9a612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c26534bb54cd015954850f06623f22a" id="r_a2c26534bb54cd015954850f06623f22a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2c26534bb54cd015954850f06623f22a">_getitem_slice</a> (<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> self, slice slobj)</td></tr>
<tr class="separator:a2c26534bb54cd015954850f06623f22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17e1f4a2add4df9c7b6a2f9beac5f63" id="r_aa17e1f4a2add4df9c7b6a2f9beac5f63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa17e1f4a2add4df9c7b6a2f9beac5f63">_can_hold_identifiers_and_holds_name</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>)</td></tr>
<tr class="separator:aa17e1f4a2add4df9c7b6a2f9beac5f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5d4a0084ecf45e9d24559249a8f8b5" id="r_a7f5d4a0084ecf45e9d24559249a8f8b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7f5d4a0084ecf45e9d24559249a8f8b5">_concat</a> (self, list[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>] to_concat, Hashable <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>)</td></tr>
<tr class="separator:a7f5d4a0084ecf45e9d24559249a8f8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b6242604597391a7f8262439edf102" id="r_a11b6242604597391a7f8262439edf102"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a11b6242604597391a7f8262439edf102">_check_indexing_error</a> (self, key)</td></tr>
<tr class="separator:a11b6242604597391a7f8262439edf102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2861ae82da69581e339915875a91cc" id="r_a3b2861ae82da69581e339915875a91cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3b2861ae82da69581e339915875a91cc">_should_fallback_to_positional</a> (self)</td></tr>
<tr class="separator:a3b2861ae82da69581e339915875a91cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a01ca5a9c2186ee82dd91f6d3b35d4" id="r_a05a01ca5a9c2186ee82dd91f6d3b35d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a05a01ca5a9c2186ee82dd91f6d3b35d4">_get_values_for_loc</a> (self, Series series, loc, key)</td></tr>
<tr class="separator:a05a01ca5a9c2186ee82dd91f6d3b35d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074db92a4b78e6de76bd54b873ebacd" id="r_a5074db92a4b78e6de76bd54b873ebacd"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, np.ndarray]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5074db92a4b78e6de76bd54b873ebacd">_get_indexer_strict</a> (self, key, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> axis_name)</td></tr>
<tr class="separator:a5074db92a4b78e6de76bd54b873ebacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc499589f7b32aa77ad40c4a31b408c" id="r_a4dc499589f7b32aa77ad40c4a31b408c"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4dc499589f7b32aa77ad40c4a31b408c">_raise_if_missing</a> (self, key, indexer, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> axis_name)</td></tr>
<tr class="separator:a4dc499589f7b32aa77ad40c4a31b408c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d18ba4f6805189d3424bb0a95a6e3d" id="r_a81d18ba4f6805189d3424bb0a95a6e3d"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a81d18ba4f6805189d3424bb0a95a6e3d">_get_indexer_non_comparable</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, method, Literal[True] <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2f22b33fc0d79997f4625ff43718ec0c">unique</a>=...)</td></tr>
<tr class="separator:a81d18ba4f6805189d3424bb0a95a6e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fbb97d7ed4acf3106be322cd8e661e" id="r_aa1fbb97d7ed4acf3106be322cd8e661e"><td class="memItemLeft" align="right" valign="top">tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa1fbb97d7ed4acf3106be322cd8e661e">_get_indexer_non_comparable</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, method, Literal[False] <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2f22b33fc0d79997f4625ff43718ec0c">unique</a>)</td></tr>
<tr class="separator:aa1fbb97d7ed4acf3106be322cd8e661e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4605d9c657151f9abe98dbeca90ab4" id="r_a7f4605d9c657151f9abe98dbeca90ab4"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7f4605d9c657151f9abe98dbeca90ab4">_get_indexer_non_comparable</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, method, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2f22b33fc0d79997f4625ff43718ec0c">unique</a>=True)</td></tr>
<tr class="separator:a7f4605d9c657151f9abe98dbeca90ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4605d9c657151f9abe98dbeca90ab4" id="r_a7f4605d9c657151f9abe98dbeca90ab4"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.intp]|tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7f4605d9c657151f9abe98dbeca90ab4">_get_indexer_non_comparable</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> target, method, bool <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2f22b33fc0d79997f4625ff43718ec0c">unique</a>=True)</td></tr>
<tr class="separator:a7f4605d9c657151f9abe98dbeca90ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8cbdfaf190452620fd6d6537f8b3af" id="r_ade8cbdfaf190452620fd6d6537f8b3af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ade8cbdfaf190452620fd6d6537f8b3af">_index_as_unique</a> (self)</td></tr>
<tr class="separator:ade8cbdfaf190452620fd6d6537f8b3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f38c6635feecb0baf3b2409345d726" id="r_a37f38c6635feecb0baf3b2409345d726"><td class="memItemLeft" align="right" valign="top">tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a37f38c6635feecb0baf3b2409345d726">_maybe_promote</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other)</td></tr>
<tr class="separator:a37f38c6635feecb0baf3b2409345d726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364a8c33aceb3ffefb8f03d5bbcbb2f4" id="r_a364a8c33aceb3ffefb8f03d5bbcbb2f4"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a364a8c33aceb3ffefb8f03d5bbcbb2f4">_find_common_type_compat</a> (self, target)</td></tr>
<tr class="separator:a364a8c33aceb3ffefb8f03d5bbcbb2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed96728036a7ea14abeb0e1ed341610" id="r_a4ed96728036a7ea14abeb0e1ed341610"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4ed96728036a7ea14abeb0e1ed341610">_should_compare</a> (self, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> other)</td></tr>
<tr class="separator:a4ed96728036a7ea14abeb0e1ed341610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4199a94a79bb306e87457970a5734439" id="r_a4199a94a79bb306e87457970a5734439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4199a94a79bb306e87457970a5734439">_is_comparable_dtype</a> (self, DtypeObj <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a89f0dd01f7221293308ad6cc8d05f842">dtype</a>)</td></tr>
<tr class="separator:a4199a94a79bb306e87457970a5734439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7101105dfd70acc9d468f7abf5605090" id="r_a7101105dfd70acc9d468f7abf5605090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7101105dfd70acc9d468f7abf5605090">_transform_index</a> (self, <a class="el" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>, *level=None)</td></tr>
<tr class="separator:a7101105dfd70acc9d468f7abf5605090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d5c5720de721f1ffbae41a43731ecf" id="r_a86d5c5720de721f1ffbae41a43731ecf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a86d5c5720de721f1ffbae41a43731ecf">_get_string_slice</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> key)</td></tr>
<tr class="separator:a86d5c5720de721f1ffbae41a43731ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f7c3fa8c471eb3be9df110a687e8bea" id="r_a6f7c3fa8c471eb3be9df110a687e8bea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f7c3fa8c471eb3be9df110a687e8bea">_maybe_cast_indexer</a> (self, key)</td></tr>
<tr class="separator:a6f7c3fa8c471eb3be9df110a687e8bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6deb56771ef3f8f8970807b2e3e8d1" id="r_a8f6deb56771ef3f8f8970807b2e3e8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8f6deb56771ef3f8f8970807b2e3e8d1">_maybe_cast_listlike_indexer</a> (self, target)</td></tr>
<tr class="separator:a8f6deb56771ef3f8f8970807b2e3e8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135360c48e1a35f5576dc734c760f26a" id="r_a135360c48e1a35f5576dc734c760f26a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a135360c48e1a35f5576dc734c760f26a">_validate_indexer</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> form, key, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> kind)</td></tr>
<tr class="separator:a135360c48e1a35f5576dc734c760f26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc058ca0e7a363b573f2003c91cd505" id="r_a0bc058ca0e7a363b573f2003c91cd505"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0bc058ca0e7a363b573f2003c91cd505">_maybe_cast_slice_bound</a> (self, label, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>, kind=no_default)</td></tr>
<tr class="separator:a0bc058ca0e7a363b573f2003c91cd505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addcfdb0432ad6e66a483b5d31957f013" id="r_addcfdb0432ad6e66a483b5d31957f013"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#addcfdb0432ad6e66a483b5d31957f013">_searchsorted_monotonic</a> (self, label, Literal[&quot;left&quot;, &quot;right&quot;] <a class="el" href="__lapack__subroutines_8h.html#a9e68bda1c892ed360a67b3e6e02cda76">side</a>=&quot;left&quot;)</td></tr>
<tr class="separator:addcfdb0432ad6e66a483b5d31957f013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15299fe176cdd788acd160740a578d79" id="r_a15299fe176cdd788acd160740a578d79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a15299fe176cdd788acd160740a578d79">_cmp_method</a> (self, other, op)</td></tr>
<tr class="separator:a15299fe176cdd788acd160740a578d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ffbb4d6fd8646f382dbb5290ec674d" id="r_aa6ffbb4d6fd8646f382dbb5290ec674d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa6ffbb4d6fd8646f382dbb5290ec674d">_construct_result</a> (self, result, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>)</td></tr>
<tr class="separator:aa6ffbb4d6fd8646f382dbb5290ec674d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1fd5198f03c0d3e5888ab49b914aa6" id="r_afd1fd5198f03c0d3e5888ab49b914aa6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#afd1fd5198f03c0d3e5888ab49b914aa6">_arith_method</a> (self, other, op)</td></tr>
<tr class="separator:afd1fd5198f03c0d3e5888ab49b914aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87d7e44eb54356256b84292944aa8d4" id="r_aa87d7e44eb54356256b84292944aa8d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa87d7e44eb54356256b84292944aa8d4">_unary_method</a> (self, op)</td></tr>
<tr class="separator:aa87d7e44eb54356256b84292944aa8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac542abc7754f845c6847882f7158dda1" id="r_ac542abc7754f845c6847882f7158dda1"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac542abc7754f845c6847882f7158dda1">_maybe_disable_logical_methods</a> (self, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> opname)</td></tr>
<tr class="separator:ac542abc7754f845c6847882f7158dda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e83c575beb751c05d6cea77973daf" id="r_af05e83c575beb751c05d6cea77973daf"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af05e83c575beb751c05d6cea77973daf">_deprecated_arg</a> (self, value, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a3ff207e0d287fb46016e9beb32ef8c28">name</a>, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> methodname)</td></tr>
<tr class="separator:af05e83c575beb751c05d6cea77973daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
<tr class="memitem:a7cba37fb1158234770b64abaa29a5155 inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a7cba37fb1158234770b64abaa29a5155"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a7cba37fb1158234770b64abaa29a5155">_reduce</a> (self, op, str name, *axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)</td></tr>
<tr class="separator:a7cba37fb1158234770b64abaa29a5155 inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaaaf8898b685f8ca04bff0271cd17f inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_aabaaaf8898b685f8ca04bff0271cd17f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#aabaaaf8898b685f8ca04bff0271cd17f">_map_values</a> (self, mapper, na_action=None)</td></tr>
<tr class="separator:aabaaaf8898b685f8ca04bff0271cd17f inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93dc31823c624bc7db5859e02f7ca1cf inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a93dc31823c624bc7db5859e02f7ca1cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a93dc31823c624bc7db5859e02f7ca1cf">_memory_usage</a> (self, bool deep=False)</td></tr>
<tr class="separator:a93dc31823c624bc7db5859e02f7ca1cf inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514b5bafb20a48a6d9bb683f744604d0 inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a514b5bafb20a48a6d9bb683f744604d0"><td class="memItemLeft" align="right" valign="top">npt.NDArray[np.bool_]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a514b5bafb20a48a6d9bb683f744604d0">_duplicated</a> (self, Literal[&quot;first&quot;, &quot;last&quot;, False] keep=&quot;first&quot;)</td></tr>
<tr class="separator:a514b5bafb20a48a6d9bb683f744604d0 inherit pro_methods_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html">pandas.core.arraylike.OpsMixin</a></td></tr>
<tr class="memitem:a70647d86f30672246d0e61a3222615a2 inherit pro_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin" id="r_a70647d86f30672246d0e61a3222615a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a70647d86f30672246d0e61a3222615a2">_logical_method</a> (self, other, op)</td></tr>
<tr class="separator:a70647d86f30672246d0e61a3222615a2 inherit pro_methods_classpandas_1_1core_1_1arraylike_1_1_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:a8a2b95a9e1e4befc5ad3cba09c3f3e68 inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_a8a2b95a9e1e4befc5ad3cba09c3f3e68"><td class="memItemLeft" align="right" valign="top">None&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a8a2b95a9e1e4befc5ad3cba09c3f3e68">_reset_cache</a> (self, str|None key=None)</td></tr>
<tr class="separator:a8a2b95a9e1e4befc5ad3cba09c3f3e68 inherit pro_methods_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:a3151f76f1b53042e9d13da3d3ef3cb92 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a3151f76f1b53042e9d13da3d3ef3cb92"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a3151f76f1b53042e9d13da3d3ef3cb92">_dir_deletions</a> (self)</td></tr>
<tr class="separator:a3151f76f1b53042e9d13da3d3ef3cb92 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8183d13494a720c8d4cc996826fd7323 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a8183d13494a720c8d4cc996826fd7323"><td class="memItemLeft" align="right" valign="top">set[str]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a8183d13494a720c8d4cc996826fd7323">_dir_additions</a> (self)</td></tr>
<tr class="separator:a8183d13494a720c8d4cc996826fd7323 inherit pro_methods_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad06490c50902ec2100f537ad226edc96" id="r_ad06490c50902ec2100f537ad226edc96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ad06490c50902ec2100f537ad226edc96">_data_cls</a></td></tr>
<tr class="separator:ad06490c50902ec2100f537ad226edc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b09379759ea599131ee56ba8ddbba5" id="r_aa0b09379759ea599131ee56ba8ddbba5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa0b09379759ea599131ee56ba8ddbba5">_id</a></td></tr>
<tr class="separator:aa0b09379759ea599131ee56ba8ddbba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec59fbfc1e0fea18e0ac79017b8a7ed1" id="r_aec59fbfc1e0fea18e0ac79017b8a7ed1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aec59fbfc1e0fea18e0ac79017b8a7ed1">_data</a></td></tr>
<tr class="separator:aec59fbfc1e0fea18e0ac79017b8a7ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd25b951980c40690cc5f33b7475cba8" id="r_acd25b951980c40690cc5f33b7475cba8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#acd25b951980c40690cc5f33b7475cba8">_formatter_func</a></td></tr>
<tr class="separator:acd25b951980c40690cc5f33b7475cba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba78217120b7c58e123180c90178f582" id="r_aba78217120b7c58e123180c90178f582"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aba78217120b7c58e123180c90178f582">_name</a></td></tr>
<tr class="separator:aba78217120b7c58e123180c90178f582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8205121019db1c2670b43c14dbb20cb" id="r_aa8205121019db1c2670b43c14dbb20cb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa8205121019db1c2670b43c14dbb20cb">_values</a></td></tr>
<tr class="separator:aa8205121019db1c2670b43c14dbb20cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e2dd23b29bfd34c67d7f50df6dc7b1" id="r_ac4e2dd23b29bfd34c67d7f50df6dc7b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac4e2dd23b29bfd34c67d7f50df6dc7b1">_requires_unique_msg</a></td></tr>
<tr class="separator:ac4e2dd23b29bfd34c67d7f50df6dc7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3176c73933475321981e0452a288ca" id="r_a8e3176c73933475321981e0452a288ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a8e3176c73933475321981e0452a288ca">_range</a></td></tr>
<tr class="separator:a8e3176c73933475321981e0452a288ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dd104387bbd169760b23ece055a416" id="r_a70dd104387bbd169760b23ece055a416"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a70dd104387bbd169760b23ece055a416">_typ</a></td></tr>
<tr class="separator:a70dd104387bbd169760b23ece055a416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a04055aed79b8044489b5152bd9e8b5c3" id="r_a04055aed79b8044489b5152bd9e8b5c3"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a04055aed79b8044489b5152bd9e8b5c3">_hidden_attrs</a></td></tr>
<tr class="separator:a04055aed79b8044489b5152bd9e8b5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e0b60d1efa60e7134f67f532785fce" id="r_ab7e0b60d1efa60e7134f67f532785fce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ab7e0b60d1efa60e7134f67f532785fce">_join_precedence</a> = 1</td></tr>
<tr class="separator:ab7e0b60d1efa60e7134f67f532785fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dd4af4c1377a81c16675eec6e825a4" id="r_a67dd4af4c1377a81c16675eec6e825a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a09dc54c97265b31bbbe2b25730d404e0">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a67dd4af4c1377a81c16675eec6e825a4">_typ</a> = &quot;index&quot;</td></tr>
<tr class="separator:a67dd4af4c1377a81c16675eec6e825a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a3191708ce47ff3341186cc0af42be" id="r_a98a3191708ce47ff3341186cc0af42be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a98a3191708ce47ff3341186cc0af42be">_data</a> | np.ndarray</td></tr>
<tr class="separator:a98a3191708ce47ff3341186cc0af42be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891d552bc01c6f433888d9134b2010af" id="r_a891d552bc01c6f433888d9134b2010af"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a891d552bc01c6f433888d9134b2010af">_data_cls</a></td></tr>
<tr class="separator:a891d552bc01c6f433888d9134b2010af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75021533c394fd113f641ba7f038d335" id="r_a75021533c394fd113f641ba7f038d335"><td class="memItemLeft" align="right" valign="top">object&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a75021533c394fd113f641ba7f038d335">_id</a> = None</td></tr>
<tr class="separator:a75021533c394fd113f641ba7f038d335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa591db6e26b93e8529fcde91d2f04428" id="r_aa591db6e26b93e8529fcde91d2f04428"><td class="memItemLeft" align="right" valign="top">Hashable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aa591db6e26b93e8529fcde91d2f04428">_name</a> = None</td></tr>
<tr class="separator:aa591db6e26b93e8529fcde91d2f04428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7393d95bc48316b158792b1acb768aab" id="r_a7393d95bc48316b158792b1acb768aab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a7393d95bc48316b158792b1acb768aab">_no_setting_name</a> = False</td></tr>
<tr class="separator:a7393d95bc48316b158792b1acb768aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f620a9a15678d770bfa5facf62f212b" id="r_a6f620a9a15678d770bfa5facf62f212b"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a6f620a9a15678d770bfa5facf62f212b">_comparables</a> = [&quot;name&quot;]</td></tr>
<tr class="separator:a6f620a9a15678d770bfa5facf62f212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9458743a4a7f5c0dfac3520684062804" id="r_a9458743a4a7f5c0dfac3520684062804"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a9458743a4a7f5c0dfac3520684062804">_attributes</a> = [&quot;name&quot;]</td></tr>
<tr class="separator:a9458743a4a7f5c0dfac3520684062804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed5edd50792ceccc9c66350944a4a03" id="r_afed5edd50792ceccc9c66350944a4a03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#afed5edd50792ceccc9c66350944a4a03">_is_numeric_dtype</a> = False</td></tr>
<tr class="separator:afed5edd50792ceccc9c66350944a4a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32a12ed2d32d56e2e70922cb634c375" id="r_ac32a12ed2d32d56e2e70922cb634c375"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#ac32a12ed2d32d56e2e70922cb634c375">_can_hold_strings</a> = True</td></tr>
<tr class="separator:ac32a12ed2d32d56e2e70922cb634c375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73231a672b7fb2838868bdf3eccdbfe" id="r_af73231a672b7fb2838868bdf3eccdbfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af73231a672b7fb2838868bdf3eccdbfe">_is_backward_compat_public_numeric_index</a> = False</td></tr>
<tr class="separator:af73231a672b7fb2838868bdf3eccdbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2786c41936290dba55f184420ee987f0" id="r_a2786c41936290dba55f184420ee987f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a2786c41936290dba55f184420ee987f0">_supports_partial_string_indexing</a> = False</td></tr>
<tr class="separator:a2786c41936290dba55f184420ee987f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aae8eda9d31004df02be5178ce1fc6" id="r_a05aae8eda9d31004df02be5178ce1fc6"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a05aae8eda9d31004df02be5178ce1fc6">_accessors</a> = {&quot;str&quot;}</td></tr>
<tr class="separator:a05aae8eda9d31004df02be5178ce1fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8305c50b11b342b3778b45c76c928a" id="r_a0b8305c50b11b342b3778b45c76c928a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a09dc54c97265b31bbbe2b25730d404e0">str</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a0b8305c50b11b342b3778b45c76c928a">_requires_unique_msg</a> = &quot;Reindexing only valid with uniquely valued <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> objects&quot;</td></tr>
<tr class="separator:a0b8305c50b11b342b3778b45c76c928a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
<tr class="memitem:a358db439134cd51ecc8927c554240caf inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_a358db439134cd51ecc8927c554240caf"><td class="memItemLeft" align="right" valign="top">frozenset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a358db439134cd51ecc8927c554240caf">_hidden_attrs</a></td></tr>
<tr class="separator:a358db439134cd51ecc8927c554240caf inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html">pandas.core.base.PandasObject</a></td></tr>
<tr class="memitem:a3972565a4ab5ff072118eda20364cd2c inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object" id="r_a3972565a4ab5ff072118eda20364cd2c"><td class="memItemLeft" align="right" valign="top">dict&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a3972565a4ab5ff072118eda20364cd2c">_cache</a> [str, Any]</td></tr>
<tr class="separator:a3972565a4ab5ff072118eda20364cd2c inherit pro_static_attribs_classpandas_1_1core_1_1base_1_1_pandas_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td colspan="2" onclick="javascript:toggleInherit('pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin')"><img src="closed.png" alt="-"/>&#160;Static Protected Attributes inherited from <a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html">pandas.core.accessor.DirNamesMixin</a></td></tr>
<tr class="memitem:a1e3f9f50e3532c77c3610c4b8fe27e6f inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a1e3f9f50e3532c77c3610c4b8fe27e6f"><td class="memItemLeft" align="right" valign="top">set&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a1e3f9f50e3532c77c3610c4b8fe27e6f">_accessors</a> = set()</td></tr>
<tr class="separator:a1e3f9f50e3532c77c3610c4b8fe27e6f inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c1894b79d330020bdc71ddc7126f0 inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin" id="r_a7b9c1894b79d330020bdc71ddc7126f0"><td class="memItemLeft" align="right" valign="top">frozenset&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1accessor_1_1_dir_names_mixin.html#a7b9c1894b79d330020bdc71ddc7126f0">_hidden_attrs</a> = frozenset()</td></tr>
<tr class="separator:a7b9c1894b79d330020bdc71ddc7126f0 inherit pro_static_attribs_classpandas_1_1core_1_1accessor_1_1_dir_names_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="properties" name="properties"></a>
Properties</h2></td></tr>
<tr class="memitem:aeb583e3bb8a437f0d1a6fb0b82510359" id="r_aeb583e3bb8a437f0d1a6fb0b82510359"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aeb583e3bb8a437f0d1a6fb0b82510359">names</a> = property(fset=<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5698e03a836f4b2113d3002def90aba7">_set_names</a>, fget=<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af81701ab0c850457a0738bf314235a92">_get_names</a>)</td></tr>
<tr class="separator:aeb583e3bb8a437f0d1a6fb0b82510359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header properties_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td colspan="2" onclick="javascript:toggleInherit('properties_classpandas_1_1core_1_1base_1_1_index_ops_mixin')"><img src="closed.png" alt="-"/>&#160;Properties inherited from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html">pandas.core.base.IndexOpsMixin</a></td></tr>
<tr class="memitem:af66ac9845c46eda0d10837912b0c1ddb inherit properties_classpandas_1_1core_1_1base_1_1_index_ops_mixin" id="r_af66ac9845c46eda0d10837912b0c1ddb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#af66ac9845c46eda0d10837912b0c1ddb">T</a></td></tr>
<tr class="separator:af66ac9845c46eda0d10837912b0c1ddb inherit properties_classpandas_1_1core_1_1base_1_1_index_ops_mixin"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Immutable sequence used for indexing and alignment.

The basic object storing axis labels for all pandas objects.

Parameters
----------
data : array-like (1-dimensional)
dtype : NumPy dtype (default: object)
    If dtype is None, we find the dtype that best fits the data.
    If an actual dtype is provided, we coerce to that dtype if it's safe.
    Otherwise, an error will be raised.
copy : bool
    Make a copy of input ndarray.
name : object
    Name to be stored in the index.
tupleize_cols : bool (default: True)
    When True, attempt to create a MultiIndex if possible.

See Also
--------
RangeIndex : Index implementing a monotonic integer range.
CategoricalIndex : Index of :class:`Categorical` s.
MultiIndex : A multi-level, or hierarchical Index.
IntervalIndex : An Index of :class:`Interval` s.
DatetimeIndex : Index of datetime64 data.
TimedeltaIndex : Index of timedelta64 data.
PeriodIndex : Index of Period data.
NumericIndex : Index of numpy int/uint/float data.
Int64Index : Index of purely int64 labels (deprecated).
UInt64Index : Index of purely uint64 labels (deprecated).
Float64Index : Index of  purely float64 labels (deprecated).

Notes
-----
An Index instance can **only** contain hashable objects

Examples
--------
&gt;&gt;&gt; pd.Index([1, 2, 3])
Int64Index([1, 2, 3], dtype='int64')

&gt;&gt;&gt; pd.Index(list('abc'))
Index(['a', 'b', 'c'], dtype='object')
</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a61054f98e40a4bfa12ad1ecc02a31f80" name="a61054f98e40a4bfa12ad1ecc02a31f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61054f98e40a4bfa12ad1ecc02a31f80">&#9670;&#160;</a></span>__abs__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.__abs__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7057</span>    <span class="keyword">def </span>__abs__(self) -&gt; Index:</div>
<div class="line"><span class="lineno"> 7058</span>        <span class="keywordflow">return</span> self._unary_method(operator.abs)</div>
<div class="line"><span class="lineno"> 7059</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aad63922c7e09f3cdbf5a3e47cca09663" name="aad63922c7e09f3cdbf5a3e47cca09663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad63922c7e09f3cdbf5a3e47cca09663">&#9670;&#160;</a></span>__and__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__and__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#adda7224c44a31db6e7a6b8f441dd362a">pandas.core.arraylike.OpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3155</span>    <span class="keyword">def </span>__and__(self, other):</div>
<div class="line"><span class="lineno"> 3156</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 3157</span>            <span class="stringliteral">&quot;Index.__and__ operating as a set operation is deprecated, &quot;</span></div>
<div class="line"><span class="lineno"> 3158</span>            <span class="stringliteral">&quot;in the future this will be a logical operation matching &quot;</span></div>
<div class="line"><span class="lineno"> 3159</span>            <span class="stringliteral">&quot;Series.__and__.  Use index.intersection(other) instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 3160</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 3161</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3162</span>        )</div>
<div class="line"><span class="lineno"> 3163</span>        <span class="keywordflow">return</span> self.intersection(other)</div>
<div class="line"><span class="lineno"> 3164</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52343e9e9a3aab236fa2227714459739" name="a52343e9e9a3aab236fa2227714459739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52343e9e9a3aab236fa2227714459739">&#9670;&#160;</a></span>__array__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.indexes.base.Index.__array__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">The array interface, return my values.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a1a8f5e36378b2916903b611ebf7ed89a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  932</span>    <span class="keyword">def </span>__array__(self, dtype=None) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno">  933</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  934</span><span class="stringliteral">        The array interface, return my values.</span></div>
<div class="line"><span class="lineno">  935</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  936</span>        <span class="keywordflow">return</span> np.asarray(self._data, dtype=dtype)</div>
<div class="line"><span class="lineno">  937</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae46041d6654fda153af5f0c607043bbc" name="ae46041d6654fda153af5f0c607043bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46041d6654fda153af5f0c607043bbc">&#9670;&#160;</a></span>__array_ufunc__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__array_ufunc__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ufunc&#160;</td>
          <td class="paramname"><em>ufunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  938</span>    <span class="keyword">def </span>__array_ufunc__(self, ufunc: np.ufunc, method: str_t, *inputs, **kwargs):</div>
<div class="line"><span class="lineno">  939</span>        <span class="keywordflow">if</span> any(isinstance(other, (ABCSeries, ABCDataFrame)) <span class="keywordflow">for</span> other <span class="keywordflow">in</span> inputs):</div>
<div class="line"><span class="lineno">  940</span>            <span class="keywordflow">return</span> NotImplemented</div>
<div class="line"><span class="lineno">  941</span> </div>
<div class="line"><span class="lineno">  942</span>        <span class="comment"># TODO(2.0) the &#39;and&#39;, &#39;or&#39; and &#39;xor&#39; dunder methods are currently set</span></div>
<div class="line"><span class="lineno">  943</span>        <span class="comment"># operations and not logical operations, so don&#39;t dispatch</span></div>
<div class="line"><span class="lineno">  944</span>        <span class="comment"># This is deprecated, so this full &#39;if&#39; clause can be removed once</span></div>
<div class="line"><span class="lineno">  945</span>        <span class="comment"># deprecation is enforced in 2.0</span></div>
<div class="line"><span class="lineno">  946</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> (</div>
<div class="line"><span class="lineno">  947</span>            method == <span class="stringliteral">&quot;__call__&quot;</span></div>
<div class="line"><span class="lineno">  948</span>            <span class="keywordflow">and</span> ufunc <span class="keywordflow">in</span> (np.bitwise_and, np.bitwise_or, np.bitwise_xor)</div>
<div class="line"><span class="lineno">  949</span>        ):</div>
<div class="line"><span class="lineno">  950</span>            result = arraylike.maybe_dispatch_ufunc_to_dunder_op(</div>
<div class="line"><span class="lineno">  951</span>                self, ufunc, method, *inputs, **kwargs</div>
<div class="line"><span class="lineno">  952</span>            )</div>
<div class="line"><span class="lineno">  953</span>            <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> NotImplemented:</div>
<div class="line"><span class="lineno">  954</span>                <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  955</span> </div>
<div class="line"><span class="lineno">  956</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;out&quot;</span> <span class="keywordflow">in</span> kwargs:</div>
<div class="line"><span class="lineno">  957</span>            <span class="comment"># e.g. test_dti_isub_tdi</span></div>
<div class="line"><span class="lineno">  958</span>            <span class="keywordflow">return</span> arraylike.dispatch_ufunc_with_out(</div>
<div class="line"><span class="lineno">  959</span>                self, ufunc, method, *inputs, **kwargs</div>
<div class="line"><span class="lineno">  960</span>            )</div>
<div class="line"><span class="lineno">  961</span> </div>
<div class="line"><span class="lineno">  962</span>        <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;reduce&quot;</span>:</div>
<div class="line"><span class="lineno">  963</span>            result = arraylike.dispatch_reduction_ufunc(</div>
<div class="line"><span class="lineno">  964</span>                self, ufunc, method, *inputs, **kwargs</div>
<div class="line"><span class="lineno">  965</span>            )</div>
<div class="line"><span class="lineno">  966</span>            <span class="keywordflow">if</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> NotImplemented:</div>
<div class="line"><span class="lineno">  967</span>                <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span>        new_inputs = [x <span class="keywordflow">if</span> x <span class="keywordflow">is</span> <span class="keywordflow">not</span> self <span class="keywordflow">else</span> x._values <span class="keywordflow">for</span> x <span class="keywordflow">in</span> inputs]</div>
<div class="line"><span class="lineno">  970</span>        result = getattr(ufunc, method)(*new_inputs, **kwargs)</div>
<div class="line"><span class="lineno">  971</span>        <span class="keywordflow">if</span> ufunc.nout == 2:</div>
<div class="line"><span class="lineno">  972</span>            <span class="comment"># i.e. np.divmod, np.modf, np.frexp</span></div>
<div class="line"><span class="lineno">  973</span>            <span class="keywordflow">return</span> tuple(self.__array_wrap__(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> result)</div>
<div class="line"><span class="lineno">  974</span> </div>
<div class="line"><span class="lineno">  975</span>        <span class="keywordflow">return</span> self.__array_wrap__(result)</div>
<div class="line"><span class="lineno">  976</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af0045ef17048a0f4eea8d37fee1b1707" name="af0045ef17048a0f4eea8d37fee1b1707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0045ef17048a0f4eea8d37fee1b1707">&#9670;&#160;</a></span>__array_wrap__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__array_wrap__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>context</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Gets called after a ufunc and other functions e.g. np.split.
</pre> <div class="fragment"><div class="line"><span class="lineno">  977</span>    <span class="keyword">def </span>__array_wrap__(self, result, context=None):</div>
<div class="line"><span class="lineno">  978</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  979</span><span class="stringliteral">        Gets called after a ufunc and other functions e.g. np.split.</span></div>
<div class="line"><span class="lineno">  980</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  981</span>        result = lib.item_from_zerodim(result)</div>
<div class="line"><span class="lineno">  982</span>        <span class="keywordflow">if</span> is_bool_dtype(result) <span class="keywordflow">or</span> lib.is_scalar(result) <span class="keywordflow">or</span> np.ndim(result) &gt; 1:</div>
<div class="line"><span class="lineno">  983</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  984</span> </div>
<div class="line"><span class="lineno">  985</span>        <span class="keywordflow">return</span> Index(result, name=self.name)</div>
<div class="line"><span class="lineno">  986</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac91c2c62afd0c05eac52f7bc65194d11" name="ac91c2c62afd0c05eac52f7bc65194d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91c2c62afd0c05eac52f7bc65194d11">&#9670;&#160;</a></span>__contains__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.__contains__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean indicating whether the provided key is in the index.

Parameters
----------
key : label
    The key to check if it is present in the index.

Returns
-------
bool
    Whether the key search is in the index.

Raises
------
TypeError
    If the key is not hashable.

See Also
--------
Index.isin : Returns an ndarray of boolean dtype indicating whether the
    list-like key is in the index.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx
Int64Index([1, 2, 3, 4], dtype='int64')

&gt;&gt;&gt; 2 in idx
True
&gt;&gt;&gt; 6 in idx
False
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a12d278bd88980ea65ee7113543b184a7">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a9b31a0848b31863e95e838d721b2d36f">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a72ea377335066276d272f7710ca0f38f">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a8b5632bf6aa706711fc835544a23f75e">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ad90d2562478f835431b707fc1b824d77">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5297</span>    <span class="keyword">def </span>__contains__(self, key: Any) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5298</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5299</span><span class="stringliteral">        Return a boolean indicating whether the provided key is in the index.</span></div>
<div class="line"><span class="lineno"> 5300</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5301</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5302</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5303</span><span class="stringliteral">        key : label</span></div>
<div class="line"><span class="lineno"> 5304</span><span class="stringliteral">            The key to check if it is present in the index.</span></div>
<div class="line"><span class="lineno"> 5305</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5306</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5307</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5308</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 5309</span><span class="stringliteral">            Whether the key search is in the index.</span></div>
<div class="line"><span class="lineno"> 5310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5311</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 5312</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 5313</span><span class="stringliteral">        TypeError</span></div>
<div class="line"><span class="lineno"> 5314</span><span class="stringliteral">            If the key is not hashable.</span></div>
<div class="line"><span class="lineno"> 5315</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5316</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5317</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5318</span><span class="stringliteral">        Index.isin : Returns an ndarray of boolean dtype indicating whether the</span></div>
<div class="line"><span class="lineno"> 5319</span><span class="stringliteral">            list-like key is in the index.</span></div>
<div class="line"><span class="lineno"> 5320</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5321</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5322</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5323</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 5324</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 5325</span><span class="stringliteral">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5326</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5327</span><span class="stringliteral">        &gt;&gt;&gt; 2 in idx</span></div>
<div class="line"><span class="lineno"> 5328</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 5329</span><span class="stringliteral">        &gt;&gt;&gt; 6 in idx</span></div>
<div class="line"><span class="lineno"> 5330</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 5331</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5332</span>        hash(key)</div>
<div class="line"><span class="lineno"> 5333</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5334</span>            <span class="keywordflow">return</span> key <span class="keywordflow">in</span> self._engine</div>
<div class="line"><span class="lineno"> 5335</span>        <span class="keywordflow">except</span> (OverflowError, TypeError, ValueError):</div>
<div class="line"><span class="lineno"> 5336</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5337</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a63f2c34b78c4f428a0a3ae1fa1fbe3f4" name="a63f2c34b78c4f428a0a3ae1fa1fbe3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f2c34b78c4f428a0a3ae1fa1fbe3f4">&#9670;&#160;</a></span>__copy__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.__copy__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1333</span>    <span class="keyword">def </span>__copy__(self: _IndexT, **kwargs) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 1334</span>        <span class="keywordflow">return</span> self.copy(**kwargs)</div>
<div class="line"><span class="lineno"> 1335</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a360f6c3cc0ffe7e2dd96fcc2593905b2" name="a360f6c3cc0ffe7e2dd96fcc2593905b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360f6c3cc0ffe7e2dd96fcc2593905b2">&#9670;&#160;</a></span>__deepcopy__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.__deepcopy__ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>memo</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parameters
----------
memo, default None
    Standard signature. Unused
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1337</span>    <span class="keyword">def </span>__deepcopy__(self: _IndexT, memo=<span class="keywordtype">None</span>) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 1338</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1339</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1340</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1341</span><span class="stringliteral">        memo, default None</span></div>
<div class="line"><span class="lineno"> 1342</span><span class="stringliteral">            Standard signature. Unused</span></div>
<div class="line"><span class="lineno"> 1343</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1344</span>        <span class="keywordflow">return</span> self.copy(deep=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1345</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d26282329403b0e729dcc9f3eb56c9b" name="a5d26282329403b0e729dcc9f3eb56c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d26282329403b0e729dcc9f3eb56c9b">&#9670;&#160;</a></span>__getitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__getitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Override numpy.ndarray's __getitem__ method to work as desired.

This function adds lists and Series as valid boolean indexers
(ndarrays only supports ndarray with dtype=bool).

If resulting ndim != 1, plain ndarray is returned instead of
corresponding `Index` subclass.</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a5f1052521a55ce0fbb851c32b14436f4">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ab7b862d54d13f51d1a0f789b8918bdcd">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5347</span>    <span class="keyword">def </span>__getitem__(self, key):</div>
<div class="line"><span class="lineno"> 5348</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5349</span><span class="stringliteral">        Override numpy.ndarray&#39;s __getitem__ method to work as desired.</span></div>
<div class="line"><span class="lineno"> 5350</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5351</span><span class="stringliteral">        This function adds lists and Series as valid boolean indexers</span></div>
<div class="line"><span class="lineno"> 5352</span><span class="stringliteral">        (ndarrays only supports ndarray with dtype=bool).</span></div>
<div class="line"><span class="lineno"> 5353</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5354</span><span class="stringliteral">        If resulting ndim != 1, plain ndarray is returned instead of</span></div>
<div class="line"><span class="lineno"> 5355</span><span class="stringliteral">        corresponding `Index` subclass.</span></div>
<div class="line"><span class="lineno"> 5356</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5357</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5358</span>        getitem = self._data.__getitem__</div>
<div class="line"><span class="lineno"> 5359</span> </div>
<div class="line"><span class="lineno"> 5360</span>        <span class="keywordflow">if</span> is_integer(key) <span class="keywordflow">or</span> is_float(key):</div>
<div class="line"><span class="lineno"> 5361</span>            <span class="comment"># GH#44051 exclude bool, which would return a 2d ndarray</span></div>
<div class="line"><span class="lineno"> 5362</span>            key = com.cast_scalar_indexer(key, warn_float=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 5363</span>            <span class="keywordflow">return</span> getitem(key)</div>
<div class="line"><span class="lineno"> 5364</span> </div>
<div class="line"><span class="lineno"> 5365</span>        <span class="keywordflow">if</span> isinstance(key, slice):</div>
<div class="line"><span class="lineno"> 5366</span>            <span class="comment"># This case is separated from the conditional above to avoid</span></div>
<div class="line"><span class="lineno"> 5367</span>            <span class="comment"># pessimization com.is_bool_indexer and ndim checks.</span></div>
<div class="line"><span class="lineno"> 5368</span>            result = getitem(key)</div>
<div class="line"><span class="lineno"> 5369</span>            <span class="comment"># Going through simple_new for performance.</span></div>
<div class="line"><span class="lineno"> 5370</span>            <span class="keywordflow">return</span> type(self)._simple_new(result, name=self._name)</div>
<div class="line"><span class="lineno"> 5371</span> </div>
<div class="line"><span class="lineno"> 5372</span>        <span class="keywordflow">if</span> com.is_bool_indexer(key):</div>
<div class="line"><span class="lineno"> 5373</span>            <span class="comment"># if we have list[bools, length=1e5] then doing this check+convert</span></div>
<div class="line"><span class="lineno"> 5374</span>            <span class="comment">#  takes 166 µs + 2.1 ms and cuts the ndarray.__getitem__</span></div>
<div class="line"><span class="lineno"> 5375</span>            <span class="comment">#  time below from 3.8 ms to 496 µs</span></div>
<div class="line"><span class="lineno"> 5376</span>            <span class="comment"># if we already have ndarray[bool], the overhead is 1.4 µs or .25%</span></div>
<div class="line"><span class="lineno"> 5377</span>            <span class="keywordflow">if</span> is_extension_array_dtype(getattr(key, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)):</div>
<div class="line"><span class="lineno"> 5378</span>                key = key.to_numpy(dtype=bool, na_value=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 5379</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5380</span>                key = np.asarray(key, dtype=bool)</div>
<div class="line"><span class="lineno"> 5381</span> </div>
<div class="line"><span class="lineno"> 5382</span>        result = getitem(key)</div>
<div class="line"><span class="lineno"> 5383</span>        <span class="comment"># Because we ruled out integer above, we always get an arraylike here</span></div>
<div class="line"><span class="lineno"> 5384</span>        <span class="keywordflow">if</span> result.ndim &gt; 1:</div>
<div class="line"><span class="lineno"> 5385</span>            deprecate_ndim_indexing(result)</div>
<div class="line"><span class="lineno"> 5386</span>            <span class="keywordflow">if</span> hasattr(result, <span class="stringliteral">&quot;_ndarray&quot;</span>):</div>
<div class="line"><span class="lineno"> 5387</span>                <span class="comment"># i.e. NDArrayBackedExtensionArray</span></div>
<div class="line"><span class="lineno"> 5388</span>                <span class="comment"># Unpack to ndarray for MPL compat</span></div>
<div class="line"><span class="lineno"> 5389</span>                <span class="comment"># error: Item &quot;ndarray[Any, Any]&quot; of</span></div>
<div class="line"><span class="lineno"> 5390</span>                <span class="comment"># &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;</span></div>
<div class="line"><span class="lineno"> 5391</span>                <span class="comment"># has no attribute &quot;_ndarray&quot;</span></div>
<div class="line"><span class="lineno"> 5392</span>                <span class="keywordflow">return</span> result._ndarray  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 5393</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 5394</span> </div>
<div class="line"><span class="lineno"> 5395</span>        <span class="comment"># NB: Using _constructor._simple_new would break if MultiIndex</span></div>
<div class="line"><span class="lineno"> 5396</span>        <span class="comment">#  didn&#39;t override __getitem__</span></div>
<div class="line"><span class="lineno"> 5397</span>        <span class="keywordflow">return</span> self._constructor._simple_new(result, name=self._name)</div>
<div class="line"><span class="lineno"> 5398</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa071a604a18a4ed8c36d964ac9bf99d4" name="aa071a604a18a4ed8c36d964ac9bf99d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa071a604a18a4ed8c36d964ac9bf99d4">&#9670;&#160;</a></span>__iadd__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__iadd__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3150</span>    <span class="keyword">def </span>__iadd__(self, other):</div>
<div class="line"><span class="lineno"> 3151</span>        <span class="comment"># alias for __add__</span></div>
<div class="line"><span class="lineno"> 3152</span>        <span class="keywordflow">return</span> self + other</div>
<div class="line"><span class="lineno"> 3153</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5d7d754151ec7bae0ba0ad4f46e9f31e" name="a5d7d754151ec7bae0ba0ad4f46e9f31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7d754151ec7bae0ba0ad4f46e9f31e">&#9670;&#160;</a></span>__invert__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.__invert__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7066</span>    <span class="keyword">def </span>__invert__(self) -&gt; Index:</div>
<div class="line"><span class="lineno"> 7067</span>        <span class="comment"># GH#8875</span></div>
<div class="line"><span class="lineno"> 7068</span>        <span class="keywordflow">return</span> self._unary_method(operator.inv)</div>
<div class="line"><span class="lineno"> 7069</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a47c75c1fa745494cfc6f3e5a81392c81" name="a47c75c1fa745494cfc6f3e5a81392c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c75c1fa745494cfc6f3e5a81392c81">&#9670;&#160;</a></span>__len__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.__len__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the length of the Index.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a2d3bfad08d6ed62fa6ea959a195320a2">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#af1e8adbb427b22f13bdf320fd029109f">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a663fef7127e69f735f6abcb778aaaa93">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  926</span>    <span class="keyword">def </span>__len__(self) -&gt; int:</div>
<div class="line"><span class="lineno">  927</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  928</span><span class="stringliteral">        Return the length of the Index.</span></div>
<div class="line"><span class="lineno">  929</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  930</span>        <span class="keywordflow">return</span> len(self._data)</div>
<div class="line"><span class="lineno">  931</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaf2969db9ed738ba76d637645e482488" name="aaf2969db9ed738ba76d637645e482488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf2969db9ed738ba76d637645e482488">&#9670;&#160;</a></span>__neg__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.__neg__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7060</span>    <span class="keyword">def </span>__neg__(self) -&gt; Index:</div>
<div class="line"><span class="lineno"> 7061</span>        <span class="keywordflow">return</span> self._unary_method(operator.neg)</div>
<div class="line"><span class="lineno"> 7062</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1fb6b348defa931b9543581955a35d1b" name="a1fb6b348defa931b9543581955a35d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb6b348defa931b9543581955a35d1b">&#9670;&#160;</a></span>__new__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.__new__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>copy</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tupleize_cols</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#aa69a934468da8312d7525473b1d2cb7a">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#acea88ad532a53294b0d61e7cf1832848">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#af9e9cf431832bb325be575ea0ad752df">pandas.core.indexes.numeric.NumericIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a3703fc466be3be6a9a51b1a40f02a153">pandas.core.indexes.period.PeriodIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#afd672ac46977e8cf023b770d62b81bd9">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#abd52e75a640ac0bdd6a339b36a3c87b6">pandas.core.indexes.timedeltas.TimedeltaIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad350ca0718e3359bb963d4c86706e4bd">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a155de88040b70932bfc6466aee7b71f4">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  433</span>    ) -&gt; Index:</div>
<div class="line"><span class="lineno">  434</span> </div>
<div class="line"><span class="lineno">  435</span>        <span class="keywordflow">if</span> kwargs:</div>
<div class="line"><span class="lineno">  436</span>            warnings.warn(</div>
<div class="line"><span class="lineno">  437</span>                <span class="stringliteral">&quot;Passing keywords other than &#39;data&#39;, &#39;dtype&#39;, &#39;copy&#39;, &#39;name&#39;, &quot;</span></div>
<div class="line"><span class="lineno">  438</span>                <span class="stringliteral">&quot;&#39;tupleize_cols&#39; is deprecated and will raise TypeError in a &quot;</span></div>
<div class="line"><span class="lineno">  439</span>                <span class="stringliteral">&quot;future version.  Use the specific Index subclass directly instead.&quot;</span>,</div>
<div class="line"><span class="lineno">  440</span>                FutureWarning,</div>
<div class="line"><span class="lineno">  441</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  442</span>            )</div>
<div class="line"><span class="lineno">  443</span> </div>
<div class="line"><span class="lineno">  444</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a> <span class="keyword">import</span> PandasArray</div>
<div class="line"><span class="lineno">  445</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1range.html">pandas.core.indexes.range</a> <span class="keyword">import</span> RangeIndex</div>
<div class="line"><span class="lineno">  446</span> </div>
<div class="line"><span class="lineno">  447</span>        name = maybe_extract_name(name, data, cls)</div>
<div class="line"><span class="lineno">  448</span> </div>
<div class="line"><span class="lineno">  449</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  450</span>            dtype = pandas_dtype(dtype)</div>
<div class="line"><span class="lineno">  451</span>        <span class="keywordflow">if</span> <span class="stringliteral">&quot;tz&quot;</span> <span class="keywordflow">in</span> kwargs:</div>
<div class="line"><span class="lineno">  452</span>            tz = kwargs.pop(<span class="stringliteral">&quot;tz&quot;</span>)</div>
<div class="line"><span class="lineno">  453</span>            validate_tz_from_dtype(dtype, tz)</div>
<div class="line"><span class="lineno">  454</span>            dtype = tz_to_dtype(tz)</div>
<div class="line"><span class="lineno">  455</span> </div>
<div class="line"><span class="lineno">  456</span>        <span class="keywordflow">if</span> type(data) <span class="keywordflow">is</span> PandasArray:</div>
<div class="line"><span class="lineno">  457</span>            <span class="comment"># ensure users don&#39;t accidentally put a PandasArray in an index,</span></div>
<div class="line"><span class="lineno">  458</span>            <span class="comment">#  but don&#39;t unpack StringArray</span></div>
<div class="line"><span class="lineno">  459</span>            data = data.to_numpy()</div>
<div class="line"><span class="lineno">  460</span>        <span class="keywordflow">if</span> isinstance(dtype, PandasDtype):</div>
<div class="line"><span class="lineno">  461</span>            dtype = dtype.numpy_dtype</div>
<div class="line"><span class="lineno">  462</span> </div>
<div class="line"><span class="lineno">  463</span>        data_dtype = getattr(data, <span class="stringliteral">&quot;dtype&quot;</span>, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  464</span> </div>
<div class="line"><span class="lineno">  465</span>        <span class="comment"># range</span></div>
<div class="line"><span class="lineno">  466</span>        <span class="keywordflow">if</span> isinstance(data, (range, RangeIndex)):</div>
<div class="line"><span class="lineno">  467</span>            result = RangeIndex(start=data, copy=copy, name=name)</div>
<div class="line"><span class="lineno">  468</span>            <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  469</span>                <span class="keywordflow">return</span> result.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  470</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>        <span class="keywordflow">elif</span> is_ea_or_datetimelike_dtype(dtype):</div>
<div class="line"><span class="lineno">  473</span>            <span class="comment"># non-EA dtype indexes have special casting logic, so we punt here</span></div>
<div class="line"><span class="lineno">  474</span>            klass = cls._dtype_to_subclass(dtype)</div>
<div class="line"><span class="lineno">  475</span>            <span class="keywordflow">if</span> klass <span class="keywordflow">is</span> <span class="keywordflow">not</span> Index:</div>
<div class="line"><span class="lineno">  476</span>                <span class="keywordflow">return</span> klass(data, dtype=dtype, copy=copy, name=name, **kwargs)</div>
<div class="line"><span class="lineno">  477</span> </div>
<div class="line"><span class="lineno">  478</span>            ea_cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno">  479</span>            data = ea_cls._from_sequence(data, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  480</span>            disallow_kwargs(kwargs)</div>
<div class="line"><span class="lineno">  481</span>            <span class="keywordflow">return</span> Index._simple_new(data, name=name)</div>
<div class="line"><span class="lineno">  482</span> </div>
<div class="line"><span class="lineno">  483</span>        <span class="keywordflow">elif</span> is_ea_or_datetimelike_dtype(data_dtype):</div>
<div class="line"><span class="lineno">  484</span>            data_dtype = cast(DtypeObj, data_dtype)</div>
<div class="line"><span class="lineno">  485</span>            klass = cls._dtype_to_subclass(data_dtype)</div>
<div class="line"><span class="lineno">  486</span>            <span class="keywordflow">if</span> klass <span class="keywordflow">is</span> <span class="keywordflow">not</span> Index:</div>
<div class="line"><span class="lineno">  487</span>                result = klass(data, copy=copy, name=name, **kwargs)</div>
<div class="line"><span class="lineno">  488</span>                <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  489</span>                    <span class="keywordflow">return</span> result.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  490</span>                <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  491</span>            <span class="keywordflow">elif</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  492</span>                <span class="comment"># GH#45206</span></div>
<div class="line"><span class="lineno">  493</span>                data = data.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>            disallow_kwargs(kwargs)</div>
<div class="line"><span class="lineno">  496</span>            data = extract_array(data, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  497</span>            <span class="keywordflow">return</span> Index._simple_new(data, name=name)</div>
<div class="line"><span class="lineno">  498</span> </div>
<div class="line"><span class="lineno">  499</span>        <span class="comment"># index-like</span></div>
<div class="line"><span class="lineno">  500</span>        <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno">  501</span>            isinstance(data, Index)</div>
<div class="line"><span class="lineno">  502</span>            <span class="keywordflow">and</span> data._is_backward_compat_public_numeric_index</div>
<div class="line"><span class="lineno">  503</span>            <span class="keywordflow">and</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  504</span>        ):</div>
<div class="line"><span class="lineno">  505</span>            <span class="keywordflow">return</span> data._constructor(data, name=name, copy=copy)</div>
<div class="line"><span class="lineno">  506</span>        <span class="keywordflow">elif</span> isinstance(data, (np.ndarray, Index, ABCSeries)):</div>
<div class="line"><span class="lineno">  507</span> </div>
<div class="line"><span class="lineno">  508</span>            <span class="keywordflow">if</span> isinstance(data, ABCMultiIndex):</div>
<div class="line"><span class="lineno">  509</span>                data = data._values</div>
<div class="line"><span class="lineno">  510</span> </div>
<div class="line"><span class="lineno">  511</span>            <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  512</span>                <span class="comment"># we need to avoid having numpy coerce</span></div>
<div class="line"><span class="lineno">  513</span>                <span class="comment"># things that look like ints/floats to ints unless</span></div>
<div class="line"><span class="lineno">  514</span>                <span class="comment"># they are actually ints, e.g. &#39;0&#39; and 0.0</span></div>
<div class="line"><span class="lineno">  515</span>                <span class="comment"># should not be coerced</span></div>
<div class="line"><span class="lineno">  516</span>                <span class="comment"># GH 11836</span></div>
<div class="line"><span class="lineno">  517</span>                data = sanitize_array(data, <span class="keywordtype">None</span>, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno">  518</span> </div>
<div class="line"><span class="lineno">  519</span>                dtype = data.dtype</div>
<div class="line"><span class="lineno">  520</span> </div>
<div class="line"><span class="lineno">  521</span>            <span class="keywordflow">if</span> data.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>]:</div>
<div class="line"><span class="lineno">  522</span>                <span class="comment"># maybe coerce to a sub-class</span></div>
<div class="line"><span class="lineno">  523</span>                arr = data</div>
<div class="line"><span class="lineno">  524</span>            <span class="keywordflow">elif</span> data.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>]:</div>
<div class="line"><span class="lineno">  525</span>                <span class="comment"># No special subclass, and Index._ensure_array won&#39;t do this</span></div>
<div class="line"><span class="lineno">  526</span>                <span class="comment">#  for us.</span></div>
<div class="line"><span class="lineno">  527</span>                arr = np.asarray(data)</div>
<div class="line"><span class="lineno">  528</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  529</span>                arr = com.asarray_tuplesafe(data, dtype=_dtype_obj)</div>
<div class="line"><span class="lineno">  530</span> </div>
<div class="line"><span class="lineno">  531</span>                <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  532</span>                    arr = _maybe_cast_data_without_dtype(</div>
<div class="line"><span class="lineno">  533</span>                        arr, cast_numeric_deprecated=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  534</span>                    )</div>
<div class="line"><span class="lineno">  535</span>                    dtype = arr.dtype</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>                    <span class="keywordflow">if</span> kwargs:</div>
<div class="line"><span class="lineno">  538</span>                        <span class="keywordflow">return</span> cls(arr, dtype, copy=copy, name=name, **kwargs)</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>            klass = cls._dtype_to_subclass(arr.dtype)</div>
<div class="line"><span class="lineno">  541</span>            arr = klass._ensure_array(arr, dtype, copy)</div>
<div class="line"><span class="lineno">  542</span>            disallow_kwargs(kwargs)</div>
<div class="line"><span class="lineno">  543</span>            <span class="keywordflow">return</span> klass._simple_new(arr, name)</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>        <span class="keywordflow">elif</span> is_scalar(data):</div>
<div class="line"><span class="lineno">  546</span>            <span class="keywordflow">raise</span> cls._scalar_data_error(data)</div>
<div class="line"><span class="lineno">  547</span>        <span class="keywordflow">elif</span> hasattr(data, <span class="stringliteral">&quot;__array__&quot;</span>):</div>
<div class="line"><span class="lineno">  548</span>            <span class="keywordflow">return</span> Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)</div>
<div class="line"><span class="lineno">  549</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>            <span class="keywordflow">if</span> tupleize_cols <span class="keywordflow">and</span> is_list_like(data):</div>
<div class="line"><span class="lineno">  552</span>                <span class="comment"># GH21470: convert iterable to list before determining if empty</span></div>
<div class="line"><span class="lineno">  553</span>                <span class="keywordflow">if</span> is_iterator(data):</div>
<div class="line"><span class="lineno">  554</span>                    data = list(data)</div>
<div class="line"><span class="lineno">  555</span> </div>
<div class="line"><span class="lineno">  556</span>                <span class="keywordflow">if</span> data <span class="keywordflow">and</span> all(isinstance(e, tuple) <span class="keywordflow">for</span> e <span class="keywordflow">in</span> data):</div>
<div class="line"><span class="lineno">  557</span>                    <span class="comment"># we must be all tuples, otherwise don&#39;t construct</span></div>
<div class="line"><span class="lineno">  558</span>                    <span class="comment"># 10697</span></div>
<div class="line"><span class="lineno">  559</span>                    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>                    <span class="keywordflow">return</span> MultiIndex.from_tuples(</div>
<div class="line"><span class="lineno">  562</span>                        data, names=name <span class="keywordflow">or</span> kwargs.get(<span class="stringliteral">&quot;names&quot;</span>)</div>
<div class="line"><span class="lineno">  563</span>                    )</div>
<div class="line"><span class="lineno">  564</span>            <span class="comment"># other iterable of some kind</span></div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>            subarr = com.asarray_tuplesafe(data, dtype=_dtype_obj)</div>
<div class="line"><span class="lineno">  567</span>            <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  568</span>                <span class="comment"># with e.g. a list [1, 2, 3] casting to numeric is _not_ deprecated</span></div>
<div class="line"><span class="lineno">  569</span>                subarr = _maybe_cast_data_without_dtype(</div>
<div class="line"><span class="lineno">  570</span>                    subarr, cast_numeric_deprecated=<span class="keyword">False</span></div>
<div class="line"><span class="lineno">  571</span>                )</div>
<div class="line"><span class="lineno">  572</span>                dtype = subarr.dtype</div>
<div class="line"><span class="lineno">  573</span>            <span class="keywordflow">return</span> Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)</div>
<div class="line"><span class="lineno">  574</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays.html">pandas.core.arrays</a></div><div class="ttdef"><b>Definition</b> __init__.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1indexes_1_1multi_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a></div><div class="ttdef"><b>Definition</b> multi.py:1</div></div>
<div class="ttc" id="anamespacepandas_1_1core_1_1indexes_1_1range_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1indexes_1_1range.html">pandas.core.indexes.range</a></div><div class="ttdef"><b>Definition</b> range.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8abf8f10e1bac6784ac6fa9d64b2a577" name="a8abf8f10e1bac6784ac6fa9d64b2a577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abf8f10e1bac6784ac6fa9d64b2a577">&#9670;&#160;</a></span>__nonzero__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> NoReturn pandas.core.indexes.base.Index.__nonzero__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3188</span>    <span class="keyword">def </span>__nonzero__(self) -&gt; NoReturn:</div>
<div class="line"><span class="lineno"> 3189</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3190</span>            f<span class="stringliteral">&quot;The truth value of a {type(self).__name__} is ambiguous. &quot;</span></div>
<div class="line"><span class="lineno"> 3191</span>            <span class="stringliteral">&quot;Use a.empty, a.bool(), a.item(), a.any() or a.all().&quot;</span></div>
<div class="line"><span class="lineno"> 3192</span>        )</div>
<div class="line"><span class="lineno"> 3193</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5678f6982af4066ac39285c3b1306f18" name="a5678f6982af4066ac39285c3b1306f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5678f6982af4066ac39285c3b1306f18">&#9670;&#160;</a></span>__or__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__or__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#ab2dd14622690bccbd74acf55e16f0446">pandas.core.arraylike.OpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3166</span>    <span class="keyword">def </span>__or__(self, other):</div>
<div class="line"><span class="lineno"> 3167</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 3168</span>            <span class="stringliteral">&quot;Index.__or__ operating as a set operation is deprecated, &quot;</span></div>
<div class="line"><span class="lineno"> 3169</span>            <span class="stringliteral">&quot;in the future this will be a logical operation matching &quot;</span></div>
<div class="line"><span class="lineno"> 3170</span>            <span class="stringliteral">&quot;Series.__or__.  Use index.union(other) instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 3171</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 3172</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3173</span>        )</div>
<div class="line"><span class="lineno"> 3174</span>        <span class="keywordflow">return</span> self.union(other)</div>
<div class="line"><span class="lineno"> 3175</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab20f4d0a401404a43d90b2440d0e3f9d" name="ab20f4d0a401404a43d90b2440d0e3f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20f4d0a401404a43d90b2440d0e3f9d">&#9670;&#160;</a></span>__pos__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.__pos__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7063</span>    <span class="keyword">def </span>__pos__(self) -&gt; Index:</div>
<div class="line"><span class="lineno"> 7064</span>        <span class="keywordflow">return</span> self._unary_method(operator.pos)</div>
<div class="line"><span class="lineno"> 7065</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a44cfd79b0578b7b441e3081804d4335c" name="a44cfd79b0578b7b441e3081804d4335c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cfd79b0578b7b441e3081804d4335c">&#9670;&#160;</a></span>__reduce__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__reduce__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a7e1ad90b3de0bf3e5cbf00d0d7db2a23">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#aa52813216dc61a9e6aa804f5edc76a52">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ab547a9e89b4a44e13e7c60d5b997740f">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#adcf2c850d016e6ea4746078925687ff4">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2795</span>    <span class="keyword">def </span>__reduce__(self):</div>
<div class="line"><span class="lineno"> 2796</span>        d = {<span class="stringliteral">&quot;data&quot;</span>: self._data, <span class="stringliteral">&quot;name&quot;</span>: self.name}</div>
<div class="line"><span class="lineno"> 2797</span>        <span class="keywordflow">return</span> _new_Index, (type(self), d), <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2798</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afe4df78e1853b3851a41a2e404d2cba7" name="afe4df78e1853b3851a41a2e404d2cba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4df78e1853b3851a41a2e404d2cba7">&#9670;&#160;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> pandas.core.indexes.base.Index.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string representation for this object.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a417b85c7fda9b57f893ad25a764fcf36">pandas.core.base.PandasObject</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1350</span>    <span class="keyword">def </span>__repr__(self) -&gt; str_t:</div>
<div class="line"><span class="lineno"> 1351</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1352</span><span class="stringliteral">        Return a string representation for this object.</span></div>
<div class="line"><span class="lineno"> 1353</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1354</span>        klass_name = type(self).__name__</div>
<div class="line"><span class="lineno"> 1355</span>        data = self._format_data()</div>
<div class="line"><span class="lineno"> 1356</span>        attrs = self._format_attrs()</div>
<div class="line"><span class="lineno"> 1357</span>        space = self._format_space()</div>
<div class="line"><span class="lineno"> 1358</span>        attrs_str = [f<span class="stringliteral">&quot;{k}={v}&quot;</span> <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> attrs]</div>
<div class="line"><span class="lineno"> 1359</span>        prepr = f<span class="stringliteral">&quot;,{space}&quot;</span>.join(attrs_str)</div>
<div class="line"><span class="lineno"> 1360</span> </div>
<div class="line"><span class="lineno"> 1361</span>        <span class="comment"># no data provided, just attributes</span></div>
<div class="line"><span class="lineno"> 1362</span>        <span class="keywordflow">if</span> data <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1363</span>            data = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1364</span> </div>
<div class="line"><span class="lineno"> 1365</span>        <span class="keywordflow">return</span> f<span class="stringliteral">&quot;{klass_name}({data}{prepr})&quot;</span></div>
<div class="line"><span class="lineno"> 1366</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa228e11c6f166ce8ac16e7db3d5f8ef3" name="aa228e11c6f166ce8ac16e7db3d5f8ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa228e11c6f166ce8ac16e7db3d5f8ef3">&#9670;&#160;</a></span>__setitem__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__setitem__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5344</span>    <span class="keyword">def </span>__setitem__(self, key, value):</div>
<div class="line"><span class="lineno"> 5345</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Index does not support mutable operations&quot;</span>)</div>
<div class="line"><span class="lineno"> 5346</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aad70735ac023f3c913ed054dba4005d3" name="aad70735ac023f3c913ed054dba4005d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad70735ac023f3c913ed054dba4005d3">&#9670;&#160;</a></span>__xor__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.__xor__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#a39681cb8d56423af78232df36b0d5858">pandas.core.arraylike.OpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3177</span>    <span class="keyword">def </span>__xor__(self, other):</div>
<div class="line"><span class="lineno"> 3178</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 3179</span>            <span class="stringliteral">&quot;Index.__xor__ operating as a set operation is deprecated, &quot;</span></div>
<div class="line"><span class="lineno"> 3180</span>            <span class="stringliteral">&quot;in the future this will be a logical operation matching &quot;</span></div>
<div class="line"><span class="lineno"> 3181</span>            <span class="stringliteral">&quot;Series.__xor__.  Use index.symmetric_difference(other) instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 3182</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 3183</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3184</span>        )</div>
<div class="line"><span class="lineno"> 3185</span>        <span class="keywordflow">return</span> self.symmetric_difference(other)</div>
<div class="line"><span class="lineno"> 3186</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afd1fd5198f03c0d3e5888ab49b914aa6" name="afd1fd5198f03c0d3e5888ab49b914aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1fd5198f03c0d3e5888ab49b914aa6">&#9670;&#160;</a></span>_arith_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._arith_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a57306235a25afd6bcc8aadede321e9bb">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a52a97927f30f3542474348dcc0962911">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7039</span>    <span class="keyword">def </span>_arith_method(self, other, op):</div>
<div class="line"><span class="lineno"> 7040</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 7041</span>            isinstance(other, Index)</div>
<div class="line"><span class="lineno"> 7042</span>            <span class="keywordflow">and</span> is_object_dtype(other.dtype)</div>
<div class="line"><span class="lineno"> 7043</span>            <span class="keywordflow">and</span> type(other) <span class="keywordflow">is</span> <span class="keywordflow">not</span> Index</div>
<div class="line"><span class="lineno"> 7044</span>        ):</div>
<div class="line"><span class="lineno"> 7045</span>            <span class="comment"># We return NotImplemented for object-dtype index *subclasses* so they have</span></div>
<div class="line"><span class="lineno"> 7046</span>            <span class="comment"># a chance to implement ops before we unwrap them.</span></div>
<div class="line"><span class="lineno"> 7047</span>            <span class="comment"># See https://github.com/pandas-dev/pandas/issues/31109</span></div>
<div class="line"><span class="lineno"> 7048</span>            <span class="keywordflow">return</span> NotImplemented</div>
<div class="line"><span class="lineno"> 7049</span> </div>
<div class="line"><span class="lineno"> 7050</span>        <span class="keywordflow">return</span> super()._arith_method(other, op)</div>
<div class="line"><span class="lineno"> 7051</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3756bbd00cb2e91dee75415821bed194" name="a3756bbd00cb2e91dee75415821bed194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3756bbd00cb2e91dee75415821bed194">&#9670;&#160;</a></span>_assert_can_do_setop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._assert_can_do_setop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3733</span>    <span class="keyword">def </span>_assert_can_do_setop(self, other) -&gt; bool:</div>
<div class="line"><span class="lineno"> 3734</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(other):</div>
<div class="line"><span class="lineno"> 3735</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Input must be Index or array-like&quot;</span>)</div>
<div class="line"><span class="lineno"> 3736</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3737</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa17e1f4a2add4df9c7b6a2f9beac5f63" name="aa17e1f4a2add4df9c7b6a2f9beac5f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17e1f4a2add4df9c7b6a2f9beac5f63">&#9670;&#160;</a></span>_can_hold_identifiers_and_holds_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._can_hold_identifiers_and_holds_name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Faster check for ``name in self`` when we know `name` is a Python
identifier (e.g. in NDFrame.__getattr__, which hits this to support
. key lookup). For indexes that can't hold identifiers (everything
but object &amp; categorical) we just return False.

https://github.com/pandas-dev/pandas/issues/19764
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5407</span>    <span class="keyword">def </span>_can_hold_identifiers_and_holds_name(self, name) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5408</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5409</span><span class="stringliteral">        Faster check for ``name in self`` when we know `name` is a Python</span></div>
<div class="line"><span class="lineno"> 5410</span><span class="stringliteral">        identifier (e.g. in NDFrame.__getattr__, which hits this to support</span></div>
<div class="line"><span class="lineno"> 5411</span><span class="stringliteral">        . key lookup). For indexes that can&#39;t hold identifiers (everything</span></div>
<div class="line"><span class="lineno"> 5412</span><span class="stringliteral">        but object &amp; categorical) we just return False.</span></div>
<div class="line"><span class="lineno"> 5413</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5414</span><span class="stringliteral">        https://github.com/pandas-dev/pandas/issues/19764</span></div>
<div class="line"><span class="lineno"> 5415</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5416</span>        <span class="keywordflow">if</span> self.is_object() <span class="keywordflow">or</span> is_string_dtype(self.dtype) <span class="keywordflow">or</span> self.is_categorical():</div>
<div class="line"><span class="lineno"> 5417</span>            <span class="keywordflow">return</span> name <span class="keywordflow">in</span> self</div>
<div class="line"><span class="lineno"> 5418</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5419</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a19d6f304bd067838816fec557c043494" name="a19d6f304bd067838816fec557c043494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d6f304bd067838816fec557c043494">&#9670;&#160;</a></span>_can_hold_na()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._can_hold_na </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 2284</span>    <span class="keyword">def </span>_can_hold_na(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2285</span>        <span class="keywordflow">if</span> isinstance(self.dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno"> 2286</span>            <span class="keywordflow">if</span> isinstance(self.dtype, IntervalDtype):</div>
<div class="line"><span class="lineno"> 2287</span>                <span class="comment"># FIXME(GH#45720): this is inaccurate for integer-backed</span></div>
<div class="line"><span class="lineno"> 2288</span>                <span class="comment">#  IntervalArray, but without it other.categories.take raises</span></div>
<div class="line"><span class="lineno"> 2289</span>                <span class="comment">#  in IntervalArray._cmp_method</span></div>
<div class="line"><span class="lineno"> 2290</span>                <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2291</span>            <span class="keywordflow">return</span> self.dtype._can_hold_na</div>
<div class="line"><span class="lineno"> 2292</span>        <span class="keywordflow">if</span> self.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>]:</div>
<div class="line"><span class="lineno"> 2293</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2294</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2295</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6320aea954549ca0240d8eac57452c9c" name="a6320aea954549ca0240d8eac57452c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6320aea954549ca0240d8eac57452c9c">&#9670;&#160;</a></span>_can_use_libjoin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._can_use_libjoin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Whether we can use the fastpaths implement in _libs.join
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5087</span>    <span class="keyword">def </span>_can_use_libjoin(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5088</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5089</span><span class="stringliteral">        Whether we can use the fastpaths implement in _libs.join</span></div>
<div class="line"><span class="lineno"> 5090</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5091</span>        <span class="keywordflow">if</span> type(self) <span class="keywordflow">is</span> Index:</div>
<div class="line"><span class="lineno"> 5092</span>            <span class="comment"># excludes EAs</span></div>
<div class="line"><span class="lineno"> 5093</span>            <span class="keywordflow">return</span> isinstance(self.dtype, np.dtype)</div>
<div class="line"><span class="lineno"> 5094</span>        <span class="keywordflow">return</span> <span class="keywordflow">not</span> is_interval_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 5095</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a11b6242604597391a7f8262439edf102" name="a11b6242604597391a7f8262439edf102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b6242604597391a7f8262439edf102">&#9670;&#160;</a></span>_check_indexing_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._check_indexing_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#af7006c8d6a52cdcd1cf30af59a4b8c71">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5964</span>    <span class="keyword">def </span>_check_indexing_error(self, key):</div>
<div class="line"><span class="lineno"> 5965</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(key):</div>
<div class="line"><span class="lineno"> 5966</span>            <span class="comment"># if key is not a scalar, directly raise an error (the code below</span></div>
<div class="line"><span class="lineno"> 5967</span>            <span class="comment"># would convert to numpy arrays and raise later any way) - GH29926</span></div>
<div class="line"><span class="lineno"> 5968</span>            <span class="keywordflow">raise</span> InvalidIndexError(key)</div>
<div class="line"><span class="lineno"> 5969</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a997a952ffa381fe0f1acf6eeb089a4cb" name="a997a952ffa381fe0f1acf6eeb089a4cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a997a952ffa381fe0f1acf6eeb089a4cb">&#9670;&#160;</a></span>_check_indexing_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._check_indexing_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> | None&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Raise if we have a get_indexer `method` that is not supported or valid.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4027</span>    ) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4028</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4029</span><span class="stringliteral">        Raise if we have a get_indexer `method` that is not supported or valid.</span></div>
<div class="line"><span class="lineno"> 4030</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4031</span>        <span class="keywordflow">if</span> method <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="keywordtype">None</span>, <span class="stringliteral">&quot;bfill&quot;</span>, <span class="stringliteral">&quot;backfill&quot;</span>, <span class="stringliteral">&quot;pad&quot;</span>, <span class="stringliteral">&quot;ffill&quot;</span>, <span class="stringliteral">&quot;nearest&quot;</span>]:</div>
<div class="line"><span class="lineno"> 4032</span>            <span class="comment"># in practice the clean_reindex_fill_method call would raise</span></div>
<div class="line"><span class="lineno"> 4033</span>            <span class="comment">#  before we get here</span></div>
<div class="line"><span class="lineno"> 4034</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Invalid fill method&quot;</span>)  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 4035</span> </div>
<div class="line"><span class="lineno"> 4036</span>        <span class="keywordflow">if</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 4037</span>            <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;nearest&quot;</span>:</div>
<div class="line"><span class="lineno"> 4038</span>                <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 4039</span>                    <span class="stringliteral">&quot;method=&#39;nearest&#39; not implemented yet &quot;</span></div>
<div class="line"><span class="lineno"> 4040</span>                    <span class="stringliteral">&quot;for MultiIndex; see GitHub issue 9365&quot;</span></div>
<div class="line"><span class="lineno"> 4041</span>                )</div>
<div class="line"><span class="lineno"> 4042</span>            <span class="keywordflow">elif</span> method == <span class="stringliteral">&quot;pad&quot;</span> <span class="keywordflow">or</span> method == <span class="stringliteral">&quot;backfill&quot;</span>:</div>
<div class="line"><span class="lineno"> 4043</span>                <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4044</span>                    <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 4045</span>                        <span class="stringliteral">&quot;tolerance not implemented yet for MultiIndex&quot;</span></div>
<div class="line"><span class="lineno"> 4046</span>                    )</div>
<div class="line"><span class="lineno"> 4047</span> </div>
<div class="line"><span class="lineno"> 4048</span>        <span class="keywordflow">if</span> is_interval_dtype(self.dtype) <span class="keywordflow">or</span> is_categorical_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 4049</span>            <span class="comment"># GH#37871 for now this is only for IntervalIndex and CategoricalIndex</span></div>
<div class="line"><span class="lineno"> 4050</span>            <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4051</span>                <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 4052</span>                    f<span class="stringliteral">&quot;method {method} not yet implemented for {type(self).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 4053</span>                )</div>
<div class="line"><span class="lineno"> 4054</span> </div>
<div class="line"><span class="lineno"> 4055</span>        <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4056</span>            <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4057</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 4058</span>                    <span class="stringliteral">&quot;tolerance argument only valid if doing pad, &quot;</span></div>
<div class="line"><span class="lineno"> 4059</span>                    <span class="stringliteral">&quot;backfill or nearest reindexing&quot;</span></div>
<div class="line"><span class="lineno"> 4060</span>                )</div>
<div class="line"><span class="lineno"> 4061</span>            <span class="keywordflow">if</span> limit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4062</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 4063</span>                    <span class="stringliteral">&quot;limit argument only valid if doing pad, &quot;</span></div>
<div class="line"><span class="lineno"> 4064</span>                    <span class="stringliteral">&quot;backfill or nearest reindexing&quot;</span></div>
<div class="line"><span class="lineno"> 4065</span>                )</div>
<div class="line"><span class="lineno"> 4066</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4633c74b11623eed428e252ec0cb2efb" name="a4633c74b11623eed428e252ec0cb2efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4633c74b11623eed428e252ec0cb2efb">&#9670;&#160;</a></span>_cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._cleanup </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  879</span>    <span class="keyword">def </span>_cleanup(self) -&gt; None:</div>
<div class="line"><span class="lineno">  880</span>        self._engine.clear_mapping()</div>
<div class="line"><span class="lineno">  881</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a15299fe176cdd788acd160740a578d79" name="a15299fe176cdd788acd160740a578d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15299fe176cdd788acd160740a578d79">&#9670;&#160;</a></span>_cmp_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._cmp_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Wrapper used to dispatch comparison operations.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1arraylike_1_1_ops_mixin.html#af27c1b99e331751cbcf2d502ed982ce9">pandas.core.arraylike.OpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a2e03cf95653eefdb9268786554332ac9">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6984</span>    <span class="keyword">def </span>_cmp_method(self, other, op):</div>
<div class="line"><span class="lineno"> 6985</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6986</span><span class="stringliteral">        Wrapper used to dispatch comparison operations.</span></div>
<div class="line"><span class="lineno"> 6987</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6988</span>        <span class="keywordflow">if</span> self.is_(other):</div>
<div class="line"><span class="lineno"> 6989</span>            <span class="comment"># fastpath</span></div>
<div class="line"><span class="lineno"> 6990</span>            <span class="keywordflow">if</span> op <span class="keywordflow">in</span> {operator.eq, operator.le, operator.ge}:</div>
<div class="line"><span class="lineno"> 6991</span>                arr = np.ones(len(self), dtype=bool)</div>
<div class="line"><span class="lineno"> 6992</span>                <span class="keywordflow">if</span> self._can_hold_na <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 6993</span>                    <span class="comment"># TODO: should set MultiIndex._can_hold_na = False?</span></div>
<div class="line"><span class="lineno"> 6994</span>                    arr[self.isna()] = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 6995</span>                <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno"> 6996</span>            <span class="keywordflow">elif</span> op <span class="keywordflow">is</span> operator.ne:</div>
<div class="line"><span class="lineno"> 6997</span>                arr = np.zeros(len(self), dtype=bool)</div>
<div class="line"><span class="lineno"> 6998</span>                <span class="keywordflow">if</span> self._can_hold_na <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 6999</span>                    arr[self.isna()] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 7000</span>                <span class="keywordflow">return</span> arr</div>
<div class="line"><span class="lineno"> 7001</span> </div>
<div class="line"><span class="lineno"> 7002</span>        <span class="keywordflow">if</span> isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)) <span class="keywordflow">and</span> len(</div>
<div class="line"><span class="lineno"> 7003</span>            self</div>
<div class="line"><span class="lineno"> 7004</span>        ) != len(other):</div>
<div class="line"><span class="lineno"> 7005</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Lengths must match to compare&quot;</span>)</div>
<div class="line"><span class="lineno"> 7006</span> </div>
<div class="line"><span class="lineno"> 7007</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(other, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 7008</span>            other = extract_array(other, extract_numpy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 7009</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7010</span>            other = np.asarray(other)</div>
<div class="line"><span class="lineno"> 7011</span> </div>
<div class="line"><span class="lineno"> 7012</span>        <span class="keywordflow">if</span> is_object_dtype(self.dtype) <span class="keywordflow">and</span> isinstance(other, ExtensionArray):</div>
<div class="line"><span class="lineno"> 7013</span>            <span class="comment"># e.g. PeriodArray, Categorical</span></div>
<div class="line"><span class="lineno"> 7014</span>            <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 7015</span>                result = op(self._values, other)</div>
<div class="line"><span class="lineno"> 7016</span> </div>
<div class="line"><span class="lineno"> 7017</span>        <span class="keywordflow">elif</span> isinstance(self._values, ExtensionArray):</div>
<div class="line"><span class="lineno"> 7018</span>            result = op(self._values, other)</div>
<div class="line"><span class="lineno"> 7019</span> </div>
<div class="line"><span class="lineno"> 7020</span>        <span class="keywordflow">elif</span> is_object_dtype(self.dtype) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 7021</span>            <span class="comment"># don&#39;t pass MultiIndex</span></div>
<div class="line"><span class="lineno"> 7022</span>            <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 7023</span>                result = ops.comp_method_OBJECT_ARRAY(op, self._values, other)</div>
<div class="line"><span class="lineno"> 7024</span> </div>
<div class="line"><span class="lineno"> 7025</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 7026</span>            <span class="keyword">with</span> np.errstate(all=<span class="stringliteral">&quot;ignore&quot;</span>):</div>
<div class="line"><span class="lineno"> 7027</span>                result = ops.comparison_op(self._values, other, op)</div>
<div class="line"><span class="lineno"> 7028</span> </div>
<div class="line"><span class="lineno"> 7029</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 7030</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f5d4a0084ecf45e9d24559249a8f8b5" name="a7f5d4a0084ecf45e9d24559249a8f8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f5d4a0084ecf45e9d24559249a8f8b5">&#9670;&#160;</a></span>_concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index._concat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>]&#160;</td>
          <td class="paramname"><em>to_concat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Concatenate multiple Index objects.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ab504c3d76a321ccf60db5e98bf339ec1">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#af60a4925cb3b130d2bdb9b9772dfe510">pandas.core.indexes.category.CategoricalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5450</span>    <span class="keyword">def </span>_concat(self, to_concat: list[Index], name: Hashable) -&gt; Index:</div>
<div class="line"><span class="lineno"> 5451</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5452</span><span class="stringliteral">        Concatenate multiple Index objects.</span></div>
<div class="line"><span class="lineno"> 5453</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5454</span>        to_concat_vals = [x._values <span class="keywordflow">for</span> x <span class="keywordflow">in</span> to_concat]</div>
<div class="line"><span class="lineno"> 5455</span> </div>
<div class="line"><span class="lineno"> 5456</span>        result = concat_compat(to_concat_vals)</div>
<div class="line"><span class="lineno"> 5457</span> </div>
<div class="line"><span class="lineno"> 5458</span>        is_numeric = result.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>]</div>
<div class="line"><span class="lineno"> 5459</span>        <span class="keywordflow">if</span> self._is_backward_compat_public_numeric_index <span class="keywordflow">and</span> is_numeric:</div>
<div class="line"><span class="lineno"> 5460</span>            <span class="keywordflow">return</span> type(self)._simple_new(result, name=name)</div>
<div class="line"><span class="lineno"> 5461</span> </div>
<div class="line"><span class="lineno"> 5462</span>        <span class="keywordflow">return</span> Index._with_infer(result, name=name)</div>
<div class="line"><span class="lineno"> 5463</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6ffbb4d6fd8646f382dbb5290ec674d" name="aa6ffbb4d6fd8646f382dbb5290ec674d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ffbb4d6fd8646f382dbb5290ec674d">&#9670;&#160;</a></span>_construct_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._construct_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct an appropriately-wrapped result from the ArrayLike result
of an arithmetic-like operation.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a8440d323b1bed7ad4bfaf0e27c154bce">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7031</span>    <span class="keyword">def </span>_construct_result(self, result, name):</div>
<div class="line"><span class="lineno"> 7032</span>        <span class="keywordflow">if</span> isinstance(result, tuple):</div>
<div class="line"><span class="lineno"> 7033</span>            <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno"> 7034</span>                Index._with_infer(result[0], name=name),</div>
<div class="line"><span class="lineno"> 7035</span>                Index._with_infer(result[1], name=name),</div>
<div class="line"><span class="lineno"> 7036</span>            )</div>
<div class="line"><span class="lineno"> 7037</span>        <span class="keywordflow">return</span> Index._with_infer(result, name=name)</div>
<div class="line"><span class="lineno"> 7038</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6ea6e83ccdc78314b900763b6975ba4" name="aa6ea6e83ccdc78314b900763b6975ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ea6e83ccdc78314b900763b6975ba4">&#9670;&#160;</a></span>_constructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> type[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>] pandas.core.indexes.base.Index._constructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Class constructor (for this class it's just `__class__`.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_pandas_object.html#a7b5112b72a8bafe13b1fa732bf1ea30d">pandas.core.base.PandasObject</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a168d36175ea87452e6b4545710cbd8ca">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a3644df27c4224f81e41f070d863c1a3d">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  730</span>    <span class="keyword">def </span>_constructor(self: _IndexT) -&gt; type[_IndexT]:</div>
<div class="line"><span class="lineno">  731</span>        <span class="keywordflow">return</span> type(self)</div>
<div class="line"><span class="lineno">  732</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a398c4f33e1e09478d869810f80cbd9" name="a6a398c4f33e1e09478d869810f80cbd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a398c4f33e1e09478d869810f80cbd9">&#9670;&#160;</a></span>_convert_can_do_setop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, Hashable] pandas.core.indexes.base.Index._convert_can_do_setop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aa8eadd6f3fc929b1d0dda17d7135b36a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3738</span>    <span class="keyword">def </span>_convert_can_do_setop(self, other) -&gt; tuple[Index, Hashable]:</div>
<div class="line"><span class="lineno"> 3739</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(other, Index):</div>
<div class="line"><span class="lineno"> 3740</span>            <span class="comment"># TODO(2.0): no need to special-case here once _with_infer</span></div>
<div class="line"><span class="lineno"> 3741</span>            <span class="comment">#  deprecation is enforced</span></div>
<div class="line"><span class="lineno"> 3742</span>            <span class="keywordflow">if</span> hasattr(other, <span class="stringliteral">&quot;dtype&quot;</span>):</div>
<div class="line"><span class="lineno"> 3743</span>                other = Index(other, name=self.name, dtype=other.dtype)</div>
<div class="line"><span class="lineno"> 3744</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3745</span>                <span class="comment"># e.g. list</span></div>
<div class="line"><span class="lineno"> 3746</span>                other = Index(other, name=self.name)</div>
<div class="line"><span class="lineno"> 3747</span>            result_name = self.name</div>
<div class="line"><span class="lineno"> 3748</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3749</span>            result_name = get_op_result_name(self, other)</div>
<div class="line"><span class="lineno"> 3750</span>        <span class="keywordflow">return</span> other, result_name</div>
<div class="line"><span class="lineno"> 3751</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab44c447b67bf7e9340e5ac0933f610c6" name="ab44c447b67bf7e9340e5ac0933f610c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44c447b67bf7e9340e5ac0933f610c6">&#9670;&#160;</a></span>_convert_slice_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._convert_slice_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slice&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>is_frame</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Convert a slice indexer.

By definition, these are labels unless 'iloc' is passed in.
Floats are not allowed as the start, step, or stop of the slice.

Parameters
----------
key : label of the slice bound
kind : {'loc', 'getitem'}
is_frame : bool, default False
    Whether this is a slice called on DataFrame.__getitem__
    as opposed to Series.__getitem__
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#aff2d843db6bf2320fec311b513ebd705">pandas.core.indexes.interval.IntervalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#a3a0b747f8a974b9de846926fabacbc97">pandas.core.indexes.numeric.NumericIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4216</span>    <span class="keyword">def </span>_convert_slice_indexer(self, key: slice, kind: str_t, is_frame: bool = <span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 4217</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4218</span><span class="stringliteral">        Convert a slice indexer.</span></div>
<div class="line"><span class="lineno"> 4219</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4220</span><span class="stringliteral">        By definition, these are labels unless &#39;iloc&#39; is passed in.</span></div>
<div class="line"><span class="lineno"> 4221</span><span class="stringliteral">        Floats are not allowed as the start, step, or stop of the slice.</span></div>
<div class="line"><span class="lineno"> 4222</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4223</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4224</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4225</span><span class="stringliteral">        key : label of the slice bound</span></div>
<div class="line"><span class="lineno"> 4226</span><span class="stringliteral">        kind : {&#39;loc&#39;, &#39;getitem&#39;}</span></div>
<div class="line"><span class="lineno"> 4227</span><span class="stringliteral">        is_frame : bool, default False</span></div>
<div class="line"><span class="lineno"> 4228</span><span class="stringliteral">            Whether this is a slice called on DataFrame.__getitem__</span></div>
<div class="line"><span class="lineno"> 4229</span><span class="stringliteral">            as opposed to Series.__getitem__</span></div>
<div class="line"><span class="lineno"> 4230</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4231</span>        <span class="keyword">assert</span> kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;loc&quot;</span>, <span class="stringliteral">&quot;getitem&quot;</span>], kind</div>
<div class="line"><span class="lineno"> 4232</span> </div>
<div class="line"><span class="lineno"> 4233</span>        <span class="comment"># potentially cast the bounds to integers</span></div>
<div class="line"><span class="lineno"> 4234</span>        start, stop, step = key.start, key.stop, key.step</div>
<div class="line"><span class="lineno"> 4235</span> </div>
<div class="line"><span class="lineno"> 4236</span>        <span class="comment"># figure out if this is a positional indexer</span></div>
<div class="line"><span class="lineno"> 4237</span>        <span class="keyword">def </span>is_int(v):</div>
<div class="line"><span class="lineno"> 4238</span>            <span class="keywordflow">return</span> v <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> is_integer(v)</div>
<div class="line"><span class="lineno"> 4239</span> </div>
<div class="line"><span class="lineno"> 4240</span>        is_index_slice = is_int(start) <span class="keywordflow">and</span> is_int(stop) <span class="keywordflow">and</span> is_int(step)</div>
<div class="line"><span class="lineno"> 4241</span> </div>
<div class="line"><span class="lineno"> 4242</span>        <span class="comment"># special case for interval_dtype bc we do not do partial-indexing</span></div>
<div class="line"><span class="lineno"> 4243</span>        <span class="comment">#  on integer Intervals when slicing</span></div>
<div class="line"><span class="lineno"> 4244</span>        <span class="comment"># TODO: write this in terms of e.g. should_partial_index?</span></div>
<div class="line"><span class="lineno"> 4245</span>        ints_are_positional = self._should_fallback_to_positional <span class="keywordflow">or</span> is_interval_dtype(</div>
<div class="line"><span class="lineno"> 4246</span>            self.dtype</div>
<div class="line"><span class="lineno"> 4247</span>        )</div>
<div class="line"><span class="lineno"> 4248</span>        is_positional = is_index_slice <span class="keywordflow">and</span> ints_are_positional</div>
<div class="line"><span class="lineno"> 4249</span> </div>
<div class="line"><span class="lineno"> 4250</span>        <span class="keywordflow">if</span> kind == <span class="stringliteral">&quot;getitem&quot;</span>:</div>
<div class="line"><span class="lineno"> 4251</span>            <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4252</span><span class="stringliteral">            called from the getitem slicers, validate that we are in fact</span></div>
<div class="line"><span class="lineno"> 4253</span><span class="stringliteral">            integers</span></div>
<div class="line"><span class="lineno"> 4254</span><span class="stringliteral">            &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4255</span>            <span class="keywordflow">if</span> self.is_integer():</div>
<div class="line"><span class="lineno"> 4256</span>                <span class="keywordflow">if</span> is_frame:</div>
<div class="line"><span class="lineno"> 4257</span>                    <span class="comment"># unambiguously positional, no deprecation</span></div>
<div class="line"><span class="lineno"> 4258</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4259</span>                <span class="keywordflow">elif</span> start <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> stop <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4260</span>                    <span class="comment"># label-based vs positional is irrelevant</span></div>
<div class="line"><span class="lineno"> 4261</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4262</span>                <span class="keywordflow">elif</span> isinstance(self, ABCRangeIndex) <span class="keywordflow">and</span> self._range == range(</div>
<div class="line"><span class="lineno"> 4263</span>                    len(self)</div>
<div class="line"><span class="lineno"> 4264</span>                ):</div>
<div class="line"><span class="lineno"> 4265</span>                    <span class="comment"># In this case there is no difference between label-based</span></div>
<div class="line"><span class="lineno"> 4266</span>                    <span class="comment">#  and positional, so nothing will change.</span></div>
<div class="line"><span class="lineno"> 4267</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4268</span>                <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno"> 4269</span>                    self.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]</div>
<div class="line"><span class="lineno"> 4270</span>                    <span class="keywordflow">and</span> self._is_strictly_monotonic_increasing</div>
<div class="line"><span class="lineno"> 4271</span>                    <span class="keywordflow">and</span> len(self) &gt; 0</div>
<div class="line"><span class="lineno"> 4272</span>                    <span class="keywordflow">and</span> self[0] == 0</div>
<div class="line"><span class="lineno"> 4273</span>                    <span class="keywordflow">and</span> self[-1] == len(self) - 1</div>
<div class="line"><span class="lineno"> 4274</span>                ):</div>
<div class="line"><span class="lineno"> 4275</span>                    <span class="comment"># We are range-like, e.g. created with Index(np.arange(N))</span></div>
<div class="line"><span class="lineno"> 4276</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4277</span>                <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_index_slice:</div>
<div class="line"><span class="lineno"> 4278</span>                    <span class="comment"># we&#39;re going to raise, so don&#39;t bother warning, e.g.</span></div>
<div class="line"><span class="lineno"> 4279</span>                    <span class="comment">#  test_integer_positional_indexing</span></div>
<div class="line"><span class="lineno"> 4280</span>                    <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4281</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4282</span>                    warnings.warn(</div>
<div class="line"><span class="lineno"> 4283</span>                        <span class="stringliteral">&quot;The behavior of `series[i:j]` with an integer-dtype index &quot;</span></div>
<div class="line"><span class="lineno"> 4284</span>                        <span class="stringliteral">&quot;is deprecated. In a future version, this will be treated &quot;</span></div>
<div class="line"><span class="lineno"> 4285</span>                        <span class="stringliteral">&quot;as *label-based* indexing, consistent with e.g. `series[i]` &quot;</span></div>
<div class="line"><span class="lineno"> 4286</span>                        <span class="stringliteral">&quot;lookups. To retain the old behavior, use `series.iloc[i:j]`. &quot;</span></div>
<div class="line"><span class="lineno"> 4287</span>                        <span class="stringliteral">&quot;To get the future behavior, use `series.loc[i:j]`.&quot;</span>,</div>
<div class="line"><span class="lineno"> 4288</span>                        FutureWarning,</div>
<div class="line"><span class="lineno"> 4289</span>                        stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 4290</span>                    )</div>
<div class="line"><span class="lineno"> 4291</span>            <span class="keywordflow">if</span> self.is_integer() <span class="keywordflow">or</span> is_index_slice:</div>
<div class="line"><span class="lineno"> 4292</span>                <span class="comment"># Note: these checks are redundant if we know is_index_slice</span></div>
<div class="line"><span class="lineno"> 4293</span>                self._validate_indexer(<span class="stringliteral">&quot;slice&quot;</span>, key.start, <span class="stringliteral">&quot;getitem&quot;</span>)</div>
<div class="line"><span class="lineno"> 4294</span>                self._validate_indexer(<span class="stringliteral">&quot;slice&quot;</span>, key.stop, <span class="stringliteral">&quot;getitem&quot;</span>)</div>
<div class="line"><span class="lineno"> 4295</span>                self._validate_indexer(<span class="stringliteral">&quot;slice&quot;</span>, key.step, <span class="stringliteral">&quot;getitem&quot;</span>)</div>
<div class="line"><span class="lineno"> 4296</span>                <span class="keywordflow">return</span> key</div>
<div class="line"><span class="lineno"> 4297</span> </div>
<div class="line"><span class="lineno"> 4298</span>        <span class="comment"># convert the slice to an indexer here</span></div>
<div class="line"><span class="lineno"> 4299</span> </div>
<div class="line"><span class="lineno"> 4300</span>        <span class="comment"># if we are mixed and have integers</span></div>
<div class="line"><span class="lineno"> 4301</span>        <span class="keywordflow">if</span> is_positional:</div>
<div class="line"><span class="lineno"> 4302</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 4303</span>                <span class="comment"># Validate start &amp; stop</span></div>
<div class="line"><span class="lineno"> 4304</span>                <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4305</span>                    self.get_loc(start)</div>
<div class="line"><span class="lineno"> 4306</span>                <span class="keywordflow">if</span> stop <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4307</span>                    self.get_loc(stop)</div>
<div class="line"><span class="lineno"> 4308</span>                is_positional = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4309</span>            <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno"> 4310</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4311</span> </div>
<div class="line"><span class="lineno"> 4312</span>        <span class="keywordflow">if</span> com.is_null_slice(key):</div>
<div class="line"><span class="lineno"> 4313</span>            <span class="comment"># It doesn&#39;t matter if we are positional or label based</span></div>
<div class="line"><span class="lineno"> 4314</span>            indexer = key</div>
<div class="line"><span class="lineno"> 4315</span>        <span class="keywordflow">elif</span> is_positional:</div>
<div class="line"><span class="lineno"> 4316</span>            <span class="keywordflow">if</span> kind == <span class="stringliteral">&quot;loc&quot;</span>:</div>
<div class="line"><span class="lineno"> 4317</span>                <span class="comment"># GH#16121, GH#24612, GH#31810</span></div>
<div class="line"><span class="lineno"> 4318</span>                warnings.warn(</div>
<div class="line"><span class="lineno"> 4319</span>                    <span class="stringliteral">&quot;Slicing a positional slice with .loc is not supported, &quot;</span></div>
<div class="line"><span class="lineno"> 4320</span>                    <span class="stringliteral">&quot;and will raise TypeError in a future version.  &quot;</span></div>
<div class="line"><span class="lineno"> 4321</span>                    <span class="stringliteral">&quot;Use .loc with labels or .iloc with positions instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 4322</span>                    FutureWarning,</div>
<div class="line"><span class="lineno"> 4323</span>                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 4324</span>                )</div>
<div class="line"><span class="lineno"> 4325</span>            indexer = key</div>
<div class="line"><span class="lineno"> 4326</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4327</span>            indexer = self.slice_indexer(start, stop, step)</div>
<div class="line"><span class="lineno"> 4328</span> </div>
<div class="line"><span class="lineno"> 4329</span>        <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 4330</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1b462fbc8b21347e64de5e344f3a4fd" name="ab1b462fbc8b21347e64de5e344f3a4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b462fbc8b21347e64de5e344f3a4fd">&#9670;&#160;</a></span>_convert_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.indexes.base.Index._convert_tolerance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray | <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a8143a2ca44411ad474663491f68fe083">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#a19613d49855414c24a89056883f97cfc">pandas.core.indexes.numeric.NumericIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a2337af40116f38470a7e001daa514340">pandas.core.indexes.period.PeriodIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4067</span>    <span class="keyword">def </span>_convert_tolerance(self, tolerance, target: np.ndarray | Index) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 4068</span>        <span class="comment"># override this method on subclasses</span></div>
<div class="line"><span class="lineno"> 4069</span>        tolerance = np.asarray(tolerance)</div>
<div class="line"><span class="lineno"> 4070</span>        <span class="keywordflow">if</span> target.size != tolerance.size <span class="keywordflow">and</span> tolerance.size &gt; 1:</div>
<div class="line"><span class="lineno"> 4071</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;list-like tolerance size must match target index size&quot;</span>)</div>
<div class="line"><span class="lineno"> 4072</span>        <span class="keywordflow">return</span> tolerance</div>
<div class="line"><span class="lineno"> 4073</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab2bde2e76c59ae03b175974ad9ca0a68" name="ab2bde2e76c59ae03b175974ad9ca0a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2bde2e76c59ae03b175974ad9ca0a68">&#9670;&#160;</a></span>_deprecate_dti_setop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._deprecate_dti_setop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>setop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Deprecate setop behavior between timezone-aware DatetimeIndexes with
mismatched timezones.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3219</span>    <span class="keyword">def </span>_deprecate_dti_setop(self, other: Index, setop: str_t):</div>
<div class="line"><span class="lineno"> 3220</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3221</span><span class="stringliteral">        Deprecate setop behavior between timezone-aware DatetimeIndexes with</span></div>
<div class="line"><span class="lineno"> 3222</span><span class="stringliteral">        mismatched timezones.</span></div>
<div class="line"><span class="lineno"> 3223</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3224</span>        <span class="comment"># Caller is responsibelf or checking</span></div>
<div class="line"><span class="lineno"> 3225</span>        <span class="comment">#  `not is_dtype_equal(self.dtype, other.dtype)`</span></div>
<div class="line"><span class="lineno"> 3226</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3227</span>            isinstance(self, ABCDatetimeIndex)</div>
<div class="line"><span class="lineno"> 3228</span>            <span class="keywordflow">and</span> isinstance(other, ABCDatetimeIndex)</div>
<div class="line"><span class="lineno"> 3229</span>            <span class="keywordflow">and</span> self.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3230</span>            <span class="keywordflow">and</span> other.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3231</span>        ):</div>
<div class="line"><span class="lineno"> 3232</span>            <span class="comment"># GH#39328, GH#45357</span></div>
<div class="line"><span class="lineno"> 3233</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 3234</span>                f<span class="stringliteral">&quot;In a future version, the {setop} of DatetimeIndex objects &quot;</span></div>
<div class="line"><span class="lineno"> 3235</span>                <span class="stringliteral">&quot;with mismatched timezones will cast both to UTC instead of &quot;</span></div>
<div class="line"><span class="lineno"> 3236</span>                <span class="stringliteral">&quot;object dtype. To retain the old behavior, &quot;</span></div>
<div class="line"><span class="lineno"> 3237</span>                f<span class="stringliteral">&quot;use `index.astype(object).{setop}(other)`&quot;</span>,</div>
<div class="line"><span class="lineno"> 3238</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 3239</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3240</span>            )</div>
<div class="line"><span class="lineno"> 3241</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af05e83c575beb751c05d6cea77973daf" name="af05e83c575beb751c05d6cea77973daf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05e83c575beb751c05d6cea77973daf">&#9670;&#160;</a></span>_deprecated_arg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._deprecated_arg </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>methodname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Issue a FutureWarning if the arg/kwarg is not no_default.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 7267</span>    <span class="keyword">def </span>_deprecated_arg(self, value, name: str_t, methodname: str_t) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 7268</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7269</span><span class="stringliteral">        Issue a FutureWarning if the arg/kwarg is not no_default.</span></div>
<div class="line"><span class="lineno"> 7270</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7271</span>        <span class="keywordflow">if</span> value <span class="keywordflow">is</span> <span class="keywordflow">not</span> no_default:</div>
<div class="line"><span class="lineno"> 7272</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 7273</span>                f<span class="stringliteral">&quot;&#39;{name}&#39; argument in {methodname} is deprecated &quot;</span></div>
<div class="line"><span class="lineno"> 7274</span>                <span class="stringliteral">&quot;and will be removed in a future version.  Do not pass it.&quot;</span>,</div>
<div class="line"><span class="lineno"> 7275</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 7276</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 7277</span>            )</div>
<div class="line"><span class="lineno"> 7278</span> </div>
<div class="line"><span class="lineno"> 7279</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac94cb17285aaf55f8698618459c6428d" name="ac94cb17285aaf55f8698618459c6428d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94cb17285aaf55f8698618459c6428d">&#9670;&#160;</a></span>_difference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a2421f6d825c7d57e7264618ca8a45f2b">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3626</span>    <span class="keyword">def </span>_difference(self, other, sort):</div>
<div class="line"><span class="lineno"> 3627</span>        <span class="comment"># overridden by RangeIndex</span></div>
<div class="line"><span class="lineno"> 3628</span> </div>
<div class="line"><span class="lineno"> 3629</span>        this = self.unique()</div>
<div class="line"><span class="lineno"> 3630</span> </div>
<div class="line"><span class="lineno"> 3631</span>        indexer = this.get_indexer_for(other)</div>
<div class="line"><span class="lineno"> 3632</span>        indexer = indexer.take((indexer != -1).nonzero()[0])</div>
<div class="line"><span class="lineno"> 3633</span> </div>
<div class="line"><span class="lineno"> 3634</span>        label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3635</span>        the_diff = this._values.take(label_diff)</div>
<div class="line"><span class="lineno"> 3636</span>        the_diff = _maybe_try_sort(the_diff, sort)</div>
<div class="line"><span class="lineno"> 3637</span> </div>
<div class="line"><span class="lineno"> 3638</span>        <span class="keywordflow">return</span> the_diff</div>
<div class="line"><span class="lineno"> 3639</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa7b01f337a2084acb72ba3031655bf31" name="aa7b01f337a2084acb72ba3031655bf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7b01f337a2084acb72ba3031655bf31">&#9670;&#160;</a></span>_difference_compat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.indexes.base.Index._difference_compat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]
    &#160;</td>
          <td class="paramname"><em>indexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4188</span>    ) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 4189</span>        <span class="comment"># Compatibility for PeriodArray, for which __sub__ returns an ndarray[object]</span></div>
<div class="line"><span class="lineno"> 4190</span>        <span class="comment">#  of DateOffset objects, which do not support __abs__ (and would be slow</span></div>
<div class="line"><span class="lineno"> 4191</span>        <span class="comment">#  if they did)</span></div>
<div class="line"><span class="lineno"> 4192</span> </div>
<div class="line"><span class="lineno"> 4193</span>        <span class="keywordflow">if</span> isinstance(self.dtype, PeriodDtype):</div>
<div class="line"><span class="lineno"> 4194</span>            <span class="comment"># Note: we only get here with matching dtypes</span></div>
<div class="line"><span class="lineno"> 4195</span>            own_values = cast(<span class="stringliteral">&quot;PeriodArray&quot;</span>, self._data)._ndarray</div>
<div class="line"><span class="lineno"> 4196</span>            target_values = cast(<span class="stringliteral">&quot;PeriodArray&quot;</span>, target._data)._ndarray</div>
<div class="line"><span class="lineno"> 4197</span>            diff = own_values[indexer] - target_values</div>
<div class="line"><span class="lineno"> 4198</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4199</span>            <span class="comment"># error: Unsupported left operand type for - (&quot;ExtensionArray&quot;)</span></div>
<div class="line"><span class="lineno"> 4200</span>            diff = self._values[indexer] - target._values  <span class="comment"># type: ignore[operator]</span></div>
<div class="line"><span class="lineno"> 4201</span>        <span class="keywordflow">return</span> abs(diff)</div>
<div class="line"><span class="lineno"> 4202</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad0acfcf7fe9c2fa9b5a12c755987f5d4" name="ad0acfcf7fe9c2fa9b5a12c755987f5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0acfcf7fe9c2fa9b5a12c755987f5d4">&#9670;&#160;</a></span>_dir_additions_for_owner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> set[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>] pandas.core.indexes.base.Index._dir_additions_for_owner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Add the string-like labels to the owner dataframe/series dir output.

If this is a MultiIndex, it's first level values are used.
</pre> <div class="fragment"><div class="line"><span class="lineno">  910</span>    <span class="keyword">def </span>_dir_additions_for_owner(self) -&gt; set[str_t]:</div>
<div class="line"><span class="lineno">  911</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  912</span><span class="stringliteral">        Add the string-like labels to the owner dataframe/series dir output.</span></div>
<div class="line"><span class="lineno">  913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  914</span><span class="stringliteral">        If this is a MultiIndex, it&#39;s first level values are used.</span></div>
<div class="line"><span class="lineno">  915</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  916</span>        <span class="keywordflow">return</span> {</div>
<div class="line"><span class="lineno">  917</span>            c</div>
<div class="line"><span class="lineno">  918</span>            <span class="keywordflow">for</span> c <span class="keywordflow">in</span> self.unique(level=0)[: get_option(<span class="stringliteral">&quot;display.max_dir_items&quot;</span>)]</div>
<div class="line"><span class="lineno">  919</span>            <span class="keywordflow">if</span> isinstance(c, str) <span class="keywordflow">and</span> c.isidentifier()</div>
<div class="line"><span class="lineno">  920</span>        }</div>
<div class="line"><span class="lineno">  921</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5ba53652f5d091601943c1eb7fdd3104" name="a5ba53652f5d091601943c1eb7fdd3104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba53652f5d091601943c1eb7fdd3104">&#9670;&#160;</a></span>_drop_level_numbers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._drop_level_numbers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[int]&#160;</td>
          <td class="paramname"><em>levnums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Drop MultiIndex levels by level _number_, not name.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2186</span>    <span class="keyword">def </span>_drop_level_numbers(self, levnums: list[int]):</div>
<div class="line"><span class="lineno"> 2187</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2188</span><span class="stringliteral">        Drop MultiIndex levels by level _number_, not name.</span></div>
<div class="line"><span class="lineno"> 2189</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2190</span> </div>
<div class="line"><span class="lineno"> 2191</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> levnums <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 2192</span>            <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno"> 2193</span>        <span class="keywordflow">if</span> len(levnums) &gt;= self.nlevels:</div>
<div class="line"><span class="lineno"> 2194</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 2195</span>                f<span class="stringliteral">&quot;Cannot remove {len(levnums)} levels from an index with &quot;</span></div>
<div class="line"><span class="lineno"> 2196</span>                f<span class="stringliteral">&quot;{self.nlevels} levels: at least one level must be left.&quot;</span></div>
<div class="line"><span class="lineno"> 2197</span>            )</div>
<div class="line"><span class="lineno"> 2198</span>        <span class="comment"># The two checks above guarantee that here self is a MultiIndex</span></div>
<div class="line"><span class="lineno"> 2199</span>        self = cast(<span class="stringliteral">&quot;MultiIndex&quot;</span>, self)</div>
<div class="line"><span class="lineno"> 2200</span> </div>
<div class="line"><span class="lineno"> 2201</span>        new_levels = list(self.levels)</div>
<div class="line"><span class="lineno"> 2202</span>        new_codes = list(self.codes)</div>
<div class="line"><span class="lineno"> 2203</span>        new_names = list(self.names)</div>
<div class="line"><span class="lineno"> 2204</span> </div>
<div class="line"><span class="lineno"> 2205</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> levnums:</div>
<div class="line"><span class="lineno"> 2206</span>            new_levels.pop(i)</div>
<div class="line"><span class="lineno"> 2207</span>            new_codes.pop(i)</div>
<div class="line"><span class="lineno"> 2208</span>            new_names.pop(i)</div>
<div class="line"><span class="lineno"> 2209</span> </div>
<div class="line"><span class="lineno"> 2210</span>        <span class="keywordflow">if</span> len(new_levels) == 1:</div>
<div class="line"><span class="lineno"> 2211</span>            lev = new_levels[0]</div>
<div class="line"><span class="lineno"> 2212</span> </div>
<div class="line"><span class="lineno"> 2213</span>            <span class="keywordflow">if</span> len(lev) == 0:</div>
<div class="line"><span class="lineno"> 2214</span>                <span class="comment"># If lev is empty, lev.take will fail GH#42055</span></div>
<div class="line"><span class="lineno"> 2215</span>                <span class="keywordflow">if</span> len(new_codes[0]) == 0:</div>
<div class="line"><span class="lineno"> 2216</span>                    <span class="comment"># GH#45230 preserve RangeIndex here</span></div>
<div class="line"><span class="lineno"> 2217</span>                    <span class="comment">#  see test_reset_index_empty_rangeindex</span></div>
<div class="line"><span class="lineno"> 2218</span>                    result = lev[:0]</div>
<div class="line"><span class="lineno"> 2219</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2220</span>                    res_values = algos.take(lev._values, new_codes[0], allow_fill=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 2221</span>                    <span class="comment"># _constructor instead of type(lev) for RangeIndex compat GH#35230</span></div>
<div class="line"><span class="lineno"> 2222</span>                    result = lev._constructor._simple_new(res_values, name=new_names[0])</div>
<div class="line"><span class="lineno"> 2223</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2224</span>                <span class="comment"># set nan if needed</span></div>
<div class="line"><span class="lineno"> 2225</span>                mask = new_codes[0] == -1</div>
<div class="line"><span class="lineno"> 2226</span>                result = new_levels[0].take(new_codes[0])</div>
<div class="line"><span class="lineno"> 2227</span>                <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno"> 2228</span>                    result = result.putmask(mask, np.nan)</div>
<div class="line"><span class="lineno"> 2229</span> </div>
<div class="line"><span class="lineno"> 2230</span>                result._name = new_names[0]</div>
<div class="line"><span class="lineno"> 2231</span> </div>
<div class="line"><span class="lineno"> 2232</span>            <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 2233</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2234</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 2235</span> </div>
<div class="line"><span class="lineno"> 2236</span>            <span class="keywordflow">return</span> MultiIndex(</div>
<div class="line"><span class="lineno"> 2237</span>                levels=new_levels,</div>
<div class="line"><span class="lineno"> 2238</span>                codes=new_codes,</div>
<div class="line"><span class="lineno"> 2239</span>                names=new_names,</div>
<div class="line"><span class="lineno"> 2240</span>                verify_integrity=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 2241</span>            )</div>
<div class="line"><span class="lineno"> 2242</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a629d3a5311ce5e1fba41ee355543048c" name="a629d3a5311ce5e1fba41ee355543048c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629d3a5311ce5e1fba41ee355543048c">&#9670;&#160;</a></span>_dtype_to_subclass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._dtype_to_subclass </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  591</span>    <span class="keyword">def </span>_dtype_to_subclass(cls, dtype: DtypeObj):</div>
<div class="line"><span class="lineno">  592</span>        <span class="comment"># Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423</span></div>
<div class="line"><span class="lineno">  593</span> </div>
<div class="line"><span class="lineno">  594</span>        <span class="keywordflow">if</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  595</span>            <span class="keywordflow">if</span> isinstance(dtype, DatetimeTZDtype):</div>
<div class="line"><span class="lineno">  596</span>                <span class="keyword">from</span> pandas <span class="keyword">import</span> DatetimeIndex</div>
<div class="line"><span class="lineno">  597</span> </div>
<div class="line"><span class="lineno">  598</span>                <span class="keywordflow">return</span> DatetimeIndex</div>
<div class="line"><span class="lineno">  599</span>            <span class="keywordflow">elif</span> isinstance(dtype, CategoricalDtype):</div>
<div class="line"><span class="lineno">  600</span>                <span class="keyword">from</span> pandas <span class="keyword">import</span> CategoricalIndex</div>
<div class="line"><span class="lineno">  601</span> </div>
<div class="line"><span class="lineno">  602</span>                <span class="keywordflow">return</span> CategoricalIndex</div>
<div class="line"><span class="lineno">  603</span>            <span class="keywordflow">elif</span> isinstance(dtype, IntervalDtype):</div>
<div class="line"><span class="lineno">  604</span>                <span class="keyword">from</span> pandas <span class="keyword">import</span> IntervalIndex</div>
<div class="line"><span class="lineno">  605</span> </div>
<div class="line"><span class="lineno">  606</span>                <span class="keywordflow">return</span> IntervalIndex</div>
<div class="line"><span class="lineno">  607</span>            <span class="keywordflow">elif</span> isinstance(dtype, PeriodDtype):</div>
<div class="line"><span class="lineno">  608</span>                <span class="keyword">from</span> pandas <span class="keyword">import</span> PeriodIndex</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>                <span class="keywordflow">return</span> PeriodIndex</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>            <span class="keywordflow">elif</span> isinstance(dtype, SparseDtype):</div>
<div class="line"><span class="lineno">  613</span>                warnings.warn(</div>
<div class="line"><span class="lineno">  614</span>                    <span class="stringliteral">&quot;In a future version, passing a SparseArray to pd.Index &quot;</span></div>
<div class="line"><span class="lineno">  615</span>                    <span class="stringliteral">&quot;will store that array directly instead of converting to a &quot;</span></div>
<div class="line"><span class="lineno">  616</span>                    <span class="stringliteral">&quot;dense numpy ndarray. To retain the old behavior, use &quot;</span></div>
<div class="line"><span class="lineno">  617</span>                    <span class="stringliteral">&quot;pd.Index(arr.to_numpy()) instead&quot;</span>,</div>
<div class="line"><span class="lineno">  618</span>                    FutureWarning,</div>
<div class="line"><span class="lineno">  619</span>                    stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  620</span>                )</div>
<div class="line"><span class="lineno">  621</span>                <span class="keywordflow">return</span> cls._dtype_to_subclass(dtype.subtype)</div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>            <span class="keywordflow">return</span> Index</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>        <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span>:</div>
<div class="line"><span class="lineno">  626</span>            <span class="keyword">from</span> pandas <span class="keyword">import</span> DatetimeIndex</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>            <span class="keywordflow">return</span> DatetimeIndex</div>
<div class="line"><span class="lineno">  629</span> </div>
<div class="line"><span class="lineno">  630</span>        <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span>:</div>
<div class="line"><span class="lineno">  631</span>            <span class="keyword">from</span> pandas <span class="keyword">import</span> TimedeltaIndex</div>
<div class="line"><span class="lineno">  632</span> </div>
<div class="line"><span class="lineno">  633</span>            <span class="keywordflow">return</span> TimedeltaIndex</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>        <span class="keywordflow">elif</span> is_float_dtype(dtype):</div>
<div class="line"><span class="lineno">  636</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1api.html">pandas.core.api</a> <span class="keyword">import</span> Float64Index</div>
<div class="line"><span class="lineno">  637</span> </div>
<div class="line"><span class="lineno">  638</span>            <span class="keywordflow">return</span> Float64Index</div>
<div class="line"><span class="lineno">  639</span>        <span class="keywordflow">elif</span> is_unsigned_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  640</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1api.html">pandas.core.api</a> <span class="keyword">import</span> UInt64Index</div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>            <span class="keywordflow">return</span> UInt64Index</div>
<div class="line"><span class="lineno">  643</span>        <span class="keywordflow">elif</span> is_signed_integer_dtype(dtype):</div>
<div class="line"><span class="lineno">  644</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1api.html">pandas.core.api</a> <span class="keyword">import</span> Int64Index</div>
<div class="line"><span class="lineno">  645</span> </div>
<div class="line"><span class="lineno">  646</span>            <span class="keywordflow">return</span> Int64Index</div>
<div class="line"><span class="lineno">  647</span> </div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">elif</span> dtype == _dtype_obj:</div>
<div class="line"><span class="lineno">  649</span>            <span class="comment"># NB: assuming away MultiIndex</span></div>
<div class="line"><span class="lineno">  650</span>            <span class="keywordflow">return</span> Index</div>
<div class="line"><span class="lineno">  651</span> </div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">elif</span> issubclass(</div>
<div class="line"><span class="lineno">  653</span>            dtype.type, (str, bool, np.bool_, complex, np.complex64, np.complex128)</div>
<div class="line"><span class="lineno">  654</span>        ):</div>
<div class="line"><span class="lineno">  655</span>            <span class="keywordflow">return</span> Index</div>
<div class="line"><span class="lineno">  656</span> </div>
<div class="line"><span class="lineno">  657</span>        <span class="keywordflow">raise</span> NotImplementedError(dtype)</div>
<div class="line"><span class="lineno">  658</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1api_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1api.html">pandas.core.api</a></div><div class="ttdef"><b>Definition</b> api.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="adddaf9c7d5c4941a72958f7fe072eb49" name="adddaf9c7d5c4941a72958f7fe072eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adddaf9c7d5c4941a72958f7fe072eb49">&#9670;&#160;</a></span>_engine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> libindex.IndexEngine | libindex.ExtensionEngine pandas.core.indexes.base.Index._engine </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#ae83bc9644d3945096280e03dae8940ad">pandas.core.indexes.interval.IntervalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a653eadba0b719b092aef3ae511dd8f5e">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  885</span>    ) -&gt; libindex.IndexEngine | libindex.ExtensionEngine:</div>
<div class="line"><span class="lineno">  886</span>        <span class="comment"># For base class (object dtype) we get ObjectEngine</span></div>
<div class="line"><span class="lineno">  887</span>        target_values = self._get_engine_target()</div>
<div class="line"><span class="lineno">  888</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  889</span>            isinstance(target_values, ExtensionArray)</div>
<div class="line"><span class="lineno">  890</span>            <span class="keywordflow">and</span> self._engine_type <span class="keywordflow">is</span> libindex.ObjectEngine</div>
<div class="line"><span class="lineno">  891</span>        ):</div>
<div class="line"><span class="lineno">  892</span>            <span class="keywordflow">return</span> libindex.ExtensionEngine(target_values)</div>
<div class="line"><span class="lineno">  893</span> </div>
<div class="line"><span class="lineno">  894</span>        target_values = cast(np.ndarray, target_values)</div>
<div class="line"><span class="lineno">  895</span>        <span class="comment"># to avoid a reference cycle, bind `target_values` to a local variable, so</span></div>
<div class="line"><span class="lineno">  896</span>        <span class="comment"># `self` is not passed into the lambda.</span></div>
<div class="line"><span class="lineno">  897</span>        <span class="keywordflow">if</span> target_values.dtype == bool:</div>
<div class="line"><span class="lineno">  898</span>            <span class="keywordflow">return</span> libindex.BoolEngine(target_values)</div>
<div class="line"><span class="lineno">  899</span>        <span class="keywordflow">elif</span> target_values.dtype == np.complex64:</div>
<div class="line"><span class="lineno">  900</span>            <span class="keywordflow">return</span> libindex.Complex64Engine(target_values)</div>
<div class="line"><span class="lineno">  901</span>        <span class="keywordflow">elif</span> target_values.dtype == np.complex128:</div>
<div class="line"><span class="lineno">  902</span>            <span class="keywordflow">return</span> libindex.Complex128Engine(target_values)</div>
<div class="line"><span class="lineno">  903</span> </div>
<div class="line"><span class="lineno">  904</span>        <span class="comment"># error: Argument 1 to &quot;ExtensionEngine&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  905</span>        <span class="comment"># &quot;ndarray[Any, Any]&quot;; expected &quot;ExtensionArray&quot;</span></div>
<div class="line"><span class="lineno">  906</span>        <span class="keywordflow">return</span> self._engine_type(target_values)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  907</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af6deaeab0d9868a2a560ebe4fab9ddbb" name="af6deaeab0d9868a2a560ebe4fab9ddbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6deaeab0d9868a2a560ebe4fab9ddbb">&#9670;&#160;</a></span>_engine_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> type[libindex.IndexEngine] | type[libindex.ExtensionEngine] pandas.core.indexes.base.Index._engine_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#aa9be0986f0ebfedf02e555c9552f83c7">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a339aa0f6516c0c362890c9935a77b213">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#af35580edc592d5b7383bece0a0442c88">pandas.core.indexes.numeric.NumericIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_int64_index.html#a8477d7dd156cc76761f71d27665398eb">pandas.core.indexes.numeric.Int64Index</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_u_int64_index.html#a45523000e03d04b83348c7186fc7292a">pandas.core.indexes.numeric.UInt64Index</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_float64_index.html#af93f19de178914288c9e2dbc2a3cdfee">pandas.core.indexes.numeric.Float64Index</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#accc7bef0f54802d8539af507d44ce4ba">pandas.core.indexes.period.PeriodIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a6114c181ea27c9751385e0c9c16e2667">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#a681429450618946a790d804b82cd4da9">pandas.core.indexes.timedeltas.TimedeltaIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  417</span>    ) -&gt; type[libindex.IndexEngine] | type[libindex.ExtensionEngine]:</div>
<div class="line"><span class="lineno">  418</span>        <span class="keywordflow">return</span> libindex.ObjectEngine</div>
<div class="line"><span class="lineno">  419</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ff8f1403380dc6043d0d4a7331b2630" name="a4ff8f1403380dc6043d0d4a7331b2630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff8f1403380dc6043d0d4a7331b2630">&#9670;&#160;</a></span>_ensure_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._ensure_array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Ensure we have a valid array to pass to _simple_new.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#a6eceed768dc98d1a44172d59be137d6a">pandas.core.indexes.numeric.NumericIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  576</span>    <span class="keyword">def </span>_ensure_array(cls, data, dtype, copy: bool):</div>
<div class="line"><span class="lineno">  577</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  578</span><span class="stringliteral">        Ensure we have a valid array to pass to _simple_new.</span></div>
<div class="line"><span class="lineno">  579</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  580</span>        <span class="keywordflow">if</span> data.ndim &gt; 1:</div>
<div class="line"><span class="lineno">  581</span>            <span class="comment"># GH#13601, GH#20285, GH#27125</span></div>
<div class="line"><span class="lineno">  582</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Index data must be 1-dimensional&quot;</span>)</div>
<div class="line"><span class="lineno">  583</span>        <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  584</span>            <span class="comment"># asarray_tuplesafe does not always copy underlying data,</span></div>
<div class="line"><span class="lineno">  585</span>            <span class="comment">#  so need to make sure that this happens</span></div>
<div class="line"><span class="lineno">  586</span>            data = data.copy()</div>
<div class="line"><span class="lineno">  587</span>        <span class="keywordflow">return</span> data</div>
<div class="line"><span class="lineno">  588</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a57e3a94192f742df330bf1d46fba8418" name="a57e3a94192f742df330bf1d46fba8418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e3a94192f742df330bf1d46fba8418">&#9670;&#160;</a></span>_filter_indexer_tolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._filter_indexer_tolerance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.intp]&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4179</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 4180</span> </div>
<div class="line"><span class="lineno"> 4181</span>        distance = self._difference_compat(target, indexer)</div>
<div class="line"><span class="lineno"> 4182</span> </div>
<div class="line"><span class="lineno"> 4183</span>        <span class="keywordflow">return</span> np.where(distance &lt;= tolerance, indexer, -1)</div>
<div class="line"><span class="lineno"> 4184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a364a8c33aceb3ffefb8f03d5bbcbb2f4" name="a364a8c33aceb3ffefb8f03d5bbcbb2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364a8c33aceb3ffefb8f03d5bbcbb2f4">&#9670;&#160;</a></span>_find_common_type_compat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.indexes.base.Index._find_common_type_compat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Implementation of find_common_type that adjusts for Index-specific
special cases.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6295</span>    <span class="keyword">def </span>_find_common_type_compat(self, target) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno"> 6296</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6297</span><span class="stringliteral">        Implementation of find_common_type that adjusts for Index-specific</span></div>
<div class="line"><span class="lineno"> 6298</span><span class="stringliteral">        special cases.</span></div>
<div class="line"><span class="lineno"> 6299</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6300</span>        <span class="keywordflow">if</span> is_valid_na_for_dtype(target, self.dtype):</div>
<div class="line"><span class="lineno"> 6301</span>            <span class="comment"># e.g. setting NA value into IntervalArray[int64]</span></div>
<div class="line"><span class="lineno"> 6302</span>            dtype = ensure_dtype_can_hold_na(self.dtype)</div>
<div class="line"><span class="lineno"> 6303</span>            <span class="keywordflow">if</span> is_dtype_equal(self.dtype, dtype):</div>
<div class="line"><span class="lineno"> 6304</span>                <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 6305</span>                    <span class="stringliteral">&quot;This should not be reached. Please report a bug at &quot;</span></div>
<div class="line"><span class="lineno"> 6306</span>                    <span class="stringliteral">&quot;github.com/pandas-dev/pandas&quot;</span></div>
<div class="line"><span class="lineno"> 6307</span>                )</div>
<div class="line"><span class="lineno"> 6308</span>            <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno"> 6309</span> </div>
<div class="line"><span class="lineno"> 6310</span>        target_dtype, _ = infer_dtype_from(target, pandas_dtype=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 6311</span> </div>
<div class="line"><span class="lineno"> 6312</span>        <span class="comment"># special case: if one dtype is uint64 and the other a signed int, return object</span></div>
<div class="line"><span class="lineno"> 6313</span>        <span class="comment"># See https://github.com/pandas-dev/pandas/issues/26778 for discussion</span></div>
<div class="line"><span class="lineno"> 6314</span>        <span class="comment"># Now it&#39;s:</span></div>
<div class="line"><span class="lineno"> 6315</span>        <span class="comment"># * float | [u]int -&gt; float</span></div>
<div class="line"><span class="lineno"> 6316</span>        <span class="comment"># * uint64 | signed int  -&gt; object</span></div>
<div class="line"><span class="lineno"> 6317</span>        <span class="comment"># We may change union(float | [u]int) to go to object.</span></div>
<div class="line"><span class="lineno"> 6318</span>        <span class="keywordflow">if</span> self.dtype == <span class="stringliteral">&quot;uint64&quot;</span> <span class="keywordflow">or</span> target_dtype == <span class="stringliteral">&quot;uint64&quot;</span>:</div>
<div class="line"><span class="lineno"> 6319</span>            <span class="keywordflow">if</span> is_signed_integer_dtype(self.dtype) <span class="keywordflow">or</span> is_signed_integer_dtype(</div>
<div class="line"><span class="lineno"> 6320</span>                target_dtype</div>
<div class="line"><span class="lineno"> 6321</span>            ):</div>
<div class="line"><span class="lineno"> 6322</span>                <span class="keywordflow">return</span> _dtype_obj</div>
<div class="line"><span class="lineno"> 6323</span> </div>
<div class="line"><span class="lineno"> 6324</span>        dtype = find_common_type([self.dtype, target_dtype])</div>
<div class="line"><span class="lineno"> 6325</span>        dtype = common_dtype_categorical_compat([self, target], dtype)</div>
<div class="line"><span class="lineno"> 6326</span>        <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno"> 6327</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acca193f3f8c77e60f4ef1058b73e4723" name="acca193f3f8c77e60f4ef1058b73e4723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca193f3f8c77e60f4ef1058b73e4723">&#9670;&#160;</a></span>_format_attrs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[tuple[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>, <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> | int | bool | None]] pandas.core.indexes.base.Index._format_attrs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a list of tuples of the (attr,formatted_value).
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#ae22299661f9b17d1439a3d301f6fe9a3">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a34781a728d23a3c3cd1862f0ffda72b7">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#abb8a7150791ff6121a46f15d6dfabefd">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1406</span>    <span class="keyword">def </span>_format_attrs(self) -&gt; list[tuple[str_t, str_t | int | bool | None]]:</div>
<div class="line"><span class="lineno"> 1407</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1408</span><span class="stringliteral">        Return a list of tuples of the (attr,formatted_value).</span></div>
<div class="line"><span class="lineno"> 1409</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1410</span>        attrs: list[tuple[str_t, str_t | int | bool | <span class="keywordtype">None</span>]] = []</div>
<div class="line"><span class="lineno"> 1411</span> </div>
<div class="line"><span class="lineno"> 1412</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 1413</span>            attrs.append((<span class="stringliteral">&quot;dtype&quot;</span>, f<span class="stringliteral">&quot;&#39;{self.dtype}&#39;&quot;</span>))</div>
<div class="line"><span class="lineno"> 1414</span> </div>
<div class="line"><span class="lineno"> 1415</span>        <span class="keywordflow">if</span> self.name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1416</span>            attrs.append((<span class="stringliteral">&quot;name&quot;</span>, default_pprint(self.name)))</div>
<div class="line"><span class="lineno"> 1417</span>        <span class="keywordflow">elif</span> self._is_multi <span class="keywordflow">and</span> any(x <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self.names):</div>
<div class="line"><span class="lineno"> 1418</span>            attrs.append((<span class="stringliteral">&quot;names&quot;</span>, default_pprint(self.names)))</div>
<div class="line"><span class="lineno"> 1419</span> </div>
<div class="line"><span class="lineno"> 1420</span>        max_seq_items = get_option(<span class="stringliteral">&quot;display.max_seq_items&quot;</span>) <span class="keywordflow">or</span> len(self)</div>
<div class="line"><span class="lineno"> 1421</span>        <span class="keywordflow">if</span> len(self) &gt; max_seq_items:</div>
<div class="line"><span class="lineno"> 1422</span>            attrs.append((<span class="stringliteral">&quot;length&quot;</span>, len(self)))</div>
<div class="line"><span class="lineno"> 1423</span>        <span class="keywordflow">return</span> attrs</div>
<div class="line"><span class="lineno"> 1424</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc15063a8e586643bcaa63067f2c73b6" name="acc15063a8e586643bcaa63067f2c73b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc15063a8e586643bcaa63067f2c73b6">&#9670;&#160;</a></span>_format_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> pandas.core.indexes.base.Index._format_data </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the formatted data as a unicode string.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a6341ad70217fe5413b6d582ba2bad367">pandas.core.indexes.interval.IntervalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ad24707f54749d0228163e712fd669ccc">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1384</span>    <span class="keyword">def </span>_format_data(self, name=None) -&gt; str_t:</div>
<div class="line"><span class="lineno"> 1385</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1386</span><span class="stringliteral">        Return the formatted data as a unicode string.</span></div>
<div class="line"><span class="lineno"> 1387</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1388</span>        <span class="comment"># do we want to justify (only do so for non-objects)</span></div>
<div class="line"><span class="lineno"> 1389</span>        is_justify = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 1390</span> </div>
<div class="line"><span class="lineno"> 1391</span>        <span class="keywordflow">if</span> self.inferred_type == <span class="stringliteral">&quot;string&quot;</span>:</div>
<div class="line"><span class="lineno"> 1392</span>            is_justify = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1393</span>        <span class="keywordflow">elif</span> self.inferred_type == <span class="stringliteral">&quot;categorical&quot;</span>:</div>
<div class="line"><span class="lineno"> 1394</span>            self = cast(<span class="stringliteral">&quot;CategoricalIndex&quot;</span>, self)</div>
<div class="line"><span class="lineno"> 1395</span>            <span class="keywordflow">if</span> is_object_dtype(self.categories):</div>
<div class="line"><span class="lineno"> 1396</span>                is_justify = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1397</span> </div>
<div class="line"><span class="lineno"> 1398</span>        <span class="keywordflow">return</span> format_object_summary(</div>
<div class="line"><span class="lineno"> 1399</span>            self,</div>
<div class="line"><span class="lineno"> 1400</span>            self._formatter_func,</div>
<div class="line"><span class="lineno"> 1401</span>            is_justify=is_justify,</div>
<div class="line"><span class="lineno"> 1402</span>            name=name,</div>
<div class="line"><span class="lineno"> 1403</span>            line_break_each_value=self._is_multi,</div>
<div class="line"><span class="lineno"> 1404</span>        )</div>
<div class="line"><span class="lineno"> 1405</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a629955f0f921bb0239bb27cfde0fed0c" name="a629955f0f921bb0239bb27cfde0fed0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629955f0f921bb0239bb27cfde0fed0c">&#9670;&#160;</a></span>_format_duplicate_message()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.indexes.base.Index._format_duplicate_message </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct the DataFrame for a DuplicateLabelError.

This returns a DataFrame indicating the labels and positions
of duplicates in an index. This should only be called when it's
already known that duplicates are present.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['a', 'b', 'a'])
&gt;&gt;&gt; idx._format_duplicate_message()
    positions
label
a        [0, 2]
</pre> <div class="fragment"><div class="line"><span class="lineno">  755</span>    <span class="keyword">def </span>_format_duplicate_message(self) -&gt; DataFrame:</div>
<div class="line"><span class="lineno">  756</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  757</span><span class="stringliteral">        Construct the DataFrame for a DuplicateLabelError.</span></div>
<div class="line"><span class="lineno">  758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  759</span><span class="stringliteral">        This returns a DataFrame indicating the labels and positions</span></div>
<div class="line"><span class="lineno">  760</span><span class="stringliteral">        of duplicates in an index. This should only be called when it&#39;s</span></div>
<div class="line"><span class="lineno">  761</span><span class="stringliteral">        already known that duplicates are present.</span></div>
<div class="line"><span class="lineno">  762</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  763</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno">  764</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  765</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;a&#39;])</span></div>
<div class="line"><span class="lineno">  766</span><span class="stringliteral">        &gt;&gt;&gt; idx._format_duplicate_message()</span></div>
<div class="line"><span class="lineno">  767</span><span class="stringliteral">            positions</span></div>
<div class="line"><span class="lineno">  768</span><span class="stringliteral">        label</span></div>
<div class="line"><span class="lineno">  769</span><span class="stringliteral">        a        [0, 2]</span></div>
<div class="line"><span class="lineno">  770</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  771</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno">  772</span> </div>
<div class="line"><span class="lineno">  773</span>        duplicates = self[self.duplicated(keep=<span class="stringliteral">&quot;first&quot;</span>)].unique()</div>
<div class="line"><span class="lineno">  774</span>        <span class="keyword">assert</span> len(duplicates)</div>
<div class="line"><span class="lineno">  775</span> </div>
<div class="line"><span class="lineno">  776</span>        out = Series(np.arange(len(self))).groupby(self).agg(list)[duplicates]</div>
<div class="line"><span class="lineno">  777</span>        <span class="keywordflow">if</span> self._is_multi:</div>
<div class="line"><span class="lineno">  778</span>            <span class="comment"># test_format_duplicate_labels_message_multi</span></div>
<div class="line"><span class="lineno">  779</span>            <span class="comment"># error: &quot;Type[Index]&quot; has no attribute &quot;from_tuples&quot;  [attr-defined]</span></div>
<div class="line"><span class="lineno">  780</span>            out.index = type(self).from_tuples(out.index)  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno">  781</span> </div>
<div class="line"><span class="lineno">  782</span>        <span class="keywordflow">if</span> self.nlevels == 1:</div>
<div class="line"><span class="lineno">  783</span>            out = out.rename_axis(<span class="stringliteral">&quot;label&quot;</span>)</div>
<div class="line"><span class="lineno">  784</span>        <span class="keywordflow">return</span> out.to_frame(name=<span class="stringliteral">&quot;positions&quot;</span>)</div>
<div class="line"><span class="lineno">  785</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a68fb228b5af28fdd5e72c75f449fa76e" name="a68fb228b5af28fdd5e72c75f449fa76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68fb228b5af28fdd5e72c75f449fa76e">&#9670;&#160;</a></span>_format_native_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.object_] pandas.core.indexes.base.Index._format_native_types </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>na_rep</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>quoting</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Actually format specific types of the index.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#a3068c7661cba548b1ac0ce4248a3fee6">pandas.core.indexes.numeric.NumericIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ab033dc2fc60f392385274df900ec7c84">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a42d63bd46a2651ce70ef87e45f7fd306">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1528</span>    ) -&gt; npt.NDArray[np.object_]:</div>
<div class="line"><span class="lineno"> 1529</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1530</span><span class="stringliteral">        Actually format specific types of the index.</span></div>
<div class="line"><span class="lineno"> 1531</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1532</span>        mask = isna(self)</div>
<div class="line"><span class="lineno"> 1533</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.is_object() <span class="keywordflow">and</span> <span class="keywordflow">not</span> quoting:</div>
<div class="line"><span class="lineno"> 1534</span>            values = np.asarray(self).astype(str)</div>
<div class="line"><span class="lineno"> 1535</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1536</span>            values = np.array(self, dtype=object, copy=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1537</span> </div>
<div class="line"><span class="lineno"> 1538</span>        values[mask] = na_rep</div>
<div class="line"><span class="lineno"> 1539</span>        <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 1540</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4233dfd966c60ca04fc4c81615f1ef5" name="ac4233dfd966c60ca04fc4c81615f1ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4233dfd966c60ca04fc4c81615f1ef5">&#9670;&#160;</a></span>_format_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> pandas.core.indexes.base.Index._format_space </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1367</span>    <span class="keyword">def </span>_format_space(self) -&gt; str_t:</div>
<div class="line"><span class="lineno"> 1368</span> </div>
<div class="line"><span class="lineno"> 1369</span>        <span class="comment"># using space here controls if the attributes</span></div>
<div class="line"><span class="lineno"> 1370</span>        <span class="comment"># are line separated or not (the default)</span></div>
<div class="line"><span class="lineno"> 1371</span> </div>
<div class="line"><span class="lineno"> 1372</span>        <span class="comment"># max_seq_items = get_option(&#39;display.max_seq_items&#39;)</span></div>
<div class="line"><span class="lineno"> 1373</span>        <span class="comment"># if len(self) &gt; max_seq_items:</span></div>
<div class="line"><span class="lineno"> 1374</span>        <span class="comment">#    space = &quot;\n%s&quot; % (&#39; &#39; * (len(klass) + 1))</span></div>
<div class="line"><span class="lineno"> 1375</span>        <span class="keywordflow">return</span> <span class="stringliteral">&quot; &quot;</span></div>
<div class="line"><span class="lineno"> 1376</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a01addbe09d0e78da36c825968c819c44" name="a01addbe09d0e78da36c825968c819c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01addbe09d0e78da36c825968c819c44">&#9670;&#160;</a></span>_format_with_header()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>] pandas.core.indexes.base.Index._format_with_header </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>]&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>na_rep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a1fc2b97ef31a34efe99c8a7cdcbbceae">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#ad9750cae6acb55d34e22f90b23bf27ec">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a5182a46caf96f52822cdef91b4eb462d">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a22e9877af79efa75c0c49baf097ccf3b">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1466</span>    <span class="keyword">def </span>_format_with_header(self, header: list[str_t], na_rep: str_t) -&gt; list[str_t]:</div>
<div class="line"><span class="lineno"> 1467</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1io_1_1formats_1_1format.html">pandas.io.formats.format</a> <span class="keyword">import</span> format_array</div>
<div class="line"><span class="lineno"> 1468</span> </div>
<div class="line"><span class="lineno"> 1469</span>        values = self._values</div>
<div class="line"><span class="lineno"> 1470</span> </div>
<div class="line"><span class="lineno"> 1471</span>        <span class="keywordflow">if</span> is_object_dtype(values.dtype):</div>
<div class="line"><span class="lineno"> 1472</span>            values = cast(np.ndarray, values)</div>
<div class="line"><span class="lineno"> 1473</span>            values = lib.maybe_convert_objects(values, safe=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 1474</span> </div>
<div class="line"><span class="lineno"> 1475</span>            result = [pprint_thing(x, escape_chars=(<span class="stringliteral">&quot;\t&quot;</span>, <span class="stringliteral">&quot;\r&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>)) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> values]</div>
<div class="line"><span class="lineno"> 1476</span> </div>
<div class="line"><span class="lineno"> 1477</span>            <span class="comment"># could have nans</span></div>
<div class="line"><span class="lineno"> 1478</span>            mask = is_float_nan(values)</div>
<div class="line"><span class="lineno"> 1479</span>            <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno"> 1480</span>                result_arr = np.array(result)</div>
<div class="line"><span class="lineno"> 1481</span>                result_arr[mask] = na_rep</div>
<div class="line"><span class="lineno"> 1482</span>                result = result_arr.tolist()</div>
<div class="line"><span class="lineno"> 1483</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1484</span>            result = trim_front(format_array(values, <span class="keywordtype">None</span>, justify=<span class="stringliteral">&quot;left&quot;</span>))</div>
<div class="line"><span class="lineno"> 1485</span>        <span class="keywordflow">return</span> header + result</div>
<div class="line"><span class="lineno"> 1486</span> </div>
<div class="ttc" id="anamespacepandas_1_1io_1_1formats_1_1format_html"><div class="ttname"><a href="namespacepandas_1_1io_1_1formats_1_1format.html">pandas.io.formats.format</a></div><div class="ttdef"><b>Definition</b> format.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a202b25124939f709f533e3868ee62063" name="a202b25124939f709f533e3868ee62063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a202b25124939f709f533e3868ee62063">&#9670;&#160;</a></span>_formatter_func()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._formatter_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the formatter function.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a36426ed27802c26f3fe206e2702ef76e">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a76dd114b63b041224c6c9effbeaa2fbd">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a89af4f9c3042537ffa4298ba54c29e2c">pandas.core.indexes.datetimes.DatetimeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a2ee40da4871fdc4cc1ce1bb6309331a1">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1378</span>    <span class="keyword">def </span>_formatter_func(self):</div>
<div class="line"><span class="lineno"> 1379</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1380</span><span class="stringliteral">        Return the formatter function.</span></div>
<div class="line"><span class="lineno"> 1381</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1382</span>        <span class="keywordflow">return</span> default_pprint</div>
<div class="line"><span class="lineno"> 1383</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4370524ecf6a1869e8c1148c3c2c5267" name="a4370524ecf6a1869e8c1148c3c2c5267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4370524ecf6a1869e8c1148c3c2c5267">&#9670;&#160;</a></span>_from_join_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.indexes.base.Index._from_join_target </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Cast the ndarray returned from one of the libjoin.foo_indexer functions
back to type(self)._data.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a878e94845debb486077cfac38b9dcdbf">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1extension_1_1_n_d_array_backed_extension_index.html#acb151689021ce9d2a8d2fe06de93b6ee">pandas.core.indexes.extension.NDArrayBackedExtensionIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a395c689e3c6c1895adfc3cc7ea387f26">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5173</span>    <span class="keyword">def </span>_from_join_target(self, result: np.ndarray) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 5174</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5175</span><span class="stringliteral">        Cast the ndarray returned from one of the libjoin.foo_indexer functions</span></div>
<div class="line"><span class="lineno"> 5176</span><span class="stringliteral">        back to type(self)._data.</span></div>
<div class="line"><span class="lineno"> 5177</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5178</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 5179</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9eca673aa878c46872d0002cf4611961" name="a9eca673aa878c46872d0002cf4611961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eca673aa878c46872d0002cf4611961">&#9670;&#160;</a></span>_get_attributes_dict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> dict[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>, Any] pandas.core.indexes.base.Index._get_attributes_dict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return an attributes dict for my class.

Temporarily added back for compatibility issue in dask, see
https://github.com/pandas-dev/pandas/pull/43895
</pre> <div class="fragment"><div class="line"><span class="lineno">  790</span>    <span class="keyword">def </span>_get_attributes_dict(self) -&gt; dict[str_t, Any]:</div>
<div class="line"><span class="lineno">  791</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  792</span><span class="stringliteral">        Return an attributes dict for my class.</span></div>
<div class="line"><span class="lineno">  793</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  794</span><span class="stringliteral">        Temporarily added back for compatibility issue in dask, see</span></div>
<div class="line"><span class="lineno">  795</span><span class="stringliteral">        https://github.com/pandas-dev/pandas/pull/43895</span></div>
<div class="line"><span class="lineno">  796</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  797</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  798</span>            <span class="stringliteral">&quot;The Index._get_attributes_dict method is deprecated, and will be &quot;</span></div>
<div class="line"><span class="lineno">  799</span>            <span class="stringliteral">&quot;removed in a future version&quot;</span>,</div>
<div class="line"><span class="lineno">  800</span>            DeprecationWarning,</div>
<div class="line"><span class="lineno">  801</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  802</span>        )</div>
<div class="line"><span class="lineno">  803</span>        <span class="keywordflow">return</span> {k: getattr(self, k, <span class="keywordtype">None</span>) <span class="keywordflow">for</span> k <span class="keywordflow">in</span> self._attributes}</div>
<div class="line"><span class="lineno">  804</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f5998822b15a152247780496b590ca3" name="a8f5998822b15a152247780496b590ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5998822b15a152247780496b590ca3">&#9670;&#160;</a></span>_get_default_index_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[Hashable] pandas.core.indexes.base.Index._get_default_index_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | Sequence[Hashable] | None &#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>default</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get names of index.

Parameters
----------
names : int, str or 1-dimensional list, default None
    Index names to set.
default : str
    Default name of index.

Raises
------
TypeError
    if names not str or list-like
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1788</span>    ) -&gt; list[Hashable]:</div>
<div class="line"><span class="lineno"> 1789</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1790</span><span class="stringliteral">        Get names of index.</span></div>
<div class="line"><span class="lineno"> 1791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1792</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1793</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1794</span><span class="stringliteral">        names : int, str or 1-dimensional list, default None</span></div>
<div class="line"><span class="lineno"> 1795</span><span class="stringliteral">            Index names to set.</span></div>
<div class="line"><span class="lineno"> 1796</span><span class="stringliteral">        default : str</span></div>
<div class="line"><span class="lineno"> 1797</span><span class="stringliteral">            Default name of index.</span></div>
<div class="line"><span class="lineno"> 1798</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1799</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 1800</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 1801</span><span class="stringliteral">        TypeError</span></div>
<div class="line"><span class="lineno"> 1802</span><span class="stringliteral">            if names not str or list-like</span></div>
<div class="line"><span class="lineno"> 1803</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1804</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 1805</span> </div>
<div class="line"><span class="lineno"> 1806</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1807</span>            <span class="keywordflow">if</span> isinstance(names, str) <span class="keywordflow">or</span> isinstance(names, int):</div>
<div class="line"><span class="lineno"> 1808</span>                names = [names]</div>
<div class="line"><span class="lineno"> 1809</span> </div>
<div class="line"><span class="lineno"> 1810</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(names, list) <span class="keywordflow">and</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1811</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Index names must be str or 1-dimensional list&quot;</span>)</div>
<div class="line"><span class="lineno"> 1812</span> </div>
<div class="line"><span class="lineno"> 1813</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> names:</div>
<div class="line"><span class="lineno"> 1814</span>            <span class="keywordflow">if</span> isinstance(self, MultiIndex):</div>
<div class="line"><span class="lineno"> 1815</span>                names = com.fill_missing_names(self.names)</div>
<div class="line"><span class="lineno"> 1816</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1817</span>                names = [default] <span class="keywordflow">if</span> self.name <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> [self.name]</div>
<div class="line"><span class="lineno"> 1818</span> </div>
<div class="line"><span class="lineno"> 1819</span>        <span class="keywordflow">return</span> names</div>
<div class="line"><span class="lineno"> 1820</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a50097696e9d23abe7c8616a2530c38a5" name="a50097696e9d23abe7c8616a2530c38a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50097696e9d23abe7c8616a2530c38a5">&#9670;&#160;</a></span>_get_engine_target()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.indexes.base.Index._get_engine_target </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the ndarray or ExtensionArray that we can pass to the IndexEngine
constructor.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a5a726d6393817ec92ba219ba1439f850">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1extension_1_1_n_d_array_backed_extension_index.html#adabdb07f1587ece7d266f31e0e5d712e">pandas.core.indexes.extension.NDArrayBackedExtensionIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a65604ffa90ad2b262648b35c8b25ef8b">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5159</span>    <span class="keyword">def </span>_get_engine_target(self) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 5160</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5161</span><span class="stringliteral">        Get the ndarray or ExtensionArray that we can pass to the IndexEngine</span></div>
<div class="line"><span class="lineno"> 5162</span><span class="stringliteral">        constructor.</span></div>
<div class="line"><span class="lineno"> 5163</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5164</span>        vals = self._values</div>
<div class="line"><span class="lineno"> 5165</span>        <span class="keywordflow">if</span> isinstance(vals, StringArray):</div>
<div class="line"><span class="lineno"> 5166</span>            <span class="comment"># GH#45652 much more performant than ExtensionEngine</span></div>
<div class="line"><span class="lineno"> 5167</span>            <span class="keywordflow">return</span> vals._ndarray</div>
<div class="line"><span class="lineno"> 5168</span>        <span class="keywordflow">if</span> type(self) <span class="keywordflow">is</span> Index <span class="keywordflow">and</span> isinstance(self._values, ExtensionArray):</div>
<div class="line"><span class="lineno"> 5169</span>            <span class="comment"># TODO(ExtensionIndex): remove special-case, just use self._values</span></div>
<div class="line"><span class="lineno"> 5170</span>            <span class="keywordflow">return</span> self._values.astype(object)</div>
<div class="line"><span class="lineno"> 5171</span>        <span class="keywordflow">return</span> vals</div>
<div class="line"><span class="lineno"> 5172</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab1679fd8983b7bc7a29ddaf44589c31b" name="ab1679fd8983b7bc7a29ddaf44589c31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1679fd8983b7bc7a29ddaf44589c31b">&#9670;&#160;</a></span>_get_fill_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._get_fill_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4077</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 4078</span> </div>
<div class="line"><span class="lineno"> 4079</span>        <span class="keywordflow">if</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 4080</span>            <span class="comment"># TODO: get_indexer_with_fill docstring says values must be _sorted_</span></div>
<div class="line"><span class="lineno"> 4081</span>            <span class="comment">#  but that doesn&#39;t appear to be enforced</span></div>
<div class="line"><span class="lineno"> 4082</span>            <span class="comment"># error: &quot;IndexEngine&quot; has no attribute &quot;get_indexer_with_fill&quot;</span></div>
<div class="line"><span class="lineno"> 4083</span>            engine = self._engine</div>
<div class="line"><span class="lineno"> 4084</span>            <span class="keywordflow">return</span> engine.get_indexer_with_fill(  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 4085</span>                target=target._values, values=self._values, method=method, limit=limit</div>
<div class="line"><span class="lineno"> 4086</span>            )</div>
<div class="line"><span class="lineno"> 4087</span> </div>
<div class="line"><span class="lineno"> 4088</span>        <span class="keywordflow">if</span> self.is_monotonic_increasing <span class="keywordflow">and</span> target.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 4089</span>            target_values = target._get_engine_target()</div>
<div class="line"><span class="lineno"> 4090</span>            own_values = self._get_engine_target()</div>
<div class="line"><span class="lineno"> 4091</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(target_values, np.ndarray) <span class="keywordflow">or</span> <span class="keywordflow">not</span> isinstance(</div>
<div class="line"><span class="lineno"> 4092</span>                own_values, np.ndarray</div>
<div class="line"><span class="lineno"> 4093</span>            ):</div>
<div class="line"><span class="lineno"> 4094</span>                <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno"> 4095</span> </div>
<div class="line"><span class="lineno"> 4096</span>            <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;pad&quot;</span>:</div>
<div class="line"><span class="lineno"> 4097</span>                indexer = libalgos.pad(own_values, target_values, limit=limit)</div>
<div class="line"><span class="lineno"> 4098</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4099</span>                <span class="comment"># i.e. &quot;backfill&quot;</span></div>
<div class="line"><span class="lineno"> 4100</span>                indexer = libalgos.backfill(own_values, target_values, limit=limit)</div>
<div class="line"><span class="lineno"> 4101</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4102</span>            indexer = self._get_fill_indexer_searchsorted(target, method, limit)</div>
<div class="line"><span class="lineno"> 4103</span>        <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> len(self):</div>
<div class="line"><span class="lineno"> 4104</span>            indexer = self._filter_indexer_tolerance(target, indexer, tolerance)</div>
<div class="line"><span class="lineno"> 4105</span>        <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 4106</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab43628cb90529c4f4cb0deef3c106efd" name="ab43628cb90529c4f4cb0deef3c106efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43628cb90529c4f4cb0deef3c106efd">&#9670;&#160;</a></span>_get_fill_indexer_searchsorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._get_fill_indexer_searchsorted </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fallback pad/backfill get_indexer that works for monotonic decreasing
indexes and non-monotonic targets.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4110</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 4111</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4112</span><span class="stringliteral">        Fallback pad/backfill get_indexer that works for monotonic decreasing</span></div>
<div class="line"><span class="lineno"> 4113</span><span class="stringliteral">        indexes and non-monotonic targets.</span></div>
<div class="line"><span class="lineno"> 4114</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4115</span>        <span class="keywordflow">if</span> limit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4116</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 4117</span>                f<span class="stringliteral">&quot;limit argument for {repr(method)} method only well-defined &quot;</span></div>
<div class="line"><span class="lineno"> 4118</span>                <span class="stringliteral">&quot;if index and target are monotonic&quot;</span></div>
<div class="line"><span class="lineno"> 4119</span>            )</div>
<div class="line"><span class="lineno"> 4120</span> </div>
<div class="line"><span class="lineno"> 4121</span>        side: Literal[<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>] = <span class="stringliteral">&quot;left&quot;</span> <span class="keywordflow">if</span> method == <span class="stringliteral">&quot;pad&quot;</span> <span class="keywordflow">else</span> <span class="stringliteral">&quot;right&quot;</span></div>
<div class="line"><span class="lineno"> 4122</span> </div>
<div class="line"><span class="lineno"> 4123</span>        <span class="comment"># find exact matches first (this simplifies the algorithm)</span></div>
<div class="line"><span class="lineno"> 4124</span>        indexer = self.get_indexer(target)</div>
<div class="line"><span class="lineno"> 4125</span>        nonexact = indexer == -1</div>
<div class="line"><span class="lineno"> 4126</span>        indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)</div>
<div class="line"><span class="lineno"> 4127</span>        <span class="keywordflow">if</span> side == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 4128</span>            <span class="comment"># searchsorted returns &quot;indices into a sorted array such that,</span></div>
<div class="line"><span class="lineno"> 4129</span>            <span class="comment"># if the corresponding elements in v were inserted before the</span></div>
<div class="line"><span class="lineno"> 4130</span>            <span class="comment"># indices, the order of a would be preserved&quot;.</span></div>
<div class="line"><span class="lineno"> 4131</span>            <span class="comment"># Thus, we need to subtract 1 to find values to the left.</span></div>
<div class="line"><span class="lineno"> 4132</span>            indexer[nonexact] -= 1</div>
<div class="line"><span class="lineno"> 4133</span>            <span class="comment"># This also mapped not found values (values of 0 from</span></div>
<div class="line"><span class="lineno"> 4134</span>            <span class="comment"># np.searchsorted) to -1, which conveniently is also our</span></div>
<div class="line"><span class="lineno"> 4135</span>            <span class="comment"># sentinel for missing values</span></div>
<div class="line"><span class="lineno"> 4136</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4137</span>            <span class="comment"># Mark indices to the right of the largest value as not found</span></div>
<div class="line"><span class="lineno"> 4138</span>            indexer[indexer == len(self)] = -1</div>
<div class="line"><span class="lineno"> 4139</span>        <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 4140</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aee45df7b7191adb95d620b3019e3c4c2" name="aee45df7b7191adb95d620b3019e3c4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee45df7b7191adb95d620b3019e3c4c2">&#9670;&#160;</a></span>_get_grouper_for_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.signedinteger] | None, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | None] pandas.core.indexes.base.Index._get_grouper_for_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>dropna</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get index grouper corresponding to an index level

Parameters
----------
mapper: Group mapping function or None
    Function mapping index values to groups
level : int or None
    Index level, positional
dropna : bool
    dropna from groupby

Returns
-------
grouper : Index
    Index of values to group on.
labels : ndarray of int or None
    Array of locations in level_index.
uniques : Index or None
    Index of unique values for level.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a3b4ed22acededf76f80557540b5ad74a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2249</span>    ) -&gt; tuple[Index, npt.NDArray[np.signedinteger] | <span class="keywordtype">None</span>, Index | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 2250</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2251</span><span class="stringliteral">        Get index grouper corresponding to an index level</span></div>
<div class="line"><span class="lineno"> 2252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2253</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2254</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2255</span><span class="stringliteral">        mapper: Group mapping function or None</span></div>
<div class="line"><span class="lineno"> 2256</span><span class="stringliteral">            Function mapping index values to groups</span></div>
<div class="line"><span class="lineno"> 2257</span><span class="stringliteral">        level : int or None</span></div>
<div class="line"><span class="lineno"> 2258</span><span class="stringliteral">            Index level, positional</span></div>
<div class="line"><span class="lineno"> 2259</span><span class="stringliteral">        dropna : bool</span></div>
<div class="line"><span class="lineno"> 2260</span><span class="stringliteral">            dropna from groupby</span></div>
<div class="line"><span class="lineno"> 2261</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2262</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2263</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2264</span><span class="stringliteral">        grouper : Index</span></div>
<div class="line"><span class="lineno"> 2265</span><span class="stringliteral">            Index of values to group on.</span></div>
<div class="line"><span class="lineno"> 2266</span><span class="stringliteral">        labels : ndarray of int or None</span></div>
<div class="line"><span class="lineno"> 2267</span><span class="stringliteral">            Array of locations in level_index.</span></div>
<div class="line"><span class="lineno"> 2268</span><span class="stringliteral">        uniques : Index or None</span></div>
<div class="line"><span class="lineno"> 2269</span><span class="stringliteral">            Index of unique values for level.</span></div>
<div class="line"><span class="lineno"> 2270</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2271</span>        <span class="keyword">assert</span> level <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> level == 0</div>
<div class="line"><span class="lineno"> 2272</span>        <span class="keywordflow">if</span> mapper <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2273</span>            grouper = self</div>
<div class="line"><span class="lineno"> 2274</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2275</span>            grouper = self.map(mapper)</div>
<div class="line"><span class="lineno"> 2276</span> </div>
<div class="line"><span class="lineno"> 2277</span>        <span class="keywordflow">return</span> grouper, <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 2278</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a671476cb3d6481c661b74083146acf82" name="a671476cb3d6481c661b74083146acf82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a671476cb3d6481c661b74083146acf82">&#9670;&#160;</a></span>_get_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._get_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> | None &#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a1d09dfb9305a3a9426bc37def979b65e">pandas.core.indexes.interval.IntervalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ad712c12e8c6ccd03f5d2a8b775bc8752">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3982</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 3983</span>        <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3984</span>            tolerance = self._convert_tolerance(tolerance, target)</div>
<div class="line"><span class="lineno"> 3985</span> </div>
<div class="line"><span class="lineno"> 3986</span>        <span class="keywordflow">if</span> method <span class="keywordflow">in</span> [<span class="stringliteral">&quot;pad&quot;</span>, <span class="stringliteral">&quot;backfill&quot;</span>]:</div>
<div class="line"><span class="lineno"> 3987</span>            indexer = self._get_fill_indexer(target, method, limit, tolerance)</div>
<div class="line"><span class="lineno"> 3988</span>        <span class="keywordflow">elif</span> method == <span class="stringliteral">&quot;nearest&quot;</span>:</div>
<div class="line"><span class="lineno"> 3989</span>            indexer = self._get_nearest_indexer(target, limit, tolerance)</div>
<div class="line"><span class="lineno"> 3990</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3991</span>            <span class="keywordflow">if</span> target._is_multi <span class="keywordflow">and</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 3992</span>                engine = self._engine</div>
<div class="line"><span class="lineno"> 3993</span>                <span class="comment"># error: Item &quot;IndexEngine&quot; of &quot;Union[IndexEngine, ExtensionEngine]&quot;</span></div>
<div class="line"><span class="lineno"> 3994</span>                <span class="comment"># has no attribute &quot;_extract_level_codes&quot;</span></div>
<div class="line"><span class="lineno"> 3995</span>                tgt_values = engine._extract_level_codes(  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 3996</span>                    target</div>
<div class="line"><span class="lineno"> 3997</span>                )</div>
<div class="line"><span class="lineno"> 3998</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3999</span>                tgt_values = target._get_engine_target()</div>
<div class="line"><span class="lineno"> 4000</span> </div>
<div class="line"><span class="lineno"> 4001</span>            indexer = self._engine.get_indexer(tgt_values)</div>
<div class="line"><span class="lineno"> 4002</span> </div>
<div class="line"><span class="lineno"> 4003</span>        <span class="keywordflow">return</span> ensure_platform_int(indexer)</div>
<div class="line"><span class="lineno"> 4004</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f4605d9c657151f9abe98dbeca90ab4" name="a7f4605d9c657151f9abe98dbeca90ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4605d9c657151f9abe98dbeca90ab4">&#9670;&#160;</a></span>_get_indexer_non_comparable() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] | tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._get_indexer_non_comparable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>unique</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6193</span>    ) -&gt; npt.NDArray[np.intp] | tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 6194</span>        ...</div>
<div class="line"><span class="lineno"> 6195</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7f4605d9c657151f9abe98dbeca90ab4" name="a7f4605d9c657151f9abe98dbeca90ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4605d9c657151f9abe98dbeca90ab4">&#9670;&#160;</a></span>_get_indexer_non_comparable() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] | tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._get_indexer_non_comparable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>unique</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Called from get_indexer or get_indexer_non_unique when the target
is of a non-comparable dtype.

For get_indexer lookups with method=None, get_indexer is an _equality_
check, so non-comparable dtypes mean we will always have no matches.

For get_indexer lookups with a method, get_indexer is an _inequality_
check, so non-comparable dtypes mean we will always raise TypeError.

Parameters
----------
target : Index
method : str or None
unique : bool, default True
    * True if called from get_indexer.
    * False if called from get_indexer_non_unique.

Raises
------
TypeError
    If doing an inequality check, i.e. method is not None.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6199</span>    ) -&gt; npt.NDArray[np.intp] | tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 6200</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6201</span><span class="stringliteral">        Called from get_indexer or get_indexer_non_unique when the target</span></div>
<div class="line"><span class="lineno"> 6202</span><span class="stringliteral">        is of a non-comparable dtype.</span></div>
<div class="line"><span class="lineno"> 6203</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6204</span><span class="stringliteral">        For get_indexer lookups with method=None, get_indexer is an _equality_</span></div>
<div class="line"><span class="lineno"> 6205</span><span class="stringliteral">        check, so non-comparable dtypes mean we will always have no matches.</span></div>
<div class="line"><span class="lineno"> 6206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6207</span><span class="stringliteral">        For get_indexer lookups with a method, get_indexer is an _inequality_</span></div>
<div class="line"><span class="lineno"> 6208</span><span class="stringliteral">        check, so non-comparable dtypes mean we will always raise TypeError.</span></div>
<div class="line"><span class="lineno"> 6209</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6210</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6211</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6212</span><span class="stringliteral">        target : Index</span></div>
<div class="line"><span class="lineno"> 6213</span><span class="stringliteral">        method : str or None</span></div>
<div class="line"><span class="lineno"> 6214</span><span class="stringliteral">        unique : bool, default True</span></div>
<div class="line"><span class="lineno"> 6215</span><span class="stringliteral">            * True if called from get_indexer.</span></div>
<div class="line"><span class="lineno"> 6216</span><span class="stringliteral">            * False if called from get_indexer_non_unique.</span></div>
<div class="line"><span class="lineno"> 6217</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6218</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 6219</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 6220</span><span class="stringliteral">        TypeError</span></div>
<div class="line"><span class="lineno"> 6221</span><span class="stringliteral">            If doing an inequality check, i.e. method is not None.</span></div>
<div class="line"><span class="lineno"> 6222</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6223</span>        <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6224</span>            other = unpack_nested_dtype(target)</div>
<div class="line"><span class="lineno"> 6225</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;Cannot compare dtypes {self.dtype} and {other.dtype}&quot;</span>)</div>
<div class="line"><span class="lineno"> 6226</span> </div>
<div class="line"><span class="lineno"> 6227</span>        no_matches = -1 * np.ones(target.shape, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 6228</span>        <span class="keywordflow">if</span> unique:</div>
<div class="line"><span class="lineno"> 6229</span>            <span class="comment"># This is for get_indexer</span></div>
<div class="line"><span class="lineno"> 6230</span>            <span class="keywordflow">return</span> no_matches</div>
<div class="line"><span class="lineno"> 6231</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6232</span>            <span class="comment"># This is for get_indexer_non_unique</span></div>
<div class="line"><span class="lineno"> 6233</span>            missing = np.arange(len(target), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 6234</span>            <span class="keywordflow">return</span> no_matches, missing</div>
<div class="line"><span class="lineno"> 6235</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1fbb97d7ed4acf3106be322cd8e661e" name="aa1fbb97d7ed4acf3106be322cd8e661e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fbb97d7ed4acf3106be322cd8e661e">&#9670;&#160;</a></span>_get_indexer_non_comparable() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._get_indexer_non_comparable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False]
    &#160;</td>
          <td class="paramname"><em>unique</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6187</span>    ) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 6188</span>        ...</div>
<div class="line"><span class="lineno"> 6189</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a81d18ba4f6805189d3424bb0a95a6e3d" name="a81d18ba4f6805189d3424bb0a95a6e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d18ba4f6805189d3424bb0a95a6e3d">&#9670;&#160;</a></span>_get_indexer_non_comparable() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._get_indexer_non_comparable </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True] &#160;</td>
          <td class="paramname"><em>unique</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 6181</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 6182</span>        ...</div>
<div class="line"><span class="lineno"> 6183</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5074db92a4b78e6de76bd54b873ebacd" name="a5074db92a4b78e6de76bd54b873ebacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074db92a4b78e6de76bd54b873ebacd">&#9670;&#160;</a></span>_get_indexer_strict()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, np.ndarray] pandas.core.indexes.base.Index._get_indexer_strict </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>axis_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Analogue to get_indexer that raises if any elements are missing.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aa2af349f89738ca098813f5954a9e41c">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6099</span>    <span class="keyword">def </span>_get_indexer_strict(self, key, axis_name: str_t) -&gt; tuple[Index, np.ndarray]:</div>
<div class="line"><span class="lineno"> 6100</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6101</span><span class="stringliteral">        Analogue to get_indexer that raises if any elements are missing.</span></div>
<div class="line"><span class="lineno"> 6102</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6103</span>        keyarr = key</div>
<div class="line"><span class="lineno"> 6104</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(keyarr, Index):</div>
<div class="line"><span class="lineno"> 6105</span>            keyarr = com.asarray_tuplesafe(keyarr)</div>
<div class="line"><span class="lineno"> 6106</span> </div>
<div class="line"><span class="lineno"> 6107</span>        <span class="keywordflow">if</span> self._index_as_unique:</div>
<div class="line"><span class="lineno"> 6108</span>            indexer = self.get_indexer_for(keyarr)</div>
<div class="line"><span class="lineno"> 6109</span>            keyarr = self.reindex(keyarr)[0]</div>
<div class="line"><span class="lineno"> 6110</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6111</span>            keyarr, indexer, new_indexer = self._reindex_non_unique(keyarr)</div>
<div class="line"><span class="lineno"> 6112</span> </div>
<div class="line"><span class="lineno"> 6113</span>        self._raise_if_missing(keyarr, indexer, axis_name)</div>
<div class="line"><span class="lineno"> 6114</span> </div>
<div class="line"><span class="lineno"> 6115</span>        keyarr = self.take(indexer)</div>
<div class="line"><span class="lineno"> 6116</span>        <span class="keywordflow">if</span> isinstance(key, Index):</div>
<div class="line"><span class="lineno"> 6117</span>            <span class="comment"># GH 42790 - Preserve name from an Index</span></div>
<div class="line"><span class="lineno"> 6118</span>            keyarr.name = key.name</div>
<div class="line"><span class="lineno"> 6119</span>        <span class="keywordflow">if</span> keyarr.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 6120</span>            <span class="comment"># DTI/TDI.take can infer a freq in some cases when we dont want one</span></div>
<div class="line"><span class="lineno"> 6121</span>            <span class="keywordflow">if</span> isinstance(key, list) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno"> 6122</span>                isinstance(key, type(self))</div>
<div class="line"><span class="lineno"> 6123</span>                <span class="comment"># &quot;Index&quot; has no attribute &quot;freq&quot;</span></div>
<div class="line"><span class="lineno"> 6124</span>                <span class="keywordflow">and</span> key.freq <span class="keywordflow">is</span> <span class="keywordtype">None</span>  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 6125</span>            ):</div>
<div class="line"><span class="lineno"> 6126</span>                keyarr = keyarr._with_freq(<span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 6127</span> </div>
<div class="line"><span class="lineno"> 6128</span>        <span class="keywordflow">return</span> keyarr, indexer</div>
<div class="line"><span class="lineno"> 6129</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aad74a8f24bce4a71581de0183908ac05" name="aad74a8f24bce4a71581de0183908ac05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad74a8f24bce4a71581de0183908ac05">&#9670;&#160;</a></span>_get_level_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Hashable | Sequence[Hashable] pandas.core.indexes.base.Index._get_level_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a name or list of names with None replaced by the level number.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1426</span>    <span class="keyword">def </span>_get_level_names(self) -&gt; Hashable | Sequence[Hashable]:</div>
<div class="line"><span class="lineno"> 1427</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1428</span><span class="stringliteral">        Return a name or list of names with None replaced by the level number.</span></div>
<div class="line"><span class="lineno"> 1429</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1430</span>        <span class="keywordflow">if</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 1431</span>            <span class="keywordflow">return</span> [</div>
<div class="line"><span class="lineno"> 1432</span>                level <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> name <span class="keywordflow">for</span> level, name <span class="keywordflow">in</span> enumerate(self.names)</div>
<div class="line"><span class="lineno"> 1433</span>            ]</div>
<div class="line"><span class="lineno"> 1434</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1435</span>            <span class="keywordflow">return</span> 0 <span class="keywordflow">if</span> self.name <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> self.name</div>
<div class="line"><span class="lineno"> 1436</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa3b018146ec534a533393886c622b03f" name="aa3b018146ec534a533393886c622b03f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b018146ec534a533393886c622b03f">&#9670;&#160;</a></span>_get_level_number()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index._get_level_number </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#adeff5921c5ef454edd2fc07f82695882">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2055</span>    <span class="keyword">def </span>_get_level_number(self, level) -&gt; int:</div>
<div class="line"><span class="lineno"> 2056</span>        self._validate_index_level(level)</div>
<div class="line"><span class="lineno"> 2057</span>        <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno"> 2058</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abd2bf62078de48efb3f4262354d47eb8" name="abd2bf62078de48efb3f4262354d47eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2bf62078de48efb3f4262354d47eb8">&#9670;&#160;</a></span>_get_level_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index._get_level_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return an Index of values for requested level.

This is primarily useful to get an individual level of values from a
MultiIndex, but is provided on Index as well for compatibility.

Parameters
----------
level : int or str
    It is either the integer position or the name of the level.

Returns
-------
Index
    Calling object, as there is only one level in the Index.

See Also
--------
MultiIndex.get_level_values : Get values for a level of a MultiIndex.

Notes
-----
For Index, level should be 0, since there are no multiple levels.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(list('abc'))
&gt;&gt;&gt; idx
Index(['a', 'b', 'c'], dtype='object')

Get level values by supplying `level` as integer:

&gt;&gt;&gt; idx.get_level_values(0)
Index(['a', 'b', 'c'], dtype='object')
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a75a6fc0c6bb74be2eaba0efabc766390">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2092</span>    <span class="keyword">def </span>_get_level_values(self, level) -&gt; Index:</div>
<div class="line"><span class="lineno"> 2093</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2094</span><span class="stringliteral">        Return an Index of values for requested level.</span></div>
<div class="line"><span class="lineno"> 2095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2096</span><span class="stringliteral">        This is primarily useful to get an individual level of values from a</span></div>
<div class="line"><span class="lineno"> 2097</span><span class="stringliteral">        MultiIndex, but is provided on Index as well for compatibility.</span></div>
<div class="line"><span class="lineno"> 2098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2099</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2100</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2101</span><span class="stringliteral">        level : int or str</span></div>
<div class="line"><span class="lineno"> 2102</span><span class="stringliteral">            It is either the integer position or the name of the level.</span></div>
<div class="line"><span class="lineno"> 2103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2104</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2105</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2106</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 2107</span><span class="stringliteral">            Calling object, as there is only one level in the Index.</span></div>
<div class="line"><span class="lineno"> 2108</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2109</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2110</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2111</span><span class="stringliteral">        MultiIndex.get_level_values : Get values for a level of a MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2113</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 2114</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 2115</span><span class="stringliteral">        For Index, level should be 0, since there are no multiple levels.</span></div>
<div class="line"><span class="lineno"> 2116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2117</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2118</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2119</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abc&#39;))</span></div>
<div class="line"><span class="lineno"> 2120</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2121</span><span class="stringliteral">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 2122</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2123</span><span class="stringliteral">        Get level values by supplying `level` as integer:</span></div>
<div class="line"><span class="lineno"> 2124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2125</span><span class="stringliteral">        &gt;&gt;&gt; idx.get_level_values(0)</span></div>
<div class="line"><span class="lineno"> 2126</span><span class="stringliteral">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 2127</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2128</span>        self._validate_index_level(level)</div>
<div class="line"><span class="lineno"> 2129</span>        <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno"> 2130</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af81701ab0c850457a0738bf314235a92" name="af81701ab0c850457a0738bf314235a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81701ab0c850457a0738bf314235a92">&#9670;&#160;</a></span>_get_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1frozen_1_1_frozen_list.html">FrozenList</a> pandas.core.indexes.base.Index._get_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a370c1da49ca8053fd1754fdf736fa6cc">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1821</span>    <span class="keyword">def </span>_get_names(self) -&gt; FrozenList:</div>
<div class="line"><span class="lineno"> 1822</span>        <span class="keywordflow">return</span> FrozenList((self.name,))</div>
<div class="line"><span class="lineno"> 1823</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abc2c573ca77ab831bb9875eaf1e563cb" name="abc2c573ca77ab831bb9875eaf1e563cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2c573ca77ab831bb9875eaf1e563cb">&#9670;&#160;</a></span>_get_nearest_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._get_nearest_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Get the indexer for the nearest index labels; requires an index with
values that can be subtracted from each other (e.g., not strings or
tuples).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4144</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 4145</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4146</span><span class="stringliteral">        Get the indexer for the nearest index labels; requires an index with</span></div>
<div class="line"><span class="lineno"> 4147</span><span class="stringliteral">        values that can be subtracted from each other (e.g., not strings or</span></div>
<div class="line"><span class="lineno"> 4148</span><span class="stringliteral">        tuples).</span></div>
<div class="line"><span class="lineno"> 4149</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4150</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno"> 4151</span>            <span class="keywordflow">return</span> self._get_fill_indexer(target, <span class="stringliteral">&quot;pad&quot;</span>)</div>
<div class="line"><span class="lineno"> 4152</span> </div>
<div class="line"><span class="lineno"> 4153</span>        left_indexer = self.get_indexer(target, <span class="stringliteral">&quot;pad&quot;</span>, limit=limit)</div>
<div class="line"><span class="lineno"> 4154</span>        right_indexer = self.get_indexer(target, <span class="stringliteral">&quot;backfill&quot;</span>, limit=limit)</div>
<div class="line"><span class="lineno"> 4155</span> </div>
<div class="line"><span class="lineno"> 4156</span>        left_distances = self._difference_compat(target, left_indexer)</div>
<div class="line"><span class="lineno"> 4157</span>        right_distances = self._difference_compat(target, right_indexer)</div>
<div class="line"><span class="lineno"> 4158</span> </div>
<div class="line"><span class="lineno"> 4159</span>        op = operator.lt <span class="keywordflow">if</span> self.is_monotonic_increasing <span class="keywordflow">else</span> operator.le</div>
<div class="line"><span class="lineno"> 4160</span>        indexer = np.where(</div>
<div class="line"><span class="lineno"> 4161</span>            <span class="comment"># error: Argument 1&amp;2 has incompatible type &quot;Union[ExtensionArray,</span></div>
<div class="line"><span class="lineno"> 4162</span>            <span class="comment"># ndarray[Any, Any]]&quot;; expected &quot;Union[SupportsDunderLE,</span></div>
<div class="line"><span class="lineno"> 4163</span>            <span class="comment"># SupportsDunderGE, SupportsDunderGT, SupportsDunderLT]&quot;</span></div>
<div class="line"><span class="lineno"> 4164</span>            op(left_distances, right_distances)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 4165</span>            | (right_indexer == -1),</div>
<div class="line"><span class="lineno"> 4166</span>            left_indexer,</div>
<div class="line"><span class="lineno"> 4167</span>            right_indexer,</div>
<div class="line"><span class="lineno"> 4168</span>        )</div>
<div class="line"><span class="lineno"> 4169</span>        <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4170</span>            indexer = self._filter_indexer_tolerance(target, indexer, tolerance)</div>
<div class="line"><span class="lineno"> 4171</span>        <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 4172</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3589059df55a436cad79f92c939fe3e0" name="a3589059df55a436cad79f92c939fe3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3589059df55a436cad79f92c939fe3e0">&#9670;&#160;</a></span>_get_reconciled_name_object()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._get_reconciled_name_object </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If the result of a set operation will be self,
return self, unless the name changes, in which
case make a shallow copy of self.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a95c6af09f911f113852eb6952ba48a45">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3199</span>    <span class="keyword">def </span>_get_reconciled_name_object(self, other):</div>
<div class="line"><span class="lineno"> 3200</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3201</span><span class="stringliteral">        If the result of a set operation will be self,</span></div>
<div class="line"><span class="lineno"> 3202</span><span class="stringliteral">        return self, unless the name changes, in which</span></div>
<div class="line"><span class="lineno"> 3203</span><span class="stringliteral">        case make a shallow copy of self.</span></div>
<div class="line"><span class="lineno"> 3204</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3205</span>        name = get_op_result_name(self, other)</div>
<div class="line"><span class="lineno"> 3206</span>        <span class="keywordflow">if</span> self.name <span class="keywordflow">is</span> <span class="keywordflow">not</span> name:</div>
<div class="line"><span class="lineno"> 3207</span>            <span class="keywordflow">return</span> self.rename(name)</div>
<div class="line"><span class="lineno"> 3208</span>        <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno"> 3209</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a86d5c5720de721f1ffbae41a43731ecf" name="a86d5c5720de721f1ffbae41a43731ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d5c5720de721f1ffbae41a43731ecf">&#9670;&#160;</a></span>_get_string_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._get_string_slice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a07b155ed9fbbf8d793db552dbdb924bb">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6547</span>    <span class="keyword">def </span>_get_string_slice(self, key: str_t):</div>
<div class="line"><span class="lineno"> 6548</span>        <span class="comment"># this is for partial string indexing,</span></div>
<div class="line"><span class="lineno"> 6549</span>        <span class="comment"># overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex</span></div>
<div class="line"><span class="lineno"> 6550</span>        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno"> 6551</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a05a01ca5a9c2186ee82dd91f6d3b35d4" name="a05a01ca5a9c2186ee82dd91f6d3b35d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a01ca5a9c2186ee82dd91f6d3b35d4">&#9670;&#160;</a></span>_get_values_for_loc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._get_values_for_loc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Series&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Do a positional lookup on the given Series, returning either a scalar
or a Series.

Assumes that `series.index is self`

key is included for MultiIndex compat.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a5aac2d21503d67cc5320ae508ad0e182">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5977</span>    <span class="keyword">def </span>_get_values_for_loc(self, series: Series, loc, key):</div>
<div class="line"><span class="lineno"> 5978</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5979</span><span class="stringliteral">        Do a positional lookup on the given Series, returning either a scalar</span></div>
<div class="line"><span class="lineno"> 5980</span><span class="stringliteral">        or a Series.</span></div>
<div class="line"><span class="lineno"> 5981</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5982</span><span class="stringliteral">        Assumes that `series.index is self`</span></div>
<div class="line"><span class="lineno"> 5983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5984</span><span class="stringliteral">        key is included for MultiIndex compat.</span></div>
<div class="line"><span class="lineno"> 5985</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5986</span>        <span class="keywordflow">if</span> is_integer(loc):</div>
<div class="line"><span class="lineno"> 5987</span>            <span class="keywordflow">return</span> series._values[loc]</div>
<div class="line"><span class="lineno"> 5988</span> </div>
<div class="line"><span class="lineno"> 5989</span>        <span class="keywordflow">return</span> series.iloc[loc]</div>
<div class="line"><span class="lineno"> 5990</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2c26534bb54cd015954850f06623f22a" name="a2c26534bb54cd015954850f06623f22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c26534bb54cd015954850f06623f22a">&#9670;&#160;</a></span>_getitem_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._getitem_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slice&#160;</td>
          <td class="paramname"><em>slobj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Fastpath for __getitem__ when we know we have a slice.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a9a1b511a816c30a7cb3531609c1a8b8c">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ad486cf37308aa3c8edfffc3d46727a57">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5399</span>    <span class="keyword">def </span>_getitem_slice(self: _IndexT, slobj: slice) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 5400</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5401</span><span class="stringliteral">        Fastpath for __getitem__ when we know we have a slice.</span></div>
<div class="line"><span class="lineno"> 5402</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5403</span>        res = self._data[slobj]</div>
<div class="line"><span class="lineno"> 5404</span>        <span class="keywordflow">return</span> type(self)._simple_new(res, name=self._name)</div>
<div class="line"><span class="lineno"> 5405</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ade8cbdfaf190452620fd6d6537f8b3af" name="ade8cbdfaf190452620fd6d6537f8b3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8cbdfaf190452620fd6d6537f8b3af">&#9670;&#160;</a></span>_index_as_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._index_as_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Whether we should treat this as unique for the sake of
get_indexer vs get_indexer_non_unique.

For IntervalIndex compat.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a2de43c0c33b986aa156eb3653aecffa0">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6237</span>    <span class="keyword">def </span>_index_as_unique(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 6238</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6239</span><span class="stringliteral">        Whether we should treat this as unique for the sake of</span></div>
<div class="line"><span class="lineno"> 6240</span><span class="stringliteral">        get_indexer vs get_indexer_non_unique.</span></div>
<div class="line"><span class="lineno"> 6241</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6242</span><span class="stringliteral">        For IntervalIndex compat.</span></div>
<div class="line"><span class="lineno"> 6243</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6244</span>        <span class="keywordflow">return</span> self.is_unique</div>
<div class="line"><span class="lineno"> 6245</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a93ca572c49a5cc3ec520dfebd4983021" name="a93ca572c49a5cc3ec520dfebd4983021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ca572c49a5cc3ec520dfebd4983021">&#9670;&#160;</a></span>_inner_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._inner_indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>
    &#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  367</span>    ) -&gt; tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  368</span>        <span class="comment"># Caller is responsible for ensuring other.dtype == self.dtype</span></div>
<div class="line"><span class="lineno">  369</span>        sv = self._get_engine_target()</div>
<div class="line"><span class="lineno">  370</span>        ov = other._get_engine_target()</div>
<div class="line"><span class="lineno">  371</span>        <span class="comment"># can_use_libjoin assures sv and ov are ndarrays</span></div>
<div class="line"><span class="lineno">  372</span>        sv = cast(np.ndarray, sv)</div>
<div class="line"><span class="lineno">  373</span>        ov = cast(np.ndarray, ov)</div>
<div class="line"><span class="lineno">  374</span>        joined_ndarray, lidx, ridx = libjoin.inner_join_indexer(sv, ov)</div>
<div class="line"><span class="lineno">  375</span>        joined = self._from_join_target(joined_ndarray)</div>
<div class="line"><span class="lineno">  376</span>        <span class="keywordflow">return</span> joined, lidx, ridx</div>
<div class="line"><span class="lineno">  377</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f1dfc88fbeb99c226342f877fa78ef8" name="a4f1dfc88fbeb99c226342f877fa78ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1dfc88fbeb99c226342f877fa78ef8">&#9670;&#160;</a></span>_intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">intersection specialized to the case with matching dtypes.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a52398bcb843d62fbad8f7de3bdf912b7">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a9b61be1d5f5787bfeb3dbca4fc75e95b">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a4d5188948099bd1bfd0cb29d92244956">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3517</span>    <span class="keyword">def </span>_intersection(self, other: Index, sort=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 3518</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3519</span><span class="stringliteral">        intersection specialized to the case with matching dtypes.</span></div>
<div class="line"><span class="lineno"> 3520</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3521</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3522</span>            self.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 3523</span>            <span class="keywordflow">and</span> other.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 3524</span>            <span class="keywordflow">and</span> self._can_use_libjoin</div>
<div class="line"><span class="lineno"> 3525</span>        ):</div>
<div class="line"><span class="lineno"> 3526</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3527</span>                result = self._inner_indexer(other)[0]</div>
<div class="line"><span class="lineno"> 3528</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 3529</span>                <span class="comment"># non-comparable; should only be for object dtype</span></div>
<div class="line"><span class="lineno"> 3530</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 3531</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3532</span>                <span class="comment"># TODO: algos.unique1d should preserve DTA/TDA</span></div>
<div class="line"><span class="lineno"> 3533</span>                res = algos.unique1d(result)</div>
<div class="line"><span class="lineno"> 3534</span>                <span class="keywordflow">return</span> ensure_wrapped_if_datetimelike(res)</div>
<div class="line"><span class="lineno"> 3535</span> </div>
<div class="line"><span class="lineno"> 3536</span>        res_values = self._intersection_via_get_indexer(other, sort=sort)</div>
<div class="line"><span class="lineno"> 3537</span>        res_values = _maybe_try_sort(res_values, sort)</div>
<div class="line"><span class="lineno"> 3538</span>        <span class="keywordflow">return</span> res_values</div>
<div class="line"><span class="lineno"> 3539</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8fa3b456101c443a1d9d233362ecff6d" name="a8fa3b456101c443a1d9d233362ecff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa3b456101c443a1d9d233362ecff6d">&#9670;&#160;</a></span>_intersection_via_get_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.indexes.base.Index._intersection_via_get_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the intersection of two Indexes using get_indexer.

Returns
-------
np.ndarray or ExtensionArray
    The returned array will be unique.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3545</span>    <span class="keyword">def </span>_intersection_via_get_indexer(self, other: Index, sort) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 3546</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3547</span><span class="stringliteral">        Find the intersection of two Indexes using get_indexer.</span></div>
<div class="line"><span class="lineno"> 3548</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3549</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3550</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3551</span><span class="stringliteral">        np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 3552</span><span class="stringliteral">            The returned array will be unique.</span></div>
<div class="line"><span class="lineno"> 3553</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3554</span>        left_unique = self.unique()</div>
<div class="line"><span class="lineno"> 3555</span>        right_unique = other.unique()</div>
<div class="line"><span class="lineno"> 3556</span> </div>
<div class="line"><span class="lineno"> 3557</span>        <span class="comment"># even though we are unique, we need get_indexer_for for IntervalIndex</span></div>
<div class="line"><span class="lineno"> 3558</span>        indexer = left_unique.get_indexer_for(right_unique)</div>
<div class="line"><span class="lineno"> 3559</span> </div>
<div class="line"><span class="lineno"> 3560</span>        mask = indexer != -1</div>
<div class="line"><span class="lineno"> 3561</span> </div>
<div class="line"><span class="lineno"> 3562</span>        taker = indexer.take(mask.nonzero()[0])</div>
<div class="line"><span class="lineno"> 3563</span>        <span class="keywordflow">if</span> sort <span class="keywordflow">is</span> <span class="keyword">False</span>:</div>
<div class="line"><span class="lineno"> 3564</span>            <span class="comment"># sort bc we want the elements in the same order they are in self</span></div>
<div class="line"><span class="lineno"> 3565</span>            <span class="comment"># unnecessary in the case with sort=None bc we will sort later</span></div>
<div class="line"><span class="lineno"> 3566</span>            taker = np.sort(taker)</div>
<div class="line"><span class="lineno"> 3567</span> </div>
<div class="line"><span class="lineno"> 3568</span>        result = left_unique.take(taker)._values</div>
<div class="line"><span class="lineno"> 3569</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3570</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aad82f8d6e9a81927746223680392e963" name="aad82f8d6e9a81927746223680392e963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad82f8d6e9a81927746223680392e963">&#9670;&#160;</a></span>_invalid_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> TypeError pandas.core.indexes.base.Index._invalid_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Consistent invalid indexer message.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4332</span>    <span class="keyword">def </span>_invalid_indexer(self, form: str_t, key) -&gt; TypeError:</div>
<div class="line"><span class="lineno"> 4333</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4334</span><span class="stringliteral">        Consistent invalid indexer message.</span></div>
<div class="line"><span class="lineno"> 4335</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4336</span>        <span class="keywordflow">return</span> TypeError(</div>
<div class="line"><span class="lineno"> 4337</span>            f<span class="stringliteral">&quot;cannot do {form} indexing on {type(self).__name__} with these &quot;</span></div>
<div class="line"><span class="lineno"> 4338</span>            f<span class="stringliteral">&quot;indexers [{key}] of type {type(key).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 4339</span>        )</div>
<div class="line"><span class="lineno"> 4340</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a749df7c9e493acf44522ea1924f9977e" name="a749df7c9e493acf44522ea1924f9977e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749df7c9e493acf44522ea1924f9977e">&#9670;&#160;</a></span>_is_all_dates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_all_dates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Whether or not the index values only consist of dates.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2755</span>    <span class="keyword">def </span>_is_all_dates(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2756</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2757</span><span class="stringliteral">        Whether or not the index values only consist of dates.</span></div>
<div class="line"><span class="lineno"> 2758</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2759</span>        <span class="keywordflow">if</span> needs_i8_conversion(self.dtype):</div>
<div class="line"><span class="lineno"> 2760</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 2761</span>        <span class="keywordflow">elif</span> self.dtype != _dtype_obj:</div>
<div class="line"><span class="lineno"> 2762</span>            <span class="comment"># TODO(ExtensionIndex): 3rd party EA might override?</span></div>
<div class="line"><span class="lineno"> 2763</span>            <span class="comment"># Note: this includes IntervalIndex, even when the left/right</span></div>
<div class="line"><span class="lineno"> 2764</span>            <span class="comment">#  contain datetime-like objects.</span></div>
<div class="line"><span class="lineno"> 2765</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2766</span>        <span class="keywordflow">elif</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 2767</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2768</span>        <span class="keywordflow">return</span> is_datetime_array(ensure_object(self._values))</div>
<div class="line"><span class="lineno"> 2769</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4199a94a79bb306e87457970a5734439" name="a4199a94a79bb306e87457970a5734439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4199a94a79bb306e87457970a5734439">&#9670;&#160;</a></span>_is_comparable_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_comparable_dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Can we compare values of the given dtype to our own?
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a71cd9c2e3a5881a1ab8ba82dab7ce107">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#ae35c87847cf9a313f9903cc1fb8056e3">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#ad8a1e22d22a39f49d51294e0e2e38dc6">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#acb9927d6b84ab2ff7d1a490f3ce4fe84">pandas.core.indexes.multi.MultiIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a0cc0619a6e087638751f4adf749542a3">pandas.core.indexes.period.PeriodIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#aa992a47fe6908c47d8c8a076d83d25d4">pandas.core.indexes.timedeltas.TimedeltaIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6346</span>    <span class="keyword">def </span>_is_comparable_dtype(self, dtype: DtypeObj) -&gt; bool:</div>
<div class="line"><span class="lineno"> 6347</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6348</span><span class="stringliteral">        Can we compare values of the given dtype to our own?</span></div>
<div class="line"><span class="lineno"> 6349</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6350</span>        <span class="keywordflow">if</span> self.dtype.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno"> 6351</span>            <span class="keywordflow">return</span> dtype.kind == <span class="stringliteral">&quot;b&quot;</span></div>
<div class="line"><span class="lineno"> 6352</span>        <span class="keywordflow">elif</span> is_numeric_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 6353</span>            <span class="keywordflow">return</span> is_numeric_dtype(dtype)</div>
<div class="line"><span class="lineno"> 6354</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 6355</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6589dfe5acc663da458a789eea9a612e" name="a6589dfe5acc663da458a789eea9a612e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6589dfe5acc663da458a789eea9a612e">&#9670;&#160;</a></span>_is_memory_usage_qualified()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_memory_usage_qualified </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean if we need a qualified .info display.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a3a074f0dac314ab39a5261aea1d5afcf">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5279</span>    <span class="keyword">def </span>_is_memory_usage_qualified(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5280</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5281</span><span class="stringliteral">        Return a boolean if we need a qualified .info display.</span></div>
<div class="line"><span class="lineno"> 5282</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5283</span>        <span class="keywordflow">return</span> self.is_object()</div>
<div class="line"><span class="lineno"> 5284</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af77f250b7f81a755751bbd21552280cb" name="af77f250b7f81a755751bbd21552280cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77f250b7f81a755751bbd21552280cb">&#9670;&#160;</a></span>_is_multi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Cached check equivalent to isinstance(self, MultiIndex)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2786</span>    <span class="keyword">def </span>_is_multi(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2787</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2788</span><span class="stringliteral">        Cached check equivalent to isinstance(self, MultiIndex)</span></div>
<div class="line"><span class="lineno"> 2789</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2790</span>        <span class="keywordflow">return</span> isinstance(self, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 2791</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac97bc69d6e2c85c57ae7512b6dd46dac" name="ac97bc69d6e2c85c57ae7512b6dd46dac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc69d6e2c85c57ae7512b6dd46dac">&#9670;&#160;</a></span>_is_strictly_monotonic_decreasing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_strictly_monotonic_decreasing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return if the index is strictly monotonic decreasing
(only decreasing) values.

Examples
--------
&gt;&gt;&gt; Index([3, 2, 1])._is_strictly_monotonic_decreasing
True
&gt;&gt;&gt; Index([3, 2, 2])._is_strictly_monotonic_decreasing
False
&gt;&gt;&gt; Index([3, 1, 2])._is_strictly_monotonic_decreasing
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2366</span>    <span class="keyword">def </span>_is_strictly_monotonic_decreasing(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2367</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2368</span><span class="stringliteral">        Return if the index is strictly monotonic decreasing</span></div>
<div class="line"><span class="lineno"> 2369</span><span class="stringliteral">        (only decreasing) values.</span></div>
<div class="line"><span class="lineno"> 2370</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2371</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2372</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2373</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 2, 1])._is_strictly_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2374</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2375</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 2, 2])._is_strictly_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2376</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2377</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 1, 2])._is_strictly_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2378</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2379</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2380</span>        <span class="keywordflow">return</span> self.is_unique <span class="keywordflow">and</span> self.is_monotonic_decreasing</div>
<div class="line"><span class="lineno"> 2381</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4cb64ce356d6fff06e13334f633e7d77" name="a4cb64ce356d6fff06e13334f633e7d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb64ce356d6fff06e13334f633e7d77">&#9670;&#160;</a></span>_is_strictly_monotonic_increasing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._is_strictly_monotonic_increasing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return if the index is strictly monotonic increasing
(only increasing) values.

Examples
--------
&gt;&gt;&gt; Index([1, 2, 3])._is_strictly_monotonic_increasing
True
&gt;&gt;&gt; Index([1, 2, 2])._is_strictly_monotonic_increasing
False
&gt;&gt;&gt; Index([1, 3, 2])._is_strictly_monotonic_increasing
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2348</span>    <span class="keyword">def </span>_is_strictly_monotonic_increasing(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2349</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2350</span><span class="stringliteral">        Return if the index is strictly monotonic increasing</span></div>
<div class="line"><span class="lineno"> 2351</span><span class="stringliteral">        (only increasing) values.</span></div>
<div class="line"><span class="lineno"> 2352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2353</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2354</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2355</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 2, 3])._is_strictly_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2356</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2357</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 2, 2])._is_strictly_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2358</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2359</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 3, 2])._is_strictly_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2360</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2361</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2362</span>        <span class="keywordflow">return</span> self.is_unique <span class="keywordflow">and</span> self.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 2363</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5074ef758fd37bd994d42affa8eb14e1" name="a5074ef758fd37bd994d42affa8eb14e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074ef758fd37bd994d42affa8eb14e1">&#9670;&#160;</a></span>_isnan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.indexes.base.Index._isnan </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return if each value is NaN.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1extension_1_1_extension_index.html#a6e3fc411c286232e1690a150a12f1063">pandas.core.indexes.extension.ExtensionIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2813</span>    <span class="keyword">def </span>_isnan(self) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 2814</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2815</span><span class="stringliteral">        Return if each value is NaN.</span></div>
<div class="line"><span class="lineno"> 2816</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2817</span>        <span class="keywordflow">if</span> self._can_hold_na:</div>
<div class="line"><span class="lineno"> 2818</span>            <span class="keywordflow">return</span> isna(self)</div>
<div class="line"><span class="lineno"> 2819</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2820</span>            <span class="comment"># shouldn&#39;t reach to this condition by checking hasnans beforehand</span></div>
<div class="line"><span class="lineno"> 2821</span>            values = np.empty(len(self), dtype=np.bool_)</div>
<div class="line"><span class="lineno"> 2822</span>            values.fill(<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2823</span>            <span class="keywordflow">return</span> values</div>
<div class="line"><span class="lineno"> 2824</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a326f8dccb9cd9c74c6443f048452fac7" name="a326f8dccb9cd9c74c6443f048452fac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326f8dccb9cd9c74c6443f048452fac7">&#9670;&#160;</a></span>_join_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[MultiIndex, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index._join_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;left&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>keep_order</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The join method *only* affects the level of the resulting
MultiIndex. Otherwise it just exactly aligns the Index data to the
labels of the level in the MultiIndex.

If ```keep_order == True```, the order of the data indexed by the
MultiIndex will not be changed; otherwise, it will tie out
with `other`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4883</span>    ) -&gt; tuple[MultiIndex, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4884</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4885</span><span class="stringliteral">        The join method *only* affects the level of the resulting</span></div>
<div class="line"><span class="lineno"> 4886</span><span class="stringliteral">        MultiIndex. Otherwise it just exactly aligns the Index data to the</span></div>
<div class="line"><span class="lineno"> 4887</span><span class="stringliteral">        labels of the level in the MultiIndex.</span></div>
<div class="line"><span class="lineno"> 4888</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4889</span><span class="stringliteral">        If ```keep_order == True```, the order of the data indexed by the</span></div>
<div class="line"><span class="lineno"> 4890</span><span class="stringliteral">        MultiIndex will not be changed; otherwise, it will tie out</span></div>
<div class="line"><span class="lineno"> 4891</span><span class="stringliteral">        with `other`.</span></div>
<div class="line"><span class="lineno"> 4892</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4893</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 4894</span> </div>
<div class="line"><span class="lineno"> 4895</span>        <span class="keyword">def </span>_get_leaf_sorter(labels: list[np.ndarray]) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 4896</span>            <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4897</span><span class="stringliteral">            Returns sorter for the inner most level while preserving the</span></div>
<div class="line"><span class="lineno"> 4898</span><span class="stringliteral">            order of higher levels.</span></div>
<div class="line"><span class="lineno"> 4899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4900</span><span class="stringliteral">            Parameters</span></div>
<div class="line"><span class="lineno"> 4901</span><span class="stringliteral">            ----------</span></div>
<div class="line"><span class="lineno"> 4902</span><span class="stringliteral">            labels : list[np.ndarray]</span></div>
<div class="line"><span class="lineno"> 4903</span><span class="stringliteral">                Each ndarray has signed integer dtype, not necessarily identical.</span></div>
<div class="line"><span class="lineno"> 4904</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4905</span><span class="stringliteral">            Returns</span></div>
<div class="line"><span class="lineno"> 4906</span><span class="stringliteral">            -------</span></div>
<div class="line"><span class="lineno"> 4907</span><span class="stringliteral">            np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 4908</span><span class="stringliteral">            &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4909</span>            <span class="keywordflow">if</span> labels[0].size == 0:</div>
<div class="line"><span class="lineno"> 4910</span>                <span class="keywordflow">return</span> np.empty(0, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4911</span> </div>
<div class="line"><span class="lineno"> 4912</span>            <span class="keywordflow">if</span> len(labels) == 1:</div>
<div class="line"><span class="lineno"> 4913</span>                <span class="keywordflow">return</span> get_group_index_sorter(ensure_platform_int(labels[0]))</div>
<div class="line"><span class="lineno"> 4914</span> </div>
<div class="line"><span class="lineno"> 4915</span>            <span class="comment"># find indexers of beginning of each set of</span></div>
<div class="line"><span class="lineno"> 4916</span>            <span class="comment"># same-key labels w.r.t all but last level</span></div>
<div class="line"><span class="lineno"> 4917</span>            tic = labels[0][:-1] != labels[0][1:]</div>
<div class="line"><span class="lineno"> 4918</span>            <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> labels[1:-1]:</div>
<div class="line"><span class="lineno"> 4919</span>                tic |= lab[:-1] != lab[1:]</div>
<div class="line"><span class="lineno"> 4920</span> </div>
<div class="line"><span class="lineno"> 4921</span>            starts = np.hstack(([<span class="keyword">True</span>], tic, [<span class="keyword">True</span>])).nonzero()[0]</div>
<div class="line"><span class="lineno"> 4922</span>            lab = ensure_int64(labels[-1])</div>
<div class="line"><span class="lineno"> 4923</span>            <span class="keywordflow">return</span> lib.get_level_sorter(lab, ensure_platform_int(starts))</div>
<div class="line"><span class="lineno"> 4924</span> </div>
<div class="line"><span class="lineno"> 4925</span>        <span class="keywordflow">if</span> isinstance(self, MultiIndex) <span class="keywordflow">and</span> isinstance(other, MultiIndex):</div>
<div class="line"><span class="lineno"> 4926</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Join on level between two MultiIndex objects is ambiguous&quot;</span>)</div>
<div class="line"><span class="lineno"> 4927</span> </div>
<div class="line"><span class="lineno"> 4928</span>        left, right = self, other</div>
<div class="line"><span class="lineno"> 4929</span> </div>
<div class="line"><span class="lineno"> 4930</span>        flip_order = <span class="keywordflow">not</span> isinstance(self, MultiIndex)</div>
<div class="line"><span class="lineno"> 4931</span>        <span class="keywordflow">if</span> flip_order:</div>
<div class="line"><span class="lineno"> 4932</span>            left, right = right, left</div>
<div class="line"><span class="lineno"> 4933</span>            how = {<span class="stringliteral">&quot;right&quot;</span>: <span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;left&quot;</span>: <span class="stringliteral">&quot;right&quot;</span>}.get(how, how)</div>
<div class="line"><span class="lineno"> 4934</span> </div>
<div class="line"><span class="lineno"> 4935</span>        <span class="keyword">assert</span> isinstance(left, MultiIndex)</div>
<div class="line"><span class="lineno"> 4936</span> </div>
<div class="line"><span class="lineno"> 4937</span>        level = left._get_level_number(level)</div>
<div class="line"><span class="lineno"> 4938</span>        old_level = left.levels[level]</div>
<div class="line"><span class="lineno"> 4939</span> </div>
<div class="line"><span class="lineno"> 4940</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> right.is_unique:</div>
<div class="line"><span class="lineno"> 4941</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 4942</span>                <span class="stringliteral">&quot;Index._join_level on non-unique index is not implemented&quot;</span></div>
<div class="line"><span class="lineno"> 4943</span>            )</div>
<div class="line"><span class="lineno"> 4944</span> </div>
<div class="line"><span class="lineno"> 4945</span>        new_level, left_lev_indexer, right_lev_indexer = old_level.join(</div>
<div class="line"><span class="lineno"> 4946</span>            right, how=how, return_indexers=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4947</span>        )</div>
<div class="line"><span class="lineno"> 4948</span> </div>
<div class="line"><span class="lineno"> 4949</span>        <span class="keywordflow">if</span> left_lev_indexer <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4950</span>            <span class="keywordflow">if</span> keep_order <span class="keywordflow">or</span> len(left) == 0:</div>
<div class="line"><span class="lineno"> 4951</span>                left_indexer = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4952</span>                join_index = left</div>
<div class="line"><span class="lineno"> 4953</span>            <span class="keywordflow">else</span>:  <span class="comment"># sort the leaves</span></div>
<div class="line"><span class="lineno"> 4954</span>                left_indexer = _get_leaf_sorter(left.codes[: level + 1])</div>
<div class="line"><span class="lineno"> 4955</span>                join_index = left[left_indexer]</div>
<div class="line"><span class="lineno"> 4956</span> </div>
<div class="line"><span class="lineno"> 4957</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4958</span>            left_lev_indexer = ensure_platform_int(left_lev_indexer)</div>
<div class="line"><span class="lineno"> 4959</span>            rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))</div>
<div class="line"><span class="lineno"> 4960</span>            old_codes = left.codes[level]</div>
<div class="line"><span class="lineno"> 4961</span> </div>
<div class="line"><span class="lineno"> 4962</span>            taker = old_codes[old_codes != -1]</div>
<div class="line"><span class="lineno"> 4963</span>            new_lev_codes = rev_indexer.take(taker)</div>
<div class="line"><span class="lineno"> 4964</span> </div>
<div class="line"><span class="lineno"> 4965</span>            new_codes = list(left.codes)</div>
<div class="line"><span class="lineno"> 4966</span>            new_codes[level] = new_lev_codes</div>
<div class="line"><span class="lineno"> 4967</span> </div>
<div class="line"><span class="lineno"> 4968</span>            new_levels = list(left.levels)</div>
<div class="line"><span class="lineno"> 4969</span>            new_levels[level] = new_level</div>
<div class="line"><span class="lineno"> 4970</span> </div>
<div class="line"><span class="lineno"> 4971</span>            <span class="keywordflow">if</span> keep_order:  <span class="comment"># just drop missing values. o.w. keep order</span></div>
<div class="line"><span class="lineno"> 4972</span>                left_indexer = np.arange(len(left), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4973</span>                left_indexer = cast(np.ndarray, left_indexer)</div>
<div class="line"><span class="lineno"> 4974</span>                mask = new_lev_codes != -1</div>
<div class="line"><span class="lineno"> 4975</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> mask.all():</div>
<div class="line"><span class="lineno"> 4976</span>                    new_codes = [lab[mask] <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> new_codes]</div>
<div class="line"><span class="lineno"> 4977</span>                    left_indexer = left_indexer[mask]</div>
<div class="line"><span class="lineno"> 4978</span> </div>
<div class="line"><span class="lineno"> 4979</span>            <span class="keywordflow">else</span>:  <span class="comment"># tie out the order with other</span></div>
<div class="line"><span class="lineno"> 4980</span>                <span class="keywordflow">if</span> level == 0:  <span class="comment"># outer most level, take the fast route</span></div>
<div class="line"><span class="lineno"> 4981</span>                    max_new_lev = 0 <span class="keywordflow">if</span> len(new_lev_codes) == 0 <span class="keywordflow">else</span> new_lev_codes.max()</div>
<div class="line"><span class="lineno"> 4982</span>                    ngroups = 1 + max_new_lev</div>
<div class="line"><span class="lineno"> 4983</span>                    left_indexer, counts = libalgos.groupsort_indexer(</div>
<div class="line"><span class="lineno"> 4984</span>                        new_lev_codes, ngroups</div>
<div class="line"><span class="lineno"> 4985</span>                    )</div>
<div class="line"><span class="lineno"> 4986</span> </div>
<div class="line"><span class="lineno"> 4987</span>                    <span class="comment"># missing values are placed first; drop them!</span></div>
<div class="line"><span class="lineno"> 4988</span>                    left_indexer = left_indexer[counts[0] :]</div>
<div class="line"><span class="lineno"> 4989</span>                    new_codes = [lab[left_indexer] <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> new_codes]</div>
<div class="line"><span class="lineno"> 4990</span> </div>
<div class="line"><span class="lineno"> 4991</span>                <span class="keywordflow">else</span>:  <span class="comment"># sort the leaves</span></div>
<div class="line"><span class="lineno"> 4992</span>                    mask = new_lev_codes != -1</div>
<div class="line"><span class="lineno"> 4993</span>                    mask_all = mask.all()</div>
<div class="line"><span class="lineno"> 4994</span>                    <span class="keywordflow">if</span> <span class="keywordflow">not</span> mask_all:</div>
<div class="line"><span class="lineno"> 4995</span>                        new_codes = [lab[mask] <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> new_codes]</div>
<div class="line"><span class="lineno"> 4996</span> </div>
<div class="line"><span class="lineno"> 4997</span>                    left_indexer = _get_leaf_sorter(new_codes[: level + 1])</div>
<div class="line"><span class="lineno"> 4998</span>                    new_codes = [lab[left_indexer] <span class="keywordflow">for</span> lab <span class="keywordflow">in</span> new_codes]</div>
<div class="line"><span class="lineno"> 4999</span> </div>
<div class="line"><span class="lineno"> 5000</span>                    <span class="comment"># left_indexers are w.r.t masked frame.</span></div>
<div class="line"><span class="lineno"> 5001</span>                    <span class="comment"># reverse to original frame!</span></div>
<div class="line"><span class="lineno"> 5002</span>                    <span class="keywordflow">if</span> <span class="keywordflow">not</span> mask_all:</div>
<div class="line"><span class="lineno"> 5003</span>                        left_indexer = mask.nonzero()[0][left_indexer]</div>
<div class="line"><span class="lineno"> 5004</span> </div>
<div class="line"><span class="lineno"> 5005</span>            join_index = MultiIndex(</div>
<div class="line"><span class="lineno"> 5006</span>                levels=new_levels,</div>
<div class="line"><span class="lineno"> 5007</span>                codes=new_codes,</div>
<div class="line"><span class="lineno"> 5008</span>                names=left.names,</div>
<div class="line"><span class="lineno"> 5009</span>                verify_integrity=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno"> 5010</span>            )</div>
<div class="line"><span class="lineno"> 5011</span> </div>
<div class="line"><span class="lineno"> 5012</span>        <span class="keywordflow">if</span> right_lev_indexer <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 5013</span>            right_indexer = right_lev_indexer.take(join_index.codes[level])</div>
<div class="line"><span class="lineno"> 5014</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5015</span>            right_indexer = join_index.codes[level]</div>
<div class="line"><span class="lineno"> 5016</span> </div>
<div class="line"><span class="lineno"> 5017</span>        <span class="keywordflow">if</span> flip_order:</div>
<div class="line"><span class="lineno"> 5018</span>            left_indexer, right_indexer = right_indexer, left_indexer</div>
<div class="line"><span class="lineno"> 5019</span> </div>
<div class="line"><span class="lineno"> 5020</span>        left_indexer = (</div>
<div class="line"><span class="lineno"> 5021</span>            <span class="keywordtype">None</span> <span class="keywordflow">if</span> left_indexer <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> ensure_platform_int(left_indexer)</div>
<div class="line"><span class="lineno"> 5022</span>        )</div>
<div class="line"><span class="lineno"> 5023</span>        right_indexer = (</div>
<div class="line"><span class="lineno"> 5024</span>            <span class="keywordtype">None</span> <span class="keywordflow">if</span> right_indexer <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> ensure_platform_int(right_indexer)</div>
<div class="line"><span class="lineno"> 5025</span>        )</div>
<div class="line"><span class="lineno"> 5026</span>        <span class="keywordflow">return</span> join_index, left_indexer, right_indexer</div>
<div class="line"><span class="lineno"> 5027</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e8430c69ac1343b875b2e1205b05bec" name="a8e8430c69ac1343b875b2e1205b05bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8430c69ac1343b875b2e1205b05bec">&#9670;&#160;</a></span>_join_monotonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index._join_monotonic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;left&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5031</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 5032</span>        <span class="comment"># We only get here with matching dtypes and both monotonic increasing</span></div>
<div class="line"><span class="lineno"> 5033</span>        <span class="keyword">assert</span> other.dtype == self.dtype</div>
<div class="line"><span class="lineno"> 5034</span> </div>
<div class="line"><span class="lineno"> 5035</span>        <span class="keywordflow">if</span> self.equals(other):</div>
<div class="line"><span class="lineno"> 5036</span>            ret_index = other <span class="keywordflow">if</span> how == <span class="stringliteral">&quot;right&quot;</span> <span class="keywordflow">else</span> self</div>
<div class="line"><span class="lineno"> 5037</span>            <span class="keywordflow">return</span> ret_index, <span class="keywordtype">None</span>, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5038</span> </div>
<div class="line"><span class="lineno"> 5039</span>        ridx: np.ndarray | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5040</span>        lidx: np.ndarray | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5041</span> </div>
<div class="line"><span class="lineno"> 5042</span>        <span class="keywordflow">if</span> self.is_unique <span class="keywordflow">and</span> other.is_unique:</div>
<div class="line"><span class="lineno"> 5043</span>            <span class="comment"># We can perform much better than the general case</span></div>
<div class="line"><span class="lineno"> 5044</span>            <span class="keywordflow">if</span> how == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 5045</span>                join_index = self</div>
<div class="line"><span class="lineno"> 5046</span>                lidx = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5047</span>                ridx = self._left_indexer_unique(other)</div>
<div class="line"><span class="lineno"> 5048</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 5049</span>                join_index = other</div>
<div class="line"><span class="lineno"> 5050</span>                lidx = other._left_indexer_unique(self)</div>
<div class="line"><span class="lineno"> 5051</span>                ridx = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5052</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;inner&quot;</span>:</div>
<div class="line"><span class="lineno"> 5053</span>                join_array, lidx, ridx = self._inner_indexer(other)</div>
<div class="line"><span class="lineno"> 5054</span>                join_index = self._wrap_joined_index(join_array, other)</div>
<div class="line"><span class="lineno"> 5055</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;outer&quot;</span>:</div>
<div class="line"><span class="lineno"> 5056</span>                join_array, lidx, ridx = self._outer_indexer(other)</div>
<div class="line"><span class="lineno"> 5057</span>                join_index = self._wrap_joined_index(join_array, other)</div>
<div class="line"><span class="lineno"> 5058</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5059</span>            <span class="keywordflow">if</span> how == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 5060</span>                join_array, lidx, ridx = self._left_indexer(other)</div>
<div class="line"><span class="lineno"> 5061</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 5062</span>                join_array, ridx, lidx = other._left_indexer(self)</div>
<div class="line"><span class="lineno"> 5063</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;inner&quot;</span>:</div>
<div class="line"><span class="lineno"> 5064</span>                join_array, lidx, ridx = self._inner_indexer(other)</div>
<div class="line"><span class="lineno"> 5065</span>            <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;outer&quot;</span>:</div>
<div class="line"><span class="lineno"> 5066</span>                join_array, lidx, ridx = self._outer_indexer(other)</div>
<div class="line"><span class="lineno"> 5067</span> </div>
<div class="line"><span class="lineno"> 5068</span>            join_index = self._wrap_joined_index(join_array, other)</div>
<div class="line"><span class="lineno"> 5069</span> </div>
<div class="line"><span class="lineno"> 5070</span>        lidx = <span class="keywordtype">None</span> <span class="keywordflow">if</span> lidx <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> ensure_platform_int(lidx)</div>
<div class="line"><span class="lineno"> 5071</span>        ridx = <span class="keywordtype">None</span> <span class="keywordflow">if</span> ridx <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> ensure_platform_int(ridx)</div>
<div class="line"><span class="lineno"> 5072</span>        <span class="keywordflow">return</span> join_index, lidx, ridx</div>
<div class="line"><span class="lineno"> 5073</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a999711e5ae0747c4e4dd3c006c15c4c0" name="a999711e5ae0747c4e4dd3c006c15c4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999711e5ae0747c4e4dd3c006c15c4c0">&#9670;&#160;</a></span>_join_multi()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._join_multi </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>how</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4767</span>    <span class="keyword">def </span>_join_multi(self, other: Index, how: str_t):</div>
<div class="line"><span class="lineno"> 4768</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 4769</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1reshape_1_1merge.html">pandas.core.reshape.merge</a> <span class="keyword">import</span> restore_dropped_levels_multijoin</div>
<div class="line"><span class="lineno"> 4770</span> </div>
<div class="line"><span class="lineno"> 4771</span>        <span class="comment"># figure out join names</span></div>
<div class="line"><span class="lineno"> 4772</span>        self_names_list = list(com.not_none(*self.names))</div>
<div class="line"><span class="lineno"> 4773</span>        other_names_list = list(com.not_none(*other.names))</div>
<div class="line"><span class="lineno"> 4774</span>        self_names_order = self_names_list.index</div>
<div class="line"><span class="lineno"> 4775</span>        other_names_order = other_names_list.index</div>
<div class="line"><span class="lineno"> 4776</span>        self_names = set(self_names_list)</div>
<div class="line"><span class="lineno"> 4777</span>        other_names = set(other_names_list)</div>
<div class="line"><span class="lineno"> 4778</span>        overlap = self_names &amp; other_names</div>
<div class="line"><span class="lineno"> 4779</span> </div>
<div class="line"><span class="lineno"> 4780</span>        <span class="comment"># need at least 1 in common</span></div>
<div class="line"><span class="lineno"> 4781</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> overlap:</div>
<div class="line"><span class="lineno"> 4782</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot join with no overlapping index names&quot;</span>)</div>
<div class="line"><span class="lineno"> 4783</span> </div>
<div class="line"><span class="lineno"> 4784</span>        <span class="keywordflow">if</span> isinstance(self, MultiIndex) <span class="keywordflow">and</span> isinstance(other, MultiIndex):</div>
<div class="line"><span class="lineno"> 4785</span> </div>
<div class="line"><span class="lineno"> 4786</span>            <span class="comment"># Drop the non-matching levels from left and right respectively</span></div>
<div class="line"><span class="lineno"> 4787</span>            ldrop_names = sorted(self_names - overlap, key=self_names_order)</div>
<div class="line"><span class="lineno"> 4788</span>            rdrop_names = sorted(other_names - overlap, key=other_names_order)</div>
<div class="line"><span class="lineno"> 4789</span> </div>
<div class="line"><span class="lineno"> 4790</span>            <span class="comment"># if only the order differs</span></div>
<div class="line"><span class="lineno"> 4791</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(ldrop_names + rdrop_names):</div>
<div class="line"><span class="lineno"> 4792</span>                self_jnlevels = self</div>
<div class="line"><span class="lineno"> 4793</span>                other_jnlevels = other.reorder_levels(self.names)</div>
<div class="line"><span class="lineno"> 4794</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4795</span>                self_jnlevels = self.droplevel(ldrop_names)</div>
<div class="line"><span class="lineno"> 4796</span>                other_jnlevels = other.droplevel(rdrop_names)</div>
<div class="line"><span class="lineno"> 4797</span> </div>
<div class="line"><span class="lineno"> 4798</span>            <span class="comment"># Join left and right</span></div>
<div class="line"><span class="lineno"> 4799</span>            <span class="comment"># Join on same leveled multi-index frames is supported</span></div>
<div class="line"><span class="lineno"> 4800</span>            join_idx, lidx, ridx = self_jnlevels.join(</div>
<div class="line"><span class="lineno"> 4801</span>                other_jnlevels, how=how, return_indexers=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4802</span>            )</div>
<div class="line"><span class="lineno"> 4803</span> </div>
<div class="line"><span class="lineno"> 4804</span>            <span class="comment"># Restore the dropped levels</span></div>
<div class="line"><span class="lineno"> 4805</span>            <span class="comment"># Returned index level order is</span></div>
<div class="line"><span class="lineno"> 4806</span>            <span class="comment"># common levels, ldrop_names, rdrop_names</span></div>
<div class="line"><span class="lineno"> 4807</span>            dropped_names = ldrop_names + rdrop_names</div>
<div class="line"><span class="lineno"> 4808</span> </div>
<div class="line"><span class="lineno"> 4809</span>            <span class="comment"># error: Argument 5/6 to &quot;restore_dropped_levels_multijoin&quot; has</span></div>
<div class="line"><span class="lineno"> 4810</span>            <span class="comment"># incompatible type &quot;Optional[ndarray[Any, dtype[signedinteger[Any</span></div>
<div class="line"><span class="lineno"> 4811</span>            <span class="comment"># ]]]]&quot;; expected &quot;ndarray[Any, dtype[signedinteger[Any]]]&quot;</span></div>
<div class="line"><span class="lineno"> 4812</span>            levels, codes, names = restore_dropped_levels_multijoin(</div>
<div class="line"><span class="lineno"> 4813</span>                self,</div>
<div class="line"><span class="lineno"> 4814</span>                other,</div>
<div class="line"><span class="lineno"> 4815</span>                dropped_names,</div>
<div class="line"><span class="lineno"> 4816</span>                join_idx,</div>
<div class="line"><span class="lineno"> 4817</span>                lidx,  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 4818</span>                ridx,  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 4819</span>            )</div>
<div class="line"><span class="lineno"> 4820</span> </div>
<div class="line"><span class="lineno"> 4821</span>            <span class="comment"># Re-create the multi-index</span></div>
<div class="line"><span class="lineno"> 4822</span>            multi_join_idx = MultiIndex(</div>
<div class="line"><span class="lineno"> 4823</span>                levels=levels, codes=codes, names=names, verify_integrity=<span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4824</span>            )</div>
<div class="line"><span class="lineno"> 4825</span> </div>
<div class="line"><span class="lineno"> 4826</span>            multi_join_idx = multi_join_idx.remove_unused_levels()</div>
<div class="line"><span class="lineno"> 4827</span> </div>
<div class="line"><span class="lineno"> 4828</span>            <span class="keywordflow">return</span> multi_join_idx, lidx, ridx</div>
<div class="line"><span class="lineno"> 4829</span> </div>
<div class="line"><span class="lineno"> 4830</span>        jl = list(overlap)[0]</div>
<div class="line"><span class="lineno"> 4831</span> </div>
<div class="line"><span class="lineno"> 4832</span>        <span class="comment"># Case where only one index is multi</span></div>
<div class="line"><span class="lineno"> 4833</span>        <span class="comment"># make the indices into mi&#39;s that match</span></div>
<div class="line"><span class="lineno"> 4834</span>        flip_order = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4835</span>        <span class="keywordflow">if</span> isinstance(self, MultiIndex):</div>
<div class="line"><span class="lineno"> 4836</span>            self, other = other, self</div>
<div class="line"><span class="lineno"> 4837</span>            flip_order = <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4838</span>            <span class="comment"># flip if join method is right or left</span></div>
<div class="line"><span class="lineno"> 4839</span>            how = {<span class="stringliteral">&quot;right&quot;</span>: <span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;left&quot;</span>: <span class="stringliteral">&quot;right&quot;</span>}.get(how, how)</div>
<div class="line"><span class="lineno"> 4840</span> </div>
<div class="line"><span class="lineno"> 4841</span>        level = other.names.index(jl)</div>
<div class="line"><span class="lineno"> 4842</span>        result = self._join_level(other, level, how=how)</div>
<div class="line"><span class="lineno"> 4843</span> </div>
<div class="line"><span class="lineno"> 4844</span>        <span class="keywordflow">if</span> flip_order:</div>
<div class="line"><span class="lineno"> 4845</span>            <span class="keywordflow">return</span> result[0], result[2], result[1]</div>
<div class="line"><span class="lineno"> 4846</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 4847</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1reshape_1_1merge_html"><div class="ttname"><a href="namespacepandas_1_1core_1_1reshape_1_1merge.html">pandas.core.reshape.merge</a></div><div class="ttdef"><b>Definition</b> merge.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aec14555c344e7feb0b4effc2991fbbd8" name="aec14555c344e7feb0b4effc2991fbbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec14555c344e7feb0b4effc2991fbbd8">&#9670;&#160;</a></span>_join_non_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._join_non_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;left&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4851</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 4852</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1reshape_1_1merge.html">pandas.core.reshape.merge</a> <span class="keyword">import</span> get_join_indexers</div>
<div class="line"><span class="lineno"> 4853</span> </div>
<div class="line"><span class="lineno"> 4854</span>        <span class="comment"># We only get here if dtypes match</span></div>
<div class="line"><span class="lineno"> 4855</span>        <span class="keyword">assert</span> self.dtype == other.dtype</div>
<div class="line"><span class="lineno"> 4856</span> </div>
<div class="line"><span class="lineno"> 4857</span>        left_idx, right_idx = get_join_indexers(</div>
<div class="line"><span class="lineno"> 4858</span>            [self._values], [other._values], how=how, sort=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4859</span>        )</div>
<div class="line"><span class="lineno"> 4860</span>        mask = left_idx == -1</div>
<div class="line"><span class="lineno"> 4861</span> </div>
<div class="line"><span class="lineno"> 4862</span>        join_array = self._values.take(left_idx)</div>
<div class="line"><span class="lineno"> 4863</span>        right = other._values.take(right_idx)</div>
<div class="line"><span class="lineno"> 4864</span> </div>
<div class="line"><span class="lineno"> 4865</span>        <span class="keywordflow">if</span> isinstance(join_array, np.ndarray):</div>
<div class="line"><span class="lineno"> 4866</span>            <span class="comment"># error: Argument 3 to &quot;putmask&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 4867</span>            <span class="comment"># &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;; expected</span></div>
<div class="line"><span class="lineno"> 4868</span>            <span class="comment"># &quot;Union[_SupportsArray[dtype[Any]], _NestedSequence[</span></div>
<div class="line"><span class="lineno"> 4869</span>            <span class="comment"># _SupportsArray[dtype[Any]]], bool, int, float, complex,</span></div>
<div class="line"><span class="lineno"> 4870</span>            <span class="comment"># str, bytes, _NestedSequence[Union[bool, int, float,</span></div>
<div class="line"><span class="lineno"> 4871</span>            <span class="comment"># complex, str, bytes]]]&quot;</span></div>
<div class="line"><span class="lineno"> 4872</span>            np.putmask(join_array, mask, right)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 4873</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4874</span>            join_array._putmask(mask, right)</div>
<div class="line"><span class="lineno"> 4875</span> </div>
<div class="line"><span class="lineno"> 4876</span>        join_index = self._wrap_joined_index(join_array, other)</div>
<div class="line"><span class="lineno"> 4877</span> </div>
<div class="line"><span class="lineno"> 4878</span>        <span class="keywordflow">return</span> join_index, left_idx, right_idx</div>
<div class="line"><span class="lineno"> 4879</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4a2c821734309500dfbbe57aa563576" name="ae4a2c821734309500dfbbe57aa563576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a2c821734309500dfbbe57aa563576">&#9670;&#160;</a></span>_join_via_get_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index._join_via_get_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>how</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
    &#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4734</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4735</span>        <span class="comment"># Fallback if we do not have any fastpaths available based on</span></div>
<div class="line"><span class="lineno"> 4736</span>        <span class="comment">#  uniqueness/monotonicity</span></div>
<div class="line"><span class="lineno"> 4737</span> </div>
<div class="line"><span class="lineno"> 4738</span>        <span class="comment"># Note: at this point we have checked matching dtypes</span></div>
<div class="line"><span class="lineno"> 4739</span> </div>
<div class="line"><span class="lineno"> 4740</span>        <span class="keywordflow">if</span> how == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 4741</span>            join_index = self</div>
<div class="line"><span class="lineno"> 4742</span>        <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 4743</span>            join_index = other</div>
<div class="line"><span class="lineno"> 4744</span>        <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;inner&quot;</span>:</div>
<div class="line"><span class="lineno"> 4745</span>            <span class="comment"># TODO: sort=False here for backwards compat. It may</span></div>
<div class="line"><span class="lineno"> 4746</span>            <span class="comment"># be better to use the sort parameter passed into join</span></div>
<div class="line"><span class="lineno"> 4747</span>            join_index = self.intersection(other, sort=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 4748</span>        <span class="keywordflow">elif</span> how == <span class="stringliteral">&quot;outer&quot;</span>:</div>
<div class="line"><span class="lineno"> 4749</span>            <span class="comment"># TODO: sort=True here for backwards compat. It may</span></div>
<div class="line"><span class="lineno"> 4750</span>            <span class="comment"># be better to use the sort parameter passed into join</span></div>
<div class="line"><span class="lineno"> 4751</span>            join_index = self.union(other)</div>
<div class="line"><span class="lineno"> 4752</span> </div>
<div class="line"><span class="lineno"> 4753</span>        <span class="keywordflow">if</span> sort:</div>
<div class="line"><span class="lineno"> 4754</span>            join_index = join_index.sort_values()</div>
<div class="line"><span class="lineno"> 4755</span> </div>
<div class="line"><span class="lineno"> 4756</span>        <span class="keywordflow">if</span> join_index <span class="keywordflow">is</span> self:</div>
<div class="line"><span class="lineno"> 4757</span>            lindexer = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4758</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4759</span>            lindexer = self.get_indexer_for(join_index)</div>
<div class="line"><span class="lineno"> 4760</span>        <span class="keywordflow">if</span> join_index <span class="keywordflow">is</span> other:</div>
<div class="line"><span class="lineno"> 4761</span>            rindexer = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4762</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4763</span>            rindexer = other.get_indexer_for(join_index)</div>
<div class="line"><span class="lineno"> 4764</span>        <span class="keywordflow">return</span> join_index, lindexer, rindexer</div>
<div class="line"><span class="lineno"> 4765</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d4c0f371f842e4f648a4493e82a4876" name="a0d4c0f371f842e4f648a4493e82a4876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4c0f371f842e4f648a4493e82a4876">&#9670;&#160;</a></span>_left_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._left_indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>
    &#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  353</span>    ) -&gt; tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  354</span>        <span class="comment"># Caller is responsible for ensuring other.dtype == self.dtype</span></div>
<div class="line"><span class="lineno">  355</span>        sv = self._get_engine_target()</div>
<div class="line"><span class="lineno">  356</span>        ov = other._get_engine_target()</div>
<div class="line"><span class="lineno">  357</span>        <span class="comment"># can_use_libjoin assures sv and ov are ndarrays</span></div>
<div class="line"><span class="lineno">  358</span>        sv = cast(np.ndarray, sv)</div>
<div class="line"><span class="lineno">  359</span>        ov = cast(np.ndarray, ov)</div>
<div class="line"><span class="lineno">  360</span>        joined_ndarray, lidx, ridx = libjoin.left_join_indexer(sv, ov)</div>
<div class="line"><span class="lineno">  361</span>        joined = self._from_join_target(joined_ndarray)</div>
<div class="line"><span class="lineno">  362</span>        <span class="keywordflow">return</span> joined, lidx, ridx</div>
<div class="line"><span class="lineno">  363</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae6aecd6b620f811505f8135165f968df" name="ae6aecd6b620f811505f8135165f968df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6aecd6b620f811505f8135165f968df">&#9670;&#160;</a></span>_left_indexer_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index._left_indexer_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  341</span>    <span class="keyword">def </span>_left_indexer_unique(self: _IndexT, other: _IndexT) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno">  342</span>        <span class="comment"># Caller is responsible for ensuring other.dtype == self.dtype</span></div>
<div class="line"><span class="lineno">  343</span>        sv = self._get_engine_target()</div>
<div class="line"><span class="lineno">  344</span>        ov = other._get_engine_target()</div>
<div class="line"><span class="lineno">  345</span>        <span class="comment"># can_use_libjoin assures sv and ov are ndarrays</span></div>
<div class="line"><span class="lineno">  346</span>        sv = cast(np.ndarray, sv)</div>
<div class="line"><span class="lineno">  347</span>        ov = cast(np.ndarray, ov)</div>
<div class="line"><span class="lineno">  348</span>        <span class="keywordflow">return</span> libjoin.left_join_indexer_unique(sv, ov)</div>
<div class="line"><span class="lineno">  349</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f7c3fa8c471eb3be9df110a687e8bea" name="a6f7c3fa8c471eb3be9df110a687e8bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f7c3fa8c471eb3be9df110a687e8bea">&#9670;&#160;</a></span>_maybe_cast_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._maybe_cast_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If we have a float key and are not a floating index, then try to cast
to an int if equivalent.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#aaa0e8237bb5707386594b8d4f81bc6c6">pandas.core.indexes.category.CategoricalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6612</span>    <span class="keyword">def </span>_maybe_cast_indexer(self, key):</div>
<div class="line"><span class="lineno"> 6613</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6614</span><span class="stringliteral">        If we have a float key and are not a floating index, then try to cast</span></div>
<div class="line"><span class="lineno"> 6615</span><span class="stringliteral">        to an int if equivalent.</span></div>
<div class="line"><span class="lineno"> 6616</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6617</span>        <span class="keywordflow">return</span> key</div>
<div class="line"><span class="lineno"> 6618</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f6deb56771ef3f8f8970807b2e3e8d1" name="a8f6deb56771ef3f8f8970807b2e3e8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6deb56771ef3f8f8970807b2e3e8d1">&#9670;&#160;</a></span>_maybe_cast_listlike_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index._maybe_cast_listlike_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Analogue to maybe_cast_indexer for get_indexer instead of get_loc.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#adeba01b10f288e1974fca62df57896a5">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#ad36c68ff9e67f9280cc6adccf536ff9b">pandas.core.indexes.category.CategoricalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6619</span>    <span class="keyword">def </span>_maybe_cast_listlike_indexer(self, target) -&gt; Index:</div>
<div class="line"><span class="lineno"> 6620</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6621</span><span class="stringliteral">        Analogue to maybe_cast_indexer for get_indexer instead of get_loc.</span></div>
<div class="line"><span class="lineno"> 6622</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6623</span>        <span class="keywordflow">return</span> ensure_index(target)</div>
<div class="line"><span class="lineno"> 6624</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0bc058ca0e7a363b573f2003c91cd505" name="a0bc058ca0e7a363b573f2003c91cd505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bc058ca0e7a363b573f2003c91cd505">&#9670;&#160;</a></span>_maybe_cast_slice_bound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._maybe_cast_slice_bound </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">This function should be overloaded in subclasses that allow non-trivial
casting on label-slice bounds, e.g. datetime-like indices allowing
strings containing formatted datetimes.

Parameters
----------
label : object
side : {'left', 'right'}
kind : {'loc', 'getitem'} or None

    .. deprecated:: 1.3.0

Returns
-------
label : object

Notes
-----
Value of `side` parameter should be validated in caller.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a3e4ab578bcf22c24479b6d2fd5cf801c">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a2eeba7467e2145aa9c00a7448aba0134">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#ae321b9992d433e5d12270cdbd9ac032c">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#ad28a2e15e26cb7b3d752f6e63c1e025b">pandas.core.indexes.numeric.NumericIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#ac4128b2c151be0ef2985456c5ba9318d">pandas.core.indexes.period.PeriodIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6636</span>    <span class="keyword">def </span>_maybe_cast_slice_bound(self, label, side: str_t, kind=no_default):</div>
<div class="line"><span class="lineno"> 6637</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6638</span><span class="stringliteral">        This function should be overloaded in subclasses that allow non-trivial</span></div>
<div class="line"><span class="lineno"> 6639</span><span class="stringliteral">        casting on label-slice bounds, e.g. datetime-like indices allowing</span></div>
<div class="line"><span class="lineno"> 6640</span><span class="stringliteral">        strings containing formatted datetimes.</span></div>
<div class="line"><span class="lineno"> 6641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6642</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6643</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6644</span><span class="stringliteral">        label : object</span></div>
<div class="line"><span class="lineno"> 6645</span><span class="stringliteral">        side : {&#39;left&#39;, &#39;right&#39;}</span></div>
<div class="line"><span class="lineno"> 6646</span><span class="stringliteral">        kind : {&#39;loc&#39;, &#39;getitem&#39;} or None</span></div>
<div class="line"><span class="lineno"> 6647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6648</span><span class="stringliteral">            .. deprecated:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 6649</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6650</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6651</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6652</span><span class="stringliteral">        label : object</span></div>
<div class="line"><span class="lineno"> 6653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6654</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 6655</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 6656</span><span class="stringliteral">        Value of `side` parameter should be validated in caller.</span></div>
<div class="line"><span class="lineno"> 6657</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6658</span>        <span class="keyword">assert</span> kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;loc&quot;</span>, <span class="stringliteral">&quot;getitem&quot;</span>, <span class="keywordtype">None</span>, no_default]</div>
<div class="line"><span class="lineno"> 6659</span>        self._deprecated_arg(kind, <span class="stringliteral">&quot;kind&quot;</span>, <span class="stringliteral">&quot;_maybe_cast_slice_bound&quot;</span>)</div>
<div class="line"><span class="lineno"> 6660</span> </div>
<div class="line"><span class="lineno"> 6661</span>        <span class="comment"># We are a plain index here (sub-class override this method if they</span></div>
<div class="line"><span class="lineno"> 6662</span>        <span class="comment"># wish to have special treatment for floats/ints, e.g. Float64Index and</span></div>
<div class="line"><span class="lineno"> 6663</span>        <span class="comment"># datetimelike Indexes</span></div>
<div class="line"><span class="lineno"> 6664</span>        <span class="comment"># reject them, if index does not contain label</span></div>
<div class="line"><span class="lineno"> 6665</span>        <span class="keywordflow">if</span> (is_float(label) <span class="keywordflow">or</span> is_integer(label)) <span class="keywordflow">and</span> label <span class="keywordflow">not</span> <span class="keywordflow">in</span> self:</div>
<div class="line"><span class="lineno"> 6666</span>            <span class="keywordflow">raise</span> self._invalid_indexer(<span class="stringliteral">&quot;slice&quot;</span>, label)</div>
<div class="line"><span class="lineno"> 6667</span> </div>
<div class="line"><span class="lineno"> 6668</span>        <span class="keywordflow">return</span> label</div>
<div class="line"><span class="lineno"> 6669</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad194c288c817df9ef68a9bf1ee74b7e4" name="ad194c288c817df9ef68a9bf1ee74b7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad194c288c817df9ef68a9bf1ee74b7e4">&#9670;&#160;</a></span>_maybe_check_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._maybe_check_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check that an Index has no duplicates.

This is typically only called via
`NDFrame.flags.allows_duplicate_labels.setter` when it's set to
True (duplicates aren't allowed).

Raises
------
DuplicateLabelError
    When the index is not unique.
</pre> <div class="fragment"><div class="line"><span class="lineno">  734</span>    <span class="keyword">def </span>_maybe_check_unique(self) -&gt; None:</div>
<div class="line"><span class="lineno">  735</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  736</span><span class="stringliteral">        Check that an Index has no duplicates.</span></div>
<div class="line"><span class="lineno">  737</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  738</span><span class="stringliteral">        This is typically only called via</span></div>
<div class="line"><span class="lineno">  739</span><span class="stringliteral">        `NDFrame.flags.allows_duplicate_labels.setter` when it&#39;s set to</span></div>
<div class="line"><span class="lineno">  740</span><span class="stringliteral">        True (duplicates aren&#39;t allowed).</span></div>
<div class="line"><span class="lineno">  741</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  742</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno">  743</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno">  744</span><span class="stringliteral">        DuplicateLabelError</span></div>
<div class="line"><span class="lineno">  745</span><span class="stringliteral">            When the index is not unique.</span></div>
<div class="line"><span class="lineno">  746</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  747</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.is_unique:</div>
<div class="line"><span class="lineno">  748</span>            msg = <span class="stringliteral">&quot;&quot;&quot;Index has duplicates.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  749</span>            duplicates = self._format_duplicate_message()</div>
<div class="line"><span class="lineno">  750</span>            msg += f<span class="stringliteral">&quot;\n{duplicates}&quot;</span></div>
<div class="line"><span class="lineno">  751</span> </div>
<div class="line"><span class="lineno">  752</span>            <span class="keywordflow">raise</span> DuplicateLabelError(msg)</div>
<div class="line"><span class="lineno">  753</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac542abc7754f845c6847882f7158dda1" name="ac542abc7754f845c6847882f7158dda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac542abc7754f845c6847882f7158dda1">&#9670;&#160;</a></span>_maybe_disable_logical_methods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._maybe_disable_logical_methods </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>opname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">raise if this Index subclass does not support any or all.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 7165</span>    <span class="keyword">def </span>_maybe_disable_logical_methods(self, opname: str_t) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 7166</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7167</span><span class="stringliteral">        raise if this Index subclass does not support any or all.</span></div>
<div class="line"><span class="lineno"> 7168</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7169</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 7170</span>            isinstance(self, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 7171</span>            <span class="keywordflow">or</span> needs_i8_conversion(self.dtype)</div>
<div class="line"><span class="lineno"> 7172</span>            <span class="keywordflow">or</span> is_interval_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 7173</span>            <span class="keywordflow">or</span> is_categorical_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 7174</span>            <span class="keywordflow">or</span> is_float_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 7175</span>        ):</div>
<div class="line"><span class="lineno"> 7176</span>            <span class="comment"># This call will raise</span></div>
<div class="line"><span class="lineno"> 7177</span>            make_invalid_op(opname)(self)</div>
<div class="line"><span class="lineno"> 7178</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acb2cf6513da88477dce050c2c76cbebf" name="acb2cf6513da88477dce050c2c76cbebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2cf6513da88477dce050c2c76cbebf">&#9670;&#160;</a></span>_maybe_disallow_fill()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._maybe_disallow_fill </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">We only use pandas-style take when allow_fill is True _and_
fill_value is not None.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1196</span>    <span class="keyword">def </span>_maybe_disallow_fill(self, allow_fill: bool, fill_value, indices) -&gt; bool:</div>
<div class="line"><span class="lineno"> 1197</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1198</span><span class="stringliteral">        We only use pandas-style take when allow_fill is True _and_</span></div>
<div class="line"><span class="lineno"> 1199</span><span class="stringliteral">        fill_value is not None.</span></div>
<div class="line"><span class="lineno"> 1200</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1201</span>        <span class="keywordflow">if</span> allow_fill <span class="keywordflow">and</span> fill_value <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1202</span>            <span class="comment"># only fill if we are passing a non-None fill_value</span></div>
<div class="line"><span class="lineno"> 1203</span>            <span class="keywordflow">if</span> self._can_hold_na:</div>
<div class="line"><span class="lineno"> 1204</span>                <span class="keywordflow">if</span> (indices &lt; -1).any():</div>
<div class="line"><span class="lineno"> 1205</span>                    <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1206</span>                        <span class="stringliteral">&quot;When allow_fill=True and fill_value is not None, &quot;</span></div>
<div class="line"><span class="lineno"> 1207</span>                        <span class="stringliteral">&quot;all indices must be &gt;= -1&quot;</span></div>
<div class="line"><span class="lineno"> 1208</span>                    )</div>
<div class="line"><span class="lineno"> 1209</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1210</span>                cls_name = type(self).__name__</div>
<div class="line"><span class="lineno"> 1211</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1212</span>                    f<span class="stringliteral">&quot;Unable to fill values because {cls_name} cannot contain NA&quot;</span></div>
<div class="line"><span class="lineno"> 1213</span>                )</div>
<div class="line"><span class="lineno"> 1214</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1215</span>            allow_fill = <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1216</span>        <span class="keywordflow">return</span> allow_fill</div>
<div class="line"><span class="lineno"> 1217</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afa7fc0e3783f3e1eba4e7705da4e5756" name="afa7fc0e3783f3e1eba4e7705da4e5756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7fc0e3783f3e1eba4e7705da4e5756">&#9670;&#160;</a></span>_maybe_preserve_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._maybe_preserve_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad74c893a5411d1496f35dd22c0289f19">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4484</span>    <span class="keyword">def </span>_maybe_preserve_names(self, target: Index, preserve_names: bool):</div>
<div class="line"><span class="lineno"> 4485</span>        <span class="keywordflow">if</span> preserve_names <span class="keywordflow">and</span> target.nlevels == 1 <span class="keywordflow">and</span> target.name != self.name:</div>
<div class="line"><span class="lineno"> 4486</span>            target = target.copy(deep=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 4487</span>            target.name = self.name</div>
<div class="line"><span class="lineno"> 4488</span>        <span class="keywordflow">return</span> target</div>
<div class="line"><span class="lineno"> 4489</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a37f38c6635feecb0baf3b2409345d726" name="a37f38c6635feecb0baf3b2409345d726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f38c6635feecb0baf3b2409345d726">&#9670;&#160;</a></span>_maybe_promote()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>] pandas.core.indexes.base.Index._maybe_promote </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">When dealing with an object-dtype Index and a non-object Index, see
if we can upcast the object-dtype one to improve performance.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6249</span>    <span class="keyword">def </span>_maybe_promote(self, other: Index) -&gt; tuple[Index, Index]:</div>
<div class="line"><span class="lineno"> 6250</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6251</span><span class="stringliteral">        When dealing with an object-dtype Index and a non-object Index, see</span></div>
<div class="line"><span class="lineno"> 6252</span><span class="stringliteral">        if we can upcast the object-dtype one to improve performance.</span></div>
<div class="line"><span class="lineno"> 6253</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6254</span> </div>
<div class="line"><span class="lineno"> 6255</span>        <span class="keywordflow">if</span> isinstance(self, ABCDatetimeIndex) <span class="keywordflow">and</span> isinstance(other, ABCDatetimeIndex):</div>
<div class="line"><span class="lineno"> 6256</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 6257</span>                self.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6258</span>                <span class="keywordflow">and</span> other.tz <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6259</span>                <span class="keywordflow">and</span> <span class="keywordflow">not</span> tz_compare(self.tz, other.tz)</div>
<div class="line"><span class="lineno"> 6260</span>            ):</div>
<div class="line"><span class="lineno"> 6261</span>                <span class="comment"># standardize on UTC</span></div>
<div class="line"><span class="lineno"> 6262</span>                <span class="keywordflow">return</span> self.tz_convert(<span class="stringliteral">&quot;UTC&quot;</span>), other.tz_convert(<span class="stringliteral">&quot;UTC&quot;</span>)</div>
<div class="line"><span class="lineno"> 6263</span> </div>
<div class="line"><span class="lineno"> 6264</span>        <span class="keywordflow">elif</span> self.inferred_type == <span class="stringliteral">&quot;date&quot;</span> <span class="keywordflow">and</span> isinstance(other, ABCDatetimeIndex):</div>
<div class="line"><span class="lineno"> 6265</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6266</span>                <span class="keywordflow">return</span> type(other)(self), other</div>
<div class="line"><span class="lineno"> 6267</span>            <span class="keywordflow">except</span> OutOfBoundsDatetime:</div>
<div class="line"><span class="lineno"> 6268</span>                <span class="keywordflow">return</span> self, other</div>
<div class="line"><span class="lineno"> 6269</span>        <span class="keywordflow">elif</span> self.inferred_type == <span class="stringliteral">&quot;timedelta&quot;</span> <span class="keywordflow">and</span> isinstance(other, ABCTimedeltaIndex):</div>
<div class="line"><span class="lineno"> 6270</span>            <span class="comment"># TODO: we dont have tests that get here</span></div>
<div class="line"><span class="lineno"> 6271</span>            <span class="keywordflow">return</span> type(other)(self), other</div>
<div class="line"><span class="lineno"> 6272</span> </div>
<div class="line"><span class="lineno"> 6273</span>        <span class="keywordflow">elif</span> self.dtype.kind == <span class="stringliteral">&quot;u&quot;</span> <span class="keywordflow">and</span> other.dtype.kind == <span class="stringliteral">&quot;i&quot;</span>:</div>
<div class="line"><span class="lineno"> 6274</span>            <span class="comment"># GH#41873</span></div>
<div class="line"><span class="lineno"> 6275</span>            <span class="keywordflow">if</span> other.min() &gt;= 0:</div>
<div class="line"><span class="lineno"> 6276</span>                <span class="comment"># lookup min as it may be cached</span></div>
<div class="line"><span class="lineno"> 6277</span>                <span class="comment"># TODO: may need itemsize check if we have non-64-bit Indexes</span></div>
<div class="line"><span class="lineno"> 6278</span>                <span class="keywordflow">return</span> self, other.astype(self.dtype)</div>
<div class="line"><span class="lineno"> 6279</span> </div>
<div class="line"><span class="lineno"> 6280</span>        <span class="keywordflow">elif</span> self._is_multi <span class="keywordflow">and</span> <span class="keywordflow">not</span> other._is_multi:</div>
<div class="line"><span class="lineno"> 6281</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6282</span>                <span class="comment"># &quot;Type[Index]&quot; has no attribute &quot;from_tuples&quot;</span></div>
<div class="line"><span class="lineno"> 6283</span>                other = type(self).from_tuples(other)  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 6284</span>            <span class="keywordflow">except</span> (TypeError, ValueError):</div>
<div class="line"><span class="lineno"> 6285</span>                <span class="comment"># let&#39;s instead try with a straight Index</span></div>
<div class="line"><span class="lineno"> 6286</span>                self = Index(self._values)</div>
<div class="line"><span class="lineno"> 6287</span> </div>
<div class="line"><span class="lineno"> 6288</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_object_dtype(self.dtype) <span class="keywordflow">and</span> is_object_dtype(other.dtype):</div>
<div class="line"><span class="lineno"> 6289</span>            <span class="comment"># Reverse op so we dont need to re-implement on the subclasses</span></div>
<div class="line"><span class="lineno"> 6290</span>            other, self = other._maybe_promote(self)</div>
<div class="line"><span class="lineno"> 6291</span> </div>
<div class="line"><span class="lineno"> 6292</span>        <span class="keywordflow">return</span> self, other</div>
<div class="line"><span class="lineno"> 6293</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a952037d426cfd039f15b10bf9621c75e" name="a952037d426cfd039f15b10bf9621c75e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952037d426cfd039f15b10bf9621c75e">&#9670;&#160;</a></span>_mpl_repr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.indexes.base.Index._mpl_repr </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1438</span>    <span class="keyword">def </span>_mpl_repr(self) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1439</span>        <span class="comment"># how to represent ourselves to matplotlib</span></div>
<div class="line"><span class="lineno"> 1440</span>        <span class="keywordflow">if</span> isinstance(self.dtype, np.dtype) <span class="keywordflow">and</span> self.dtype.kind != <span class="stringliteral">&quot;M&quot;</span>:</div>
<div class="line"><span class="lineno"> 1441</span>            <span class="keywordflow">return</span> cast(np.ndarray, self.values)</div>
<div class="line"><span class="lineno"> 1442</span>        <span class="keywordflow">return</span> self.astype(object, copy=<span class="keyword">False</span>)._values</div>
<div class="line"><span class="lineno"> 1443</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a001ebbd18228d72fe0125bc591150f12" name="a001ebbd18228d72fe0125bc591150f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001ebbd18228d72fe0125bc591150f12">&#9670;&#160;</a></span>_na_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._na_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The expected NA value to use with this index.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2803</span>    <span class="keyword">def </span>_na_value(self):</div>
<div class="line"><span class="lineno"> 2804</span>        <span class="stringliteral">&quot;&quot;&quot;The expected NA value to use with this index.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2805</span>        dtype = self.dtype</div>
<div class="line"><span class="lineno"> 2806</span>        <span class="keywordflow">if</span> isinstance(dtype, np.dtype):</div>
<div class="line"><span class="lineno"> 2807</span>            <span class="keywordflow">if</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 2808</span>                <span class="keywordflow">return</span> NaT</div>
<div class="line"><span class="lineno"> 2809</span>            <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno"> 2810</span>        <span class="keywordflow">return</span> dtype.na_value</div>
<div class="line"><span class="lineno"> 2811</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a10b2b2f079c4d21f246f8e5af2b27b70" name="a10b2b2f079c4d21f246f8e5af2b27b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b2b2f079c4d21f246f8e5af2b27b70">&#9670;&#160;</a></span>_outer_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index._outer_indexer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>
    &#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  381</span>    ) -&gt; tuple[ArrayLike, npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno">  382</span>        <span class="comment"># Caller is responsible for ensuring other.dtype == self.dtype</span></div>
<div class="line"><span class="lineno">  383</span>        sv = self._get_engine_target()</div>
<div class="line"><span class="lineno">  384</span>        ov = other._get_engine_target()</div>
<div class="line"><span class="lineno">  385</span>        <span class="comment"># can_use_libjoin assures sv and ov are ndarrays</span></div>
<div class="line"><span class="lineno">  386</span>        sv = cast(np.ndarray, sv)</div>
<div class="line"><span class="lineno">  387</span>        ov = cast(np.ndarray, ov)</div>
<div class="line"><span class="lineno">  388</span>        joined_ndarray, lidx, ridx = libjoin.outer_join_indexer(sv, ov)</div>
<div class="line"><span class="lineno">  389</span>        joined = self._from_join_target(joined_ndarray)</div>
<div class="line"><span class="lineno">  390</span>        <span class="keywordflow">return</span> joined, lidx, ridx</div>
<div class="line"><span class="lineno">  391</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4dc499589f7b32aa77ad40c4a31b408c" name="a4dc499589f7b32aa77ad40c4a31b408c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc499589f7b32aa77ad40c4a31b408c">&#9670;&#160;</a></span>_raise_if_missing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._raise_if_missing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>axis_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check that indexer can be used to return a result.

e.g. at least one element was found,
unless the list of keys was actually empty.

Parameters
----------
key : list-like
    Targeted labels (only used to show correct error message).
indexer: array-like of booleans
    Indices corresponding to the key,
    (with -1 indicating not found).
axis_name : str

Raises
------
KeyError
    If at least one key was requested but none was found.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a88076b3c6c8365713c881487f0e37999">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6130</span>    <span class="keyword">def </span>_raise_if_missing(self, key, indexer, axis_name: str_t) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6131</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6132</span><span class="stringliteral">        Check that indexer can be used to return a result.</span></div>
<div class="line"><span class="lineno"> 6133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6134</span><span class="stringliteral">        e.g. at least one element was found,</span></div>
<div class="line"><span class="lineno"> 6135</span><span class="stringliteral">        unless the list of keys was actually empty.</span></div>
<div class="line"><span class="lineno"> 6136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6137</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6138</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6139</span><span class="stringliteral">        key : list-like</span></div>
<div class="line"><span class="lineno"> 6140</span><span class="stringliteral">            Targeted labels (only used to show correct error message).</span></div>
<div class="line"><span class="lineno"> 6141</span><span class="stringliteral">        indexer: array-like of booleans</span></div>
<div class="line"><span class="lineno"> 6142</span><span class="stringliteral">            Indices corresponding to the key,</span></div>
<div class="line"><span class="lineno"> 6143</span><span class="stringliteral">            (with -1 indicating not found).</span></div>
<div class="line"><span class="lineno"> 6144</span><span class="stringliteral">        axis_name : str</span></div>
<div class="line"><span class="lineno"> 6145</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6146</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 6147</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 6148</span><span class="stringliteral">        KeyError</span></div>
<div class="line"><span class="lineno"> 6149</span><span class="stringliteral">            If at least one key was requested but none was found.</span></div>
<div class="line"><span class="lineno"> 6150</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6151</span>        <span class="keywordflow">if</span> len(key) == 0:</div>
<div class="line"><span class="lineno"> 6152</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 6153</span> </div>
<div class="line"><span class="lineno"> 6154</span>        <span class="comment"># Count missing values</span></div>
<div class="line"><span class="lineno"> 6155</span>        missing_mask = indexer &lt; 0</div>
<div class="line"><span class="lineno"> 6156</span>        nmissing = missing_mask.sum()</div>
<div class="line"><span class="lineno"> 6157</span> </div>
<div class="line"><span class="lineno"> 6158</span>        <span class="keywordflow">if</span> nmissing:</div>
<div class="line"><span class="lineno"> 6159</span> </div>
<div class="line"><span class="lineno"> 6160</span>            <span class="comment"># TODO: remove special-case; this is just to keep exception</span></div>
<div class="line"><span class="lineno"> 6161</span>            <span class="comment">#  message tests from raising while debugging</span></div>
<div class="line"><span class="lineno"> 6162</span>            use_interval_msg = is_interval_dtype(self.dtype) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno"> 6163</span>                is_categorical_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 6164</span>                <span class="comment"># &quot;Index&quot; has no attribute &quot;categories&quot;  [attr-defined]</span></div>
<div class="line"><span class="lineno"> 6165</span>                <span class="keywordflow">and</span> is_interval_dtype(</div>
<div class="line"><span class="lineno"> 6166</span>                    self.categories.dtype  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 6167</span>                )</div>
<div class="line"><span class="lineno"> 6168</span>            )</div>
<div class="line"><span class="lineno"> 6169</span> </div>
<div class="line"><span class="lineno"> 6170</span>            <span class="keywordflow">if</span> nmissing == len(indexer):</div>
<div class="line"><span class="lineno"> 6171</span>                <span class="keywordflow">if</span> use_interval_msg:</div>
<div class="line"><span class="lineno"> 6172</span>                    key = list(key)</div>
<div class="line"><span class="lineno"> 6173</span>                <span class="keywordflow">raise</span> KeyError(f<span class="stringliteral">&quot;None of [{key}] are in the [{axis_name}]&quot;</span>)</div>
<div class="line"><span class="lineno"> 6174</span> </div>
<div class="line"><span class="lineno"> 6175</span>            not_found = list(ensure_index(key)[missing_mask.nonzero()[0]].unique())</div>
<div class="line"><span class="lineno"> 6176</span>            <span class="keywordflow">raise</span> KeyError(f<span class="stringliteral">&quot;{not_found} not in index&quot;</span>)</div>
<div class="line"><span class="lineno"> 6177</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae532208b79d7ee99b9822ac88609c0ef" name="ae532208b79d7ee99b9822ac88609c0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae532208b79d7ee99b9822ac88609c0ef">&#9670;&#160;</a></span>_reindex_non_unique()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp], npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index._reindex_non_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>
    &#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a new index with target's values (move/add/delete values as
necessary) use with non-unique Index and a possibly non-unique target.

Parameters
----------
target : an iterable

Returns
-------
new_index : pd.Index
    Resulting index.
indexer : np.ndarray[np.intp]
    Indices of output values in original index.
new_indexer : np.ndarray[np.intp] or None</pre> <div class="fragment"><div class="line"><span class="lineno"> 4493</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp], npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4494</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4495</span><span class="stringliteral">        Create a new index with target&#39;s values (move/add/delete values as</span></div>
<div class="line"><span class="lineno"> 4496</span><span class="stringliteral">        necessary) use with non-unique Index and a possibly non-unique target.</span></div>
<div class="line"><span class="lineno"> 4497</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4498</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4499</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4500</span><span class="stringliteral">        target : an iterable</span></div>
<div class="line"><span class="lineno"> 4501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4502</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4503</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4504</span><span class="stringliteral">        new_index : pd.Index</span></div>
<div class="line"><span class="lineno"> 4505</span><span class="stringliteral">            Resulting index.</span></div>
<div class="line"><span class="lineno"> 4506</span><span class="stringliteral">        indexer : np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 4507</span><span class="stringliteral">            Indices of output values in original index.</span></div>
<div class="line"><span class="lineno"> 4508</span><span class="stringliteral">        new_indexer : np.ndarray[np.intp] or None</span></div>
<div class="line"><span class="lineno"> 4509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4510</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4511</span>        target = ensure_index(target)</div>
<div class="line"><span class="lineno"> 4512</span>        <span class="keywordflow">if</span> len(target) == 0:</div>
<div class="line"><span class="lineno"> 4513</span>            <span class="comment"># GH#13691</span></div>
<div class="line"><span class="lineno"> 4514</span>            <span class="keywordflow">return</span> self[:0], np.array([], dtype=np.intp), <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4515</span> </div>
<div class="line"><span class="lineno"> 4516</span>        indexer, missing = self.get_indexer_non_unique(target)</div>
<div class="line"><span class="lineno"> 4517</span>        check = indexer != -1</div>
<div class="line"><span class="lineno"> 4518</span>        new_labels = self.take(indexer[check])</div>
<div class="line"><span class="lineno"> 4519</span>        new_indexer = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4520</span> </div>
<div class="line"><span class="lineno"> 4521</span>        <span class="keywordflow">if</span> len(missing):</div>
<div class="line"><span class="lineno"> 4522</span>            length = np.arange(len(indexer), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4523</span> </div>
<div class="line"><span class="lineno"> 4524</span>            missing = ensure_platform_int(missing)</div>
<div class="line"><span class="lineno"> 4525</span>            missing_labels = target.take(missing)</div>
<div class="line"><span class="lineno"> 4526</span>            missing_indexer = length[~check]</div>
<div class="line"><span class="lineno"> 4527</span>            cur_labels = self.take(indexer[check]).values</div>
<div class="line"><span class="lineno"> 4528</span>            cur_indexer = length[check]</div>
<div class="line"><span class="lineno"> 4529</span> </div>
<div class="line"><span class="lineno"> 4530</span>            <span class="comment"># Index constructor below will do inference</span></div>
<div class="line"><span class="lineno"> 4531</span>            new_labels = np.empty((len(indexer),), dtype=object)</div>
<div class="line"><span class="lineno"> 4532</span>            new_labels[cur_indexer] = cur_labels</div>
<div class="line"><span class="lineno"> 4533</span>            new_labels[missing_indexer] = missing_labels</div>
<div class="line"><span class="lineno"> 4534</span> </div>
<div class="line"><span class="lineno"> 4535</span>            <span class="comment"># GH#38906</span></div>
<div class="line"><span class="lineno"> 4536</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno"> 4537</span> </div>
<div class="line"><span class="lineno"> 4538</span>                new_indexer = np.arange(0, dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4539</span> </div>
<div class="line"><span class="lineno"> 4540</span>            <span class="comment"># a unique indexer</span></div>
<div class="line"><span class="lineno"> 4541</span>            <span class="keywordflow">elif</span> target.is_unique:</div>
<div class="line"><span class="lineno"> 4542</span> </div>
<div class="line"><span class="lineno"> 4543</span>                <span class="comment"># see GH5553, make sure we use the right indexer</span></div>
<div class="line"><span class="lineno"> 4544</span>                new_indexer = np.arange(len(indexer), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4545</span>                new_indexer[cur_indexer] = np.arange(len(cur_labels))</div>
<div class="line"><span class="lineno"> 4546</span>                new_indexer[missing_indexer] = -1</div>
<div class="line"><span class="lineno"> 4547</span> </div>
<div class="line"><span class="lineno"> 4548</span>            <span class="comment"># we have a non_unique selector, need to use the original</span></div>
<div class="line"><span class="lineno"> 4549</span>            <span class="comment"># indexer here</span></div>
<div class="line"><span class="lineno"> 4550</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4551</span> </div>
<div class="line"><span class="lineno"> 4552</span>                <span class="comment"># need to retake to have the same size as the indexer</span></div>
<div class="line"><span class="lineno"> 4553</span>                indexer[~check] = -1</div>
<div class="line"><span class="lineno"> 4554</span> </div>
<div class="line"><span class="lineno"> 4555</span>                <span class="comment"># reset the new indexer to account for the new size</span></div>
<div class="line"><span class="lineno"> 4556</span>                new_indexer = np.arange(len(self.take(indexer)), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 4557</span>                new_indexer[~check] = -1</div>
<div class="line"><span class="lineno"> 4558</span> </div>
<div class="line"><span class="lineno"> 4559</span>        <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 4560</span>            new_index = type(self).from_tuples(new_labels, names=self.names)</div>
<div class="line"><span class="lineno"> 4561</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4562</span>            new_index = Index._with_infer(new_labels, name=self.name)</div>
<div class="line"><span class="lineno"> 4563</span>        <span class="keywordflow">return</span> new_index, indexer, new_indexer</div>
<div class="line"><span class="lineno"> 4564</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a17fe9bfb3c4fc2fc503230d33f37f9b7" name="a17fe9bfb3c4fc2fc503230d33f37f9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17fe9bfb3c4fc2fc503230d33f37f9b7">&#9670;&#160;</a></span>_rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._rename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">fastpath for rename if new name is already validated.
</pre> <div class="fragment"><div class="line"><span class="lineno">  832</span>    <span class="keyword">def </span>_rename(self: _IndexT, name: Hashable) -&gt; _IndexT:</div>
<div class="line"><span class="lineno">  833</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  834</span><span class="stringliteral">        fastpath for rename if new name is already validated.</span></div>
<div class="line"><span class="lineno">  835</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  836</span>        result = self._view()</div>
<div class="line"><span class="lineno">  837</span>        result._name = name</div>
<div class="line"><span class="lineno">  838</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  839</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35f6899ca731408a1e44e4aecfba2212" name="a35f6899ca731408a1e44e4aecfba2212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f6899ca731408a1e44e4aecfba2212">&#9670;&#160;</a></span>_require_scalar()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._require_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check that this is a scalar value that we can use for setitem-like
operations without changing dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5270</span>    <span class="keyword">def </span>_require_scalar(self, value):</div>
<div class="line"><span class="lineno"> 5271</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5272</span><span class="stringliteral">        Check that this is a scalar value that we can use for setitem-like</span></div>
<div class="line"><span class="lineno"> 5273</span><span class="stringliteral">        operations without changing dtype.</span></div>
<div class="line"><span class="lineno"> 5274</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5275</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(value):</div>
<div class="line"><span class="lineno"> 5276</span>            <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;&#39;value&#39; must be a scalar, passed: {type(value).__name__}&quot;</span>)</div>
<div class="line"><span class="lineno"> 5277</span>        <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 5278</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a00092020db82b9221f95f166811794" name="a6a00092020db82b9221f95f166811794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a00092020db82b9221f95f166811794">&#9670;&#160;</a></span>_reset_identity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._reset_identity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Initializes or resets ``_id`` attribute with new object.
</pre> <div class="fragment"><div class="line"><span class="lineno">  872</span>    <span class="keyword">def </span>_reset_identity(self) -&gt; None:</div>
<div class="line"><span class="lineno">  873</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">        Initializes or resets ``_id`` attribute with new object.</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  876</span>        self._id = object()</div>
<div class="line"><span class="lineno">  877</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8e1d16c2d614fd1262a4e918e39eaaac" name="a8e1d16c2d614fd1262a4e918e39eaaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1d16c2d614fd1262a4e918e39eaaac">&#9670;&#160;</a></span>_scalar_data_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._scalar_data_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5231</span>    <span class="keyword">def </span>_scalar_data_error(cls, data):</div>
<div class="line"><span class="lineno"> 5232</span>        <span class="comment"># We return the TypeError so that we can raise it from the constructor</span></div>
<div class="line"><span class="lineno"> 5233</span>        <span class="comment">#  in order to keep mypy happy</span></div>
<div class="line"><span class="lineno"> 5234</span>        <span class="keywordflow">return</span> TypeError(</div>
<div class="line"><span class="lineno"> 5235</span>            f<span class="stringliteral">&quot;{cls.__name__}(...) must be called with a collection of some &quot;</span></div>
<div class="line"><span class="lineno"> 5236</span>            f<span class="stringliteral">&quot;kind, {repr(data)} was passed&quot;</span></div>
<div class="line"><span class="lineno"> 5237</span>        )</div>
<div class="line"><span class="lineno"> 5238</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="addcfdb0432ad6e66a483b5d31957f013" name="addcfdb0432ad6e66a483b5d31957f013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addcfdb0432ad6e66a483b5d31957f013">&#9670;&#160;</a></span>_searchsorted_monotonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._searchsorted_monotonic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;left&quot;, &quot;right&quot;] &#160;</td>
          <td class="paramname"><em>side</em> = <code>&quot;left&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a8f7196f7595afdec553348fe3f14c765">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6670</span>    <span class="keyword">def </span>_searchsorted_monotonic(self, label, side: Literal[<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>] = <span class="stringliteral">&quot;left&quot;</span>):</div>
<div class="line"><span class="lineno"> 6671</span>        <span class="keywordflow">if</span> self.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 6672</span>            <span class="keywordflow">return</span> self.searchsorted(label, side=side)</div>
<div class="line"><span class="lineno"> 6673</span>        <span class="keywordflow">elif</span> self.is_monotonic_decreasing:</div>
<div class="line"><span class="lineno"> 6674</span>            <span class="comment"># np.searchsorted expects ascending sort order, have to reverse</span></div>
<div class="line"><span class="lineno"> 6675</span>            <span class="comment"># everything for it to work (element ordering, search side and</span></div>
<div class="line"><span class="lineno"> 6676</span>            <span class="comment"># resulting value).</span></div>
<div class="line"><span class="lineno"> 6677</span>            pos = self[::-1].searchsorted(</div>
<div class="line"><span class="lineno"> 6678</span>                label, side=<span class="stringliteral">&quot;right&quot;</span> <span class="keywordflow">if</span> side == <span class="stringliteral">&quot;left&quot;</span> <span class="keywordflow">else</span> <span class="stringliteral">&quot;left&quot;</span></div>
<div class="line"><span class="lineno"> 6679</span>            )</div>
<div class="line"><span class="lineno"> 6680</span>            <span class="keywordflow">return</span> len(self) - pos</div>
<div class="line"><span class="lineno"> 6681</span> </div>
<div class="line"><span class="lineno"> 6682</span>        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;index must be monotonic increasing or decreasing&quot;</span>)</div>
<div class="line"><span class="lineno"> 6683</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5698e03a836f4b2113d3002def90aba7" name="a5698e03a836f4b2113d3002def90aba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5698e03a836f4b2113d3002def90aba7">&#9670;&#160;</a></span>_set_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._set_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Set new names on index. Each name has to be a hashable type.

Parameters
----------
values : str or sequence
    name(s) to set
level : int, level name, or sequence of int/level names (default None)
    If the index is a MultiIndex (hierarchical), level(s) to set (None
    for all levels).  Otherwise level must be None

Raises
------
TypeError if each name is not hashable.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ae3e36922ddb02e9af293a668aeeb1a27">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1824</span>    <span class="keyword">def </span>_set_names(self, values, *, level=None) -&gt; None:</div>
<div class="line"><span class="lineno"> 1825</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1826</span><span class="stringliteral">        Set new names on index. Each name has to be a hashable type.</span></div>
<div class="line"><span class="lineno"> 1827</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1828</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1829</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1830</span><span class="stringliteral">        values : str or sequence</span></div>
<div class="line"><span class="lineno"> 1831</span><span class="stringliteral">            name(s) to set</span></div>
<div class="line"><span class="lineno"> 1832</span><span class="stringliteral">        level : int, level name, or sequence of int/level names (default None)</span></div>
<div class="line"><span class="lineno"> 1833</span><span class="stringliteral">            If the index is a MultiIndex (hierarchical), level(s) to set (None</span></div>
<div class="line"><span class="lineno"> 1834</span><span class="stringliteral">            for all levels).  Otherwise level must be None</span></div>
<div class="line"><span class="lineno"> 1835</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1836</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 1837</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 1838</span><span class="stringliteral">        TypeError if each name is not hashable.</span></div>
<div class="line"><span class="lineno"> 1839</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1840</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(values):</div>
<div class="line"><span class="lineno"> 1841</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Names must be a list-like&quot;</span>)</div>
<div class="line"><span class="lineno"> 1842</span>        <span class="keywordflow">if</span> len(values) != 1:</div>
<div class="line"><span class="lineno"> 1843</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Length of new names must be 1, got {len(values)}&quot;</span>)</div>
<div class="line"><span class="lineno"> 1844</span> </div>
<div class="line"><span class="lineno"> 1845</span>        <span class="comment"># GH 20527</span></div>
<div class="line"><span class="lineno"> 1846</span>        <span class="comment"># All items in &#39;name&#39; need to be hashable:</span></div>
<div class="line"><span class="lineno"> 1847</span>        validate_all_hashable(*values, error_name=f<span class="stringliteral">&quot;{type(self).__name__}.name&quot;</span>)</div>
<div class="line"><span class="lineno"> 1848</span> </div>
<div class="line"><span class="lineno"> 1849</span>        self._name = values[0]</div>
<div class="line"><span class="lineno"> 1850</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a204b0034440abde8761bc75b20bf2fdb" name="a204b0034440abde8761bc75b20bf2fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204b0034440abde8761bc75b20bf2fdb">&#9670;&#160;</a></span>_shallow_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._shallow_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Create a new Index with the same class as the caller, don't copy the
data, use the same object attributes with passed in attributes taking
precedence.

*this is an internal non-public method*

Parameters
----------
values : the values to create the new Index, optional
name : Label, defaults to self.name
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a736d07b13361a74ed74583572efb3768">pandas.core.indexes.multi.MultiIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#a58db85f1e236955134ff19e952570640">pandas.core.indexes.numeric.NumericIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a6186f26b39a0eeba8bee8215ac113fa8">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  805</span>    <span class="keyword">def </span>_shallow_copy(self: _IndexT, values, name: Hashable = no_default) -&gt; _IndexT:</div>
<div class="line"><span class="lineno">  806</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  807</span><span class="stringliteral">        Create a new Index with the same class as the caller, don&#39;t copy the</span></div>
<div class="line"><span class="lineno">  808</span><span class="stringliteral">        data, use the same object attributes with passed in attributes taking</span></div>
<div class="line"><span class="lineno">  809</span><span class="stringliteral">        precedence.</span></div>
<div class="line"><span class="lineno">  810</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  811</span><span class="stringliteral">        *this is an internal non-public method*</span></div>
<div class="line"><span class="lineno">  812</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  813</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  814</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  815</span><span class="stringliteral">        values : the values to create the new Index, optional</span></div>
<div class="line"><span class="lineno">  816</span><span class="stringliteral">        name : Label, defaults to self.name</span></div>
<div class="line"><span class="lineno">  817</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  818</span>        name = self._name <span class="keywordflow">if</span> name <span class="keywordflow">is</span> no_default <span class="keywordflow">else</span> name</div>
<div class="line"><span class="lineno">  819</span> </div>
<div class="line"><span class="lineno">  820</span>        <span class="keywordflow">return</span> self._simple_new(values, name=name)</div>
<div class="line"><span class="lineno">  821</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4ed96728036a7ea14abeb0e1ed341610" name="a4ed96728036a7ea14abeb0e1ed341610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed96728036a7ea14abeb0e1ed341610">&#9670;&#160;</a></span>_should_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._should_compare </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if `self == other` can ever have non-False entries.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6329</span>    <span class="keyword">def </span>_should_compare(self, other: Index) -&gt; bool:</div>
<div class="line"><span class="lineno"> 6330</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6331</span><span class="stringliteral">        Check if `self == other` can ever have non-False entries.</span></div>
<div class="line"><span class="lineno"> 6332</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6333</span> </div>
<div class="line"><span class="lineno"> 6334</span>        <span class="keywordflow">if</span> (other.is_boolean() <span class="keywordflow">and</span> self.is_numeric()) <span class="keywordflow">or</span> (</div>
<div class="line"><span class="lineno"> 6335</span>            self.is_boolean() <span class="keywordflow">and</span> other.is_numeric()</div>
<div class="line"><span class="lineno"> 6336</span>        ):</div>
<div class="line"><span class="lineno"> 6337</span>            <span class="comment"># GH#16877 Treat boolean labels passed to a numeric index as not</span></div>
<div class="line"><span class="lineno"> 6338</span>            <span class="comment">#  found. Without this fix False and True would be treated as 0 and 1</span></div>
<div class="line"><span class="lineno"> 6339</span>            <span class="comment">#  respectively.</span></div>
<div class="line"><span class="lineno"> 6340</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 6341</span> </div>
<div class="line"><span class="lineno"> 6342</span>        other = unpack_nested_dtype(other)</div>
<div class="line"><span class="lineno"> 6343</span>        dtype = other.dtype</div>
<div class="line"><span class="lineno"> 6344</span>        <span class="keywordflow">return</span> self._is_comparable_dtype(dtype) <span class="keywordflow">or</span> is_object_dtype(dtype)</div>
<div class="line"><span class="lineno"> 6345</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b2861ae82da69581e339915875a91cc" name="a3b2861ae82da69581e339915875a91cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2861ae82da69581e339915875a91cc">&#9670;&#160;</a></span>_should_fallback_to_positional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._should_fallback_to_positional </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Should an integer key be treated as positional?
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a898d194813ff6c6fabeec0edbe91d5d1">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a2024d26595b3aa68a051a2b4af7aa7d1">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#afcaec8956292ff4e023784b846eac0de">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#aaaef8841f132f580bc35f545ab8b5617">pandas.core.indexes.numeric.NumericIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5971</span>    <span class="keyword">def </span>_should_fallback_to_positional(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5972</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5973</span><span class="stringliteral">        Should an integer key be treated as positional?</span></div>
<div class="line"><span class="lineno"> 5974</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5975</span>        <span class="keywordflow">return</span> <span class="keywordflow">not</span> self.holds_integer()</div>
<div class="line"><span class="lineno"> 5976</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a556f72b484804d2e4fb98872fe8cd28d" name="a556f72b484804d2e4fb98872fe8cd28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a556f72b484804d2e4fb98872fe8cd28d">&#9670;&#160;</a></span>_should_partial_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index._should_partial_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Should we attempt partial-matching indexing?
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4006</span>    <span class="keyword">def </span>_should_partial_index(self, target: Index) -&gt; bool:</div>
<div class="line"><span class="lineno"> 4007</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4008</span><span class="stringliteral">        Should we attempt partial-matching indexing?</span></div>
<div class="line"><span class="lineno"> 4009</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4010</span>        <span class="keywordflow">if</span> is_interval_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 4011</span>            <span class="keywordflow">if</span> is_interval_dtype(target.dtype):</div>
<div class="line"><span class="lineno"> 4012</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4013</span>            <span class="comment"># See https://github.com/pandas-dev/pandas/issues/47772 the commented</span></div>
<div class="line"><span class="lineno"> 4014</span>            <span class="comment"># out code can be restored (instead of hardcoding `return True`)</span></div>
<div class="line"><span class="lineno"> 4015</span>            <span class="comment"># once that issue if fixed</span></div>
<div class="line"><span class="lineno"> 4016</span>            <span class="comment"># &quot;Index&quot; has no attribute &quot;left&quot;</span></div>
<div class="line"><span class="lineno"> 4017</span>            <span class="comment"># return self.left._should_compare(target)  # type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 4018</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4019</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 4020</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac39d842c3e375fd53ee600305fb84a14" name="ac39d842c3e375fd53ee600305fb84a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39d842c3e375fd53ee600305fb84a14">&#9670;&#160;</a></span>_simple_new()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._simple_new </td>
          <td>(</td>
          <td class="paramtype">type[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>]&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">We require that we have a dtype compat for the values. If we are passed
a non-dtype compat, then coerce using the constructor.

Must be careful not to recurse.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a5d8fa4e09e126e51d9418c180b8cfe9e">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  692</span>    <span class="keyword">def </span>_simple_new(cls: type[_IndexT], values, name: Hashable = <span class="keywordtype">None</span>) -&gt; _IndexT:</div>
<div class="line"><span class="lineno">  693</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        We require that we have a dtype compat for the values. If we are passed</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        a non-dtype compat, then coerce using the constructor.</span></div>
<div class="line"><span class="lineno">  696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  697</span><span class="stringliteral">        Must be careful not to recurse.</span></div>
<div class="line"><span class="lineno">  698</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  699</span>        <span class="keyword">assert</span> isinstance(values, cls._data_cls), type(values)</div>
<div class="line"><span class="lineno">  700</span> </div>
<div class="line"><span class="lineno">  701</span>        result = object.__new__(cls)</div>
<div class="line"><span class="lineno">  702</span>        result._data = values</div>
<div class="line"><span class="lineno">  703</span>        result._name = name</div>
<div class="line"><span class="lineno">  704</span>        result._cache = {}</div>
<div class="line"><span class="lineno">  705</span>        result._reset_identity()</div>
<div class="line"><span class="lineno">  706</span> </div>
<div class="line"><span class="lineno">  707</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  708</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9776b9d20de2e575f790a31645421d1f" name="a9776b9d20de2e575f790a31645421d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9776b9d20de2e575f790a31645421d1f">&#9670;&#160;</a></span>_sort_levels_monotonic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._sort_levels_monotonic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compat with MultiIndex.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a0252440fb02a8a2a46b6b75605ce009a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2025</span>    <span class="keyword">def </span>_sort_levels_monotonic(self: _IndexT) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 2026</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2027</span><span class="stringliteral">        Compat with MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2028</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2029</span>        <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno"> 2030</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f65ecaa6cd031c127c61065dbfda34f" name="a5f65ecaa6cd031c127c61065dbfda34f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f65ecaa6cd031c127c61065dbfda34f">&#9670;&#160;</a></span>_string_data_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._string_data_error </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 5241</span>    <span class="keyword">def </span>_string_data_error(cls, data):</div>
<div class="line"><span class="lineno"> 5242</span>        <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 5243</span>            <span class="stringliteral">&quot;String dtype not supported, you may need &quot;</span></div>
<div class="line"><span class="lineno"> 5244</span>            <span class="stringliteral">&quot;to explicitly cast to a numeric type&quot;</span></div>
<div class="line"><span class="lineno"> 5245</span>        )</div>
<div class="line"><span class="lineno"> 5246</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a480dee6a00f852534deaef4a82216bc0" name="a480dee6a00f852534deaef4a82216bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480dee6a00f852534deaef4a82216bc0">&#9670;&#160;</a></span>_summary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> pandas.core.indexes.base.Index._summary </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return a summarized representation.

Parameters
----------
name : str
    name to use in the summary representation

Returns
-------
String with a summarized representation of the index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a4f77683839abbf8dc513ac1a9939c8b6">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1541</span>    <span class="keyword">def </span>_summary(self, name=None) -&gt; str_t:</div>
<div class="line"><span class="lineno"> 1542</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1543</span><span class="stringliteral">        Return a summarized representation.</span></div>
<div class="line"><span class="lineno"> 1544</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1545</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1546</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1547</span><span class="stringliteral">        name : str</span></div>
<div class="line"><span class="lineno"> 1548</span><span class="stringliteral">            name to use in the summary representation</span></div>
<div class="line"><span class="lineno"> 1549</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1550</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1551</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1552</span><span class="stringliteral">        String with a summarized representation of the index</span></div>
<div class="line"><span class="lineno"> 1553</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1554</span>        <span class="keywordflow">if</span> len(self) &gt; 0:</div>
<div class="line"><span class="lineno"> 1555</span>            head = self[0]</div>
<div class="line"><span class="lineno"> 1556</span>            <span class="keywordflow">if</span> hasattr(head, <span class="stringliteral">&quot;format&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(head, str):</div>
<div class="line"><span class="lineno"> 1557</span>                head = head.format()</div>
<div class="line"><span class="lineno"> 1558</span>            <span class="keywordflow">elif</span> needs_i8_conversion(self.dtype):</div>
<div class="line"><span class="lineno"> 1559</span>                <span class="comment"># e.g. Timedelta, display as values, not quoted</span></div>
<div class="line"><span class="lineno"> 1560</span>                head = self._formatter_func(head).replace(<span class="stringliteral">&quot;&#39;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1561</span>            tail = self[-1]</div>
<div class="line"><span class="lineno"> 1562</span>            <span class="keywordflow">if</span> hasattr(tail, <span class="stringliteral">&quot;format&quot;</span>) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(tail, str):</div>
<div class="line"><span class="lineno"> 1563</span>                tail = tail.format()</div>
<div class="line"><span class="lineno"> 1564</span>            <span class="keywordflow">elif</span> needs_i8_conversion(self.dtype):</div>
<div class="line"><span class="lineno"> 1565</span>                <span class="comment"># e.g. Timedelta, display as values, not quoted</span></div>
<div class="line"><span class="lineno"> 1566</span>                tail = self._formatter_func(tail).replace(<span class="stringliteral">&quot;&#39;&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line"><span class="lineno"> 1567</span> </div>
<div class="line"><span class="lineno"> 1568</span>            index_summary = f<span class="stringliteral">&quot;, {head} to {tail}&quot;</span></div>
<div class="line"><span class="lineno"> 1569</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1570</span>            index_summary = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1571</span> </div>
<div class="line"><span class="lineno"> 1572</span>        <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1573</span>            name = type(self).__name__</div>
<div class="line"><span class="lineno"> 1574</span>        <span class="keywordflow">return</span> f<span class="stringliteral">&quot;{name}: {len(self)} entries{index_summary}&quot;</span></div>
<div class="line"><span class="lineno"> 1575</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7101105dfd70acc9d468f7abf5605090" name="a7101105dfd70acc9d468f7abf5605090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7101105dfd70acc9d468f7abf5605090">&#9670;&#160;</a></span>_transform_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index._transform_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Apply function to all values found in index.

This includes transforming multiindex entries separately.
Only apply function to one level of the MultiIndex if level is specified.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6441</span>    <span class="keyword">def </span>_transform_index(self, func, *, level=None) -&gt; Index:</div>
<div class="line"><span class="lineno"> 6442</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6443</span><span class="stringliteral">        Apply function to all values found in index.</span></div>
<div class="line"><span class="lineno"> 6444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6445</span><span class="stringliteral">        This includes transforming multiindex entries separately.</span></div>
<div class="line"><span class="lineno"> 6446</span><span class="stringliteral">        Only apply function to one level of the MultiIndex if level is specified.</span></div>
<div class="line"><span class="lineno"> 6447</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6448</span>        <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 6449</span>            <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6450</span>                <span class="comment"># Caller is responsible for ensuring level is positional.</span></div>
<div class="line"><span class="lineno"> 6451</span>                items = [</div>
<div class="line"><span class="lineno"> 6452</span>                    tuple(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(y) <span class="keywordflow">if</span> i == level <span class="keywordflow">else</span> y <span class="keywordflow">for</span> i, y <span class="keywordflow">in</span> enumerate(x))</div>
<div class="line"><span class="lineno"> 6453</span>                    <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self</div>
<div class="line"><span class="lineno"> 6454</span>                ]</div>
<div class="line"><span class="lineno"> 6455</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6456</span>                items = [tuple(<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(y) <span class="keywordflow">for</span> y <span class="keywordflow">in</span> x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self]</div>
<div class="line"><span class="lineno"> 6457</span>            <span class="keywordflow">return</span> type(self).from_tuples(items, names=self.names)</div>
<div class="line"><span class="lineno"> 6458</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6459</span>            items = [<a class="code hl_function" href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a>(x) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> self]</div>
<div class="line"><span class="lineno"> 6460</span>            <span class="keywordflow">return</span> Index(items, name=self.name, tupleize_cols=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 6461</span> </div>
<div class="ttc" id="acallback_2foo_8f_html_a565fe2cc583df102f120752b0011c330"><div class="ttname"><a href="callback_2foo_8f.html#a565fe2cc583df102f120752b0011c330">func</a></div><div class="ttdeci">subroutine func(a)</div><div class="ttdef"><b>Definition</b> foo.f:9</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa87d7e44eb54356256b84292944aa8d4" name="aa87d7e44eb54356256b84292944aa8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87d7e44eb54356256b84292944aa8d4">&#9670;&#160;</a></span>_unary_method()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._unary_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 7053</span>    <span class="keyword">def </span>_unary_method(self, op):</div>
<div class="line"><span class="lineno"> 7054</span>        result = op(self._values)</div>
<div class="line"><span class="lineno"> 7055</span>        <span class="keywordflow">return</span> Index(result, name=self.name)</div>
<div class="line"><span class="lineno"> 7056</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="adfddd70684cefa1ba1d124cd10e3076e" name="adfddd70684cefa1ba1d124cd10e3076e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfddd70684cefa1ba1d124cd10e3076e">&#9670;&#160;</a></span>_union()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Specific union logic should go here. In subclasses, union behavior
should be overwritten here rather than in `self.union`.

Parameters
----------
other : Index or array-like
sort : False or None, default False
    Whether to sort the resulting index.

    * False : do not sort the result.
    * None : sort the result, except when `self` and `other` are equal
      or when the values cannot be compared.

Returns
-------
Index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8439e982d47b25e1a1ad2f1f4ce291b6">pandas.core.indexes.range.RangeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a3979bec4b3486da4f27894616bcbe2b0">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aa30889f4af9d13612a191b7480a590d5">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3359</span>    <span class="keyword">def </span>_union(self, other: Index, sort):</div>
<div class="line"><span class="lineno"> 3360</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3361</span><span class="stringliteral">        Specific union logic should go here. In subclasses, union behavior</span></div>
<div class="line"><span class="lineno"> 3362</span><span class="stringliteral">        should be overwritten here rather than in `self.union`.</span></div>
<div class="line"><span class="lineno"> 3363</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3364</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3365</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3366</span><span class="stringliteral">        other : Index or array-like</span></div>
<div class="line"><span class="lineno"> 3367</span><span class="stringliteral">        sort : False or None, default False</span></div>
<div class="line"><span class="lineno"> 3368</span><span class="stringliteral">            Whether to sort the resulting index.</span></div>
<div class="line"><span class="lineno"> 3369</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3370</span><span class="stringliteral">            * False : do not sort the result.</span></div>
<div class="line"><span class="lineno"> 3371</span><span class="stringliteral">            * None : sort the result, except when `self` and `other` are equal</span></div>
<div class="line"><span class="lineno"> 3372</span><span class="stringliteral">              or when the values cannot be compared.</span></div>
<div class="line"><span class="lineno"> 3373</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3374</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3375</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3376</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 3377</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3378</span>        lvals = self._values</div>
<div class="line"><span class="lineno"> 3379</span>        rvals = other._values</div>
<div class="line"><span class="lineno"> 3380</span> </div>
<div class="line"><span class="lineno"> 3381</span>        <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3382</span>            sort <span class="keywordflow">is</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 3383</span>            <span class="keywordflow">and</span> self.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 3384</span>            <span class="keywordflow">and</span> other.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 3385</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> (self.has_duplicates <span class="keywordflow">and</span> other.has_duplicates)</div>
<div class="line"><span class="lineno"> 3386</span>            <span class="keywordflow">and</span> self._can_use_libjoin</div>
<div class="line"><span class="lineno"> 3387</span>        ):</div>
<div class="line"><span class="lineno"> 3388</span>            <span class="comment"># Both are monotonic and at least one is unique, so can use outer join</span></div>
<div class="line"><span class="lineno"> 3389</span>            <span class="comment">#  (actually don&#39;t need either unique, but without this restriction</span></div>
<div class="line"><span class="lineno"> 3390</span>            <span class="comment">#  test_union_same_value_duplicated_in_both fails)</span></div>
<div class="line"><span class="lineno"> 3391</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3392</span>                <span class="keywordflow">return</span> self._outer_indexer(other)[0]</div>
<div class="line"><span class="lineno"> 3393</span>            <span class="keywordflow">except</span> (TypeError, IncompatibleFrequency):</div>
<div class="line"><span class="lineno"> 3394</span>                <span class="comment"># incomparable objects; should only be for object dtype</span></div>
<div class="line"><span class="lineno"> 3395</span>                value_list = list(lvals)</div>
<div class="line"><span class="lineno"> 3396</span> </div>
<div class="line"><span class="lineno"> 3397</span>                <span class="comment"># worth making this faster? a very unusual case</span></div>
<div class="line"><span class="lineno"> 3398</span>                value_set = set(lvals)</div>
<div class="line"><span class="lineno"> 3399</span>                value_list.extend([x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> rvals <span class="keywordflow">if</span> x <span class="keywordflow">not</span> <span class="keywordflow">in</span> value_set])</div>
<div class="line"><span class="lineno"> 3400</span>                <span class="comment"># If objects are unorderable, we must have object dtype.</span></div>
<div class="line"><span class="lineno"> 3401</span>                <span class="keywordflow">return</span> np.array(value_list, dtype=object)</div>
<div class="line"><span class="lineno"> 3402</span> </div>
<div class="line"><span class="lineno"> 3403</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> other.is_unique:</div>
<div class="line"><span class="lineno"> 3404</span>            <span class="comment"># other has duplicates</span></div>
<div class="line"><span class="lineno"> 3405</span>            result = algos.union_with_duplicates(lvals, rvals)</div>
<div class="line"><span class="lineno"> 3406</span>            <span class="keywordflow">return</span> _maybe_try_sort(result, sort)</div>
<div class="line"><span class="lineno"> 3407</span> </div>
<div class="line"><span class="lineno"> 3408</span>        <span class="comment"># Self may have duplicates; other already checked as unique</span></div>
<div class="line"><span class="lineno"> 3409</span>        <span class="comment"># find indexes of things in &quot;other&quot; that are not in &quot;self&quot;</span></div>
<div class="line"><span class="lineno"> 3410</span>        <span class="keywordflow">if</span> self._index_as_unique:</div>
<div class="line"><span class="lineno"> 3411</span>            indexer = self.get_indexer(other)</div>
<div class="line"><span class="lineno"> 3412</span>            missing = (indexer == -1).nonzero()[0]</div>
<div class="line"><span class="lineno"> 3413</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3414</span>            missing = algos.unique1d(self.get_indexer_non_unique(other)[1])</div>
<div class="line"><span class="lineno"> 3415</span> </div>
<div class="line"><span class="lineno"> 3416</span>        <span class="keywordflow">if</span> len(missing) &gt; 0:</div>
<div class="line"><span class="lineno"> 3417</span>            other_diff = rvals.take(missing)</div>
<div class="line"><span class="lineno"> 3418</span>            result = concat_compat((lvals, other_diff))</div>
<div class="line"><span class="lineno"> 3419</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3420</span>            result = lvals</div>
<div class="line"><span class="lineno"> 3421</span> </div>
<div class="line"><span class="lineno"> 3422</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.is_monotonic_increasing <span class="keywordflow">or</span> <span class="keywordflow">not</span> other.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 3423</span>            <span class="comment"># if both are monotonic then result should already be sorted</span></div>
<div class="line"><span class="lineno"> 3424</span>            result = _maybe_try_sort(result, sort)</div>
<div class="line"><span class="lineno"> 3425</span> </div>
<div class="line"><span class="lineno"> 3426</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3427</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94ece674a4d44b8d9911200613d7055a" name="a94ece674a4d44b8d9911200613d7055a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ece674a4d44b8d9911200613d7055a">&#9670;&#160;</a></span>_validate_can_reindex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._validate_can_reindex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">np.ndarray&#160;</td>
          <td class="paramname"><em>indexer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if we are allowing reindexing with this particular indexer.

Parameters
----------
indexer : an integer ndarray

Raises
------
ValueError if its a duplicate axis
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4345</span>    <span class="keyword">def </span>_validate_can_reindex(self, indexer: np.ndarray) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4346</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4347</span><span class="stringliteral">        Check if we are allowing reindexing with this particular indexer.</span></div>
<div class="line"><span class="lineno"> 4348</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4349</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4350</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4351</span><span class="stringliteral">        indexer : an integer ndarray</span></div>
<div class="line"><span class="lineno"> 4352</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4353</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 4354</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 4355</span><span class="stringliteral">        ValueError if its a duplicate axis</span></div>
<div class="line"><span class="lineno"> 4356</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4357</span>        <span class="comment"># trying to reindex on an axis with duplicates</span></div>
<div class="line"><span class="lineno"> 4358</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._index_as_unique <span class="keywordflow">and</span> len(indexer):</div>
<div class="line"><span class="lineno"> 4359</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot reindex on an axis with duplicate labels&quot;</span>)</div>
<div class="line"><span class="lineno"> 4360</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa5c39830f88371a4bbda4a182fe34e73" name="aa5c39830f88371a4bbda4a182fe34e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c39830f88371a4bbda4a182fe34e73">&#9670;&#160;</a></span>_validate_fill_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._validate_fill_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if the value can be inserted into our array without casting,
and convert it to an appropriate native type if necessary.

Raises
------
TypeError
    If the value cannot be inserted into an array of this dtype.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ab1e2280e7c013861f8820a9efe05ee0d">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1extension_1_1_extension_index.html#aa15aa42cffe7081c2628257c4b9c670e">pandas.core.indexes.extension.ExtensionIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5247</span>    <span class="keyword">def </span>_validate_fill_value(self, value):</div>
<div class="line"><span class="lineno"> 5248</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5249</span><span class="stringliteral">        Check if the value can be inserted into our array without casting,</span></div>
<div class="line"><span class="lineno"> 5250</span><span class="stringliteral">        and convert it to an appropriate native type if necessary.</span></div>
<div class="line"><span class="lineno"> 5251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5252</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 5253</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 5254</span><span class="stringliteral">        TypeError</span></div>
<div class="line"><span class="lineno"> 5255</span><span class="stringliteral">            If the value cannot be inserted into an array of this dtype.</span></div>
<div class="line"><span class="lineno"> 5256</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5257</span>        dtype = self.dtype</div>
<div class="line"><span class="lineno"> 5258</span>        <span class="keywordflow">if</span> isinstance(dtype, np.dtype) <span class="keywordflow">and</span> dtype.kind <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno"> 5259</span>            <span class="comment"># return np_can_hold_element(dtype, value)</span></div>
<div class="line"><span class="lineno"> 5260</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5261</span>                <span class="keywordflow">return</span> np_can_hold_element(dtype, value)</div>
<div class="line"><span class="lineno"> 5262</span>            <span class="keywordflow">except</span> LossySetitemError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 5263</span>                <span class="comment"># re-raise as TypeError for consistency</span></div>
<div class="line"><span class="lineno"> 5264</span>                <span class="keywordflow">raise</span> TypeError <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 5265</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> can_hold_element(self._values, value):</div>
<div class="line"><span class="lineno"> 5266</span>            <span class="keywordflow">raise</span> TypeError</div>
<div class="line"><span class="lineno"> 5267</span>        <span class="keywordflow">return</span> value</div>
<div class="line"><span class="lineno"> 5268</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a560cee64a9c2336cbfc21a12f7b20a0a" name="a560cee64a9c2336cbfc21a12f7b20a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a560cee64a9c2336cbfc21a12f7b20a0a">&#9670;&#160;</a></span>_validate_index_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._validate_index_level </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Validate index level.

For single-level Index getting level number is a no-op, but some
verification must be done like in MultiIndex.</pre> <div class="fragment"><div class="line"><span class="lineno"> 2032</span>    <span class="keyword">def </span>_validate_index_level(self, level) -&gt; None:</div>
<div class="line"><span class="lineno"> 2033</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2034</span><span class="stringliteral">        Validate index level.</span></div>
<div class="line"><span class="lineno"> 2035</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2036</span><span class="stringliteral">        For single-level Index getting level number is a no-op, but some</span></div>
<div class="line"><span class="lineno"> 2037</span><span class="stringliteral">        verification must be done like in MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2039</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2040</span>        <span class="keywordflow">if</span> isinstance(level, int):</div>
<div class="line"><span class="lineno"> 2041</span>            <span class="keywordflow">if</span> level &lt; 0 <span class="keywordflow">and</span> level != -1:</div>
<div class="line"><span class="lineno"> 2042</span>                <span class="keywordflow">raise</span> IndexError(</div>
<div class="line"><span class="lineno"> 2043</span>                    <span class="stringliteral">&quot;Too many levels: Index has only 1 level, &quot;</span></div>
<div class="line"><span class="lineno"> 2044</span>                    f<span class="stringliteral">&quot;{level} is not a valid level number&quot;</span></div>
<div class="line"><span class="lineno"> 2045</span>                )</div>
<div class="line"><span class="lineno"> 2046</span>            <span class="keywordflow">elif</span> level &gt; 0:</div>
<div class="line"><span class="lineno"> 2047</span>                <span class="keywordflow">raise</span> IndexError(</div>
<div class="line"><span class="lineno"> 2048</span>                    f<span class="stringliteral">&quot;Too many levels: Index has only 1 level, not {level + 1}&quot;</span></div>
<div class="line"><span class="lineno"> 2049</span>                )</div>
<div class="line"><span class="lineno"> 2050</span>        <span class="keywordflow">elif</span> level != self.name:</div>
<div class="line"><span class="lineno"> 2051</span>            <span class="keywordflow">raise</span> KeyError(</div>
<div class="line"><span class="lineno"> 2052</span>                f<span class="stringliteral">&quot;Requested level ({level}) does not match index name ({self.name})&quot;</span></div>
<div class="line"><span class="lineno"> 2053</span>            )</div>
<div class="line"><span class="lineno"> 2054</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a135360c48e1a35f5576dc734c760f26a" name="a135360c48e1a35f5576dc734c760f26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135360c48e1a35f5576dc734c760f26a">&#9670;&#160;</a></span>_validate_indexer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._validate_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>form</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">If we are positional indexer, validate that we have appropriate
typed bounds must be an integer.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6626</span>    <span class="keyword">def </span>_validate_indexer(self, form: str_t, key, kind: str_t):</div>
<div class="line"><span class="lineno"> 6627</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6628</span><span class="stringliteral">        If we are positional indexer, validate that we have appropriate</span></div>
<div class="line"><span class="lineno"> 6629</span><span class="stringliteral">        typed bounds must be an integer.</span></div>
<div class="line"><span class="lineno"> 6630</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6631</span>        <span class="keyword">assert</span> kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;getitem&quot;</span>, <span class="stringliteral">&quot;iloc&quot;</span>]</div>
<div class="line"><span class="lineno"> 6632</span> </div>
<div class="line"><span class="lineno"> 6633</span>        <span class="keywordflow">if</span> key <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_integer(key):</div>
<div class="line"><span class="lineno"> 6634</span>            <span class="keywordflow">raise</span> self._invalid_indexer(form, key)</div>
<div class="line"><span class="lineno"> 6635</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a03721b134ec56c1dd0d644a65adf4a04" name="a03721b134ec56c1dd0d644a65adf4a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03721b134ec56c1dd0d644a65adf4a04">&#9670;&#160;</a></span>_validate_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[Hashable] pandas.core.indexes.base.Index._validate_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deep</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Handles the quirks of having a singular 'name' parameter for general
Index and plural 'names' parameter for MultiIndex.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1756</span>    ) -&gt; list[Hashable]:</div>
<div class="line"><span class="lineno"> 1757</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1758</span><span class="stringliteral">        Handles the quirks of having a singular &#39;name&#39; parameter for general</span></div>
<div class="line"><span class="lineno"> 1759</span><span class="stringliteral">        Index and plural &#39;names&#39; parameter for MultiIndex.</span></div>
<div class="line"><span class="lineno"> 1760</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1761</span>        <span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</div>
<div class="line"><span class="lineno"> 1762</span> </div>
<div class="line"><span class="lineno"> 1763</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1764</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Can only provide one of `names` and `name`&quot;</span>)</div>
<div class="line"><span class="lineno"> 1765</span>        <span class="keywordflow">elif</span> names <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1766</span>            new_names = deepcopy(self.names) <span class="keywordflow">if</span> deep <span class="keywordflow">else</span> self.names</div>
<div class="line"><span class="lineno"> 1767</span>        <span class="keywordflow">elif</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1768</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(names):</div>
<div class="line"><span class="lineno"> 1769</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Must pass list-like as `names`.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1770</span>            new_names = names</div>
<div class="line"><span class="lineno"> 1771</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_list_like(name):</div>
<div class="line"><span class="lineno"> 1772</span>            new_names = [name]</div>
<div class="line"><span class="lineno"> 1773</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1774</span>            new_names = name</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span>        <span class="keywordflow">if</span> len(new_names) != len(self.names):</div>
<div class="line"><span class="lineno"> 1777</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 1778</span>                f<span class="stringliteral">&quot;Length of new names must be {len(self.names)}, got {len(new_names)}&quot;</span></div>
<div class="line"><span class="lineno"> 1779</span>            )</div>
<div class="line"><span class="lineno"> 1780</span> </div>
<div class="line"><span class="lineno"> 1781</span>        <span class="comment"># All items in &#39;new_names&#39; need to be hashable</span></div>
<div class="line"><span class="lineno"> 1782</span>        validate_all_hashable(*new_names, error_name=f<span class="stringliteral">&quot;{type(self).__name__}.name&quot;</span>)</div>
<div class="line"><span class="lineno"> 1783</span> </div>
<div class="line"><span class="lineno"> 1784</span>        <span class="keywordflow">return</span> new_names</div>
<div class="line"><span class="lineno"> 1785</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1caf1b7990e119a3b7bb782b1ca79441" name="a1caf1b7990e119a3b7bb782b1ca79441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1caf1b7990e119a3b7bb782b1ca79441">&#9670;&#160;</a></span>_validate_positional_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index._validate_positional_slice </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">slice&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">For positional indexing, a slice must have either int or None
for each of start, stop, and step.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4207</span>    <span class="keyword">def </span>_validate_positional_slice(self, key: slice) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4208</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4209</span><span class="stringliteral">        For positional indexing, a slice must have either int or None</span></div>
<div class="line"><span class="lineno"> 4210</span><span class="stringliteral">        for each of start, stop, and step.</span></div>
<div class="line"><span class="lineno"> 4211</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4212</span>        self._validate_indexer(<span class="stringliteral">&quot;positional&quot;</span>, key.start, <span class="stringliteral">&quot;iloc&quot;</span>)</div>
<div class="line"><span class="lineno"> 4213</span>        self._validate_indexer(<span class="stringliteral">&quot;positional&quot;</span>, key.stop, <span class="stringliteral">&quot;iloc&quot;</span>)</div>
<div class="line"><span class="lineno"> 4214</span>        self._validate_indexer(<span class="stringliteral">&quot;positional&quot;</span>, key.step, <span class="stringliteral">&quot;iloc&quot;</span>)</div>
<div class="line"><span class="lineno"> 4215</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae4a7cf0d7a2efb6c00041591d9b1d893" name="ae4a7cf0d7a2efb6c00041591d9b1d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4a7cf0d7a2efb6c00041591d9b1d893">&#9670;&#160;</a></span>_validate_sort_keyword()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._validate_sort_keyword </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3211</span>    <span class="keyword">def </span>_validate_sort_keyword(self, sort):</div>
<div class="line"><span class="lineno"> 3212</span>        <span class="keywordflow">if</span> sort <span class="keywordflow">not</span> <span class="keywordflow">in</span> [<span class="keywordtype">None</span>, <span class="keyword">False</span>]:</div>
<div class="line"><span class="lineno"> 3213</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3214</span>                <span class="stringliteral">&quot;The &#39;sort&#39; keyword only takes the values of &quot;</span></div>
<div class="line"><span class="lineno"> 3215</span>                f<span class="stringliteral">&quot;None or False; {sort} was passed.&quot;</span></div>
<div class="line"><span class="lineno"> 3216</span>            )</div>
<div class="line"><span class="lineno"> 3217</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac98d209ccf5775ff7e012345413d4b8b" name="ac98d209ccf5775ff7e012345413d4b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98d209ccf5775ff7e012345413d4b8b">&#9670;&#160;</a></span>_values()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> | np.ndarray pandas.core.indexes.base.Index._values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">The best array representation.

This is an ndarray or ExtensionArray.

``_values`` are consistent between ``Series`` and ``Index``.

It may differ from the public '.values' method.

index             | values          | _values       |
----------------- | --------------- | ------------- |
Index             | ndarray         | ndarray       |
CategoricalIndex  | Categorical     | Categorical   |
DatetimeIndex     | ndarray[M8ns]   | DatetimeArray |
DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray |
PeriodIndex       | ndarray[object] | PeriodArray   |
IntervalIndex     | IntervalArray   | IntervalArray |

See Also
--------
values : Values
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#afd830cb5171b366c52092fdcaa2aee2b">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a67e29d5dedb60765410baaf63a8b02ab">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5134</span>    <span class="keyword">def </span>_values(self) -&gt; ExtensionArray | np.ndarray:</div>
<div class="line"><span class="lineno"> 5135</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5136</span><span class="stringliteral">        The best array representation.</span></div>
<div class="line"><span class="lineno"> 5137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5138</span><span class="stringliteral">        This is an ndarray or ExtensionArray.</span></div>
<div class="line"><span class="lineno"> 5139</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5140</span><span class="stringliteral">        ``_values`` are consistent between ``Series`` and ``Index``.</span></div>
<div class="line"><span class="lineno"> 5141</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5142</span><span class="stringliteral">        It may differ from the public &#39;.values&#39; method.</span></div>
<div class="line"><span class="lineno"> 5143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5144</span><span class="stringliteral">        index             | values          | _values       |</span></div>
<div class="line"><span class="lineno"> 5145</span><span class="stringliteral">        ----------------- | --------------- | ------------- |</span></div>
<div class="line"><span class="lineno"> 5146</span><span class="stringliteral">        Index             | ndarray         | ndarray       |</span></div>
<div class="line"><span class="lineno"> 5147</span><span class="stringliteral">        CategoricalIndex  | Categorical     | Categorical   |</span></div>
<div class="line"><span class="lineno"> 5148</span><span class="stringliteral">        DatetimeIndex     | ndarray[M8ns]   | DatetimeArray |</span></div>
<div class="line"><span class="lineno"> 5149</span><span class="stringliteral">        DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray |</span></div>
<div class="line"><span class="lineno"> 5150</span><span class="stringliteral">        PeriodIndex       | ndarray[object] | PeriodArray   |</span></div>
<div class="line"><span class="lineno"> 5151</span><span class="stringliteral">        IntervalIndex     | IntervalArray   | IntervalArray |</span></div>
<div class="line"><span class="lineno"> 5152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5153</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5154</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5155</span><span class="stringliteral">        values : Values</span></div>
<div class="line"><span class="lineno"> 5156</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5157</span>        <span class="keywordflow">return</span> self._data</div>
<div class="line"><span class="lineno"> 5158</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a179fbf5b8be4cfd6e4d32da55baf90b7" name="a179fbf5b8be4cfd6e4d32da55baf90b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179fbf5b8be4cfd6e4d32da55baf90b7">&#9670;&#160;</a></span>_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._view </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">fastpath to make a shallow copy, i.e. new object with same data.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8d8850f46895d67f76244b95cf87c7c1">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#af3bdc71c38f55fde190f53b4457b62c5">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  822</span>    <span class="keyword">def </span>_view(self: _IndexT) -&gt; _IndexT:</div>
<div class="line"><span class="lineno">  823</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  824</span><span class="stringliteral">        fastpath to make a shallow copy, i.e. new object with same data.</span></div>
<div class="line"><span class="lineno">  825</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  826</span>        result = self._simple_new(self._values, name=self._name)</div>
<div class="line"><span class="lineno">  827</span> </div>
<div class="line"><span class="lineno">  828</span>        result._cache = self._cache</div>
<div class="line"><span class="lineno">  829</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  830</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0226fde4b5097ec6291b2303fa4bd13" name="ab0226fde4b5097ec6291b2303fa4bd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0226fde4b5097ec6291b2303fa4bd13">&#9670;&#160;</a></span>_with_infer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._with_infer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Constructor that uses the 1.0.x behavior inferring numeric dtypes
for ndarray[object] inputs.
</pre> <div class="fragment"><div class="line"><span class="lineno">  710</span>    <span class="keyword">def </span>_with_infer(cls, *args, **kwargs):</div>
<div class="line"><span class="lineno">  711</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        Constructor that uses the 1.0.x behavior inferring numeric dtypes</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        for ndarray[object] inputs.</span></div>
<div class="line"><span class="lineno">  714</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  715</span>        <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno">  716</span>            warnings.filterwarnings(<span class="stringliteral">&quot;ignore&quot;</span>, <span class="stringliteral">&quot;.*the Index constructor&quot;</span>, FutureWarning)</div>
<div class="line"><span class="lineno">  717</span>            result = cls(*args, **kwargs)</div>
<div class="line"><span class="lineno">  718</span> </div>
<div class="line"><span class="lineno">  719</span>        <span class="keywordflow">if</span> result.dtype == _dtype_obj <span class="keywordflow">and</span> <span class="keywordflow">not</span> result._is_multi:</div>
<div class="line"><span class="lineno">  720</span>            <span class="comment"># error: Argument 1 to &quot;maybe_convert_objects&quot; has incompatible type</span></div>
<div class="line"><span class="lineno">  721</span>            <span class="comment"># &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;; expected</span></div>
<div class="line"><span class="lineno">  722</span>            <span class="comment"># &quot;ndarray[Any, Any]&quot;</span></div>
<div class="line"><span class="lineno">  723</span>            values = lib.maybe_convert_objects(result._values)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno">  724</span>            <span class="keywordflow">if</span> values.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>]:</div>
<div class="line"><span class="lineno">  725</span>                <span class="keywordflow">return</span> Index(values, name=result.name)</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  728</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0caa5b52504728b3d35953c5d737c360" name="a0caa5b52504728b3d35953c5d737c360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0caa5b52504728b3d35953c5d737c360">&#9670;&#160;</a></span>_wrap_difference_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._wrap_difference_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a4a392e4e1ea246f36e8b86529005bc4c">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3640</span>    <span class="keyword">def </span>_wrap_difference_result(self, other, result):</div>
<div class="line"><span class="lineno"> 3641</span>        <span class="comment"># We will override for MultiIndex to handle empty results</span></div>
<div class="line"><span class="lineno"> 3642</span>        <span class="keywordflow">return</span> self._wrap_setop_result(other, result)</div>
<div class="line"><span class="lineno"> 3643</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14ced146253c50f98f41f5dcda11adab" name="a14ced146253c50f98f41f5dcda11adab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ced146253c50f98f41f5dcda11adab">&#9670;&#160;</a></span>_wrap_intersection_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._wrap_intersection_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aff2c09c0285f9345e23565765f97d001">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3540</span>    <span class="keyword">def </span>_wrap_intersection_result(self, other, result):</div>
<div class="line"><span class="lineno"> 3541</span>        <span class="comment"># We will override for MultiIndex to handle empty results</span></div>
<div class="line"><span class="lineno"> 3542</span>        <span class="keywordflow">return</span> self._wrap_setop_result(other, result)</div>
<div class="line"><span class="lineno"> 3543</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a983c4be44ea9df7a5273011c5706cf72" name="a983c4be44ea9df7a5273011c5706cf72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983c4be44ea9df7a5273011c5706cf72">&#9670;&#160;</a></span>_wrap_joined_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index._wrap_joined_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArrayLike&#160;</td>
          <td class="paramname"><em>joined</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a442b1fa778cc4a9e8c543300d94071d6">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5074</span>    <span class="keyword">def </span>_wrap_joined_index(self: _IndexT, joined: ArrayLike, other: _IndexT) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 5075</span>        <span class="keyword">assert</span> other.dtype == self.dtype</div>
<div class="line"><span class="lineno"> 5076</span> </div>
<div class="line"><span class="lineno"> 5077</span>        <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 5078</span>            name = self.names <span class="keywordflow">if</span> self.names == other.names <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 5079</span>            <span class="comment"># error: Incompatible return value type (got &quot;MultiIndex&quot;,</span></div>
<div class="line"><span class="lineno"> 5080</span>            <span class="comment"># expected &quot;_IndexT&quot;)</span></div>
<div class="line"><span class="lineno"> 5081</span>            <span class="keywordflow">return</span> self._constructor(joined, name=name)  <span class="comment"># type: ignore[return-value]</span></div>
<div class="line"><span class="lineno"> 5082</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5083</span>            name = get_op_result_name(self, other)</div>
<div class="line"><span class="lineno"> 5084</span>            <span class="keywordflow">return</span> self._constructor._with_infer(joined, name=name, dtype=self.dtype)</div>
<div class="line"><span class="lineno"> 5085</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1e5ae02ff44cc3fea269f5e0b18ab4ac" name="a1e5ae02ff44cc3fea269f5e0b18ab4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5ae02ff44cc3fea269f5e0b18ab4ac">&#9670;&#160;</a></span>_wrap_reindex_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._wrap_reindex_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indexer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ab4da033221d60627463193a0836b17ee">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4480</span>    <span class="keyword">def </span>_wrap_reindex_result(self, target, indexer, preserve_names: bool):</div>
<div class="line"><span class="lineno"> 4481</span>        target = self._maybe_preserve_names(target, preserve_names)</div>
<div class="line"><span class="lineno"> 4482</span>        <span class="keywordflow">return</span> target</div>
<div class="line"><span class="lineno"> 4483</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8b0b7261fabb47a29f6b60e2a1ac0410" name="a8b0b7261fabb47a29f6b60e2a1ac0410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0b7261fabb47a29f6b60e2a1ac0410">&#9670;&#160;</a></span>_wrap_setop_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index._wrap_setop_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3429</span>    <span class="keyword">def </span>_wrap_setop_result(self, other: Index, result) -&gt; Index:</div>
<div class="line"><span class="lineno"> 3430</span>        name = get_op_result_name(self, other)</div>
<div class="line"><span class="lineno"> 3431</span>        <span class="keywordflow">if</span> isinstance(result, Index):</div>
<div class="line"><span class="lineno"> 3432</span>            <span class="keywordflow">if</span> result.name != name:</div>
<div class="line"><span class="lineno"> 3433</span>                result = result.rename(name)</div>
<div class="line"><span class="lineno"> 3434</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3435</span>            result = self._shallow_copy(result, name=name)</div>
<div class="line"><span class="lineno"> 3436</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3437</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a121ffd70e57719759d79af18daac4d57" name="a121ffd70e57719759d79af18daac4d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121ffd70e57719759d79af18daac4d57">&#9670;&#160;</a></span>all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.all </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether all elements are Truthy.

Parameters
----------
*args
    Required for compatibility with numpy.
**kwargs
    Required for compatibility with numpy.

Returns
-------
all : bool or array-like (if axis is specified)
    A single element array-like may be converted to bool.

See Also
--------
Index.any : Return whether any element in an Index is True.
Series.any : Return whether any element in a Series is True.
Series.all : Return whether all elements in a Series are True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to True because these are not equal to zero.

Examples
--------
True, because nonzero integers are considered True.

&gt;&gt;&gt; pd.Index([1, 2, 3]).all()
True

False, because ``0`` is considered False.

&gt;&gt;&gt; pd.Index([0, 1, 2]).all()
False
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8c717792baceb15a3d95ceb8532fcfe7">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7117</span>    <span class="keyword">def </span>all(self, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 7118</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7119</span><span class="stringliteral">        Return whether all elements are Truthy.</span></div>
<div class="line"><span class="lineno"> 7120</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7121</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 7122</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 7123</span><span class="stringliteral">        *args</span></div>
<div class="line"><span class="lineno"> 7124</span><span class="stringliteral">            Required for compatibility with numpy.</span></div>
<div class="line"><span class="lineno"> 7125</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno"> 7126</span><span class="stringliteral">            Required for compatibility with numpy.</span></div>
<div class="line"><span class="lineno"> 7127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7128</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 7129</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 7130</span><span class="stringliteral">        all : bool or array-like (if axis is specified)</span></div>
<div class="line"><span class="lineno"> 7131</span><span class="stringliteral">            A single element array-like may be converted to bool.</span></div>
<div class="line"><span class="lineno"> 7132</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7133</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 7134</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 7135</span><span class="stringliteral">        Index.any : Return whether any element in an Index is True.</span></div>
<div class="line"><span class="lineno"> 7136</span><span class="stringliteral">        Series.any : Return whether any element in a Series is True.</span></div>
<div class="line"><span class="lineno"> 7137</span><span class="stringliteral">        Series.all : Return whether all elements in a Series are True.</span></div>
<div class="line"><span class="lineno"> 7138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7139</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 7140</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 7141</span><span class="stringliteral">        Not a Number (NaN), positive infinity and negative infinity</span></div>
<div class="line"><span class="lineno"> 7142</span><span class="stringliteral">        evaluate to True because these are not equal to zero.</span></div>
<div class="line"><span class="lineno"> 7143</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7144</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 7145</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 7146</span><span class="stringliteral">        True, because nonzero integers are considered True.</span></div>
<div class="line"><span class="lineno"> 7147</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7148</span><span class="stringliteral">        &gt;&gt;&gt; pd.Index([1, 2, 3]).all()</span></div>
<div class="line"><span class="lineno"> 7149</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 7150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7151</span><span class="stringliteral">        False, because ``0`` is considered False.</span></div>
<div class="line"><span class="lineno"> 7152</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7153</span><span class="stringliteral">        &gt;&gt;&gt; pd.Index([0, 1, 2]).all()</span></div>
<div class="line"><span class="lineno"> 7154</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 7155</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7156</span>        nv.validate_all(args, kwargs)</div>
<div class="line"><span class="lineno"> 7157</span>        self._maybe_disable_logical_methods(<span class="stringliteral">&quot;all&quot;</span>)</div>
<div class="line"><span class="lineno"> 7158</span>        <span class="comment"># error: Argument 1 to &quot;all&quot; has incompatible type &quot;ArrayLike&quot;; expected</span></div>
<div class="line"><span class="lineno"> 7159</span>        <span class="comment"># &quot;Union[Union[int, float, complex, str, bytes, generic], Sequence[Union[int,</span></div>
<div class="line"><span class="lineno"> 7160</span>        <span class="comment"># float, complex, str, bytes, generic]], Sequence[Sequence[Any]],</span></div>
<div class="line"><span class="lineno"> 7161</span>        <span class="comment"># _SupportsArray]&quot;</span></div>
<div class="line"><span class="lineno"> 7162</span>        <span class="keywordflow">return</span> np.all(self.values)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 7163</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0c586e90e1ab6c1e34300a34332ca133" name="a0c586e90e1ab6c1e34300a34332ca133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c586e90e1ab6c1e34300a34332ca133">&#9670;&#160;</a></span>any()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.any </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether any element is Truthy.

Parameters
----------
*args
    Required for compatibility with numpy.
**kwargs
    Required for compatibility with numpy.

Returns
-------
any : bool or array-like (if axis is specified)
    A single element array-like may be converted to bool.

See Also
--------
Index.all : Return whether all elements are True.
Series.all : Return whether all elements are True.

Notes
-----
Not a Number (NaN), positive infinity and negative infinity
evaluate to True because these are not equal to zero.

Examples
--------
&gt;&gt;&gt; index = pd.Index([0, 1, 2])
&gt;&gt;&gt; index.any()
True

&gt;&gt;&gt; index = pd.Index([0, 0, 0])
&gt;&gt;&gt; index.any()
False
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a816359737088bec378e3850efbea60bc">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7073</span>    <span class="keyword">def </span>any(self, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 7074</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7075</span><span class="stringliteral">        Return whether any element is Truthy.</span></div>
<div class="line"><span class="lineno"> 7076</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7077</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 7078</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 7079</span><span class="stringliteral">        *args</span></div>
<div class="line"><span class="lineno"> 7080</span><span class="stringliteral">            Required for compatibility with numpy.</span></div>
<div class="line"><span class="lineno"> 7081</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno"> 7082</span><span class="stringliteral">            Required for compatibility with numpy.</span></div>
<div class="line"><span class="lineno"> 7083</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7084</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 7085</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 7086</span><span class="stringliteral">        any : bool or array-like (if axis is specified)</span></div>
<div class="line"><span class="lineno"> 7087</span><span class="stringliteral">            A single element array-like may be converted to bool.</span></div>
<div class="line"><span class="lineno"> 7088</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7089</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 7090</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 7091</span><span class="stringliteral">        Index.all : Return whether all elements are True.</span></div>
<div class="line"><span class="lineno"> 7092</span><span class="stringliteral">        Series.all : Return whether all elements are True.</span></div>
<div class="line"><span class="lineno"> 7093</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7094</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 7095</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 7096</span><span class="stringliteral">        Not a Number (NaN), positive infinity and negative infinity</span></div>
<div class="line"><span class="lineno"> 7097</span><span class="stringliteral">        evaluate to True because these are not equal to zero.</span></div>
<div class="line"><span class="lineno"> 7098</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7099</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 7100</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 7101</span><span class="stringliteral">        &gt;&gt;&gt; index = pd.Index([0, 1, 2])</span></div>
<div class="line"><span class="lineno"> 7102</span><span class="stringliteral">        &gt;&gt;&gt; index.any()</span></div>
<div class="line"><span class="lineno"> 7103</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 7104</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 7105</span><span class="stringliteral">        &gt;&gt;&gt; index = pd.Index([0, 0, 0])</span></div>
<div class="line"><span class="lineno"> 7106</span><span class="stringliteral">        &gt;&gt;&gt; index.any()</span></div>
<div class="line"><span class="lineno"> 7107</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 7108</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7109</span>        nv.validate_any(args, kwargs)</div>
<div class="line"><span class="lineno"> 7110</span>        self._maybe_disable_logical_methods(<span class="stringliteral">&quot;any&quot;</span>)</div>
<div class="line"><span class="lineno"> 7111</span>        <span class="comment"># error: Argument 1 to &quot;any&quot; has incompatible type &quot;ArrayLike&quot;; expected</span></div>
<div class="line"><span class="lineno"> 7112</span>        <span class="comment"># &quot;Union[Union[int, float, complex, str, bytes, generic], Sequence[Union[int,</span></div>
<div class="line"><span class="lineno"> 7113</span>        <span class="comment"># float, complex, str, bytes, generic]], Sequence[Sequence[Any]],</span></div>
<div class="line"><span class="lineno"> 7114</span>        <span class="comment"># _SupportsArray]&quot;</span></div>
<div class="line"><span class="lineno"> 7115</span>        <span class="keywordflow">return</span> np.any(self.values)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 7116</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ee2c8e131d63fadda0d417782b9e306" name="a2ee2c8e131d63fadda0d417782b9e306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee2c8e131d63fadda0d417782b9e306">&#9670;&#160;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.append </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | Sequence[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>]&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Append a collection of Index options together.

Parameters
----------
other : Index or list/tuple of indices

Returns
-------
Index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a94f624573fd341c17b34806d11d0810e">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5420</span>    <span class="keyword">def </span>append(self, other: Index | Sequence[Index]) -&gt; Index:</div>
<div class="line"><span class="lineno"> 5421</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5422</span><span class="stringliteral">        Append a collection of Index options together.</span></div>
<div class="line"><span class="lineno"> 5423</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5424</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5425</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5426</span><span class="stringliteral">        other : Index or list/tuple of indices</span></div>
<div class="line"><span class="lineno"> 5427</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5428</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5429</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5430</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 5431</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5432</span>        to_concat = [self]</div>
<div class="line"><span class="lineno"> 5433</span> </div>
<div class="line"><span class="lineno"> 5434</span>        <span class="keywordflow">if</span> isinstance(other, (list, tuple)):</div>
<div class="line"><span class="lineno"> 5435</span>            to_concat += list(other)</div>
<div class="line"><span class="lineno"> 5436</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5437</span>            <span class="comment"># error: Argument 1 to &quot;append&quot; of &quot;list&quot; has incompatible type</span></div>
<div class="line"><span class="lineno"> 5438</span>            <span class="comment"># &quot;Union[Index, Sequence[Index]]&quot;; expected &quot;Index&quot;</span></div>
<div class="line"><span class="lineno"> 5439</span>            to_concat.append(other)  <span class="comment"># type: ignore[arg-type]</span></div>
<div class="line"><span class="lineno"> 5440</span> </div>
<div class="line"><span class="lineno"> 5441</span>        <span class="keywordflow">for</span> obj <span class="keywordflow">in</span> to_concat:</div>
<div class="line"><span class="lineno"> 5442</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(obj, Index):</div>
<div class="line"><span class="lineno"> 5443</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;all inputs must be Index&quot;</span>)</div>
<div class="line"><span class="lineno"> 5444</span> </div>
<div class="line"><span class="lineno"> 5445</span>        names = {obj.name <span class="keywordflow">for</span> obj <span class="keywordflow">in</span> to_concat}</div>
<div class="line"><span class="lineno"> 5446</span>        name = <span class="keywordtype">None</span> <span class="keywordflow">if</span> len(names) &gt; 1 <span class="keywordflow">else</span> self.name</div>
<div class="line"><span class="lineno"> 5447</span> </div>
<div class="line"><span class="lineno"> 5448</span>        <span class="keywordflow">return</span> self._concat(to_concat, name)</div>
<div class="line"><span class="lineno"> 5449</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae3613bddbc636b51c8de715b6035d16b" name="ae3613bddbc636b51c8de715b6035d16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3613bddbc636b51c8de715b6035d16b">&#9670;&#160;</a></span>argmax()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.argmax </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return int position of the {value} value in the Series.

If the {op}imum is achieved in multiple locations,
the first row position is returned.

Parameters
----------
axis : {{None}}
    Unused. Parameter needed for compatibility with DataFrame.
skipna : bool, default True
    Exclude NA/null values when showing the result.
*args, **kwargs
    Additional arguments and keywords for compatibility with NumPy.

Returns
-------
int
    Row position of the {op}imum value.

See Also
--------
Series.arg{op} : Return position of the {op}imum value.
Series.arg{oppose} : Return position of the {oppose}imum value.
numpy.ndarray.arg{op} : Equivalent method for numpy arrays.
Series.idxmax : Return index label of the maximum values.
Series.idxmin : Return index label of the minimum values.

Examples
--------
Consider dataset containing cereal calories

&gt;&gt;&gt; s = pd.Series({{'Corn Flakes': 100.0, 'Almond Delight': 110.0,
...                'Cinnamon Toast Crunch': 120.0, 'Cocoa Puff': 110.0}})
&gt;&gt;&gt; s
Corn Flakes              100.0
Almond Delight           110.0
Cinnamon Toast Crunch    120.0
Cocoa Puff               110.0
dtype: float64

&gt;&gt;&gt; s.argmax()
2
&gt;&gt;&gt; s.argmin()
0

The maximum cereal calories is the third element and
the minimum cereal calories is the first element,
since series is zero-indexed.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#aaa6a0e8d69ff27d06ed4ceff7b55b901">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7192</span>    <span class="keyword">def </span>argmax(self, axis=None, skipna=True, *args, **kwargs) -&gt; int:</div>
<div class="line"><span class="lineno"> 7193</span>        nv.validate_argmax(args, kwargs)</div>
<div class="line"><span class="lineno"> 7194</span>        nv.validate_minmax_axis(axis)</div>
<div class="line"><span class="lineno"> 7195</span> </div>
<div class="line"><span class="lineno"> 7196</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 7197</span>            <span class="comment"># Take advantage of cache</span></div>
<div class="line"><span class="lineno"> 7198</span>            mask = self._isnan</div>
<div class="line"><span class="lineno"> 7199</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> skipna <span class="keywordflow">or</span> mask.all():</div>
<div class="line"><span class="lineno"> 7200</span>                <span class="keywordflow">return</span> -1</div>
<div class="line"><span class="lineno"> 7201</span>        <span class="keywordflow">return</span> super().argmax(skipna=skipna)</div>
<div class="line"><span class="lineno"> 7202</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a433c9db70e4dd1a08f551919f606dcc0" name="a433c9db70e4dd1a08f551919f606dcc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433c9db70e4dd1a08f551919f606dcc0">&#9670;&#160;</a></span>argmin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.argmin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a7c9343119562522aee143e49a7180d28">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7180</span>    <span class="keyword">def </span>argmin(self, axis=None, skipna=True, *args, **kwargs) -&gt; int:</div>
<div class="line"><span class="lineno"> 7181</span>        nv.validate_argmin(args, kwargs)</div>
<div class="line"><span class="lineno"> 7182</span>        nv.validate_minmax_axis(axis)</div>
<div class="line"><span class="lineno"> 7183</span> </div>
<div class="line"><span class="lineno"> 7184</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 7185</span>            <span class="comment"># Take advantage of cache</span></div>
<div class="line"><span class="lineno"> 7186</span>            mask = self._isnan</div>
<div class="line"><span class="lineno"> 7187</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> skipna <span class="keywordflow">or</span> mask.all():</div>
<div class="line"><span class="lineno"> 7188</span>                <span class="keywordflow">return</span> -1</div>
<div class="line"><span class="lineno"> 7189</span>        <span class="keywordflow">return</span> super().argmin(skipna=skipna)</div>
<div class="line"><span class="lineno"> 7190</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a30771e43e0bb0649a29944416361354e" name="a30771e43e0bb0649a29944416361354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30771e43e0bb0649a29944416361354e">&#9670;&#160;</a></span>argsort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index.argsort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the integer indices that would sort the index.

Parameters
----------
*args
    Passed to `numpy.ndarray.argsort`.
**kwargs
    Passed to `numpy.ndarray.argsort`.

Returns
-------
np.ndarray[np.intp]
    Integer indices that would sort the index if used as
    an indexer.

See Also
--------
numpy.argsort : Similar method for NumPy arrays.
Index.sort_values : Return sorted copy of Index.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['b', 'a', 'd', 'c'])
&gt;&gt;&gt; idx
Index(['b', 'a', 'd', 'c'], dtype='object')

&gt;&gt;&gt; order = idx.argsort()
&gt;&gt;&gt; order
array([1, 0, 3, 2])

&gt;&gt;&gt; idx[order]
Index(['a', 'b', 'c', 'd'], dtype='object')
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad1d6715b9f1019b44e232c253653f68e">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a43c357288be68182f79cdaf1ba688285">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5886</span>    <span class="keyword">def </span>argsort(self, *args, **kwargs) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 5887</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5888</span><span class="stringliteral">        Return the integer indices that would sort the index.</span></div>
<div class="line"><span class="lineno"> 5889</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5890</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5891</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5892</span><span class="stringliteral">        *args</span></div>
<div class="line"><span class="lineno"> 5893</span><span class="stringliteral">            Passed to `numpy.ndarray.argsort`.</span></div>
<div class="line"><span class="lineno"> 5894</span><span class="stringliteral">        **kwargs</span></div>
<div class="line"><span class="lineno"> 5895</span><span class="stringliteral">            Passed to `numpy.ndarray.argsort`.</span></div>
<div class="line"><span class="lineno"> 5896</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5897</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5898</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5899</span><span class="stringliteral">        np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 5900</span><span class="stringliteral">            Integer indices that would sort the index if used as</span></div>
<div class="line"><span class="lineno"> 5901</span><span class="stringliteral">            an indexer.</span></div>
<div class="line"><span class="lineno"> 5902</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5903</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5904</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5905</span><span class="stringliteral">        numpy.argsort : Similar method for NumPy arrays.</span></div>
<div class="line"><span class="lineno"> 5906</span><span class="stringliteral">        Index.sort_values : Return sorted copy of Index.</span></div>
<div class="line"><span class="lineno"> 5907</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5908</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5909</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5910</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno"> 5911</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 5912</span><span class="stringliteral">        Index([&#39;b&#39;, &#39;a&#39;, &#39;d&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 5913</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5914</span><span class="stringliteral">        &gt;&gt;&gt; order = idx.argsort()</span></div>
<div class="line"><span class="lineno"> 5915</span><span class="stringliteral">        &gt;&gt;&gt; order</span></div>
<div class="line"><span class="lineno"> 5916</span><span class="stringliteral">        array([1, 0, 3, 2])</span></div>
<div class="line"><span class="lineno"> 5917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5918</span><span class="stringliteral">        &gt;&gt;&gt; idx[order]</span></div>
<div class="line"><span class="lineno"> 5919</span><span class="stringliteral">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 5920</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5921</span>        <span class="comment"># This works for either ndarray or EA, is overridden</span></div>
<div class="line"><span class="lineno"> 5922</span>        <span class="comment">#  by RangeIndex, MultIIndex</span></div>
<div class="line"><span class="lineno"> 5923</span>        <span class="keywordflow">return</span> self._data.argsort(*args, **kwargs)</div>
<div class="line"><span class="lineno"> 5924</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab86763b57a92347e7e25c9e645f4d493" name="ab86763b57a92347e7e25c9e645f4d493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86763b57a92347e7e25c9e645f4d493">&#9670;&#160;</a></span>array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> pandas.core.indexes.base.Index.array </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a861471d44d3c846457df4e918cb5292b">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a3e6a1359f6d88d3dfa43ffbed745c7ce">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5125</span>    <span class="keyword">def </span>array(self) -&gt; ExtensionArray:</div>
<div class="line"><span class="lineno"> 5126</span>        array = self._data</div>
<div class="line"><span class="lineno"> 5127</span>        <span class="keywordflow">if</span> isinstance(array, np.ndarray):</div>
<div class="line"><span class="lineno"> 5128</span>            <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1arrays_1_1numpy__.html">pandas.core.arrays.numpy_</a> <span class="keyword">import</span> PandasArray</div>
<div class="line"><span class="lineno"> 5129</span> </div>
<div class="line"><span class="lineno"> 5130</span>            array = PandasArray(array)</div>
<div class="line"><span class="lineno"> 5131</span>        <span class="keywordflow">return</span> array</div>
<div class="line"><span class="lineno"> 5132</span> </div>
<div class="ttc" id="anamespacepandas_1_1core_1_1arrays_1_1numpy___html"><div class="ttname"><a href="namespacepandas_1_1core_1_1arrays_1_1numpy__.html">pandas.core.arrays.numpy_</a></div><div class="ttdef"><b>Definition</b> numpy_.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a8742fa5bd6250a1bc5ae3be7c139f570" name="a8742fa5bd6250a1bc5ae3be7c139f570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8742fa5bd6250a1bc5ae3be7c139f570">&#9670;&#160;</a></span>asi8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.asi8 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Integer representation of the values.

Returns
-------
ndarray
    An ndarray with int64 dtype.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_integer_index.html#a02f41818a5cc8d7890082c4464b4fdd4">pandas.core.indexes.numeric.IntegerIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  675</span>    <span class="keyword">def </span>asi8(self):</div>
<div class="line"><span class="lineno">  676</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        Integer representation of the values.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral">        ndarray</span></div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">            An ndarray with int64 dtype.</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  684</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  685</span>            <span class="stringliteral">&quot;Index.asi8 is deprecated and will be removed in a future version.&quot;</span>,</div>
<div class="line"><span class="lineno">  686</span>            FutureWarning,</div>
<div class="line"><span class="lineno">  687</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno">  688</span>        )</div>
<div class="line"><span class="lineno">  689</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  690</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a214a050164c108fe178a8711d8f82de0" name="a214a050164c108fe178a8711d8f82de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214a050164c108fe178a8711d8f82de0">&#9670;&#160;</a></span>asof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.asof </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>label</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the label from the index, or, if not present, the previous one.

Assuming that the index is sorted, return the passed index label if it
is in the index, or return the previous index label if the passed one
is not in the index.

Parameters
----------
label : object
    The label up to which the method returns the latest index label.

Returns
-------
object
    The passed label if it is in the index. The previous label if the
    passed label is not in the sorted index or `NaN` if there is no
    such label.

See Also
--------
Series.asof : Return the latest value in a Series up to the
    passed index.
merge_asof : Perform an asof merge (similar to left join but it
    matches on nearest key rather than equal key).
Index.get_loc : An `asof` is a thin wrapper around `get_loc`
    with method='pad'.

Examples
--------
`Index.asof` returns the latest index label up to the passed label.

&gt;&gt;&gt; idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])
&gt;&gt;&gt; idx.asof('2014-01-01')
'2013-12-31'

If the label is in the index, the method returns the passed label.

&gt;&gt;&gt; idx.asof('2014-01-02')
'2014-01-02'

If all of the labels in the index are later than the passed label,
NaN is returned.

&gt;&gt;&gt; idx.asof('1999-01-02')
nan

If the index is not sorted, an error is raised.

&gt;&gt;&gt; idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',
...                            '2014-01-03'])
&gt;&gt;&gt; idx_not_sorted.asof('2013-12-31')
Traceback (most recent call last):
ValueError: index must be monotonic increasing or decreasing
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5615</span>    <span class="keyword">def </span>asof(self, label):</div>
<div class="line"><span class="lineno"> 5616</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5617</span><span class="stringliteral">        Return the label from the index, or, if not present, the previous one.</span></div>
<div class="line"><span class="lineno"> 5618</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5619</span><span class="stringliteral">        Assuming that the index is sorted, return the passed index label if it</span></div>
<div class="line"><span class="lineno"> 5620</span><span class="stringliteral">        is in the index, or return the previous index label if the passed one</span></div>
<div class="line"><span class="lineno"> 5621</span><span class="stringliteral">        is not in the index.</span></div>
<div class="line"><span class="lineno"> 5622</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5623</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5624</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5625</span><span class="stringliteral">        label : object</span></div>
<div class="line"><span class="lineno"> 5626</span><span class="stringliteral">            The label up to which the method returns the latest index label.</span></div>
<div class="line"><span class="lineno"> 5627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5628</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5629</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5630</span><span class="stringliteral">        object</span></div>
<div class="line"><span class="lineno"> 5631</span><span class="stringliteral">            The passed label if it is in the index. The previous label if the</span></div>
<div class="line"><span class="lineno"> 5632</span><span class="stringliteral">            passed label is not in the sorted index or `NaN` if there is no</span></div>
<div class="line"><span class="lineno"> 5633</span><span class="stringliteral">            such label.</span></div>
<div class="line"><span class="lineno"> 5634</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5635</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5636</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5637</span><span class="stringliteral">        Series.asof : Return the latest value in a Series up to the</span></div>
<div class="line"><span class="lineno"> 5638</span><span class="stringliteral">            passed index.</span></div>
<div class="line"><span class="lineno"> 5639</span><span class="stringliteral">        merge_asof : Perform an asof merge (similar to left join but it</span></div>
<div class="line"><span class="lineno"> 5640</span><span class="stringliteral">            matches on nearest key rather than equal key).</span></div>
<div class="line"><span class="lineno"> 5641</span><span class="stringliteral">        Index.get_loc : An `asof` is a thin wrapper around `get_loc`</span></div>
<div class="line"><span class="lineno"> 5642</span><span class="stringliteral">            with method=&#39;pad&#39;.</span></div>
<div class="line"><span class="lineno"> 5643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5644</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5645</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5646</span><span class="stringliteral">        `Index.asof` returns the latest index label up to the passed label.</span></div>
<div class="line"><span class="lineno"> 5647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5648</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;2013-12-31&#39;, &#39;2014-01-02&#39;, &#39;2014-01-03&#39;])</span></div>
<div class="line"><span class="lineno"> 5649</span><span class="stringliteral">        &gt;&gt;&gt; idx.asof(&#39;2014-01-01&#39;)</span></div>
<div class="line"><span class="lineno"> 5650</span><span class="stringliteral">        &#39;2013-12-31&#39;</span></div>
<div class="line"><span class="lineno"> 5651</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5652</span><span class="stringliteral">        If the label is in the index, the method returns the passed label.</span></div>
<div class="line"><span class="lineno"> 5653</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5654</span><span class="stringliteral">        &gt;&gt;&gt; idx.asof(&#39;2014-01-02&#39;)</span></div>
<div class="line"><span class="lineno"> 5655</span><span class="stringliteral">        &#39;2014-01-02&#39;</span></div>
<div class="line"><span class="lineno"> 5656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5657</span><span class="stringliteral">        If all of the labels in the index are later than the passed label,</span></div>
<div class="line"><span class="lineno"> 5658</span><span class="stringliteral">        NaN is returned.</span></div>
<div class="line"><span class="lineno"> 5659</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5660</span><span class="stringliteral">        &gt;&gt;&gt; idx.asof(&#39;1999-01-02&#39;)</span></div>
<div class="line"><span class="lineno"> 5661</span><span class="stringliteral">        nan</span></div>
<div class="line"><span class="lineno"> 5662</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5663</span><span class="stringliteral">        If the index is not sorted, an error is raised.</span></div>
<div class="line"><span class="lineno"> 5664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5665</span><span class="stringliteral">        &gt;&gt;&gt; idx_not_sorted = pd.Index([&#39;2013-12-31&#39;, &#39;2015-01-02&#39;,</span></div>
<div class="line"><span class="lineno"> 5666</span><span class="stringliteral">        ...                            &#39;2014-01-03&#39;])</span></div>
<div class="line"><span class="lineno"> 5667</span><span class="stringliteral">        &gt;&gt;&gt; idx_not_sorted.asof(&#39;2013-12-31&#39;)</span></div>
<div class="line"><span class="lineno"> 5668</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 5669</span><span class="stringliteral">        ValueError: index must be monotonic increasing or decreasing</span></div>
<div class="line"><span class="lineno"> 5670</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5671</span>        self._searchsorted_monotonic(label)  <span class="comment"># validate sortedness</span></div>
<div class="line"><span class="lineno"> 5672</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5673</span>            loc = self.get_loc(label)</div>
<div class="line"><span class="lineno"> 5674</span>        <span class="keywordflow">except</span> (KeyError, TypeError):</div>
<div class="line"><span class="lineno"> 5675</span>            <span class="comment"># KeyError -&gt; No exact match, try for padded</span></div>
<div class="line"><span class="lineno"> 5676</span>            <span class="comment"># TypeError -&gt; passed e.g. non-hashable, fall through to get</span></div>
<div class="line"><span class="lineno"> 5677</span>            <span class="comment">#  the tested exception message</span></div>
<div class="line"><span class="lineno"> 5678</span>            indexer = self.get_indexer([label], method=<span class="stringliteral">&quot;pad&quot;</span>)</div>
<div class="line"><span class="lineno"> 5679</span>            <span class="keywordflow">if</span> indexer.ndim &gt; 1 <span class="keywordflow">or</span> indexer.size &gt; 1:</div>
<div class="line"><span class="lineno"> 5680</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;asof requires scalar valued input&quot;</span>)</div>
<div class="line"><span class="lineno"> 5681</span>            loc = indexer.item()</div>
<div class="line"><span class="lineno"> 5682</span>            <span class="keywordflow">if</span> loc == -1:</div>
<div class="line"><span class="lineno"> 5683</span>                <span class="keywordflow">return</span> self._na_value</div>
<div class="line"><span class="lineno"> 5684</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5685</span>            <span class="keywordflow">if</span> isinstance(loc, slice):</div>
<div class="line"><span class="lineno"> 5686</span>                loc = loc.indices(len(self))[-1]</div>
<div class="line"><span class="lineno"> 5687</span> </div>
<div class="line"><span class="lineno"> 5688</span>        <span class="keywordflow">return</span> self[loc]</div>
<div class="line"><span class="lineno"> 5689</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1d907b39f89f0a02c61dfd3e7d609f7f" name="a1d907b39f89f0a02c61dfd3e7d609f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d907b39f89f0a02c61dfd3e7d609f7f">&#9670;&#160;</a></span>asof_locs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index.asof_locs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">npt.NDArray[np.bool_]
    &#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the locations (indices) of labels in the index.

As in the `asof` function, if the label (a particular entry in
`where`) is not in the index, the latest index label up to the
passed label is chosen and its index returned.

If all of the labels in the index are later than a label in `where`,
-1 is returned.

`mask` is used to ignore NA values in the index during calculation.

Parameters
----------
where : Index
    An Index consisting of an array of timestamps.
mask : np.ndarray[bool]
    Array of booleans denoting where values in the original
    data are not NA.

Returns
-------
np.ndarray[np.intp]
    An array of locations (indices) of the labels from the Index
    which correspond to the return values of the `asof` function
    for every element in `where`.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a574d3b3e33ab1b8963f9654471c7e932">pandas.core.indexes.period.PeriodIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5692</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 5693</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5694</span><span class="stringliteral">        Return the locations (indices) of labels in the index.</span></div>
<div class="line"><span class="lineno"> 5695</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5696</span><span class="stringliteral">        As in the `asof` function, if the label (a particular entry in</span></div>
<div class="line"><span class="lineno"> 5697</span><span class="stringliteral">        `where`) is not in the index, the latest index label up to the</span></div>
<div class="line"><span class="lineno"> 5698</span><span class="stringliteral">        passed label is chosen and its index returned.</span></div>
<div class="line"><span class="lineno"> 5699</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5700</span><span class="stringliteral">        If all of the labels in the index are later than a label in `where`,</span></div>
<div class="line"><span class="lineno"> 5701</span><span class="stringliteral">        -1 is returned.</span></div>
<div class="line"><span class="lineno"> 5702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5703</span><span class="stringliteral">        `mask` is used to ignore NA values in the index during calculation.</span></div>
<div class="line"><span class="lineno"> 5704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5705</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5706</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5707</span><span class="stringliteral">        where : Index</span></div>
<div class="line"><span class="lineno"> 5708</span><span class="stringliteral">            An Index consisting of an array of timestamps.</span></div>
<div class="line"><span class="lineno"> 5709</span><span class="stringliteral">        mask : np.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 5710</span><span class="stringliteral">            Array of booleans denoting where values in the original</span></div>
<div class="line"><span class="lineno"> 5711</span><span class="stringliteral">            data are not NA.</span></div>
<div class="line"><span class="lineno"> 5712</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5713</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5714</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5715</span><span class="stringliteral">        np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 5716</span><span class="stringliteral">            An array of locations (indices) of the labels from the Index</span></div>
<div class="line"><span class="lineno"> 5717</span><span class="stringliteral">            which correspond to the return values of the `asof` function</span></div>
<div class="line"><span class="lineno"> 5718</span><span class="stringliteral">            for every element in `where`.</span></div>
<div class="line"><span class="lineno"> 5719</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5720</span>        <span class="comment"># error: No overload variant of &quot;searchsorted&quot; of &quot;ndarray&quot; matches argument</span></div>
<div class="line"><span class="lineno"> 5721</span>        <span class="comment"># types &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;, &quot;str&quot;</span></div>
<div class="line"><span class="lineno"> 5722</span>        <span class="comment"># TODO: will be fixed when ExtensionArray.searchsorted() is fixed</span></div>
<div class="line"><span class="lineno"> 5723</span>        locs = self._values[mask].searchsorted(</div>
<div class="line"><span class="lineno"> 5724</span>            where._values, side=<span class="stringliteral">&quot;right&quot;</span>  <span class="comment"># type: ignore[call-overload]</span></div>
<div class="line"><span class="lineno"> 5725</span>        )</div>
<div class="line"><span class="lineno"> 5726</span>        locs = np.where(locs &gt; 0, locs - 1, 0)</div>
<div class="line"><span class="lineno"> 5727</span> </div>
<div class="line"><span class="lineno"> 5728</span>        result = np.arange(len(self), dtype=np.intp)[mask].take(locs)</div>
<div class="line"><span class="lineno"> 5729</span> </div>
<div class="line"><span class="lineno"> 5730</span>        first_value = self._values[mask.argmax()]</div>
<div class="line"><span class="lineno"> 5731</span>        result[(locs == 0) &amp; (where._values &lt; first_value)] = -1</div>
<div class="line"><span class="lineno"> 5732</span> </div>
<div class="line"><span class="lineno"> 5733</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 5734</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a248f0c2a5875cdd3e5ab34220dc34950" name="a248f0c2a5875cdd3e5ab34220dc34950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a248f0c2a5875cdd3e5ab34220dc34950">&#9670;&#160;</a></span>astype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.astype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>copy</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create an Index with values cast to dtypes.

The class of a new Index is determined by dtype. When conversion is
impossible, a TypeError exception is raised.

Parameters
----------
dtype : numpy dtype or pandas type
    Note that any signed integer `dtype` is treated as ``'int64'``,
    and any unsigned integer `dtype` is treated as ``'uint64'``,
    regardless of the size.
copy : bool, default True
    By default, astype always returns a newly allocated object.
    If copy is set to False and internal requirements on dtype are
    satisfied, the original data is used to create a new Index
    or the original Index is returned.

Returns
-------
Index
    Index with values cast to specified dtype.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#ae8411646b75c1dbb3951481af52d48e5">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ade759ef7ba0a8d23a9e76eda97fd3fe5">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#ade3642a7c9740c03dc315a912737f986">pandas.core.indexes.period.PeriodIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1055</span>    <span class="keyword">def </span>astype(self, dtype, copy: bool = <span class="keyword">True</span>):</div>
<div class="line"><span class="lineno"> 1056</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1057</span><span class="stringliteral">        Create an Index with values cast to dtypes.</span></div>
<div class="line"><span class="lineno"> 1058</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1059</span><span class="stringliteral">        The class of a new Index is determined by dtype. When conversion is</span></div>
<div class="line"><span class="lineno"> 1060</span><span class="stringliteral">        impossible, a TypeError exception is raised.</span></div>
<div class="line"><span class="lineno"> 1061</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1062</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1063</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1064</span><span class="stringliteral">        dtype : numpy dtype or pandas type</span></div>
<div class="line"><span class="lineno"> 1065</span><span class="stringliteral">            Note that any signed integer `dtype` is treated as ``&#39;int64&#39;``,</span></div>
<div class="line"><span class="lineno"> 1066</span><span class="stringliteral">            and any unsigned integer `dtype` is treated as ``&#39;uint64&#39;``,</span></div>
<div class="line"><span class="lineno"> 1067</span><span class="stringliteral">            regardless of the size.</span></div>
<div class="line"><span class="lineno"> 1068</span><span class="stringliteral">        copy : bool, default True</span></div>
<div class="line"><span class="lineno"> 1069</span><span class="stringliteral">            By default, astype always returns a newly allocated object.</span></div>
<div class="line"><span class="lineno"> 1070</span><span class="stringliteral">            If copy is set to False and internal requirements on dtype are</span></div>
<div class="line"><span class="lineno"> 1071</span><span class="stringliteral">            satisfied, the original data is used to create a new Index</span></div>
<div class="line"><span class="lineno"> 1072</span><span class="stringliteral">            or the original Index is returned.</span></div>
<div class="line"><span class="lineno"> 1073</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1074</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1075</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1076</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 1077</span><span class="stringliteral">            Index with values cast to specified dtype.</span></div>
<div class="line"><span class="lineno"> 1078</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1079</span>        <span class="keywordflow">if</span> dtype <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1080</span>            dtype = pandas_dtype(dtype)</div>
<div class="line"><span class="lineno"> 1081</span> </div>
<div class="line"><span class="lineno"> 1082</span>        <span class="keywordflow">if</span> is_dtype_equal(self.dtype, dtype):</div>
<div class="line"><span class="lineno"> 1083</span>            <span class="comment"># Ensure that self.astype(self.dtype) is self</span></div>
<div class="line"><span class="lineno"> 1084</span>            <span class="keywordflow">return</span> self.copy() <span class="keywordflow">if</span> copy <span class="keywordflow">else</span> self</div>
<div class="line"><span class="lineno"> 1085</span> </div>
<div class="line"><span class="lineno"> 1086</span>        values = self._data</div>
<div class="line"><span class="lineno"> 1087</span>        <span class="keywordflow">if</span> isinstance(values, ExtensionArray):</div>
<div class="line"><span class="lineno"> 1088</span>            <span class="keywordflow">if</span> isinstance(dtype, np.dtype) <span class="keywordflow">and</span> dtype.kind == <span class="stringliteral">&quot;M&quot;</span> <span class="keywordflow">and</span> is_unitless(dtype):</div>
<div class="line"><span class="lineno"> 1089</span>                <span class="comment"># TODO(2.0): remove this special-casing once this is enforced</span></div>
<div class="line"><span class="lineno"> 1090</span>                <span class="comment">#  in DTA.astype</span></div>
<div class="line"><span class="lineno"> 1091</span>                <span class="keywordflow">raise</span> TypeError(f<span class="stringliteral">&quot;Cannot cast {type(self).__name__} to dtype&quot;</span>)</div>
<div class="line"><span class="lineno"> 1092</span> </div>
<div class="line"><span class="lineno"> 1093</span>            <span class="keyword">with</span> rewrite_exception(type(values).__name__, type(self).__name__):</div>
<div class="line"><span class="lineno"> 1094</span>                new_values = values.astype(dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1095</span> </div>
<div class="line"><span class="lineno"> 1096</span>        <span class="keywordflow">elif</span> is_float_dtype(self.dtype) <span class="keywordflow">and</span> needs_i8_conversion(dtype):</div>
<div class="line"><span class="lineno"> 1097</span>            <span class="comment"># NB: this must come before the ExtensionDtype check below</span></div>
<div class="line"><span class="lineno"> 1098</span>            <span class="comment"># TODO: this differs from Series behavior; can/should we align them?</span></div>
<div class="line"><span class="lineno"> 1099</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1100</span>                f<span class="stringliteral">&quot;Cannot convert Float64Index to dtype {dtype}; integer &quot;</span></div>
<div class="line"><span class="lineno"> 1101</span>                <span class="stringliteral">&quot;values are required for conversion&quot;</span></div>
<div class="line"><span class="lineno"> 1102</span>            )</div>
<div class="line"><span class="lineno"> 1103</span> </div>
<div class="line"><span class="lineno"> 1104</span>        <span class="keywordflow">elif</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno"> 1105</span>            cls = dtype.construct_array_type()</div>
<div class="line"><span class="lineno"> 1106</span>            <span class="comment"># Note: for RangeIndex and CategoricalDtype self vs self._values</span></div>
<div class="line"><span class="lineno"> 1107</span>            <span class="comment">#  behaves differently here.</span></div>
<div class="line"><span class="lineno"> 1108</span>            new_values = cls._from_sequence(self, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1109</span> </div>
<div class="line"><span class="lineno"> 1110</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1111</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1112</span>                <span class="keywordflow">if</span> dtype == str:</div>
<div class="line"><span class="lineno"> 1113</span>                    <span class="comment"># GH#38607</span></div>
<div class="line"><span class="lineno"> 1114</span>                    new_values = values.astype(dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1115</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1116</span>                    <span class="comment"># GH#13149 specifically use astype_nansafe instead of astype</span></div>
<div class="line"><span class="lineno"> 1117</span>                    new_values = astype_nansafe(values, dtype=dtype, copy=copy)</div>
<div class="line"><span class="lineno"> 1118</span>            <span class="keywordflow">except</span> IntCastingNaNError:</div>
<div class="line"><span class="lineno"> 1119</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1120</span>            <span class="keywordflow">except</span> (TypeError, ValueError) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 1121</span>                <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;u&quot;</span> <span class="keywordflow">and</span> <span class="stringliteral">&quot;losslessly&quot;</span> <span class="keywordflow">in</span> str(err):</div>
<div class="line"><span class="lineno"> 1122</span>                    <span class="comment"># keep the message from _astype_float_to_int_nansafe</span></div>
<div class="line"><span class="lineno"> 1123</span>                    <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 1124</span>                <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 1125</span>                    f<span class="stringliteral">&quot;Cannot cast {type(self).__name__} to dtype {dtype}&quot;</span></div>
<div class="line"><span class="lineno"> 1126</span>                ) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 1127</span> </div>
<div class="line"><span class="lineno"> 1128</span>        <span class="comment"># pass copy=False because any copying will be done in the astype above</span></div>
<div class="line"><span class="lineno"> 1129</span>        <span class="keywordflow">if</span> self._is_backward_compat_public_numeric_index:</div>
<div class="line"><span class="lineno"> 1130</span>            <span class="comment"># this block is needed so e.g. NumericIndex[int8].astype(&quot;int32&quot;) returns</span></div>
<div class="line"><span class="lineno"> 1131</span>            <span class="comment"># NumericIndex[int32] and not Int64Index with dtype int64.</span></div>
<div class="line"><span class="lineno"> 1132</span>            <span class="comment"># When Int64Index etc. are removed from the code base, removed this also.</span></div>
<div class="line"><span class="lineno"> 1133</span>            <span class="keywordflow">if</span> isinstance(dtype, np.dtype) <span class="keywordflow">and</span> is_numeric_dtype(dtype):</div>
<div class="line"><span class="lineno"> 1134</span>                <span class="keywordflow">return</span> self._constructor(</div>
<div class="line"><span class="lineno"> 1135</span>                    new_values, name=self.name, dtype=dtype, copy=<span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 1136</span>                )</div>
<div class="line"><span class="lineno"> 1137</span>        <span class="keywordflow">return</span> Index(new_values, name=self.name, dtype=new_values.dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 1138</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6f9ce0340d28fefd8934989df2681722" name="a6f9ce0340d28fefd8934989df2681722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9ce0340d28fefd8934989df2681722">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | None &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deep</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Dtype | None &#160;</td>
          <td class="paramname"><em>dtype</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence[Hashable] | None &#160;</td>
          <td class="paramname"><em>names</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make a copy of this object.

Name and dtype sets those attributes on the new object.

Parameters
----------
name : Label, optional
    Set name for new object.
deep : bool, default False
dtype : numpy dtype or pandas type, optional
    Set dtype for new object.

    .. deprecated:: 1.2.0
        use ``astype`` method instead.
names : list-like, optional
    Kept for compatibility with MultiIndex. Should not be used.

    .. deprecated:: 1.4.0
        use ``name`` instead.

Returns
-------
Index
    Index refer to new object which is a copy of this object.

Notes
-----
In most cases, there should be no functional difference from using
``deep``, but if ``deep`` is passed it will attempt to deepcopy.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a861fbcee768aa5fcc39e78d1042484d4">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a4576b80d5747d2b003232fa188f3a3a3">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1275</span>    ) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 1276</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1277</span><span class="stringliteral">        Make a copy of this object.</span></div>
<div class="line"><span class="lineno"> 1278</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1279</span><span class="stringliteral">        Name and dtype sets those attributes on the new object.</span></div>
<div class="line"><span class="lineno"> 1280</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1281</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1282</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1283</span><span class="stringliteral">        name : Label, optional</span></div>
<div class="line"><span class="lineno"> 1284</span><span class="stringliteral">            Set name for new object.</span></div>
<div class="line"><span class="lineno"> 1285</span><span class="stringliteral">        deep : bool, default False</span></div>
<div class="line"><span class="lineno"> 1286</span><span class="stringliteral">        dtype : numpy dtype or pandas type, optional</span></div>
<div class="line"><span class="lineno"> 1287</span><span class="stringliteral">            Set dtype for new object.</span></div>
<div class="line"><span class="lineno"> 1288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1289</span><span class="stringliteral">            .. deprecated:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1290</span><span class="stringliteral">                use ``astype`` method instead.</span></div>
<div class="line"><span class="lineno"> 1291</span><span class="stringliteral">        names : list-like, optional</span></div>
<div class="line"><span class="lineno"> 1292</span><span class="stringliteral">            Kept for compatibility with MultiIndex. Should not be used.</span></div>
<div class="line"><span class="lineno"> 1293</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1294</span><span class="stringliteral">            .. deprecated:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 1295</span><span class="stringliteral">                use ``name`` instead.</span></div>
<div class="line"><span class="lineno"> 1296</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1297</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1298</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1299</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 1300</span><span class="stringliteral">            Index refer to new object which is a copy of this object.</span></div>
<div class="line"><span class="lineno"> 1301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1302</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 1303</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 1304</span><span class="stringliteral">        In most cases, there should be no functional difference from using</span></div>
<div class="line"><span class="lineno"> 1305</span><span class="stringliteral">        ``deep``, but if ``deep`` is passed it will attempt to deepcopy.</span></div>
<div class="line"><span class="lineno"> 1306</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1307</span>        <span class="keywordflow">if</span> names <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1308</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1309</span>                <span class="stringliteral">&quot;parameter names is deprecated and will be removed in a future &quot;</span></div>
<div class="line"><span class="lineno"> 1310</span>                <span class="stringliteral">&quot;version. Use the name parameter instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1311</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1312</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1313</span>            )</div>
<div class="line"><span class="lineno"> 1314</span> </div>
<div class="line"><span class="lineno"> 1315</span>        name = self._validate_names(name=name, names=names, deep=deep)[0]</div>
<div class="line"><span class="lineno"> 1316</span>        <span class="keywordflow">if</span> deep:</div>
<div class="line"><span class="lineno"> 1317</span>            new_data = self._data.copy()</div>
<div class="line"><span class="lineno"> 1318</span>            new_index = type(self)._simple_new(new_data, name=name)</div>
<div class="line"><span class="lineno"> 1319</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1320</span>            new_index = self._rename(name=name)</div>
<div class="line"><span class="lineno"> 1321</span> </div>
<div class="line"><span class="lineno"> 1322</span>        <span class="keywordflow">if</span> dtype:</div>
<div class="line"><span class="lineno"> 1323</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1324</span>                <span class="stringliteral">&quot;parameter dtype is deprecated and will be removed in a future &quot;</span></div>
<div class="line"><span class="lineno"> 1325</span>                <span class="stringliteral">&quot;version. Use the astype method instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1326</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1327</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1328</span>            )</div>
<div class="line"><span class="lineno"> 1329</span>            new_index = new_index.astype(dtype)</div>
<div class="line"><span class="lineno"> 1330</span>        <span class="keywordflow">return</span> new_index</div>
<div class="line"><span class="lineno"> 1331</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0eedeb5284d87e3fecc39569f41a9215" name="a0eedeb5284d87e3fecc39569f41a9215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eedeb5284d87e3fecc39569f41a9215">&#9670;&#160;</a></span>delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make new Index with passed location(-s) deleted.

Parameters
----------
loc : int or list of int
    Location of item(-s) which will be deleted.
    Use a list of locations to delete more than one value at the same time.

Returns
-------
Index
    Will be same type as self, except for RangeIndex.

See Also
--------
numpy.delete : Delete any rows and column from NumPy array (ndarray).

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['a', 'b', 'c'])
&gt;&gt;&gt; idx.delete(1)
Index(['a', 'c'], dtype='object')

&gt;&gt;&gt; idx = pd.Index(['a', 'b', 'c'])
&gt;&gt;&gt; idx.delete([0, 2])
Index(['b'], dtype='object')
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#aa135f348b668fdf4b1d242c3a383d6de">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ac3fb5be7fbe13a0224f2d6a66aa43d72">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#aa3dfd1403619ef46ba9c78971b683513">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6847</span>    <span class="keyword">def </span>delete(self: _IndexT, loc) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 6848</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6849</span><span class="stringliteral">        Make new Index with passed location(-s) deleted.</span></div>
<div class="line"><span class="lineno"> 6850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6851</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6852</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6853</span><span class="stringliteral">        loc : int or list of int</span></div>
<div class="line"><span class="lineno"> 6854</span><span class="stringliteral">            Location of item(-s) which will be deleted.</span></div>
<div class="line"><span class="lineno"> 6855</span><span class="stringliteral">            Use a list of locations to delete more than one value at the same time.</span></div>
<div class="line"><span class="lineno"> 6856</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6857</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6858</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6859</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 6860</span><span class="stringliteral">            Will be same type as self, except for RangeIndex.</span></div>
<div class="line"><span class="lineno"> 6861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6862</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 6863</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6864</span><span class="stringliteral">        numpy.delete : Delete any rows and column from NumPy array (ndarray).</span></div>
<div class="line"><span class="lineno"> 6865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6866</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 6867</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6868</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno"> 6869</span><span class="stringliteral">        &gt;&gt;&gt; idx.delete(1)</span></div>
<div class="line"><span class="lineno"> 6870</span><span class="stringliteral">        Index([&#39;a&#39;, &#39;c&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 6871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6872</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])</span></div>
<div class="line"><span class="lineno"> 6873</span><span class="stringliteral">        &gt;&gt;&gt; idx.delete([0, 2])</span></div>
<div class="line"><span class="lineno"> 6874</span><span class="stringliteral">        Index([&#39;b&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 6875</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6876</span>        values = self._values</div>
<div class="line"><span class="lineno"> 6877</span>        res_values: ArrayLike</div>
<div class="line"><span class="lineno"> 6878</span>        <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno"> 6879</span>            <span class="comment"># TODO(__array_function__): special casing will be unnecessary</span></div>
<div class="line"><span class="lineno"> 6880</span>            res_values = np.delete(values, loc)</div>
<div class="line"><span class="lineno"> 6881</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6882</span>            res_values = values.delete(loc)</div>
<div class="line"><span class="lineno"> 6883</span> </div>
<div class="line"><span class="lineno"> 6884</span>        <span class="comment"># _constructor so RangeIndex-&gt;Int64Index</span></div>
<div class="line"><span class="lineno"> 6885</span>        <span class="keywordflow">return</span> self._constructor._simple_new(res_values, name=self.name)</div>
<div class="line"><span class="lineno"> 6886</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afdd8f9301b393845459728bd7364f456" name="afdd8f9301b393845459728bd7364f456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd8f9301b393845459728bd7364f456">&#9670;&#160;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new Index with elements of index not in `other`.

This is the set difference of two Index objects.

Parameters
----------
other : Index or array-like
sort : False or None, default None
    Whether to sort the resulting index. By default, the
    values are attempted to be sorted, but any TypeError from
    incomparable elements is caught by pandas.

    * None : Attempt to sort the result, but catch any TypeErrors
      from comparing incomparable elements.
    * False : Do not sort the result.

Returns
-------
difference : Index

Examples
--------
&gt;&gt;&gt; idx1 = pd.Index([2, 1, 3, 4])
&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])
&gt;&gt;&gt; idx1.difference(idx2)
Int64Index([1, 2], dtype='int64')
&gt;&gt;&gt; idx1.difference(idx2, sort=False)
Int64Index([2, 1], dtype='int64')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3572</span>    <span class="keyword">def </span>difference(self, other, sort=None):</div>
<div class="line"><span class="lineno"> 3573</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3574</span><span class="stringliteral">        Return a new Index with elements of index not in `other`.</span></div>
<div class="line"><span class="lineno"> 3575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3576</span><span class="stringliteral">        This is the set difference of two Index objects.</span></div>
<div class="line"><span class="lineno"> 3577</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3578</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3579</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3580</span><span class="stringliteral">        other : Index or array-like</span></div>
<div class="line"><span class="lineno"> 3581</span><span class="stringliteral">        sort : False or None, default None</span></div>
<div class="line"><span class="lineno"> 3582</span><span class="stringliteral">            Whether to sort the resulting index. By default, the</span></div>
<div class="line"><span class="lineno"> 3583</span><span class="stringliteral">            values are attempted to be sorted, but any TypeError from</span></div>
<div class="line"><span class="lineno"> 3584</span><span class="stringliteral">            incomparable elements is caught by pandas.</span></div>
<div class="line"><span class="lineno"> 3585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3586</span><span class="stringliteral">            * None : Attempt to sort the result, but catch any TypeErrors</span></div>
<div class="line"><span class="lineno"> 3587</span><span class="stringliteral">              from comparing incomparable elements.</span></div>
<div class="line"><span class="lineno"> 3588</span><span class="stringliteral">            * False : Do not sort the result.</span></div>
<div class="line"><span class="lineno"> 3589</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3590</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3591</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3592</span><span class="stringliteral">        difference : Index</span></div>
<div class="line"><span class="lineno"> 3593</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3594</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3595</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3596</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([2, 1, 3, 4])</span></div>
<div class="line"><span class="lineno"> 3597</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 3598</span><span class="stringliteral">        &gt;&gt;&gt; idx1.difference(idx2)</span></div>
<div class="line"><span class="lineno"> 3599</span><span class="stringliteral">        Int64Index([1, 2], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 3600</span><span class="stringliteral">        &gt;&gt;&gt; idx1.difference(idx2, sort=False)</span></div>
<div class="line"><span class="lineno"> 3601</span><span class="stringliteral">        Int64Index([2, 1], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 3602</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3603</span>        self._validate_sort_keyword(sort)</div>
<div class="line"><span class="lineno"> 3604</span>        self._assert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3605</span>        other, result_name = self._convert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3606</span> </div>
<div class="line"><span class="lineno"> 3607</span>        <span class="comment"># Note: we do NOT call _deprecate_dti_setop here, as there</span></div>
<div class="line"><span class="lineno"> 3608</span>        <span class="comment">#  is no requirement that .difference be commutative, so it does</span></div>
<div class="line"><span class="lineno"> 3609</span>        <span class="comment">#  not cast to object.</span></div>
<div class="line"><span class="lineno"> 3610</span> </div>
<div class="line"><span class="lineno"> 3611</span>        <span class="keywordflow">if</span> self.equals(other):</div>
<div class="line"><span class="lineno"> 3612</span>            <span class="comment"># Note: we do not (yet) sort even if sort=None GH#24959</span></div>
<div class="line"><span class="lineno"> 3613</span>            <span class="keywordflow">return</span> self[:0].rename(result_name)</div>
<div class="line"><span class="lineno"> 3614</span> </div>
<div class="line"><span class="lineno"> 3615</span>        <span class="keywordflow">if</span> len(other) == 0:</div>
<div class="line"><span class="lineno"> 3616</span>            <span class="comment"># Note: we do not (yet) sort even if sort=None GH#24959</span></div>
<div class="line"><span class="lineno"> 3617</span>            <span class="keywordflow">return</span> self.rename(result_name)</div>
<div class="line"><span class="lineno"> 3618</span> </div>
<div class="line"><span class="lineno"> 3619</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._should_compare(other):</div>
<div class="line"><span class="lineno"> 3620</span>            <span class="comment"># Nothing matches -&gt; difference is everything</span></div>
<div class="line"><span class="lineno"> 3621</span>            <span class="keywordflow">return</span> self.rename(result_name)</div>
<div class="line"><span class="lineno"> 3622</span> </div>
<div class="line"><span class="lineno"> 3623</span>        result = self._difference(other, sort=sort)</div>
<div class="line"><span class="lineno"> 3624</span>        <span class="keywordflow">return</span> self._wrap_difference_result(other, result)</div>
<div class="line"><span class="lineno"> 3625</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af2baa3f9a3d9eddf303486451eb684d4" name="af2baa3f9a3d9eddf303486451eb684d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2baa3f9a3d9eddf303486451eb684d4">&#9670;&#160;</a></span>drop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.drop </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | np.ndarray | Iterable[Hashable]&#160;</td>
          <td class="paramname"><em>labels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IgnoreRaise &#160;</td>
          <td class="paramname"><em>errors</em> = <code>&quot;raise&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make new Index with passed list of labels deleted.

Parameters
----------
labels : array-like or scalar
errors : {'ignore', 'raise'}, default 'raise'
    If 'ignore', suppress error and existing labels are dropped.

Returns
-------
dropped : Index
    Will be same type as self, except for RangeIndex.

Raises
------
KeyError
    If not all of the labels are found in the selected axis
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a092428364d114167a37447c4423a268a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6948</span>    ) -&gt; Index:</div>
<div class="line"><span class="lineno"> 6949</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6950</span><span class="stringliteral">        Make new Index with passed list of labels deleted.</span></div>
<div class="line"><span class="lineno"> 6951</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6952</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6953</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6954</span><span class="stringliteral">        labels : array-like or scalar</span></div>
<div class="line"><span class="lineno"> 6955</span><span class="stringliteral">        errors : {&#39;ignore&#39;, &#39;raise&#39;}, default &#39;raise&#39;</span></div>
<div class="line"><span class="lineno"> 6956</span><span class="stringliteral">            If &#39;ignore&#39;, suppress error and existing labels are dropped.</span></div>
<div class="line"><span class="lineno"> 6957</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6958</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6959</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6960</span><span class="stringliteral">        dropped : Index</span></div>
<div class="line"><span class="lineno"> 6961</span><span class="stringliteral">            Will be same type as self, except for RangeIndex.</span></div>
<div class="line"><span class="lineno"> 6962</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6963</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 6964</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 6965</span><span class="stringliteral">        KeyError</span></div>
<div class="line"><span class="lineno"> 6966</span><span class="stringliteral">            If not all of the labels are found in the selected axis</span></div>
<div class="line"><span class="lineno"> 6967</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6968</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(labels, Index):</div>
<div class="line"><span class="lineno"> 6969</span>            <span class="comment"># avoid materializing e.g. RangeIndex</span></div>
<div class="line"><span class="lineno"> 6970</span>            arr_dtype = <span class="stringliteral">&quot;object&quot;</span> <span class="keywordflow">if</span> self.dtype == <span class="stringliteral">&quot;object&quot;</span> <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6971</span>            labels = com.index_labels_to_array(labels, dtype=arr_dtype)</div>
<div class="line"><span class="lineno"> 6972</span> </div>
<div class="line"><span class="lineno"> 6973</span>        indexer = self.get_indexer_for(labels)</div>
<div class="line"><span class="lineno"> 6974</span>        mask = indexer == -1</div>
<div class="line"><span class="lineno"> 6975</span>        <span class="keywordflow">if</span> mask.any():</div>
<div class="line"><span class="lineno"> 6976</span>            <span class="keywordflow">if</span> errors != <span class="stringliteral">&quot;ignore&quot;</span>:</div>
<div class="line"><span class="lineno"> 6977</span>                <span class="keywordflow">raise</span> KeyError(f<span class="stringliteral">&quot;{list(labels[mask])} not found in axis&quot;</span>)</div>
<div class="line"><span class="lineno"> 6978</span>            indexer = indexer[~mask]</div>
<div class="line"><span class="lineno"> 6979</span>        <span class="keywordflow">return</span> self.delete(indexer)</div>
<div class="line"><span class="lineno"> 6980</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae5276b67d16571148394cec488bb5218" name="ae5276b67d16571148394cec488bb5218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5276b67d16571148394cec488bb5218">&#9670;&#160;</a></span>drop_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.drop_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> | bool &#160;</td>
          <td class="paramname"><em>keep</em> = <code>&quot;first&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return Index with duplicate values removed.

Parameters
----------
keep : {'first', 'last', ``False``}, default 'first'
    - 'first' : Drop duplicates except for the first occurrence.
    - 'last' : Drop duplicates except for the last occurrence.
    - ``False`` : Drop all duplicates.

Returns
-------
deduplicated : Index

See Also
--------
Series.drop_duplicates : Equivalent method on Series.
DataFrame.drop_duplicates : Equivalent method on DataFrame.
Index.duplicated : Related method on Index, indicating duplicate
    Index values.

Examples
--------
Generate an pandas.Index with duplicate values.

&gt;&gt;&gt; idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])

The `keep` parameter controls  which duplicate values are removed.
The value 'first' keeps the first occurrence for each
set of duplicated entries. The default value of keep is 'first'.

&gt;&gt;&gt; idx.drop_duplicates(keep='first')
Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')

The value 'last' keeps the last occurrence for each set of duplicated
entries.

&gt;&gt;&gt; idx.drop_duplicates(keep='last')
Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')

The value ``False`` discards all sets of duplicated entries.

&gt;&gt;&gt; idx.drop_duplicates(keep=False)
Index(['cow', 'beetle', 'hippo'], dtype='object')
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#aad42d739ec794dddb345aa85f9f4f85a">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#acdda007f2c2d06235b1f3bbe4cb49311">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3035</span>    <span class="keyword">def </span>drop_duplicates(self: _IndexT, keep: str_t | bool = <span class="stringliteral">&quot;first&quot;</span>) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 3036</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3037</span><span class="stringliteral">        Return Index with duplicate values removed.</span></div>
<div class="line"><span class="lineno"> 3038</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3039</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3040</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3041</span><span class="stringliteral">        keep : {&#39;first&#39;, &#39;last&#39;, ``False``}, default &#39;first&#39;</span></div>
<div class="line"><span class="lineno"> 3042</span><span class="stringliteral">            - &#39;first&#39; : Drop duplicates except for the first occurrence.</span></div>
<div class="line"><span class="lineno"> 3043</span><span class="stringliteral">            - &#39;last&#39; : Drop duplicates except for the last occurrence.</span></div>
<div class="line"><span class="lineno"> 3044</span><span class="stringliteral">            - ``False`` : Drop all duplicates.</span></div>
<div class="line"><span class="lineno"> 3045</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3046</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3047</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3048</span><span class="stringliteral">        deduplicated : Index</span></div>
<div class="line"><span class="lineno"> 3049</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3050</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3051</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3052</span><span class="stringliteral">        Series.drop_duplicates : Equivalent method on Series.</span></div>
<div class="line"><span class="lineno"> 3053</span><span class="stringliteral">        DataFrame.drop_duplicates : Equivalent method on DataFrame.</span></div>
<div class="line"><span class="lineno"> 3054</span><span class="stringliteral">        Index.duplicated : Related method on Index, indicating duplicate</span></div>
<div class="line"><span class="lineno"> 3055</span><span class="stringliteral">            Index values.</span></div>
<div class="line"><span class="lineno"> 3056</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3057</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3058</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3059</span><span class="stringliteral">        Generate an pandas.Index with duplicate values.</span></div>
<div class="line"><span class="lineno"> 3060</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3061</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;])</span></div>
<div class="line"><span class="lineno"> 3062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3063</span><span class="stringliteral">        The `keep` parameter controls  which duplicate values are removed.</span></div>
<div class="line"><span class="lineno"> 3064</span><span class="stringliteral">        The value &#39;first&#39; keeps the first occurrence for each</span></div>
<div class="line"><span class="lineno"> 3065</span><span class="stringliteral">        set of duplicated entries. The default value of keep is &#39;first&#39;.</span></div>
<div class="line"><span class="lineno"> 3066</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3067</span><span class="stringliteral">        &gt;&gt;&gt; idx.drop_duplicates(keep=&#39;first&#39;)</span></div>
<div class="line"><span class="lineno"> 3068</span><span class="stringliteral">        Index([&#39;lama&#39;, &#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 3069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3070</span><span class="stringliteral">        The value &#39;last&#39; keeps the last occurrence for each set of duplicated</span></div>
<div class="line"><span class="lineno"> 3071</span><span class="stringliteral">        entries.</span></div>
<div class="line"><span class="lineno"> 3072</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3073</span><span class="stringliteral">        &gt;&gt;&gt; idx.drop_duplicates(keep=&#39;last&#39;)</span></div>
<div class="line"><span class="lineno"> 3074</span><span class="stringliteral">        Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;lama&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 3075</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3076</span><span class="stringliteral">        The value ``False`` discards all sets of duplicated entries.</span></div>
<div class="line"><span class="lineno"> 3077</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3078</span><span class="stringliteral">        &gt;&gt;&gt; idx.drop_duplicates(keep=False)</span></div>
<div class="line"><span class="lineno"> 3079</span><span class="stringliteral">        Index([&#39;cow&#39;, &#39;beetle&#39;, &#39;hippo&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 3080</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3081</span>        <span class="keywordflow">if</span> self.is_unique:</div>
<div class="line"><span class="lineno"> 3082</span>            <span class="keywordflow">return</span> self._view()</div>
<div class="line"><span class="lineno"> 3083</span> </div>
<div class="line"><span class="lineno"> 3084</span>        <span class="keywordflow">return</span> super().drop_duplicates(keep=keep)</div>
<div class="line"><span class="lineno"> 3085</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae48a1cd410ee175df42645d47ba596b" name="aae48a1cd410ee175df42645d47ba596b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae48a1cd410ee175df42645d47ba596b">&#9670;&#160;</a></span>droplevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.droplevel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return index with requested level(s) removed.

If resulting index has only 1 level left, the result will be
of Index type, not MultiIndex.

Parameters
----------
level : int, str, or list-like, default 0
    If a string is given, must be the name of a level
    If list-like, elements must be names or indexes of levels.

Returns
-------
Index or MultiIndex

Examples
--------
&gt;&gt;&gt; mi = pd.MultiIndex.from_arrays(
... [[1, 2], [3, 4], [5, 6]], names=['x', 'y', 'z'])
&gt;&gt;&gt; mi
MultiIndex([(1, 3, 5),
            (2, 4, 6)],
           names=['x', 'y', 'z'])

&gt;&gt;&gt; mi.droplevel()
MultiIndex([(3, 5),
            (4, 6)],
           names=['y', 'z'])

&gt;&gt;&gt; mi.droplevel(2)
MultiIndex([(1, 3),
            (2, 4)],
           names=['x', 'y'])

&gt;&gt;&gt; mi.droplevel('z')
MultiIndex([(1, 3),
            (2, 4)],
           names=['x', 'y'])

&gt;&gt;&gt; mi.droplevel(['x', 'y'])
Int64Index([5, 6], dtype='int64', name='z')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2134</span>    <span class="keyword">def </span>droplevel(self, level=0):</div>
<div class="line"><span class="lineno"> 2135</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2136</span><span class="stringliteral">        Return index with requested level(s) removed.</span></div>
<div class="line"><span class="lineno"> 2137</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2138</span><span class="stringliteral">        If resulting index has only 1 level left, the result will be</span></div>
<div class="line"><span class="lineno"> 2139</span><span class="stringliteral">        of Index type, not MultiIndex.</span></div>
<div class="line"><span class="lineno"> 2140</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2141</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2142</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2143</span><span class="stringliteral">        level : int, str, or list-like, default 0</span></div>
<div class="line"><span class="lineno"> 2144</span><span class="stringliteral">            If a string is given, must be the name of a level</span></div>
<div class="line"><span class="lineno"> 2145</span><span class="stringliteral">            If list-like, elements must be names or indexes of levels.</span></div>
<div class="line"><span class="lineno"> 2146</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2147</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2148</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2149</span><span class="stringliteral">        Index or MultiIndex</span></div>
<div class="line"><span class="lineno"> 2150</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2151</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2152</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2153</span><span class="stringliteral">        &gt;&gt;&gt; mi = pd.MultiIndex.from_arrays(</span></div>
<div class="line"><span class="lineno"> 2154</span><span class="stringliteral">        ... [[1, 2], [3, 4], [5, 6]], names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span></div>
<div class="line"><span class="lineno"> 2155</span><span class="stringliteral">        &gt;&gt;&gt; mi</span></div>
<div class="line"><span class="lineno"> 2156</span><span class="stringliteral">        MultiIndex([(1, 3, 5),</span></div>
<div class="line"><span class="lineno"> 2157</span><span class="stringliteral">                    (2, 4, 6)],</span></div>
<div class="line"><span class="lineno"> 2158</span><span class="stringliteral">                   names=[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])</span></div>
<div class="line"><span class="lineno"> 2159</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2160</span><span class="stringliteral">        &gt;&gt;&gt; mi.droplevel()</span></div>
<div class="line"><span class="lineno"> 2161</span><span class="stringliteral">        MultiIndex([(3, 5),</span></div>
<div class="line"><span class="lineno"> 2162</span><span class="stringliteral">                    (4, 6)],</span></div>
<div class="line"><span class="lineno"> 2163</span><span class="stringliteral">                   names=[&#39;y&#39;, &#39;z&#39;])</span></div>
<div class="line"><span class="lineno"> 2164</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2165</span><span class="stringliteral">        &gt;&gt;&gt; mi.droplevel(2)</span></div>
<div class="line"><span class="lineno"> 2166</span><span class="stringliteral">        MultiIndex([(1, 3),</span></div>
<div class="line"><span class="lineno"> 2167</span><span class="stringliteral">                    (2, 4)],</span></div>
<div class="line"><span class="lineno"> 2168</span><span class="stringliteral">                   names=[&#39;x&#39;, &#39;y&#39;])</span></div>
<div class="line"><span class="lineno"> 2169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2170</span><span class="stringliteral">        &gt;&gt;&gt; mi.droplevel(&#39;z&#39;)</span></div>
<div class="line"><span class="lineno"> 2171</span><span class="stringliteral">        MultiIndex([(1, 3),</span></div>
<div class="line"><span class="lineno"> 2172</span><span class="stringliteral">                    (2, 4)],</span></div>
<div class="line"><span class="lineno"> 2173</span><span class="stringliteral">                   names=[&#39;x&#39;, &#39;y&#39;])</span></div>
<div class="line"><span class="lineno"> 2174</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2175</span><span class="stringliteral">        &gt;&gt;&gt; mi.droplevel([&#39;x&#39;, &#39;y&#39;])</span></div>
<div class="line"><span class="lineno"> 2176</span><span class="stringliteral">        Int64Index([5, 6], dtype=&#39;int64&#39;, name=&#39;z&#39;)</span></div>
<div class="line"><span class="lineno"> 2177</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2178</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(level, (tuple, list)):</div>
<div class="line"><span class="lineno"> 2179</span>            level = [level]</div>
<div class="line"><span class="lineno"> 2180</span> </div>
<div class="line"><span class="lineno"> 2181</span>        levnums = sorted(self._get_level_number(lev) <span class="keywordflow">for</span> lev <span class="keywordflow">in</span> level)[::-1]</div>
<div class="line"><span class="lineno"> 2182</span> </div>
<div class="line"><span class="lineno"> 2183</span>        <span class="keywordflow">return</span> self._drop_level_numbers(levnums)</div>
<div class="line"><span class="lineno"> 2184</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a90a16b6957c9c008ada0dce2238ab892" name="a90a16b6957c9c008ada0dce2238ab892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a16b6957c9c008ada0dce2238ab892">&#9670;&#160;</a></span>dropna()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.dropna </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;any&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return Index without NA/NaN values.

Parameters
----------
how : {'any', 'all'}, default 'any'
    If the Index is a MultiIndex, drop the value when any or all levels
    are NaN.

Returns
-------
Index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a47c0d4916e0ea4694cc35aa0ffba7291">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2979</span>    <span class="keyword">def </span>dropna(self: _IndexT, how: str_t = <span class="stringliteral">&quot;any&quot;</span>) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 2980</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2981</span><span class="stringliteral">        Return Index without NA/NaN values.</span></div>
<div class="line"><span class="lineno"> 2982</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2983</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2984</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2985</span><span class="stringliteral">        how : {&#39;any&#39;, &#39;all&#39;}, default &#39;any&#39;</span></div>
<div class="line"><span class="lineno"> 2986</span><span class="stringliteral">            If the Index is a MultiIndex, drop the value when any or all levels</span></div>
<div class="line"><span class="lineno"> 2987</span><span class="stringliteral">            are NaN.</span></div>
<div class="line"><span class="lineno"> 2988</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2989</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2990</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2991</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 2992</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2993</span>        <span class="keywordflow">if</span> how <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;any&quot;</span>, <span class="stringliteral">&quot;all&quot;</span>):</div>
<div class="line"><span class="lineno"> 2994</span>            <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;invalid how option: {how}&quot;</span>)</div>
<div class="line"><span class="lineno"> 2995</span> </div>
<div class="line"><span class="lineno"> 2996</span>        <span class="keywordflow">if</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 2997</span>            res_values = self._values[~self._isnan]</div>
<div class="line"><span class="lineno"> 2998</span>            <span class="keywordflow">return</span> type(self)._simple_new(res_values, name=self.name)</div>
<div class="line"><span class="lineno"> 2999</span>        <span class="keywordflow">return</span> self._view()</div>
<div class="line"><span class="lineno"> 3000</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a59ddb1903b411542fb12a8eadd1cbf14" name="a59ddb1903b411542fb12a8eadd1cbf14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ddb1903b411542fb12a8eadd1cbf14">&#9670;&#160;</a></span>dtype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.indexes.base.Index.dtype </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the dtype object of the underlying data.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a2396ceae5c47c65c95ca5ddfd5e09ea1">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a022680e8955b0fe4d760a4feaf6cf093">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8f212b8253bdbd9417b9c7fed9a9a601">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  988</span>    <span class="keyword">def </span><a class="code hl_namespace" href="namespacedtype.html">dtype</a>(self) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno">  989</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  990</span><span class="stringliteral">        Return the dtype object of the underlying data.</span></div>
<div class="line"><span class="lineno">  991</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  992</span>        <span class="keywordflow">return</span> self._data.dtype</div>
<div class="line"><span class="lineno">  993</span> </div>
<div class="ttc" id="anamespacedtype_html"><div class="ttname"><a href="namespacedtype.html">dtype</a></div><div class="ttdef"><b>Definition</b> dtype.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa0914a1dee40aecf965b677264f3d0bf" name="aa0914a1dee40aecf965b677264f3d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0914a1dee40aecf965b677264f3d0bf">&#9670;&#160;</a></span>duplicated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.indexes.base.Index.duplicated </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;first&quot;, &quot;last&quot;, False] &#160;</td>
          <td class="paramname"><em>keep</em> = <code>&quot;first&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Indicate duplicate index values.

Duplicated values are indicated as ``True`` values in the resulting
array. Either all duplicates, all except the first, or all except the
last occurrence of duplicates can be indicated.

Parameters
----------
keep : {'first', 'last', False}, default 'first'
    The value or values in a set of duplicates to mark as missing.

    - 'first' : Mark duplicates as ``True`` except for the first
      occurrence.
    - 'last' : Mark duplicates as ``True`` except for the last
      occurrence.
    - ``False`` : Mark all duplicates as ``True``.

Returns
-------
np.ndarray[bool]

See Also
--------
Series.duplicated : Equivalent method on pandas.Series.
DataFrame.duplicated : Equivalent method on pandas.DataFrame.
Index.drop_duplicates : Remove duplicate values from Index.

Examples
--------
By default, for each set of duplicated values, the first occurrence is
set to False and all others to True:

&gt;&gt;&gt; idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])
&gt;&gt;&gt; idx.duplicated()
array([False, False,  True, False,  True])

which is equivalent to

&gt;&gt;&gt; idx.duplicated(keep='first')
array([False, False,  True, False,  True])

By using 'last', the last occurrence of each set of duplicated values
is set on False and all others on True:

&gt;&gt;&gt; idx.duplicated(keep='last')
array([ True, False,  True, False, False])

By setting keep on ``False``, all duplicates are True:

&gt;&gt;&gt; idx.duplicated(keep=False)
array([ True, False,  True, False,  True])
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ab9043ec7e942faaeae2350c8919dc62a">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3088</span>    ) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 3089</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3090</span><span class="stringliteral">        Indicate duplicate index values.</span></div>
<div class="line"><span class="lineno"> 3091</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3092</span><span class="stringliteral">        Duplicated values are indicated as ``True`` values in the resulting</span></div>
<div class="line"><span class="lineno"> 3093</span><span class="stringliteral">        array. Either all duplicates, all except the first, or all except the</span></div>
<div class="line"><span class="lineno"> 3094</span><span class="stringliteral">        last occurrence of duplicates can be indicated.</span></div>
<div class="line"><span class="lineno"> 3095</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3096</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3097</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3098</span><span class="stringliteral">        keep : {&#39;first&#39;, &#39;last&#39;, False}, default &#39;first&#39;</span></div>
<div class="line"><span class="lineno"> 3099</span><span class="stringliteral">            The value or values in a set of duplicates to mark as missing.</span></div>
<div class="line"><span class="lineno"> 3100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3101</span><span class="stringliteral">            - &#39;first&#39; : Mark duplicates as ``True`` except for the first</span></div>
<div class="line"><span class="lineno"> 3102</span><span class="stringliteral">              occurrence.</span></div>
<div class="line"><span class="lineno"> 3103</span><span class="stringliteral">            - &#39;last&#39; : Mark duplicates as ``True`` except for the last</span></div>
<div class="line"><span class="lineno"> 3104</span><span class="stringliteral">              occurrence.</span></div>
<div class="line"><span class="lineno"> 3105</span><span class="stringliteral">            - ``False`` : Mark all duplicates as ``True``.</span></div>
<div class="line"><span class="lineno"> 3106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3107</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3108</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3109</span><span class="stringliteral">        np.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 3110</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3111</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3112</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3113</span><span class="stringliteral">        Series.duplicated : Equivalent method on pandas.Series.</span></div>
<div class="line"><span class="lineno"> 3114</span><span class="stringliteral">        DataFrame.duplicated : Equivalent method on pandas.DataFrame.</span></div>
<div class="line"><span class="lineno"> 3115</span><span class="stringliteral">        Index.drop_duplicates : Remove duplicate values from Index.</span></div>
<div class="line"><span class="lineno"> 3116</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3117</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3118</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3119</span><span class="stringliteral">        By default, for each set of duplicated values, the first occurrence is</span></div>
<div class="line"><span class="lineno"> 3120</span><span class="stringliteral">        set to False and all others to True:</span></div>
<div class="line"><span class="lineno"> 3121</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3122</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;lama&#39;, &#39;cow&#39;, &#39;lama&#39;, &#39;beetle&#39;, &#39;lama&#39;])</span></div>
<div class="line"><span class="lineno"> 3123</span><span class="stringliteral">        &gt;&gt;&gt; idx.duplicated()</span></div>
<div class="line"><span class="lineno"> 3124</span><span class="stringliteral">        array([False, False,  True, False,  True])</span></div>
<div class="line"><span class="lineno"> 3125</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3126</span><span class="stringliteral">        which is equivalent to</span></div>
<div class="line"><span class="lineno"> 3127</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3128</span><span class="stringliteral">        &gt;&gt;&gt; idx.duplicated(keep=&#39;first&#39;)</span></div>
<div class="line"><span class="lineno"> 3129</span><span class="stringliteral">        array([False, False,  True, False,  True])</span></div>
<div class="line"><span class="lineno"> 3130</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3131</span><span class="stringliteral">        By using &#39;last&#39;, the last occurrence of each set of duplicated values</span></div>
<div class="line"><span class="lineno"> 3132</span><span class="stringliteral">        is set on False and all others on True:</span></div>
<div class="line"><span class="lineno"> 3133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3134</span><span class="stringliteral">        &gt;&gt;&gt; idx.duplicated(keep=&#39;last&#39;)</span></div>
<div class="line"><span class="lineno"> 3135</span><span class="stringliteral">        array([ True, False,  True, False, False])</span></div>
<div class="line"><span class="lineno"> 3136</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3137</span><span class="stringliteral">        By setting keep on ``False``, all duplicates are True:</span></div>
<div class="line"><span class="lineno"> 3138</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3139</span><span class="stringliteral">        &gt;&gt;&gt; idx.duplicated(keep=False)</span></div>
<div class="line"><span class="lineno"> 3140</span><span class="stringliteral">        array([ True, False,  True, False,  True])</span></div>
<div class="line"><span class="lineno"> 3141</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3142</span>        <span class="keywordflow">if</span> self.is_unique:</div>
<div class="line"><span class="lineno"> 3143</span>            <span class="comment"># fastpath available bc we are immutable</span></div>
<div class="line"><span class="lineno"> 3144</span>            <span class="keywordflow">return</span> np.zeros(len(self), dtype=bool)</div>
<div class="line"><span class="lineno"> 3145</span>        <span class="keywordflow">return</span> self._duplicated(keep=keep)</div>
<div class="line"><span class="lineno"> 3146</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9de144ee709375fcee0626bdf60f54bd" name="a9de144ee709375fcee0626bdf60f54bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de144ee709375fcee0626bdf60f54bd">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.equals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Any&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Determine if two Index object are equal.

The things that are being compared are:

* The elements inside the Index object.
* The order of the elements inside the Index object.

Parameters
----------
other : Any
    The other object to compare against.

Returns
-------
bool
    True if "other" is an Index and it has the same elements and order
    as the calling index; False otherwise.

Examples
--------
&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3])
&gt;&gt;&gt; idx1
Int64Index([1, 2, 3], dtype='int64')
&gt;&gt;&gt; idx1.equals(pd.Index([1, 2, 3]))
True

The elements inside are compared

&gt;&gt;&gt; idx2 = pd.Index(["1", "2", "3"])
&gt;&gt;&gt; idx2
Index(['1', '2', '3'], dtype='object')

&gt;&gt;&gt; idx1.equals(idx2)
False

The order is compared

&gt;&gt;&gt; ascending_idx = pd.Index([1, 2, 3])
&gt;&gt;&gt; ascending_idx
Int64Index([1, 2, 3], dtype='int64')
&gt;&gt;&gt; descending_idx = pd.Index([3, 2, 1])
&gt;&gt;&gt; descending_idx
Int64Index([3, 2, 1], dtype='int64')
&gt;&gt;&gt; ascending_idx.equals(descending_idx)
False

The dtype is *not* compared

&gt;&gt;&gt; int64_idx = pd.Index([1, 2, 3], dtype='int64')
&gt;&gt;&gt; int64_idx
Int64Index([1, 2, 3], dtype='int64')
&gt;&gt;&gt; uint64_idx = pd.Index([1, 2, 3], dtype='uint64')
&gt;&gt;&gt; uint64_idx
UInt64Index([1, 2, 3], dtype='uint64')
&gt;&gt;&gt; int64_idx.equals(uint64_idx)
True
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a9c97c9a1cc78bed5719935a135a0e5a7">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a15ca54aaa5bd9a350303e52b7797b8b7">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a52358406d0b973d05792633bcac3d8da">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ab15518f459af72cc40ec91a19942e1b3">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5507</span>    <span class="keyword">def </span>equals(self, other: Any) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5508</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5509</span><span class="stringliteral">        Determine if two Index object are equal.</span></div>
<div class="line"><span class="lineno"> 5510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5511</span><span class="stringliteral">        The things that are being compared are:</span></div>
<div class="line"><span class="lineno"> 5512</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5513</span><span class="stringliteral">        * The elements inside the Index object.</span></div>
<div class="line"><span class="lineno"> 5514</span><span class="stringliteral">        * The order of the elements inside the Index object.</span></div>
<div class="line"><span class="lineno"> 5515</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5516</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5517</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5518</span><span class="stringliteral">        other : Any</span></div>
<div class="line"><span class="lineno"> 5519</span><span class="stringliteral">            The other object to compare against.</span></div>
<div class="line"><span class="lineno"> 5520</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5521</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5522</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5523</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 5524</span><span class="stringliteral">            True if &quot;other&quot; is an Index and it has the same elements and order</span></div>
<div class="line"><span class="lineno"> 5525</span><span class="stringliteral">            as the calling index; False otherwise.</span></div>
<div class="line"><span class="lineno"> 5526</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5527</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5528</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5529</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 5530</span><span class="stringliteral">        &gt;&gt;&gt; idx1</span></div>
<div class="line"><span class="lineno"> 5531</span><span class="stringliteral">        Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5532</span><span class="stringliteral">        &gt;&gt;&gt; idx1.equals(pd.Index([1, 2, 3]))</span></div>
<div class="line"><span class="lineno"> 5533</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 5534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5535</span><span class="stringliteral">        The elements inside are compared</span></div>
<div class="line"><span class="lineno"> 5536</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5537</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])</span></div>
<div class="line"><span class="lineno"> 5538</span><span class="stringliteral">        &gt;&gt;&gt; idx2</span></div>
<div class="line"><span class="lineno"> 5539</span><span class="stringliteral">        Index([&#39;1&#39;, &#39;2&#39;, &#39;3&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 5540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5541</span><span class="stringliteral">        &gt;&gt;&gt; idx1.equals(idx2)</span></div>
<div class="line"><span class="lineno"> 5542</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 5543</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5544</span><span class="stringliteral">        The order is compared</span></div>
<div class="line"><span class="lineno"> 5545</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5546</span><span class="stringliteral">        &gt;&gt;&gt; ascending_idx = pd.Index([1, 2, 3])</span></div>
<div class="line"><span class="lineno"> 5547</span><span class="stringliteral">        &gt;&gt;&gt; ascending_idx</span></div>
<div class="line"><span class="lineno"> 5548</span><span class="stringliteral">        Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5549</span><span class="stringliteral">        &gt;&gt;&gt; descending_idx = pd.Index([3, 2, 1])</span></div>
<div class="line"><span class="lineno"> 5550</span><span class="stringliteral">        &gt;&gt;&gt; descending_idx</span></div>
<div class="line"><span class="lineno"> 5551</span><span class="stringliteral">        Int64Index([3, 2, 1], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5552</span><span class="stringliteral">        &gt;&gt;&gt; ascending_idx.equals(descending_idx)</span></div>
<div class="line"><span class="lineno"> 5553</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 5554</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5555</span><span class="stringliteral">        The dtype is *not* compared</span></div>
<div class="line"><span class="lineno"> 5556</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5557</span><span class="stringliteral">        &gt;&gt;&gt; int64_idx = pd.Index([1, 2, 3], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5558</span><span class="stringliteral">        &gt;&gt;&gt; int64_idx</span></div>
<div class="line"><span class="lineno"> 5559</span><span class="stringliteral">        Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5560</span><span class="stringliteral">        &gt;&gt;&gt; uint64_idx = pd.Index([1, 2, 3], dtype=&#39;uint64&#39;)</span></div>
<div class="line"><span class="lineno"> 5561</span><span class="stringliteral">        &gt;&gt;&gt; uint64_idx</span></div>
<div class="line"><span class="lineno"> 5562</span><span class="stringliteral">        UInt64Index([1, 2, 3], dtype=&#39;uint64&#39;)</span></div>
<div class="line"><span class="lineno"> 5563</span><span class="stringliteral">        &gt;&gt;&gt; int64_idx.equals(uint64_idx)</span></div>
<div class="line"><span class="lineno"> 5564</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 5565</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5566</span>        <span class="keywordflow">if</span> self.is_(other):</div>
<div class="line"><span class="lineno"> 5567</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 5568</span> </div>
<div class="line"><span class="lineno"> 5569</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(other, Index):</div>
<div class="line"><span class="lineno"> 5570</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5571</span> </div>
<div class="line"><span class="lineno"> 5572</span>        <span class="keywordflow">if</span> is_object_dtype(self.dtype) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_object_dtype(other.dtype):</div>
<div class="line"><span class="lineno"> 5573</span>            <span class="comment"># if other is not object, use other&#39;s logic for coercion</span></div>
<div class="line"><span class="lineno"> 5574</span>            <span class="keywordflow">return</span> other.equals(self)</div>
<div class="line"><span class="lineno"> 5575</span> </div>
<div class="line"><span class="lineno"> 5576</span>        <span class="keywordflow">if</span> isinstance(other, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 5577</span>            <span class="comment"># d-level MultiIndex can equal d-tuple Index</span></div>
<div class="line"><span class="lineno"> 5578</span>            <span class="keywordflow">return</span> other.equals(self)</div>
<div class="line"><span class="lineno"> 5579</span> </div>
<div class="line"><span class="lineno"> 5580</span>        <span class="keywordflow">if</span> isinstance(self._values, ExtensionArray):</div>
<div class="line"><span class="lineno"> 5581</span>            <span class="comment"># Dispatch to the ExtensionArray&#39;s .equals method.</span></div>
<div class="line"><span class="lineno"> 5582</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(other, type(self)):</div>
<div class="line"><span class="lineno"> 5583</span>                <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 5584</span> </div>
<div class="line"><span class="lineno"> 5585</span>            earr = cast(ExtensionArray, self._data)</div>
<div class="line"><span class="lineno"> 5586</span>            <span class="keywordflow">return</span> earr.equals(other._data)</div>
<div class="line"><span class="lineno"> 5587</span> </div>
<div class="line"><span class="lineno"> 5588</span>        <span class="keywordflow">if</span> is_extension_array_dtype(other.dtype):</div>
<div class="line"><span class="lineno"> 5589</span>            <span class="comment"># All EA-backed Index subclasses override equals</span></div>
<div class="line"><span class="lineno"> 5590</span>            <span class="keywordflow">return</span> other.equals(self)</div>
<div class="line"><span class="lineno"> 5591</span> </div>
<div class="line"><span class="lineno"> 5592</span>        <span class="keywordflow">return</span> array_equivalent(self._values, other._values)</div>
<div class="line"><span class="lineno"> 5593</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a468b626b7f95c07b7742e7e8af832491" name="a468b626b7f95c07b7742e7e8af832491"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468b626b7f95c07b7742e7e8af832491">&#9670;&#160;</a></span>fillna()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.fillna </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>downcast</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fill NA/NaN values with the specified value.

Parameters
----------
value : scalar
    Scalar value to use to fill holes (e.g. 0).
    This value cannot be a list-likes.
downcast : dict, default is None
    A dict of item-&gt;dtype of what to downcast if possible,
    or the string 'infer' which will try to downcast to an appropriate
    equal type (e.g. float64 to int64 if possible).

Returns
-------
Index

See Also
--------
DataFrame.fillna : Fill NaN values of a DataFrame.
Series.fillna : Fill NaN Values of a Series.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a749a0afe14c03e614c492b676b710594">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2942</span>    <span class="keyword">def </span>fillna(self, value=None, downcast=None):</div>
<div class="line"><span class="lineno"> 2943</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2944</span><span class="stringliteral">        Fill NA/NaN values with the specified value.</span></div>
<div class="line"><span class="lineno"> 2945</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2946</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2947</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2948</span><span class="stringliteral">        value : scalar</span></div>
<div class="line"><span class="lineno"> 2949</span><span class="stringliteral">            Scalar value to use to fill holes (e.g. 0).</span></div>
<div class="line"><span class="lineno"> 2950</span><span class="stringliteral">            This value cannot be a list-likes.</span></div>
<div class="line"><span class="lineno"> 2951</span><span class="stringliteral">        downcast : dict, default is None</span></div>
<div class="line"><span class="lineno"> 2952</span><span class="stringliteral">            A dict of item-&gt;dtype of what to downcast if possible,</span></div>
<div class="line"><span class="lineno"> 2953</span><span class="stringliteral">            or the string &#39;infer&#39; which will try to downcast to an appropriate</span></div>
<div class="line"><span class="lineno"> 2954</span><span class="stringliteral">            equal type (e.g. float64 to int64 if possible).</span></div>
<div class="line"><span class="lineno"> 2955</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2956</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2957</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2958</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 2959</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2960</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2961</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2962</span><span class="stringliteral">        DataFrame.fillna : Fill NaN values of a DataFrame.</span></div>
<div class="line"><span class="lineno"> 2963</span><span class="stringliteral">        Series.fillna : Fill NaN Values of a Series.</span></div>
<div class="line"><span class="lineno"> 2964</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2965</span> </div>
<div class="line"><span class="lineno"> 2966</span>        value = self._require_scalar(value)</div>
<div class="line"><span class="lineno"> 2967</span>        <span class="keywordflow">if</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 2968</span>            result = self.putmask(self._isnan, value)</div>
<div class="line"><span class="lineno"> 2969</span>            <span class="keywordflow">if</span> downcast <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 2970</span>                <span class="comment"># no need to care metadata other than name</span></div>
<div class="line"><span class="lineno"> 2971</span>                <span class="comment"># because it can&#39;t have freq if it has NaTs</span></div>
<div class="line"><span class="lineno"> 2972</span>                <span class="keywordflow">return</span> Index._with_infer(result, name=self.name)</div>
<div class="line"><span class="lineno"> 2973</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 2974</span>                f<span class="stringliteral">&quot;{type(self).__name__}.fillna does not support &#39;downcast&#39; &quot;</span></div>
<div class="line"><span class="lineno"> 2975</span>                <span class="stringliteral">&quot;argument values other than &#39;None&#39;.&quot;</span></div>
<div class="line"><span class="lineno"> 2976</span>            )</div>
<div class="line"><span class="lineno"> 2977</span>        <span class="keywordflow">return</span> self._view()</div>
<div class="line"><span class="lineno"> 2978</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4af499fd538f621f813b9334cef63bb4" name="a4af499fd538f621f813b9334cef63bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af499fd538f621f813b9334cef63bb4">&#9670;&#160;</a></span>format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> list[<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>] pandas.core.indexes.base.Index.format </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>name</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None &#160;</td>
          <td class="paramname"><em>formatter</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>na_rep</em> = <code>&quot;NaN&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Render a string representation of the Index.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#af8752ed2cadecf992bb5b8f00eb5626c">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aea791d68b0a52eab9fa901fbc7c0bacd">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1449</span>    ) -&gt; list[str_t]:</div>
<div class="line"><span class="lineno"> 1450</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1451</span><span class="stringliteral">        Render a string representation of the Index.</span></div>
<div class="line"><span class="lineno"> 1452</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1453</span>        header = []</div>
<div class="line"><span class="lineno"> 1454</span>        <span class="keywordflow">if</span> name:</div>
<div class="line"><span class="lineno"> 1455</span>            header.append(</div>
<div class="line"><span class="lineno"> 1456</span>                pprint_thing(self.name, escape_chars=(<span class="stringliteral">&quot;\t&quot;</span>, <span class="stringliteral">&quot;\r&quot;</span>, <span class="stringliteral">&quot;\n&quot;</span>))</div>
<div class="line"><span class="lineno"> 1457</span>                <span class="keywordflow">if</span> self.name <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 1458</span>                <span class="keywordflow">else</span> <span class="stringliteral">&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1459</span>            )</div>
<div class="line"><span class="lineno"> 1460</span> </div>
<div class="line"><span class="lineno"> 1461</span>        <span class="keywordflow">if</span> formatter <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1462</span>            <span class="keywordflow">return</span> header + list(self.map(formatter))</div>
<div class="line"><span class="lineno"> 1463</span> </div>
<div class="line"><span class="lineno"> 1464</span>        <span class="keywordflow">return</span> self._format_with_header(header, na_rep=na_rep)</div>
<div class="line"><span class="lineno"> 1465</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8ed8d6401e9429eb9ee365f636cffbe" name="ac8ed8d6401e9429eb9ee365f636cffbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ed8d6401e9429eb9ee365f636cffbe">&#9670;&#160;</a></span>get_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index.get_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> | None &#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 3897</span>    ) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 3898</span>        method = missing.clean_reindex_fill_method(method)</div>
<div class="line"><span class="lineno"> 3899</span>        orig_target = target</div>
<div class="line"><span class="lineno"> 3900</span>        target = self._maybe_cast_listlike_indexer(target)</div>
<div class="line"><span class="lineno"> 3901</span> </div>
<div class="line"><span class="lineno"> 3902</span>        self._check_indexing_method(method, limit, tolerance)</div>
<div class="line"><span class="lineno"> 3903</span> </div>
<div class="line"><span class="lineno"> 3904</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._index_as_unique:</div>
<div class="line"><span class="lineno"> 3905</span>            <span class="keywordflow">raise</span> InvalidIndexError(self._requires_unique_msg)</div>
<div class="line"><span class="lineno"> 3906</span> </div>
<div class="line"><span class="lineno"> 3907</span>        <span class="keywordflow">if</span> len(target) == 0:</div>
<div class="line"><span class="lineno"> 3908</span>            <span class="keywordflow">return</span> np.array([], dtype=np.intp)</div>
<div class="line"><span class="lineno"> 3909</span> </div>
<div class="line"><span class="lineno"> 3910</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._should_compare(target) <span class="keywordflow">and</span> <span class="keywordflow">not</span> self._should_partial_index(target):</div>
<div class="line"><span class="lineno"> 3911</span>            <span class="comment"># IntervalIndex get special treatment bc numeric scalars can be</span></div>
<div class="line"><span class="lineno"> 3912</span>            <span class="comment">#  matched to Interval scalars</span></div>
<div class="line"><span class="lineno"> 3913</span>            <span class="keywordflow">return</span> self._get_indexer_non_comparable(target, method=method, unique=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 3914</span> </div>
<div class="line"><span class="lineno"> 3915</span>        <span class="keywordflow">if</span> is_categorical_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 3916</span>            <span class="comment"># _maybe_cast_listlike_indexer ensures target has our dtype</span></div>
<div class="line"><span class="lineno"> 3917</span>            <span class="comment">#  (could improve perf by doing _should_compare check earlier?)</span></div>
<div class="line"><span class="lineno"> 3918</span>            <span class="keyword">assert</span> is_dtype_equal(self.dtype, target.dtype)</div>
<div class="line"><span class="lineno"> 3919</span> </div>
<div class="line"><span class="lineno"> 3920</span>            indexer = self._engine.get_indexer(target.codes)</div>
<div class="line"><span class="lineno"> 3921</span>            <span class="keywordflow">if</span> self.hasnans <span class="keywordflow">and</span> target.hasnans:</div>
<div class="line"><span class="lineno"> 3922</span>                <span class="comment"># After _maybe_cast_listlike_indexer, target elements which do not</span></div>
<div class="line"><span class="lineno"> 3923</span>                <span class="comment"># belong to some category are changed to NaNs</span></div>
<div class="line"><span class="lineno"> 3924</span>                <span class="comment"># Mask to track actual NaN values compared to inserted NaN values</span></div>
<div class="line"><span class="lineno"> 3925</span>                <span class="comment"># GH#45361</span></div>
<div class="line"><span class="lineno"> 3926</span>                target_nans = isna(orig_target)</div>
<div class="line"><span class="lineno"> 3927</span>                loc = self.get_loc(np.nan)</div>
<div class="line"><span class="lineno"> 3928</span>                mask = target.isna()</div>
<div class="line"><span class="lineno"> 3929</span>                indexer[target_nans] = loc</div>
<div class="line"><span class="lineno"> 3930</span>                indexer[mask &amp; ~target_nans] = -1</div>
<div class="line"><span class="lineno"> 3931</span>            <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 3932</span> </div>
<div class="line"><span class="lineno"> 3933</span>        <span class="keywordflow">if</span> is_categorical_dtype(target.dtype):</div>
<div class="line"><span class="lineno"> 3934</span>            <span class="comment"># potential fastpath</span></div>
<div class="line"><span class="lineno"> 3935</span>            <span class="comment"># get an indexer for unique categories then propagate to codes via take_nd</span></div>
<div class="line"><span class="lineno"> 3936</span>            <span class="comment"># get_indexer instead of _get_indexer needed for MultiIndex cases</span></div>
<div class="line"><span class="lineno"> 3937</span>            <span class="comment">#  e.g. test_append_different_columns_types</span></div>
<div class="line"><span class="lineno"> 3938</span>            categories_indexer = self.get_indexer(target.categories)</div>
<div class="line"><span class="lineno"> 3939</span> </div>
<div class="line"><span class="lineno"> 3940</span>            indexer = algos.take_nd(categories_indexer, target.codes, fill_value=-1)</div>
<div class="line"><span class="lineno"> 3941</span> </div>
<div class="line"><span class="lineno"> 3942</span>            <span class="keywordflow">if</span> (<span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> self.hasnans) <span class="keywordflow">and</span> target.hasnans:</div>
<div class="line"><span class="lineno"> 3943</span>                <span class="comment"># Exclude MultiIndex because hasnans raises NotImplementedError</span></div>
<div class="line"><span class="lineno"> 3944</span>                <span class="comment"># we should only get here if we are unique, so loc is an integer</span></div>
<div class="line"><span class="lineno"> 3945</span>                <span class="comment"># GH#41934</span></div>
<div class="line"><span class="lineno"> 3946</span>                loc = self.get_loc(np.nan)</div>
<div class="line"><span class="lineno"> 3947</span>                mask = target.isna()</div>
<div class="line"><span class="lineno"> 3948</span>                indexer[mask] = loc</div>
<div class="line"><span class="lineno"> 3949</span> </div>
<div class="line"><span class="lineno"> 3950</span>            <span class="keywordflow">return</span> ensure_platform_int(indexer)</div>
<div class="line"><span class="lineno"> 3951</span> </div>
<div class="line"><span class="lineno"> 3952</span>        pself, ptarget = self._maybe_promote(target)</div>
<div class="line"><span class="lineno"> 3953</span>        <span class="keywordflow">if</span> pself <span class="keywordflow">is</span> <span class="keywordflow">not</span> self <span class="keywordflow">or</span> ptarget <span class="keywordflow">is</span> <span class="keywordflow">not</span> target:</div>
<div class="line"><span class="lineno"> 3954</span>            <span class="keywordflow">return</span> pself.get_indexer(</div>
<div class="line"><span class="lineno"> 3955</span>                ptarget, method=method, limit=limit, tolerance=tolerance</div>
<div class="line"><span class="lineno"> 3956</span>            )</div>
<div class="line"><span class="lineno"> 3957</span> </div>
<div class="line"><span class="lineno"> 3958</span>        <span class="keywordflow">if</span> is_dtype_equal(self.dtype, target.dtype) <span class="keywordflow">and</span> self.equals(target):</div>
<div class="line"><span class="lineno"> 3959</span>            <span class="comment"># Only call equals if we have same dtype to avoid inference/casting</span></div>
<div class="line"><span class="lineno"> 3960</span>            <span class="keywordflow">return</span> np.arange(len(target), dtype=np.intp)</div>
<div class="line"><span class="lineno"> 3961</span> </div>
<div class="line"><span class="lineno"> 3962</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, target.dtype) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_interval_dtype(</div>
<div class="line"><span class="lineno"> 3963</span>            self.dtype</div>
<div class="line"><span class="lineno"> 3964</span>        ):</div>
<div class="line"><span class="lineno"> 3965</span>            <span class="comment"># IntervalIndex gets special treatment for partial-indexing</span></div>
<div class="line"><span class="lineno"> 3966</span>            dtype = self._find_common_type_compat(target)</div>
<div class="line"><span class="lineno"> 3967</span> </div>
<div class="line"><span class="lineno"> 3968</span>            this = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3969</span>            target = target.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3970</span>            <span class="keywordflow">return</span> this._get_indexer(</div>
<div class="line"><span class="lineno"> 3971</span>                target, method=method, limit=limit, tolerance=tolerance</div>
<div class="line"><span class="lineno"> 3972</span>            )</div>
<div class="line"><span class="lineno"> 3973</span> </div>
<div class="line"><span class="lineno"> 3974</span>        <span class="keywordflow">return</span> self._get_indexer(target, method, limit, tolerance)</div>
<div class="line"><span class="lineno"> 3975</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a6ad01cb4764f92e08a6c7047b7f8a9dd" name="a6ad01cb4764f92e08a6c7047b7f8a9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad01cb4764f92e08a6c7047b7f8a9dd">&#9670;&#160;</a></span>get_indexer_for()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.intp] pandas.core.indexes.base.Index.get_indexer_for </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Guaranteed return of an indexer even when non-unique.

This dispatches to get_indexer or get_indexer_non_unique
as appropriate.

Returns
-------
np.ndarray[np.intp]
    List of indices.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([np.nan, 'var1', np.nan])
&gt;&gt;&gt; idx.get_indexer_for([np.nan])
array([0, 2])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6076</span>    <span class="keyword">def </span>get_indexer_for(self, target) -&gt; npt.NDArray[np.intp]:</div>
<div class="line"><span class="lineno"> 6077</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6078</span><span class="stringliteral">        Guaranteed return of an indexer even when non-unique.</span></div>
<div class="line"><span class="lineno"> 6079</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6080</span><span class="stringliteral">        This dispatches to get_indexer or get_indexer_non_unique</span></div>
<div class="line"><span class="lineno"> 6081</span><span class="stringliteral">        as appropriate.</span></div>
<div class="line"><span class="lineno"> 6082</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6083</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6084</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6085</span><span class="stringliteral">        np.ndarray[np.intp]</span></div>
<div class="line"><span class="lineno"> 6086</span><span class="stringliteral">            List of indices.</span></div>
<div class="line"><span class="lineno"> 6087</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6088</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 6089</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6090</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([np.nan, &#39;var1&#39;, np.nan])</span></div>
<div class="line"><span class="lineno"> 6091</span><span class="stringliteral">        &gt;&gt;&gt; idx.get_indexer_for([np.nan])</span></div>
<div class="line"><span class="lineno"> 6092</span><span class="stringliteral">        array([0, 2])</span></div>
<div class="line"><span class="lineno"> 6093</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6094</span>        <span class="keywordflow">if</span> self._index_as_unique:</div>
<div class="line"><span class="lineno"> 6095</span>            <span class="keywordflow">return</span> self.get_indexer(target)</div>
<div class="line"><span class="lineno"> 6096</span>        indexer, _ = self.get_indexer_non_unique(target)</div>
<div class="line"><span class="lineno"> 6097</span>        <span class="keywordflow">return</span> indexer</div>
<div class="line"><span class="lineno"> 6098</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abb228f0a8f17ec6541bbce50ef934c59" name="abb228f0a8f17ec6541bbce50ef934c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb228f0a8f17ec6541bbce50ef934c59">&#9670;&#160;</a></span>get_indexer_non_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]] pandas.core.indexes.base.Index.get_indexer_non_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a9cda749ac1b0d3864aea3fb4dc246ffd">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6041</span>    ) -&gt; tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]:</div>
<div class="line"><span class="lineno"> 6042</span>        target = ensure_index(target)</div>
<div class="line"><span class="lineno"> 6043</span>        target = self._maybe_cast_listlike_indexer(target)</div>
<div class="line"><span class="lineno"> 6044</span> </div>
<div class="line"><span class="lineno"> 6045</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._should_compare(target) <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_interval_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 6046</span>            <span class="comment"># IntervalIndex get special treatment bc numeric scalars can be</span></div>
<div class="line"><span class="lineno"> 6047</span>            <span class="comment">#  matched to Interval scalars</span></div>
<div class="line"><span class="lineno"> 6048</span>            <span class="keywordflow">return</span> self._get_indexer_non_comparable(target, method=<span class="keywordtype">None</span>, unique=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 6049</span> </div>
<div class="line"><span class="lineno"> 6050</span>        pself, ptarget = self._maybe_promote(target)</div>
<div class="line"><span class="lineno"> 6051</span>        <span class="keywordflow">if</span> pself <span class="keywordflow">is</span> <span class="keywordflow">not</span> self <span class="keywordflow">or</span> ptarget <span class="keywordflow">is</span> <span class="keywordflow">not</span> target:</div>
<div class="line"><span class="lineno"> 6052</span>            <span class="keywordflow">return</span> pself.get_indexer_non_unique(ptarget)</div>
<div class="line"><span class="lineno"> 6053</span> </div>
<div class="line"><span class="lineno"> 6054</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, target.dtype):</div>
<div class="line"><span class="lineno"> 6055</span>            <span class="comment"># TODO: if object, could use infer_dtype to preempt costly</span></div>
<div class="line"><span class="lineno"> 6056</span>            <span class="comment">#  conversion if still non-comparable?</span></div>
<div class="line"><span class="lineno"> 6057</span>            dtype = self._find_common_type_compat(target)</div>
<div class="line"><span class="lineno"> 6058</span> </div>
<div class="line"><span class="lineno"> 6059</span>            this = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 6060</span>            that = target.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 6061</span>            <span class="keywordflow">return</span> this.get_indexer_non_unique(that)</div>
<div class="line"><span class="lineno"> 6062</span> </div>
<div class="line"><span class="lineno"> 6063</span>        <span class="comment"># Note: _maybe_promote ensures we never get here with MultiIndex</span></div>
<div class="line"><span class="lineno"> 6064</span>        <span class="comment">#  self and non-Multi target</span></div>
<div class="line"><span class="lineno"> 6065</span>        tgt_values = target._get_engine_target()</div>
<div class="line"><span class="lineno"> 6066</span>        <span class="keywordflow">if</span> self._is_multi <span class="keywordflow">and</span> target._is_multi:</div>
<div class="line"><span class="lineno"> 6067</span>            engine = self._engine</div>
<div class="line"><span class="lineno"> 6068</span>            <span class="comment"># Item &quot;IndexEngine&quot; of &quot;Union[IndexEngine, ExtensionEngine]&quot; has</span></div>
<div class="line"><span class="lineno"> 6069</span>            <span class="comment"># no attribute &quot;_extract_level_codes&quot;</span></div>
<div class="line"><span class="lineno"> 6070</span>            tgt_values = engine._extract_level_codes(target)  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 6071</span> </div>
<div class="line"><span class="lineno"> 6072</span>        indexer, missing = self._engine.get_indexer_non_unique(tgt_values)</div>
<div class="line"><span class="lineno"> 6073</span>        <span class="keywordflow">return</span> ensure_platform_int(indexer), ensure_platform_int(missing)</div>
<div class="line"><span class="lineno"> 6074</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4558511f6c65512766f5bde05fad2d3" name="ac4558511f6c65512766f5bde05fad2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4558511f6c65512766f5bde05fad2d3">&#9670;&#160;</a></span>get_loc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.get_loc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get integer location, slice or boolean mask for requested label.

Parameters
----------
key : label
method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
    * default: exact matches only.
    * pad / ffill: find the PREVIOUS index value if no exact match.
    * backfill / bfill: use NEXT index value if no exact match
    * nearest: use the NEAREST index value if no exact match. Tied
      distances are broken by preferring the larger index value.

    .. deprecated:: 1.4
        Use index.get_indexer([item], method=...) instead.

tolerance : int or float, optional
    Maximum distance from index value for inexact matches. The value of
    the index at the matching location must satisfy the equation
    ``abs(index[loc] - key) &lt;= tolerance``.

Returns
-------
loc : int if unique index, slice if monotonic index, else mask

Examples
--------
&gt;&gt;&gt; unique_index = pd.Index(list('abc'))
&gt;&gt;&gt; unique_index.get_loc('b')
1

&gt;&gt;&gt; monotonic_index = pd.Index(list('abbc'))
&gt;&gt;&gt; monotonic_index.get_loc('b')
slice(1, 3, None)

&gt;&gt;&gt; non_monotonic_index = pd.Index(list('abcb'))
&gt;&gt;&gt; non_monotonic_index.get_loc('b')
array([False,  True, False,  True])
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aa49d12a2ae855c54bec7305f94b86aa7">pandas.core.indexes.multi.MultiIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#ab8f2eb1cb299e038de83666b95e33636">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a037e148454773def1fdc95ff4fd18057">pandas.core.indexes.period.PeriodIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#aeaa844711b6aff7ced01c38b33cac99b">pandas.core.indexes.range.RangeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#a49bdb7b7658ece3e44425b39d3c2c8b1">pandas.core.indexes.timedeltas.TimedeltaIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a16c9bd47038eadc91d722d882fe9de6c">pandas.core.indexes.interval.IntervalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3755</span>    <span class="keyword">def </span>get_loc(self, key, method=None, tolerance=None):</div>
<div class="line"><span class="lineno"> 3756</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3757</span><span class="stringliteral">        Get integer location, slice or boolean mask for requested label.</span></div>
<div class="line"><span class="lineno"> 3758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3759</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3760</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3761</span><span class="stringliteral">        key : label</span></div>
<div class="line"><span class="lineno"> 3762</span><span class="stringliteral">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 3763</span><span class="stringliteral">            * default: exact matches only.</span></div>
<div class="line"><span class="lineno"> 3764</span><span class="stringliteral">            * pad / ffill: find the PREVIOUS index value if no exact match.</span></div>
<div class="line"><span class="lineno"> 3765</span><span class="stringliteral">            * backfill / bfill: use NEXT index value if no exact match</span></div>
<div class="line"><span class="lineno"> 3766</span><span class="stringliteral">            * nearest: use the NEAREST index value if no exact match. Tied</span></div>
<div class="line"><span class="lineno"> 3767</span><span class="stringliteral">              distances are broken by preferring the larger index value.</span></div>
<div class="line"><span class="lineno"> 3768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3769</span><span class="stringliteral">            .. deprecated:: 1.4</span></div>
<div class="line"><span class="lineno"> 3770</span><span class="stringliteral">                Use index.get_indexer([item], method=...) instead.</span></div>
<div class="line"><span class="lineno"> 3771</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3772</span><span class="stringliteral">        tolerance : int or float, optional</span></div>
<div class="line"><span class="lineno"> 3773</span><span class="stringliteral">            Maximum distance from index value for inexact matches. The value of</span></div>
<div class="line"><span class="lineno"> 3774</span><span class="stringliteral">            the index at the matching location must satisfy the equation</span></div>
<div class="line"><span class="lineno"> 3775</span><span class="stringliteral">            ``abs(index[loc] - key) &lt;= tolerance``.</span></div>
<div class="line"><span class="lineno"> 3776</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3777</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3778</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3779</span><span class="stringliteral">        loc : int if unique index, slice if monotonic index, else mask</span></div>
<div class="line"><span class="lineno"> 3780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3781</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3782</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3783</span><span class="stringliteral">        &gt;&gt;&gt; unique_index = pd.Index(list(&#39;abc&#39;))</span></div>
<div class="line"><span class="lineno"> 3784</span><span class="stringliteral">        &gt;&gt;&gt; unique_index.get_loc(&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 3785</span><span class="stringliteral">        1</span></div>
<div class="line"><span class="lineno"> 3786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3787</span><span class="stringliteral">        &gt;&gt;&gt; monotonic_index = pd.Index(list(&#39;abbc&#39;))</span></div>
<div class="line"><span class="lineno"> 3788</span><span class="stringliteral">        &gt;&gt;&gt; monotonic_index.get_loc(&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 3789</span><span class="stringliteral">        slice(1, 3, None)</span></div>
<div class="line"><span class="lineno"> 3790</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3791</span><span class="stringliteral">        &gt;&gt;&gt; non_monotonic_index = pd.Index(list(&#39;abcb&#39;))</span></div>
<div class="line"><span class="lineno"> 3792</span><span class="stringliteral">        &gt;&gt;&gt; non_monotonic_index.get_loc(&#39;b&#39;)</span></div>
<div class="line"><span class="lineno"> 3793</span><span class="stringliteral">        array([False,  True, False,  True])</span></div>
<div class="line"><span class="lineno"> 3794</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3795</span>        <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3796</span>            <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3797</span>                <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 3798</span>                    <span class="stringliteral">&quot;tolerance argument only valid if using pad, &quot;</span></div>
<div class="line"><span class="lineno"> 3799</span>                    <span class="stringliteral">&quot;backfill or nearest lookups&quot;</span></div>
<div class="line"><span class="lineno"> 3800</span>                )</div>
<div class="line"><span class="lineno"> 3801</span>            casted_key = self._maybe_cast_indexer(key)</div>
<div class="line"><span class="lineno"> 3802</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 3803</span>                <span class="keywordflow">return</span> self._engine.get_loc(casted_key)</div>
<div class="line"><span class="lineno"> 3804</span>            <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 3805</span>                <span class="keywordflow">raise</span> KeyError(key) <span class="keyword">from</span> err</div>
<div class="line"><span class="lineno"> 3806</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 3807</span>                <span class="comment"># If we have a listlike key, _check_indexing_error will raise</span></div>
<div class="line"><span class="lineno"> 3808</span>                <span class="comment">#  InvalidIndexError. Otherwise we fall through and re-raise</span></div>
<div class="line"><span class="lineno"> 3809</span>                <span class="comment">#  the TypeError.</span></div>
<div class="line"><span class="lineno"> 3810</span>                self._check_indexing_error(key)</div>
<div class="line"><span class="lineno"> 3811</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 3812</span> </div>
<div class="line"><span class="lineno"> 3813</span>        <span class="comment"># GH#42269</span></div>
<div class="line"><span class="lineno"> 3814</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 3815</span>            f<span class="stringliteral">&quot;Passing method to {type(self).__name__}.get_loc is deprecated &quot;</span></div>
<div class="line"><span class="lineno"> 3816</span>            <span class="stringliteral">&quot;and will raise in a future version. Use &quot;</span></div>
<div class="line"><span class="lineno"> 3817</span>            <span class="stringliteral">&quot;index.get_indexer([item], method=...) instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 3818</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 3819</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 3820</span>        )</div>
<div class="line"><span class="lineno"> 3821</span> </div>
<div class="line"><span class="lineno"> 3822</span>        <span class="keywordflow">if</span> is_scalar(key) <span class="keywordflow">and</span> isna(key) <span class="keywordflow">and</span> <span class="keywordflow">not</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 3823</span>            <span class="keywordflow">raise</span> KeyError(key)</div>
<div class="line"><span class="lineno"> 3824</span> </div>
<div class="line"><span class="lineno"> 3825</span>        <span class="keywordflow">if</span> tolerance <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3826</span>            tolerance = self._convert_tolerance(tolerance, np.asarray(key))</div>
<div class="line"><span class="lineno"> 3827</span> </div>
<div class="line"><span class="lineno"> 3828</span>        indexer = self.get_indexer([key], method=method, tolerance=tolerance)</div>
<div class="line"><span class="lineno"> 3829</span>        <span class="keywordflow">if</span> indexer.ndim &gt; 1 <span class="keywordflow">or</span> indexer.size &gt; 1:</div>
<div class="line"><span class="lineno"> 3830</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;get_loc requires scalar valued input&quot;</span>)</div>
<div class="line"><span class="lineno"> 3831</span>        loc = indexer.item()</div>
<div class="line"><span class="lineno"> 3832</span>        <span class="keywordflow">if</span> loc == -1:</div>
<div class="line"><span class="lineno"> 3833</span>            <span class="keywordflow">raise</span> KeyError(key)</div>
<div class="line"><span class="lineno"> 3834</span>        <span class="keywordflow">return</span> loc</div>
<div class="line"><span class="lineno"> 3835</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a982caf9e7632d89dafc1dc0ecc987f2f" name="a982caf9e7632d89dafc1dc0ecc987f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982caf9e7632d89dafc1dc0ecc987f2f">&#9670;&#160;</a></span>get_slice_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.get_slice_bound </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[&quot;left&quot;, &quot;right&quot;]&#160;</td>
          <td class="paramname"><em>side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Calculate slice bound that corresponds to given label.

Returns leftmost (one-past-the-rightmost if ``side=='right'``) position
of given label.

Parameters
----------
label : object
side : {'left', 'right'}
kind : {'loc', 'getitem'} or None

    .. deprecated:: 1.4.0

Returns
-------
int
    Index of label.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a41b9251cafc6fb27b63baea5956498b7">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6686</span>    ) -&gt; int:</div>
<div class="line"><span class="lineno"> 6687</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6688</span><span class="stringliteral">        Calculate slice bound that corresponds to given label.</span></div>
<div class="line"><span class="lineno"> 6689</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6690</span><span class="stringliteral">        Returns leftmost (one-past-the-rightmost if ``side==&#39;right&#39;``) position</span></div>
<div class="line"><span class="lineno"> 6691</span><span class="stringliteral">        of given label.</span></div>
<div class="line"><span class="lineno"> 6692</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6693</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6694</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6695</span><span class="stringliteral">        label : object</span></div>
<div class="line"><span class="lineno"> 6696</span><span class="stringliteral">        side : {&#39;left&#39;, &#39;right&#39;}</span></div>
<div class="line"><span class="lineno"> 6697</span><span class="stringliteral">        kind : {&#39;loc&#39;, &#39;getitem&#39;} or None</span></div>
<div class="line"><span class="lineno"> 6698</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6699</span><span class="stringliteral">            .. deprecated:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 6700</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6701</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6702</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6703</span><span class="stringliteral">        int</span></div>
<div class="line"><span class="lineno"> 6704</span><span class="stringliteral">            Index of label.</span></div>
<div class="line"><span class="lineno"> 6705</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6706</span>        <span class="keyword">assert</span> kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;loc&quot;</span>, <span class="stringliteral">&quot;getitem&quot;</span>, <span class="keywordtype">None</span>, no_default]</div>
<div class="line"><span class="lineno"> 6707</span>        self._deprecated_arg(kind, <span class="stringliteral">&quot;kind&quot;</span>, <span class="stringliteral">&quot;get_slice_bound&quot;</span>)</div>
<div class="line"><span class="lineno"> 6708</span> </div>
<div class="line"><span class="lineno"> 6709</span>        <span class="keywordflow">if</span> side <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;right&quot;</span>):</div>
<div class="line"><span class="lineno"> 6710</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 6711</span>                <span class="stringliteral">&quot;Invalid value for side kwarg, must be either &quot;</span></div>
<div class="line"><span class="lineno"> 6712</span>                f<span class="stringliteral">&quot;&#39;left&#39; or &#39;right&#39;: {side}&quot;</span></div>
<div class="line"><span class="lineno"> 6713</span>            )</div>
<div class="line"><span class="lineno"> 6714</span> </div>
<div class="line"><span class="lineno"> 6715</span>        original_label = label</div>
<div class="line"><span class="lineno"> 6716</span> </div>
<div class="line"><span class="lineno"> 6717</span>        <span class="comment"># For datetime indices label may be a string that has to be converted</span></div>
<div class="line"><span class="lineno"> 6718</span>        <span class="comment"># to datetime boundary according to its resolution.</span></div>
<div class="line"><span class="lineno"> 6719</span>        label = self._maybe_cast_slice_bound(label, side)</div>
<div class="line"><span class="lineno"> 6720</span> </div>
<div class="line"><span class="lineno"> 6721</span>        <span class="comment"># we need to look up the label</span></div>
<div class="line"><span class="lineno"> 6722</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6723</span>            slc = self.get_loc(label)</div>
<div class="line"><span class="lineno"> 6724</span>        <span class="keywordflow">except</span> KeyError <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 6725</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6726</span>                <span class="keywordflow">return</span> self._searchsorted_monotonic(label, side)</div>
<div class="line"><span class="lineno"> 6727</span>            <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 6728</span>                <span class="comment"># raise the original KeyError</span></div>
<div class="line"><span class="lineno"> 6729</span>                <span class="keywordflow">raise</span> err</div>
<div class="line"><span class="lineno"> 6730</span> </div>
<div class="line"><span class="lineno"> 6731</span>        <span class="keywordflow">if</span> isinstance(slc, np.ndarray):</div>
<div class="line"><span class="lineno"> 6732</span>            <span class="comment"># get_loc may return a boolean array, which</span></div>
<div class="line"><span class="lineno"> 6733</span>            <span class="comment"># is OK as long as they are representable by a slice.</span></div>
<div class="line"><span class="lineno"> 6734</span>            <span class="keyword">assert</span> is_bool_dtype(slc.dtype)</div>
<div class="line"><span class="lineno"> 6735</span>            slc = lib.maybe_booleans_to_slice(slc.view(<span class="stringliteral">&quot;u1&quot;</span>))</div>
<div class="line"><span class="lineno"> 6736</span>            <span class="keywordflow">if</span> isinstance(slc, np.ndarray):</div>
<div class="line"><span class="lineno"> 6737</span>                <span class="keywordflow">raise</span> KeyError(</div>
<div class="line"><span class="lineno"> 6738</span>                    f<span class="stringliteral">&quot;Cannot get {side} slice bound for non-unique &quot;</span></div>
<div class="line"><span class="lineno"> 6739</span>                    f<span class="stringliteral">&quot;label: {repr(original_label)}&quot;</span></div>
<div class="line"><span class="lineno"> 6740</span>                )</div>
<div class="line"><span class="lineno"> 6741</span> </div>
<div class="line"><span class="lineno"> 6742</span>        <span class="keywordflow">if</span> isinstance(slc, slice):</div>
<div class="line"><span class="lineno"> 6743</span>            <span class="keywordflow">if</span> side == <span class="stringliteral">&quot;left&quot;</span>:</div>
<div class="line"><span class="lineno"> 6744</span>                <span class="keywordflow">return</span> slc.start</div>
<div class="line"><span class="lineno"> 6745</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6746</span>                <span class="keywordflow">return</span> slc.stop</div>
<div class="line"><span class="lineno"> 6747</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6748</span>            <span class="keywordflow">if</span> side == <span class="stringliteral">&quot;right&quot;</span>:</div>
<div class="line"><span class="lineno"> 6749</span>                <span class="keywordflow">return</span> slc + 1</div>
<div class="line"><span class="lineno"> 6750</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6751</span>                <span class="keywordflow">return</span> slc</div>
<div class="line"><span class="lineno"> 6752</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3addf078ac693c762d0075e1d2d5ee6" name="ab3addf078ac693c762d0075e1d2d5ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3addf078ac693c762d0075e1d2d5ee6">&#9670;&#160;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.get_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Series&#160;</td>
          <td class="paramname"><em>series</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fast lookup of value from 1-dimensional ndarray.

Only use this if you know what you're doing.

Returns
-------
scalar or Series
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5926</span>    <span class="keyword">def </span>get_value(self, series: Series, key):</div>
<div class="line"><span class="lineno"> 5927</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5928</span><span class="stringliteral">        Fast lookup of value from 1-dimensional ndarray.</span></div>
<div class="line"><span class="lineno"> 5929</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5930</span><span class="stringliteral">        Only use this if you know what you&#39;re doing.</span></div>
<div class="line"><span class="lineno"> 5931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5932</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5933</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5934</span><span class="stringliteral">        scalar or Series</span></div>
<div class="line"><span class="lineno"> 5935</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5936</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 5937</span>            <span class="stringliteral">&quot;get_value is deprecated and will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 5938</span>            <span class="stringliteral">&quot;Use Series[key] instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 5939</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 5940</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 5941</span>        )</div>
<div class="line"><span class="lineno"> 5942</span> </div>
<div class="line"><span class="lineno"> 5943</span>        self._check_indexing_error(key)</div>
<div class="line"><span class="lineno"> 5944</span> </div>
<div class="line"><span class="lineno"> 5945</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5946</span>            <span class="comment"># GH 20882, 21257</span></div>
<div class="line"><span class="lineno"> 5947</span>            <span class="comment"># First try to convert the key to a location</span></div>
<div class="line"><span class="lineno"> 5948</span>            <span class="comment"># If that fails, raise a KeyError if an integer</span></div>
<div class="line"><span class="lineno"> 5949</span>            <span class="comment"># index, otherwise, see if key is an integer, and</span></div>
<div class="line"><span class="lineno"> 5950</span>            <span class="comment"># try that</span></div>
<div class="line"><span class="lineno"> 5951</span>            loc = self.get_loc(key)</div>
<div class="line"><span class="lineno"> 5952</span>        <span class="keywordflow">except</span> KeyError:</div>
<div class="line"><span class="lineno"> 5953</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._should_fallback_to_positional:</div>
<div class="line"><span class="lineno"> 5954</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 5955</span>            <span class="keywordflow">elif</span> is_integer(key):</div>
<div class="line"><span class="lineno"> 5956</span>                <span class="comment"># If the Index cannot hold integer, then this is unambiguously</span></div>
<div class="line"><span class="lineno"> 5957</span>                <span class="comment">#  a locational lookup.</span></div>
<div class="line"><span class="lineno"> 5958</span>                loc = key</div>
<div class="line"><span class="lineno"> 5959</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5960</span>                <span class="keywordflow">raise</span></div>
<div class="line"><span class="lineno"> 5961</span> </div>
<div class="line"><span class="lineno"> 5962</span>        <span class="keywordflow">return</span> self._get_values_for_loc(series, loc, key)</div>
<div class="line"><span class="lineno"> 5963</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4bbf5d5324d7161721ced420d788a1dc" name="a4bbf5d5324d7161721ced420d788a1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbf5d5324d7161721ced420d788a1dc">&#9670;&#160;</a></span>groupby()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1io_1_1formats_1_1printing_1_1_pretty_dict.html">PrettyDict</a>[Hashable, np.ndarray] pandas.core.indexes.base.Index.groupby </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Group the index labels by a given array of values.

Parameters
----------
values : array
    Values used to determine the groups.

Returns
-------
dict
    {group name -&gt; group labels}
</pre> <div class="fragment"><div class="line"><span class="lineno"> 6357</span>    <span class="keyword">def </span>groupby(self, values) -&gt; PrettyDict[Hashable, np.ndarray]:</div>
<div class="line"><span class="lineno"> 6358</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6359</span><span class="stringliteral">        Group the index labels by a given array of values.</span></div>
<div class="line"><span class="lineno"> 6360</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6361</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6362</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6363</span><span class="stringliteral">        values : array</span></div>
<div class="line"><span class="lineno"> 6364</span><span class="stringliteral">            Values used to determine the groups.</span></div>
<div class="line"><span class="lineno"> 6365</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6366</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6367</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6368</span><span class="stringliteral">        dict</span></div>
<div class="line"><span class="lineno"> 6369</span><span class="stringliteral">            {group name -&gt; group labels}</span></div>
<div class="line"><span class="lineno"> 6370</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6371</span>        <span class="comment"># TODO: if we are a MultiIndex, we can do better</span></div>
<div class="line"><span class="lineno"> 6372</span>        <span class="comment"># that converting to tuples</span></div>
<div class="line"><span class="lineno"> 6373</span>        <span class="keywordflow">if</span> isinstance(values, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 6374</span>            values = values._values</div>
<div class="line"><span class="lineno"> 6375</span>        values = Categorical(values)</div>
<div class="line"><span class="lineno"> 6376</span>        result = values._reverse_indexer()</div>
<div class="line"><span class="lineno"> 6377</span> </div>
<div class="line"><span class="lineno"> 6378</span>        <span class="comment"># map to the label</span></div>
<div class="line"><span class="lineno"> 6379</span>        result = {k: self.take(v) <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> result.items()}</div>
<div class="line"><span class="lineno"> 6380</span> </div>
<div class="line"><span class="lineno"> 6381</span>        <span class="keywordflow">return</span> PrettyDict(result)</div>
<div class="line"><span class="lineno"> 6382</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4c61640fa376eeca9c49deb83154c97" name="ad4c61640fa376eeca9c49deb83154c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c61640fa376eeca9c49deb83154c97">&#9670;&#160;</a></span>has_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.has_duplicates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index has duplicate values.

Returns
-------
bool
    Whether or not the Index has duplicate values.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1, 5, 7, 7])
&gt;&gt;&gt; idx.has_duplicates
True

&gt;&gt;&gt; idx = pd.Index([1, 5, 7])
&gt;&gt;&gt; idx.has_duplicates
False

&gt;&gt;&gt; idx = pd.Index(["Watermelon", "Orange", "Apple",
...                 "Watermelon"]).astype("category")
&gt;&gt;&gt; idx.has_duplicates
True

&gt;&gt;&gt; idx = pd.Index(["Orange", "Apple",
...                 "Watermelon"]).astype("category")
&gt;&gt;&gt; idx.has_duplicates
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2391</span>    <span class="keyword">def </span>has_duplicates(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2392</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2393</span><span class="stringliteral">        Check if the Index has duplicate values.</span></div>
<div class="line"><span class="lineno"> 2394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2395</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2396</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2397</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2398</span><span class="stringliteral">            Whether or not the Index has duplicate values.</span></div>
<div class="line"><span class="lineno"> 2399</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2400</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2401</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2402</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7, 7])</span></div>
<div class="line"><span class="lineno"> 2403</span><span class="stringliteral">        &gt;&gt;&gt; idx.has_duplicates</span></div>
<div class="line"><span class="lineno"> 2404</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2405</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2406</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 5, 7])</span></div>
<div class="line"><span class="lineno"> 2407</span><span class="stringliteral">        &gt;&gt;&gt; idx.has_duplicates</span></div>
<div class="line"><span class="lineno"> 2408</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2409</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2410</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span></div>
<div class="line"><span class="lineno"> 2411</span><span class="stringliteral">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span></div>
<div class="line"><span class="lineno"> 2412</span><span class="stringliteral">        &gt;&gt;&gt; idx.has_duplicates</span></div>
<div class="line"><span class="lineno"> 2413</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2414</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2415</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Orange&quot;, &quot;Apple&quot;,</span></div>
<div class="line"><span class="lineno"> 2416</span><span class="stringliteral">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span></div>
<div class="line"><span class="lineno"> 2417</span><span class="stringliteral">        &gt;&gt;&gt; idx.has_duplicates</span></div>
<div class="line"><span class="lineno"> 2418</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2419</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2420</span>        <span class="keywordflow">return</span> <span class="keywordflow">not</span> self.is_unique</div>
<div class="line"><span class="lineno"> 2421</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af5adc82ea31ab153a79bbd7ab3a6ce13" name="af5adc82ea31ab153a79bbd7ab3a6ce13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5adc82ea31ab153a79bbd7ab3a6ce13">&#9670;&#160;</a></span>hasnans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.hasnans </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if there are any NaNs.

Enables various performance speedups.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a0067c96706913675e437ee95e27ed783">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a2cca65b0a2e669dd7f92c9ea9445313b">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2826</span>    <span class="keyword">def </span>hasnans(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2827</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2828</span><span class="stringliteral">        Return True if there are any NaNs.</span></div>
<div class="line"><span class="lineno"> 2829</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2830</span><span class="stringliteral">        Enables various performance speedups.</span></div>
<div class="line"><span class="lineno"> 2831</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2832</span>        <span class="keywordflow">if</span> self._can_hold_na:</div>
<div class="line"><span class="lineno"> 2833</span>            <span class="keywordflow">return</span> bool(self._isnan.any())</div>
<div class="line"><span class="lineno"> 2834</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 2835</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno"> 2836</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a142be584fc0bb24c9f076fa8d23297a2" name="a142be584fc0bb24c9f076fa8d23297a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142be584fc0bb24c9f076fa8d23297a2">&#9670;&#160;</a></span>holds_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.holds_integer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Whether the type is an integer type.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2740</span>    <span class="keyword">def </span>holds_integer(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2741</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2742</span><span class="stringliteral">        Whether the type is an integer type.</span></div>
<div class="line"><span class="lineno"> 2743</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2744</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;integer&quot;</span>, <span class="stringliteral">&quot;mixed-integer&quot;</span>]</div>
<div class="line"><span class="lineno"> 2745</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a60a6fe0b02e66409348958e182dfa973" name="a60a6fe0b02e66409348958e182dfa973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a6fe0b02e66409348958e182dfa973">&#9670;&#160;</a></span>identical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.identical </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Similar to equals, but checks that object attributes and types are also equal.

Returns
-------
bool
    If two Index objects have equal elements and same type True,
    otherwise False.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5595</span>    <span class="keyword">def </span>identical(self, other) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5596</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5597</span><span class="stringliteral">        Similar to equals, but checks that object attributes and types are also equal.</span></div>
<div class="line"><span class="lineno"> 5598</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5599</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5600</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5601</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 5602</span><span class="stringliteral">            If two Index objects have equal elements and same type True,</span></div>
<div class="line"><span class="lineno"> 5603</span><span class="stringliteral">            otherwise False.</span></div>
<div class="line"><span class="lineno"> 5604</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5605</span>        <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno"> 5606</span>            self.equals(other)</div>
<div class="line"><span class="lineno"> 5607</span>            <span class="keywordflow">and</span> all(</div>
<div class="line"><span class="lineno"> 5608</span>                getattr(self, c, <span class="keywordtype">None</span>) == getattr(other, c, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno"> 5609</span>                <span class="keywordflow">for</span> c <span class="keywordflow">in</span> self._comparables</div>
<div class="line"><span class="lineno"> 5610</span>            )</div>
<div class="line"><span class="lineno"> 5611</span>            <span class="keywordflow">and</span> type(self) == type(other)</div>
<div class="line"><span class="lineno"> 5612</span>        )</div>
<div class="line"><span class="lineno"> 5613</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3a22dc88869208aa9ebe329128d4db9b" name="a3a22dc88869208aa9ebe329128d4db9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a22dc88869208aa9ebe329128d4db9b">&#9670;&#160;</a></span>inferred_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> pandas.core.indexes.base.Index.inferred_type </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a string of the type inferred from the values.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a2c5b93b95a1c47583a3e57d733f04736">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a224cbd96ebcd6f4cb7211c090d7d443b">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a0ea92ad33a82b076a9cafa9dc5a042f0">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad57b8c298c5a2190ed6e93dd879d04b6">pandas.core.indexes.multi.MultiIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#ab9988a87e6742ff69dff4bfd5cefc62d">pandas.core.indexes.numeric.NumericIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a733482aece5a1b0bed4b976a206975af">pandas.core.indexes.period.PeriodIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a2d65ffa08bcb17232e56ba7caf7e0ce3">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#af5688402cfe2f64073e0eb549d72682d">pandas.core.indexes.timedeltas.TimedeltaIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2747</span>    <span class="keyword">def </span>inferred_type(self) -&gt; str_t:</div>
<div class="line"><span class="lineno"> 2748</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2749</span><span class="stringliteral">        Return a string of the type inferred from the values.</span></div>
<div class="line"><span class="lineno"> 2750</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2751</span>        <span class="keywordflow">return</span> lib.infer_dtype(self._values, skipna=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 2752</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad5aec3bcd721454a1ffbb8f5a0c2176a" name="ad5aec3bcd721454a1ffbb8f5a0c2176a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aec3bcd721454a1ffbb8f5a0c2176a">&#9670;&#160;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.insert </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Make new Index inserting new item at location.

Follows Python numpy.insert semantics for negative values.

Parameters
----------
loc : int
item : object

Returns
-------
new_index : Index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#a7b5d4bf8bc03d6e440a37ebf51c5fede">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a81f2cf79c044c1b9f18c0a1c6b94c8f1">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a890e4e469c9eac5e1a747fffd120b5e5">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6887</span>    <span class="keyword">def </span>insert(self, loc: int, item) -&gt; Index:</div>
<div class="line"><span class="lineno"> 6888</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6889</span><span class="stringliteral">        Make new Index inserting new item at location.</span></div>
<div class="line"><span class="lineno"> 6890</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6891</span><span class="stringliteral">        Follows Python numpy.insert semantics for negative values.</span></div>
<div class="line"><span class="lineno"> 6892</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6893</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6894</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6895</span><span class="stringliteral">        loc : int</span></div>
<div class="line"><span class="lineno"> 6896</span><span class="stringliteral">        item : object</span></div>
<div class="line"><span class="lineno"> 6897</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6898</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6899</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6900</span><span class="stringliteral">        new_index : Index</span></div>
<div class="line"><span class="lineno"> 6901</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6902</span>        item = lib.item_from_zerodim(item)</div>
<div class="line"><span class="lineno"> 6903</span>        <span class="keywordflow">if</span> is_valid_na_for_dtype(item, self.dtype) <span class="keywordflow">and</span> self.dtype != object:</div>
<div class="line"><span class="lineno"> 6904</span>            item = self._na_value</div>
<div class="line"><span class="lineno"> 6905</span> </div>
<div class="line"><span class="lineno"> 6906</span>        arr = self._values</div>
<div class="line"><span class="lineno"> 6907</span> </div>
<div class="line"><span class="lineno"> 6908</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6909</span>            <span class="keywordflow">if</span> isinstance(arr, ExtensionArray):</div>
<div class="line"><span class="lineno"> 6910</span>                res_values = arr.insert(loc, item)</div>
<div class="line"><span class="lineno"> 6911</span>                <span class="keywordflow">return</span> type(self)._simple_new(res_values, name=self.name)</div>
<div class="line"><span class="lineno"> 6912</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6913</span>                item = self._validate_fill_value(item)</div>
<div class="line"><span class="lineno"> 6914</span>        <span class="keywordflow">except</span> (TypeError, ValueError, LossySetitemError):</div>
<div class="line"><span class="lineno"> 6915</span>            <span class="comment"># e.g. trying to insert an integer into a DatetimeIndex</span></div>
<div class="line"><span class="lineno"> 6916</span>            <span class="comment">#  We cannot keep the same dtype, so cast to the (often object)</span></div>
<div class="line"><span class="lineno"> 6917</span>            <span class="comment">#  minimal shared dtype before doing the insert.</span></div>
<div class="line"><span class="lineno"> 6918</span>            dtype = self._find_common_type_compat(item)</div>
<div class="line"><span class="lineno"> 6919</span>            <span class="keywordflow">return</span> self.astype(dtype).insert(loc, item)</div>
<div class="line"><span class="lineno"> 6920</span> </div>
<div class="line"><span class="lineno"> 6921</span>        <span class="keywordflow">if</span> arr.dtype != object <span class="keywordflow">or</span> <span class="keywordflow">not</span> isinstance(</div>
<div class="line"><span class="lineno"> 6922</span>            item, (tuple, np.datetime64, np.timedelta64)</div>
<div class="line"><span class="lineno"> 6923</span>        ):</div>
<div class="line"><span class="lineno"> 6924</span>            <span class="comment"># with object-dtype we need to worry about numpy incorrectly casting</span></div>
<div class="line"><span class="lineno"> 6925</span>            <span class="comment"># dt64/td64 to integer, also about treating tuples as sequences</span></div>
<div class="line"><span class="lineno"> 6926</span>            <span class="comment"># special-casing dt64/td64 https://github.com/numpy/numpy/issues/12550</span></div>
<div class="line"><span class="lineno"> 6927</span>            casted = arr.dtype.type(item)</div>
<div class="line"><span class="lineno"> 6928</span>            new_values = np.insert(arr, loc, casted)</div>
<div class="line"><span class="lineno"> 6929</span> </div>
<div class="line"><span class="lineno"> 6930</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6931</span>            <span class="comment"># error: No overload variant of &quot;insert&quot; matches argument types</span></div>
<div class="line"><span class="lineno"> 6932</span>            <span class="comment"># &quot;ndarray[Any, Any]&quot;, &quot;int&quot;, &quot;None&quot;</span></div>
<div class="line"><span class="lineno"> 6933</span>            new_values = np.insert(arr, loc, <span class="keywordtype">None</span>)  <span class="comment"># type: ignore[call-overload]</span></div>
<div class="line"><span class="lineno"> 6934</span>            loc = loc <span class="keywordflow">if</span> loc &gt;= 0 <span class="keywordflow">else</span> loc - 1</div>
<div class="line"><span class="lineno"> 6935</span>            new_values[loc] = item</div>
<div class="line"><span class="lineno"> 6936</span> </div>
<div class="line"><span class="lineno"> 6937</span>        <span class="keywordflow">if</span> self._typ == <span class="stringliteral">&quot;numericindex&quot;</span>:</div>
<div class="line"><span class="lineno"> 6938</span>            <span class="comment"># Use self._constructor instead of Index to retain NumericIndex GH#43921</span></div>
<div class="line"><span class="lineno"> 6939</span>            <span class="comment"># TODO(2.0) can use Index instead of self._constructor</span></div>
<div class="line"><span class="lineno"> 6940</span>            <span class="keywordflow">return</span> self._constructor._with_infer(new_values, name=self.name)</div>
<div class="line"><span class="lineno"> 6941</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6942</span>            <span class="keywordflow">return</span> Index._with_infer(new_values, name=self.name)</div>
<div class="line"><span class="lineno"> 6943</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a665bcdaee23489dfc2b62b98e31e465d" name="a665bcdaee23489dfc2b62b98e31e465d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665bcdaee23489dfc2b62b98e31e465d">&#9670;&#160;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Form the intersection of two Index objects.

This returns a new Index with elements common to the index and `other`.

Parameters
----------
other : Index or array-like
sort : False or None, default False
    Whether to sort the resulting index.

    * False : do not sort the result.
    * None : sort the result, except when `self` and `other` are equal
      or when the values cannot be compared.

Returns
-------
intersection : Index

Examples
--------
&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])
&gt;&gt;&gt; idx1.intersection(idx2)
Int64Index([3, 4], dtype='int64')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3439</span>    <span class="keyword">def </span>intersection(self, other, sort=False):</div>
<div class="line"><span class="lineno"> 3440</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3441</span><span class="stringliteral">        Form the intersection of two Index objects.</span></div>
<div class="line"><span class="lineno"> 3442</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3443</span><span class="stringliteral">        This returns a new Index with elements common to the index and `other`.</span></div>
<div class="line"><span class="lineno"> 3444</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3445</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3446</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3447</span><span class="stringliteral">        other : Index or array-like</span></div>
<div class="line"><span class="lineno"> 3448</span><span class="stringliteral">        sort : False or None, default False</span></div>
<div class="line"><span class="lineno"> 3449</span><span class="stringliteral">            Whether to sort the resulting index.</span></div>
<div class="line"><span class="lineno"> 3450</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3451</span><span class="stringliteral">            * False : do not sort the result.</span></div>
<div class="line"><span class="lineno"> 3452</span><span class="stringliteral">            * None : sort the result, except when `self` and `other` are equal</span></div>
<div class="line"><span class="lineno"> 3453</span><span class="stringliteral">              or when the values cannot be compared.</span></div>
<div class="line"><span class="lineno"> 3454</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3455</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3456</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3457</span><span class="stringliteral">        intersection : Index</span></div>
<div class="line"><span class="lineno"> 3458</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3459</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3460</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3461</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 3462</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 3463</span><span class="stringliteral">        &gt;&gt;&gt; idx1.intersection(idx2)</span></div>
<div class="line"><span class="lineno"> 3464</span><span class="stringliteral">        Int64Index([3, 4], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 3465</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3466</span>        self._validate_sort_keyword(sort)</div>
<div class="line"><span class="lineno"> 3467</span>        self._assert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3468</span>        other, result_name = self._convert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3469</span> </div>
<div class="line"><span class="lineno"> 3470</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 3471</span>            self._deprecate_dti_setop(other, <span class="stringliteral">&quot;intersection&quot;</span>)</div>
<div class="line"><span class="lineno"> 3472</span> </div>
<div class="line"><span class="lineno"> 3473</span>        <span class="keywordflow">if</span> self.equals(other):</div>
<div class="line"><span class="lineno"> 3474</span>            <span class="keywordflow">if</span> self.has_duplicates:</div>
<div class="line"><span class="lineno"> 3475</span>                <span class="keywordflow">return</span> self.unique()._get_reconciled_name_object(other)</div>
<div class="line"><span class="lineno"> 3476</span>            <span class="keywordflow">return</span> self._get_reconciled_name_object(other)</div>
<div class="line"><span class="lineno"> 3477</span> </div>
<div class="line"><span class="lineno"> 3478</span>        <span class="keywordflow">if</span> len(self) == 0 <span class="keywordflow">or</span> len(other) == 0:</div>
<div class="line"><span class="lineno"> 3479</span>            <span class="comment"># fastpath; we need to be careful about having commutativity</span></div>
<div class="line"><span class="lineno"> 3480</span> </div>
<div class="line"><span class="lineno"> 3481</span>            <span class="keywordflow">if</span> self._is_multi <span class="keywordflow">or</span> other._is_multi:</div>
<div class="line"><span class="lineno"> 3482</span>                <span class="comment"># _convert_can_do_setop ensures that we have both or neither</span></div>
<div class="line"><span class="lineno"> 3483</span>                <span class="comment"># We retain self.levels</span></div>
<div class="line"><span class="lineno"> 3484</span>                <span class="keywordflow">return</span> self[:0].rename(result_name)</div>
<div class="line"><span class="lineno"> 3485</span> </div>
<div class="line"><span class="lineno"> 3486</span>            dtype = self._find_common_type_compat(other)</div>
<div class="line"><span class="lineno"> 3487</span>            <span class="keywordflow">if</span> is_dtype_equal(self.dtype, dtype):</div>
<div class="line"><span class="lineno"> 3488</span>                <span class="comment"># Slicing allows us to retain DTI/TDI.freq, RangeIndex</span></div>
<div class="line"><span class="lineno"> 3489</span> </div>
<div class="line"><span class="lineno"> 3490</span>                <span class="comment"># Note: self[:0] vs other[:0] affects</span></div>
<div class="line"><span class="lineno"> 3491</span>                <span class="comment">#  1) which index&#39;s `freq` we get in DTI/TDI cases</span></div>
<div class="line"><span class="lineno"> 3492</span>                <span class="comment">#     This may be a historical artifact, i.e. no documented</span></div>
<div class="line"><span class="lineno"> 3493</span>                <span class="comment">#     reason for this choice.</span></div>
<div class="line"><span class="lineno"> 3494</span>                <span class="comment">#  2) The `step` we get in RangeIndex cases</span></div>
<div class="line"><span class="lineno"> 3495</span>                <span class="keywordflow">if</span> len(self) == 0:</div>
<div class="line"><span class="lineno"> 3496</span>                    <span class="keywordflow">return</span> self[:0].rename(result_name)</div>
<div class="line"><span class="lineno"> 3497</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 3498</span>                    <span class="keywordflow">return</span> other[:0].rename(result_name)</div>
<div class="line"><span class="lineno"> 3499</span> </div>
<div class="line"><span class="lineno"> 3500</span>            <span class="keywordflow">return</span> Index([], dtype=dtype, name=result_name)</div>
<div class="line"><span class="lineno"> 3501</span> </div>
<div class="line"><span class="lineno"> 3502</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> self._should_compare(other):</div>
<div class="line"><span class="lineno"> 3503</span>            <span class="comment"># We can infer that the intersection is empty.</span></div>
<div class="line"><span class="lineno"> 3504</span>            <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 3505</span>                <span class="keywordflow">return</span> self[:0].rename(result_name)</div>
<div class="line"><span class="lineno"> 3506</span>            <span class="keywordflow">return</span> Index([], name=result_name)</div>
<div class="line"><span class="lineno"> 3507</span> </div>
<div class="line"><span class="lineno"> 3508</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 3509</span>            dtype = self._find_common_type_compat(other)</div>
<div class="line"><span class="lineno"> 3510</span>            this = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3511</span>            other = other.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3512</span>            <span class="keywordflow">return</span> this.intersection(other, sort=sort)</div>
<div class="line"><span class="lineno"> 3513</span> </div>
<div class="line"><span class="lineno"> 3514</span>        result = self._intersection(other, sort=sort)</div>
<div class="line"><span class="lineno"> 3515</span>        <span class="keywordflow">return</span> self._wrap_intersection_result(other, result)</div>
<div class="line"><span class="lineno"> 3516</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abbd960d46f2c19b3672210af966a0d5f" name="abbd960d46f2c19b3672210af966a0d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd960d46f2c19b3672210af966a0d5f">&#9670;&#160;</a></span>is_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">More flexible, faster check like ``is`` but that works through views.

Note: this is *not* the same as ``Index.identical()``, which checks
that metadata is also the same.

Parameters
----------
other : object
    Other object to compare against.

Returns
-------
bool
    True if both have same underlying data, False otherwise.

See Also
--------
Index.identical : Works like ``Index.is_`` but also checks metadata.
</pre> <div class="fragment"><div class="line"><span class="lineno">  841</span>    <span class="keyword">def </span>is_(self, other) -&gt; bool:</div>
<div class="line"><span class="lineno">  842</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  843</span><span class="stringliteral">        More flexible, faster check like ``is`` but that works through views.</span></div>
<div class="line"><span class="lineno">  844</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  845</span><span class="stringliteral">        Note: this is *not* the same as ``Index.identical()``, which checks</span></div>
<div class="line"><span class="lineno">  846</span><span class="stringliteral">        that metadata is also the same.</span></div>
<div class="line"><span class="lineno">  847</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  848</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  849</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  850</span><span class="stringliteral">        other : object</span></div>
<div class="line"><span class="lineno">  851</span><span class="stringliteral">            Other object to compare against.</span></div>
<div class="line"><span class="lineno">  852</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  853</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  854</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  855</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno">  856</span><span class="stringliteral">            True if both have same underlying data, False otherwise.</span></div>
<div class="line"><span class="lineno">  857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  858</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno">  859</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno">  860</span><span class="stringliteral">        Index.identical : Works like ``Index.is_`` but also checks metadata.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  862</span>        <span class="keywordflow">if</span> self <span class="keywordflow">is</span> other:</div>
<div class="line"><span class="lineno">  863</span>            <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  864</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> hasattr(other, <span class="stringliteral">&quot;_id&quot;</span>):</div>
<div class="line"><span class="lineno">  865</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  866</span>        <span class="keywordflow">elif</span> self._id <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> other._id <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  867</span>            <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  868</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  869</span>            <span class="keywordflow">return</span> self._id <span class="keywordflow">is</span> other._id</div>
<div class="line"><span class="lineno">  870</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abcc7c1977c20ef5871adc456cfdd05e1" name="abcc7c1977c20ef5871adc456cfdd05e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc7c1977c20ef5871adc456cfdd05e1">&#9670;&#160;</a></span>is_all_dates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_all_dates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Whether or not the index values only consist of dates.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2772</span>    <span class="keyword">def </span>is_all_dates(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2773</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2774</span><span class="stringliteral">        Whether or not the index values only consist of dates.</span></div>
<div class="line"><span class="lineno"> 2775</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2776</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2777</span>            <span class="stringliteral">&quot;Index.is_all_dates is deprecated, will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 2778</span>            <span class="stringliteral">&quot;check index.inferred_type instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2779</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2780</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2781</span>        )</div>
<div class="line"><span class="lineno"> 2782</span>        <span class="keywordflow">return</span> self._is_all_dates</div>
<div class="line"><span class="lineno"> 2783</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a058ecbb1133fb00a575c2b475935996b" name="a058ecbb1133fb00a575c2b475935996b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058ecbb1133fb00a575c2b475935996b">&#9670;&#160;</a></span>is_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_boolean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index only consists of booleans.

Returns
-------
bool
    Whether or not the Index only consists of booleans.

See Also
--------
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([True, False, True])
&gt;&gt;&gt; idx.is_boolean()
True

&gt;&gt;&gt; idx = pd.Index(["True", "False", "True"])
&gt;&gt;&gt; idx.is_boolean()
False

&gt;&gt;&gt; idx = pd.Index([True, False, "True"])
&gt;&gt;&gt; idx.is_boolean()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2423</span>    <span class="keyword">def </span>is_boolean(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2424</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2425</span><span class="stringliteral">        Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2426</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2427</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2428</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2429</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2430</span><span class="stringliteral">            Whether or not the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2431</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2432</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2433</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2434</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2435</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2436</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2437</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2438</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2439</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2440</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2441</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2442</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2443</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2444</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([True, False, True])</span></div>
<div class="line"><span class="lineno"> 2445</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_boolean()</span></div>
<div class="line"><span class="lineno"> 2446</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2447</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2448</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;True&quot;, &quot;False&quot;, &quot;True&quot;])</span></div>
<div class="line"><span class="lineno"> 2449</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_boolean()</span></div>
<div class="line"><span class="lineno"> 2450</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2451</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2452</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([True, False, &quot;True&quot;])</span></div>
<div class="line"><span class="lineno"> 2453</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_boolean()</span></div>
<div class="line"><span class="lineno"> 2454</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2455</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2456</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;boolean&quot;</span>]</div>
<div class="line"><span class="lineno"> 2457</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a37f2a24053b72b85f81ff7a52c493a74" name="a37f2a24053b72b85f81ff7a52c493a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37f2a24053b72b85f81ff7a52c493a74">&#9670;&#160;</a></span>is_categorical()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_categorical </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index holds categorical data.

Returns
-------
bool
    True if the Index is categorical.

See Also
--------
CategoricalIndex : Index for categorical data.
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(["Watermelon", "Orange", "Apple",
...                 "Watermelon"]).astype("category")
&gt;&gt;&gt; idx.is_categorical()
True

&gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])
&gt;&gt;&gt; idx.is_categorical()
False

&gt;&gt;&gt; s = pd.Series(["Peter", "Victor", "Elisabeth", "Mar"])
&gt;&gt;&gt; s
0        Peter
1       Victor
2    Elisabeth
3          Mar
dtype: object
&gt;&gt;&gt; s.index.is_categorical()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2624</span>    <span class="keyword">def </span>is_categorical(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2625</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2626</span><span class="stringliteral">        Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2628</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2629</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2630</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2631</span><span class="stringliteral">            True if the Index is categorical.</span></div>
<div class="line"><span class="lineno"> 2632</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2633</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2634</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2635</span><span class="stringliteral">        CategoricalIndex : Index for categorical data.</span></div>
<div class="line"><span class="lineno"> 2636</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2637</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2638</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2639</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2640</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2641</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2642</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2644</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2645</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2646</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span></div>
<div class="line"><span class="lineno"> 2647</span><span class="stringliteral">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span></div>
<div class="line"><span class="lineno"> 2648</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_categorical()</span></div>
<div class="line"><span class="lineno"> 2649</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2650</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2651</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])</span></div>
<div class="line"><span class="lineno"> 2652</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_categorical()</span></div>
<div class="line"><span class="lineno"> 2653</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2654</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2655</span><span class="stringliteral">        &gt;&gt;&gt; s = pd.Series([&quot;Peter&quot;, &quot;Victor&quot;, &quot;Elisabeth&quot;, &quot;Mar&quot;])</span></div>
<div class="line"><span class="lineno"> 2656</span><span class="stringliteral">        &gt;&gt;&gt; s</span></div>
<div class="line"><span class="lineno"> 2657</span><span class="stringliteral">        0        Peter</span></div>
<div class="line"><span class="lineno"> 2658</span><span class="stringliteral">        1       Victor</span></div>
<div class="line"><span class="lineno"> 2659</span><span class="stringliteral">        2    Elisabeth</span></div>
<div class="line"><span class="lineno"> 2660</span><span class="stringliteral">        3          Mar</span></div>
<div class="line"><span class="lineno"> 2661</span><span class="stringliteral">        dtype: object</span></div>
<div class="line"><span class="lineno"> 2662</span><span class="stringliteral">        &gt;&gt;&gt; s.index.is_categorical()</span></div>
<div class="line"><span class="lineno"> 2663</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2664</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2665</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;categorical&quot;</span>]</div>
<div class="line"><span class="lineno"> 2666</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5617ac233bbb693188e32114b469db82" name="a5617ac233bbb693188e32114b469db82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5617ac233bbb693188e32114b469db82">&#9670;&#160;</a></span>is_floating()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_floating </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index is a floating type.

The Index may consist of only floats, NaNs, or a mix of floats,
integers, or NaNs.

Returns
-------
bool
    Whether or not the Index only consists of only consists of floats, NaNs, or
    a mix of floats, integers, or NaNs.

See Also
--------
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])
&gt;&gt;&gt; idx.is_floating()
True

&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, np.nan, 4.0])
&gt;&gt;&gt; idx.is_floating()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4, np.nan])
&gt;&gt;&gt; idx.is_floating()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx.is_floating()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2495</span>    <span class="keyword">def </span>is_floating(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2496</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2497</span><span class="stringliteral">        Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2498</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2499</span><span class="stringliteral">        The Index may consist of only floats, NaNs, or a mix of floats,</span></div>
<div class="line"><span class="lineno"> 2500</span><span class="stringliteral">        integers, or NaNs.</span></div>
<div class="line"><span class="lineno"> 2501</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2502</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2503</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2504</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2505</span><span class="stringliteral">            Whether or not the Index only consists of only consists of floats, NaNs, or</span></div>
<div class="line"><span class="lineno"> 2506</span><span class="stringliteral">            a mix of floats, integers, or NaNs.</span></div>
<div class="line"><span class="lineno"> 2507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2508</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2509</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2510</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2511</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2512</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2513</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2514</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2515</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2516</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2517</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2518</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2519</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2520</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span></div>
<div class="line"><span class="lineno"> 2521</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_floating()</span></div>
<div class="line"><span class="lineno"> 2522</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2523</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2524</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, np.nan, 4.0])</span></div>
<div class="line"><span class="lineno"> 2525</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_floating()</span></div>
<div class="line"><span class="lineno"> 2526</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2528</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4, np.nan])</span></div>
<div class="line"><span class="lineno"> 2529</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_floating()</span></div>
<div class="line"><span class="lineno"> 2530</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2531</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2532</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 2533</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_floating()</span></div>
<div class="line"><span class="lineno"> 2534</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2535</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2536</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;floating&quot;</span>, <span class="stringliteral">&quot;mixed-integer-float&quot;</span>, <span class="stringliteral">&quot;integer-na&quot;</span>]</div>
<div class="line"><span class="lineno"> 2537</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a41724f23783dc0ff8427ce141539b88d" name="a41724f23783dc0ff8427ce141539b88d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41724f23783dc0ff8427ce141539b88d">&#9670;&#160;</a></span>is_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_integer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index only consists of integers.

Returns
-------
bool
    Whether or not the Index only consists of integers.

See Also
--------
is_boolean : Check if the Index only consists of booleans.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx.is_integer()
True

&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])
&gt;&gt;&gt; idx.is_integer()
False

&gt;&gt;&gt; idx = pd.Index(["Apple", "Mango", "Watermelon"])
&gt;&gt;&gt; idx.is_integer()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2459</span>    <span class="keyword">def </span>is_integer(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2460</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2461</span><span class="stringliteral">        Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2462</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2463</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2464</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2465</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2466</span><span class="stringliteral">            Whether or not the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2467</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2468</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2469</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2470</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2471</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2472</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2473</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2474</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2475</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2476</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2478</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2479</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2480</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 2481</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_integer()</span></div>
<div class="line"><span class="lineno"> 2482</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2483</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2484</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span></div>
<div class="line"><span class="lineno"> 2485</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_integer()</span></div>
<div class="line"><span class="lineno"> 2486</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2488</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, &quot;Watermelon&quot;])</span></div>
<div class="line"><span class="lineno"> 2489</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_integer()</span></div>
<div class="line"><span class="lineno"> 2490</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2491</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2492</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;integer&quot;</span>]</div>
<div class="line"><span class="lineno"> 2493</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a977c91d9f1d44004e703a64d9aa1956f" name="a977c91d9f1d44004e703a64d9aa1956f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977c91d9f1d44004e703a64d9aa1956f">&#9670;&#160;</a></span>is_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_interval </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index holds Interval objects.

Returns
-------
bool
    Whether or not the Index holds Interval objects.

See Also
--------
IntervalIndex : Index for Interval objects.
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([pd.Interval(left=0, right=5),
...                 pd.Interval(left=5, right=10)])
&gt;&gt;&gt; idx.is_interval()
True

&gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])
&gt;&gt;&gt; idx.is_interval()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2668</span>    <span class="keyword">def </span>is_interval(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2669</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2670</span><span class="stringliteral">        Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2672</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2673</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2674</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2675</span><span class="stringliteral">            Whether or not the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2676</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2677</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2678</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2679</span><span class="stringliteral">        IntervalIndex : Index for Interval objects.</span></div>
<div class="line"><span class="lineno"> 2680</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2681</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2682</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2683</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2684</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2685</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2686</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2687</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2688</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2689</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2690</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([pd.Interval(left=0, right=5),</span></div>
<div class="line"><span class="lineno"> 2691</span><span class="stringliteral">        ...                 pd.Interval(left=5, right=10)])</span></div>
<div class="line"><span class="lineno"> 2692</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_interval()</span></div>
<div class="line"><span class="lineno"> 2693</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2695</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 3, 5, 7])</span></div>
<div class="line"><span class="lineno"> 2696</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_interval()</span></div>
<div class="line"><span class="lineno"> 2697</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2698</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2699</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;interval&quot;</span>]</div>
<div class="line"><span class="lineno"> 2700</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aab3ba2bda01f4ea001008a0af26974fa" name="aab3ba2bda01f4ea001008a0af26974fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab3ba2bda01f4ea001008a0af26974fa">&#9670;&#160;</a></span>is_mixed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_mixed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index holds data with mixed data types.

Returns
-------
bool
    Whether or not the Index holds data with mixed data types.

See Also
--------
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['a', np.nan, 'b'])
&gt;&gt;&gt; idx.is_mixed()
True

&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 5.0])
&gt;&gt;&gt; idx.is_mixed()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2702</span>    <span class="keyword">def </span>is_mixed(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2703</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2704</span><span class="stringliteral">        Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2705</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2706</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2707</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2708</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2709</span><span class="stringliteral">            Whether or not the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2710</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2711</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2712</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2713</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2714</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2715</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2716</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2717</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2718</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2719</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2720</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2721</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2722</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2723</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;a&#39;, np.nan, &#39;b&#39;])</span></div>
<div class="line"><span class="lineno"> 2724</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_mixed()</span></div>
<div class="line"><span class="lineno"> 2725</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2726</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2727</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 5.0])</span></div>
<div class="line"><span class="lineno"> 2728</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_mixed()</span></div>
<div class="line"><span class="lineno"> 2729</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2730</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2731</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2732</span>            <span class="stringliteral">&quot;Index.is_mixed is deprecated and will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 2733</span>            <span class="stringliteral">&quot;Check index.inferred_type directly instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2734</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2735</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2736</span>        )</div>
<div class="line"><span class="lineno"> 2737</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;mixed&quot;</span>]</div>
<div class="line"><span class="lineno"> 2738</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8db5340ed49b3a98f4d9c8d71ff185d1" name="a8db5340ed49b3a98f4d9c8d71ff185d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db5340ed49b3a98f4d9c8d71ff185d1">&#9670;&#160;</a></span>is_monotonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_monotonic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Alias for is_monotonic_increasing.

.. deprecated:: 1.5.0
    is_monotonic is deprecated and will be removed in a future version.
    Use is_monotonic_increasing instead.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a32205ce9d2b8dace49854451ccf6b3ef">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2298</span>    <span class="keyword">def </span>is_monotonic(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2299</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2300</span><span class="stringliteral">        Alias for is_monotonic_increasing.</span></div>
<div class="line"><span class="lineno"> 2301</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2302</span><span class="stringliteral">        .. deprecated:: 1.5.0</span></div>
<div class="line"><span class="lineno"> 2303</span><span class="stringliteral">            is_monotonic is deprecated and will be removed in a future version.</span></div>
<div class="line"><span class="lineno"> 2304</span><span class="stringliteral">            Use is_monotonic_increasing instead.</span></div>
<div class="line"><span class="lineno"> 2305</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2306</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 2307</span>            <span class="stringliteral">&quot;is_monotonic is deprecated and will be removed in a future version. &quot;</span></div>
<div class="line"><span class="lineno"> 2308</span>            <span class="stringliteral">&quot;Use is_monotonic_increasing instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 2309</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 2310</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 2311</span>        )</div>
<div class="line"><span class="lineno"> 2312</span>        <span class="keywordflow">return</span> self.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 2313</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a51889270cdfc9b14c65f016f1c077a6d" name="a51889270cdfc9b14c65f016f1c077a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51889270cdfc9b14c65f016f1c077a6d">&#9670;&#160;</a></span>is_monotonic_decreasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_monotonic_decreasing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean if the values are equal or decreasing.

Examples
--------
&gt;&gt;&gt; Index([3, 2, 1]).is_monotonic_decreasing
True
&gt;&gt;&gt; Index([3, 2, 2]).is_monotonic_decreasing
True
&gt;&gt;&gt; Index([3, 1, 2]).is_monotonic_decreasing
False
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a279ba2bf972b78dba8bd235a99cdf6eb">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a3ed87bbd88dc82ea31d6b6921fcb310f">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#abd05a7043593b92d5b247975e7d2a77d">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#abddc49b15bad2b5a15cb21da906e1d92">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2331</span>    <span class="keyword">def </span>is_monotonic_decreasing(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2332</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2333</span><span class="stringliteral">        Return a boolean if the values are equal or decreasing.</span></div>
<div class="line"><span class="lineno"> 2334</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2335</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2336</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2337</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 2, 1]).is_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2338</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2339</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 2, 2]).is_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2340</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2341</span><span class="stringliteral">        &gt;&gt;&gt; Index([3, 1, 2]).is_monotonic_decreasing</span></div>
<div class="line"><span class="lineno"> 2342</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2343</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2344</span>        <span class="keywordflow">return</span> self._engine.is_monotonic_decreasing</div>
<div class="line"><span class="lineno"> 2345</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a52b8a90f3bb4fd121aa68ce876f03901" name="a52b8a90f3bb4fd121aa68ce876f03901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b8a90f3bb4fd121aa68ce876f03901">&#9670;&#160;</a></span>is_monotonic_increasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_monotonic_increasing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean if the values are equal or increasing.

Examples
--------
&gt;&gt;&gt; Index([1, 2, 3]).is_monotonic_increasing
True
&gt;&gt;&gt; Index([1, 2, 2]).is_monotonic_increasing
True
&gt;&gt;&gt; Index([1, 3, 2]).is_monotonic_increasing
False
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a262e213b99e9f11e5a5ed3064502eac6">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#abadeb4638d88fae0b9cdde3ac17c83f8">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a5b3726a1c83b56dde61c9d120bd571be">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2315</span>    <span class="keyword">def </span>is_monotonic_increasing(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2316</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2317</span><span class="stringliteral">        Return a boolean if the values are equal or increasing.</span></div>
<div class="line"><span class="lineno"> 2318</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2319</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2320</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2321</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 2, 3]).is_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2322</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2323</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 2, 2]).is_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2324</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2325</span><span class="stringliteral">        &gt;&gt;&gt; Index([1, 3, 2]).is_monotonic_increasing</span></div>
<div class="line"><span class="lineno"> 2326</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2327</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2328</span>        <span class="keywordflow">return</span> self._engine.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 2329</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aef3a3d0393d53c0cd227e205b07718e4" name="aef3a3d0393d53c0cd227e205b07718e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3a3d0393d53c0cd227e205b07718e4">&#9670;&#160;</a></span>is_numeric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_numeric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index only consists of numeric data.

Returns
-------
bool
    Whether or not the Index only consists of numeric data.

See Also
--------
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_object : Check if the Index is of the object dtype.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])
&gt;&gt;&gt; idx.is_numeric()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0])
&gt;&gt;&gt; idx.is_numeric()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx.is_numeric()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan])
&gt;&gt;&gt; idx.is_numeric()
True

&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan, "Apple"])
&gt;&gt;&gt; idx.is_numeric()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2539</span>    <span class="keyword">def </span>is_numeric(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2540</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2541</span><span class="stringliteral">        Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2542</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2543</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2544</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2545</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2546</span><span class="stringliteral">            Whether or not the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2547</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2548</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2549</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2550</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2551</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2552</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2553</span><span class="stringliteral">        is_object : Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2554</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2555</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2556</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2557</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2558</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2559</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2560</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span></div>
<div class="line"><span class="lineno"> 2561</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_numeric()</span></div>
<div class="line"><span class="lineno"> 2562</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2564</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0])</span></div>
<div class="line"><span class="lineno"> 2565</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_numeric()</span></div>
<div class="line"><span class="lineno"> 2566</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2567</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2568</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 2569</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_numeric()</span></div>
<div class="line"><span class="lineno"> 2570</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2571</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2572</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan])</span></div>
<div class="line"><span class="lineno"> 2573</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_numeric()</span></div>
<div class="line"><span class="lineno"> 2574</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2575</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2576</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4.0, np.nan, &quot;Apple&quot;])</span></div>
<div class="line"><span class="lineno"> 2577</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_numeric()</span></div>
<div class="line"><span class="lineno"> 2578</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2579</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2580</span>        <span class="keywordflow">return</span> self.inferred_type <span class="keywordflow">in</span> [<span class="stringliteral">&quot;integer&quot;</span>, <span class="stringliteral">&quot;floating&quot;</span>]</div>
<div class="line"><span class="lineno"> 2581</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a408521f8b4a1b63413f1ec3d2ce85c22" name="a408521f8b4a1b63413f1ec3d2ce85c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408521f8b4a1b63413f1ec3d2ce85c22">&#9670;&#160;</a></span>is_object()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_object </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Check if the Index is of the object dtype.

Returns
-------
bool
    Whether or not the Index is of the object dtype.

See Also
--------
is_boolean : Check if the Index only consists of booleans.
is_integer : Check if the Index only consists of integers.
is_floating : Check if the Index is a floating type.
is_numeric : Check if the Index only consists of numeric data.
is_categorical : Check if the Index holds categorical data.
is_interval : Check if the Index holds Interval objects.
is_mixed : Check if the Index holds data with mixed data types.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(["Apple", "Mango", "Watermelon"])
&gt;&gt;&gt; idx.is_object()
True

&gt;&gt;&gt; idx = pd.Index(["Apple", "Mango", 2.0])
&gt;&gt;&gt; idx.is_object()
True

&gt;&gt;&gt; idx = pd.Index(["Watermelon", "Orange", "Apple",
...                 "Watermelon"]).astype("category")
&gt;&gt;&gt; idx.is_object()
False

&gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])
&gt;&gt;&gt; idx.is_object()
False
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2583</span>    <span class="keyword">def </span>is_object(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2584</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2585</span><span class="stringliteral">        Check if the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2586</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2587</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2588</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2589</span><span class="stringliteral">        bool</span></div>
<div class="line"><span class="lineno"> 2590</span><span class="stringliteral">            Whether or not the Index is of the object dtype.</span></div>
<div class="line"><span class="lineno"> 2591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2592</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2593</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2594</span><span class="stringliteral">        is_boolean : Check if the Index only consists of booleans.</span></div>
<div class="line"><span class="lineno"> 2595</span><span class="stringliteral">        is_integer : Check if the Index only consists of integers.</span></div>
<div class="line"><span class="lineno"> 2596</span><span class="stringliteral">        is_floating : Check if the Index is a floating type.</span></div>
<div class="line"><span class="lineno"> 2597</span><span class="stringliteral">        is_numeric : Check if the Index only consists of numeric data.</span></div>
<div class="line"><span class="lineno"> 2598</span><span class="stringliteral">        is_categorical : Check if the Index holds categorical data.</span></div>
<div class="line"><span class="lineno"> 2599</span><span class="stringliteral">        is_interval : Check if the Index holds Interval objects.</span></div>
<div class="line"><span class="lineno"> 2600</span><span class="stringliteral">        is_mixed : Check if the Index holds data with mixed data types.</span></div>
<div class="line"><span class="lineno"> 2601</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2602</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2603</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2604</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, &quot;Watermelon&quot;])</span></div>
<div class="line"><span class="lineno"> 2605</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_object()</span></div>
<div class="line"><span class="lineno"> 2606</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2607</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2608</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Apple&quot;, &quot;Mango&quot;, 2.0])</span></div>
<div class="line"><span class="lineno"> 2609</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_object()</span></div>
<div class="line"><span class="lineno"> 2610</span><span class="stringliteral">        True</span></div>
<div class="line"><span class="lineno"> 2611</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2612</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&quot;Watermelon&quot;, &quot;Orange&quot;, &quot;Apple&quot;,</span></div>
<div class="line"><span class="lineno"> 2613</span><span class="stringliteral">        ...                 &quot;Watermelon&quot;]).astype(&quot;category&quot;)</span></div>
<div class="line"><span class="lineno"> 2614</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_object()</span></div>
<div class="line"><span class="lineno"> 2615</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2616</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2617</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1.0, 2.0, 3.0, 4.0])</span></div>
<div class="line"><span class="lineno"> 2618</span><span class="stringliteral">        &gt;&gt;&gt; idx.is_object()</span></div>
<div class="line"><span class="lineno"> 2619</span><span class="stringliteral">        False</span></div>
<div class="line"><span class="lineno"> 2620</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2621</span>        <span class="keywordflow">return</span> is_object_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 2622</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad7c7f637a502c2af3df7fa122c2e8ffd" name="ad7c7f637a502c2af3df7fa122c2e8ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c7f637a502c2af3df7fa122c2e8ffd">&#9670;&#160;</a></span>is_type_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_type_compatible </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a>&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Whether the index type is compatible with the provided type.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#ad8e8d76aa5ec25893396fb91fe12abd2">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5285</span>    <span class="keyword">def </span>is_type_compatible(self, kind: str_t) -&gt; bool:</div>
<div class="line"><span class="lineno"> 5286</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5287</span><span class="stringliteral">        Whether the index type is compatible with the provided type.</span></div>
<div class="line"><span class="lineno"> 5288</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5289</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 5290</span>            <span class="stringliteral">&quot;Index.is_type_compatible is deprecated and will be removed in a &quot;</span></div>
<div class="line"><span class="lineno"> 5291</span>            <span class="stringliteral">&quot;future version.&quot;</span>,</div>
<div class="line"><span class="lineno"> 5292</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 5293</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 5294</span>        )</div>
<div class="line"><span class="lineno"> 5295</span>        <span class="keywordflow">return</span> kind == self.inferred_type</div>
<div class="line"><span class="lineno"> 5296</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a561a56933b9b4d2f641a8c20052c9d64" name="a561a56933b9b4d2f641a8c20052c9d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a561a56933b9b4d2f641a8c20052c9d64">&#9670;&#160;</a></span>is_unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.indexes.base.Index.is_unique </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return if the index has unique values.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a5f68388823438799315c5ec515132e77">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a48100a7e8246326adfbe034113684c4c">pandas.core.indexes.interval.IntervalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#affcd23a1a29db023712f072960d765ba">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2383</span>    <span class="keyword">def </span>is_unique(self) -&gt; bool:</div>
<div class="line"><span class="lineno"> 2384</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2385</span><span class="stringliteral">        Return if the index has unique values.</span></div>
<div class="line"><span class="lineno"> 2386</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2387</span>        <span class="keywordflow">return</span> self._engine.is_unique</div>
<div class="line"><span class="lineno"> 2388</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4e4887bf57bd655762834e00c60383f" name="ad4e4887bf57bd655762834e00c60383f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e4887bf57bd655762834e00c60383f">&#9670;&#160;</a></span>isin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.indexes.base.Index.isin </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a boolean array where the index values are in `values`.

Compute boolean array of whether each index value is found in the
passed set of values. The length of the returned boolean array matches
the length of the index.

Parameters
----------
values : set or list-like
    Sought values.
level : str or int, optional
    Name or position of the index level to use (if the index is a
    `MultiIndex`).

Returns
-------
np.ndarray[bool]
    NumPy array of boolean values.

See Also
--------
Series.isin : Same for Series.
DataFrame.isin : Same method for DataFrames.

Notes
-----
In the case of `MultiIndex` you must either specify `values` as a
list-like object containing tuples that are the same length as the
number of levels, or specify `level`. Otherwise it will raise a
``ValueError``.

If `level` is specified:

- if it is the name of one *and only one* index level, use that level;
- otherwise it should be a number indicating level position.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1,2,3])
&gt;&gt;&gt; idx
Int64Index([1, 2, 3], dtype='int64')

Check whether each index value in a list of values.

&gt;&gt;&gt; idx.isin([1, 4])
array([ True, False, False])

&gt;&gt;&gt; midx = pd.MultiIndex.from_arrays([[1,2,3],
...                                  ['red', 'blue', 'green']],
...                                  names=('number', 'color'))
&gt;&gt;&gt; midx
MultiIndex([(1,   'red'),
            (2,  'blue'),
            (3, 'green')],
           names=['number', 'color'])

Check whether the strings in the 'color' level of the MultiIndex
are in a list of colors.

&gt;&gt;&gt; midx.isin(['red', 'orange', 'yellow'], level='color')
array([ True, False, False])

To check across the levels of a MultiIndex, pass a list of tuples:

&gt;&gt;&gt; midx.isin([(1, 'red'), (3, 'red')])
array([ True, False, False])

For a DatetimeIndex, string values in `values` are converted to
Timestamps.

&gt;&gt;&gt; dates = ['2000-03-11', '2000-03-12', '2000-03-13']
&gt;&gt;&gt; dti = pd.to_datetime(dates)
&gt;&gt;&gt; dti
DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],
dtype='datetime64[ns]', freq=None)

&gt;&gt;&gt; dti.isin(['2000-03-11'])
array([ True, False, False])
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#affa2b4562917b715115340bc3e15951b">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6462</span>    <span class="keyword">def </span>isin(self, values, level=None) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 6463</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6464</span><span class="stringliteral">        Return a boolean array where the index values are in `values`.</span></div>
<div class="line"><span class="lineno"> 6465</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6466</span><span class="stringliteral">        Compute boolean array of whether each index value is found in the</span></div>
<div class="line"><span class="lineno"> 6467</span><span class="stringliteral">        passed set of values. The length of the returned boolean array matches</span></div>
<div class="line"><span class="lineno"> 6468</span><span class="stringliteral">        the length of the index.</span></div>
<div class="line"><span class="lineno"> 6469</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6470</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6471</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6472</span><span class="stringliteral">        values : set or list-like</span></div>
<div class="line"><span class="lineno"> 6473</span><span class="stringliteral">            Sought values.</span></div>
<div class="line"><span class="lineno"> 6474</span><span class="stringliteral">        level : str or int, optional</span></div>
<div class="line"><span class="lineno"> 6475</span><span class="stringliteral">            Name or position of the index level to use (if the index is a</span></div>
<div class="line"><span class="lineno"> 6476</span><span class="stringliteral">            `MultiIndex`).</span></div>
<div class="line"><span class="lineno"> 6477</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6478</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6479</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6480</span><span class="stringliteral">        np.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 6481</span><span class="stringliteral">            NumPy array of boolean values.</span></div>
<div class="line"><span class="lineno"> 6482</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6483</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 6484</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6485</span><span class="stringliteral">        Series.isin : Same for Series.</span></div>
<div class="line"><span class="lineno"> 6486</span><span class="stringliteral">        DataFrame.isin : Same method for DataFrames.</span></div>
<div class="line"><span class="lineno"> 6487</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6488</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 6489</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 6490</span><span class="stringliteral">        In the case of `MultiIndex` you must either specify `values` as a</span></div>
<div class="line"><span class="lineno"> 6491</span><span class="stringliteral">        list-like object containing tuples that are the same length as the</span></div>
<div class="line"><span class="lineno"> 6492</span><span class="stringliteral">        number of levels, or specify `level`. Otherwise it will raise a</span></div>
<div class="line"><span class="lineno"> 6493</span><span class="stringliteral">        ``ValueError``.</span></div>
<div class="line"><span class="lineno"> 6494</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6495</span><span class="stringliteral">        If `level` is specified:</span></div>
<div class="line"><span class="lineno"> 6496</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6497</span><span class="stringliteral">        - if it is the name of one *and only one* index level, use that level;</span></div>
<div class="line"><span class="lineno"> 6498</span><span class="stringliteral">        - otherwise it should be a number indicating level position.</span></div>
<div class="line"><span class="lineno"> 6499</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6500</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 6501</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6502</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1,2,3])</span></div>
<div class="line"><span class="lineno"> 6503</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 6504</span><span class="stringliteral">        Int64Index([1, 2, 3], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 6505</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6506</span><span class="stringliteral">        Check whether each index value in a list of values.</span></div>
<div class="line"><span class="lineno"> 6507</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6508</span><span class="stringliteral">        &gt;&gt;&gt; idx.isin([1, 4])</span></div>
<div class="line"><span class="lineno"> 6509</span><span class="stringliteral">        array([ True, False, False])</span></div>
<div class="line"><span class="lineno"> 6510</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6511</span><span class="stringliteral">        &gt;&gt;&gt; midx = pd.MultiIndex.from_arrays([[1,2,3],</span></div>
<div class="line"><span class="lineno"> 6512</span><span class="stringliteral">        ...                                  [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;]],</span></div>
<div class="line"><span class="lineno"> 6513</span><span class="stringliteral">        ...                                  names=(&#39;number&#39;, &#39;color&#39;))</span></div>
<div class="line"><span class="lineno"> 6514</span><span class="stringliteral">        &gt;&gt;&gt; midx</span></div>
<div class="line"><span class="lineno"> 6515</span><span class="stringliteral">        MultiIndex([(1,   &#39;red&#39;),</span></div>
<div class="line"><span class="lineno"> 6516</span><span class="stringliteral">                    (2,  &#39;blue&#39;),</span></div>
<div class="line"><span class="lineno"> 6517</span><span class="stringliteral">                    (3, &#39;green&#39;)],</span></div>
<div class="line"><span class="lineno"> 6518</span><span class="stringliteral">                   names=[&#39;number&#39;, &#39;color&#39;])</span></div>
<div class="line"><span class="lineno"> 6519</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6520</span><span class="stringliteral">        Check whether the strings in the &#39;color&#39; level of the MultiIndex</span></div>
<div class="line"><span class="lineno"> 6521</span><span class="stringliteral">        are in a list of colors.</span></div>
<div class="line"><span class="lineno"> 6522</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6523</span><span class="stringliteral">        &gt;&gt;&gt; midx.isin([&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;], level=&#39;color&#39;)</span></div>
<div class="line"><span class="lineno"> 6524</span><span class="stringliteral">        array([ True, False, False])</span></div>
<div class="line"><span class="lineno"> 6525</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6526</span><span class="stringliteral">        To check across the levels of a MultiIndex, pass a list of tuples:</span></div>
<div class="line"><span class="lineno"> 6527</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6528</span><span class="stringliteral">        &gt;&gt;&gt; midx.isin([(1, &#39;red&#39;), (3, &#39;red&#39;)])</span></div>
<div class="line"><span class="lineno"> 6529</span><span class="stringliteral">        array([ True, False, False])</span></div>
<div class="line"><span class="lineno"> 6530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6531</span><span class="stringliteral">        For a DatetimeIndex, string values in `values` are converted to</span></div>
<div class="line"><span class="lineno"> 6532</span><span class="stringliteral">        Timestamps.</span></div>
<div class="line"><span class="lineno"> 6533</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6534</span><span class="stringliteral">        &gt;&gt;&gt; dates = [&#39;2000-03-11&#39;, &#39;2000-03-12&#39;, &#39;2000-03-13&#39;]</span></div>
<div class="line"><span class="lineno"> 6535</span><span class="stringliteral">        &gt;&gt;&gt; dti = pd.to_datetime(dates)</span></div>
<div class="line"><span class="lineno"> 6536</span><span class="stringliteral">        &gt;&gt;&gt; dti</span></div>
<div class="line"><span class="lineno"> 6537</span><span class="stringliteral">        DatetimeIndex([&#39;2000-03-11&#39;, &#39;2000-03-12&#39;, &#39;2000-03-13&#39;],</span></div>
<div class="line"><span class="lineno"> 6538</span><span class="stringliteral">        dtype=&#39;datetime64[ns]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 6539</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6540</span><span class="stringliteral">        &gt;&gt;&gt; dti.isin([&#39;2000-03-11&#39;])</span></div>
<div class="line"><span class="lineno"> 6541</span><span class="stringliteral">        array([ True, False, False])</span></div>
<div class="line"><span class="lineno"> 6542</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6543</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6544</span>            self._validate_index_level(level)</div>
<div class="line"><span class="lineno"> 6545</span>        <span class="keywordflow">return</span> algos.isin(self._values, values)</div>
<div class="line"><span class="lineno"> 6546</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4fb4a4fc94bfe6bad9e0df500a5919c2" name="a4fb4a4fc94bfe6bad9e0df500a5919c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb4a4fc94bfe6bad9e0df500a5919c2">&#9670;&#160;</a></span>isna()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.indexes.base.Index.isna </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Detect missing values.

Return a boolean same-sized object indicating if the values are NA.
NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get
mapped to ``True`` values.
Everything else get mapped to ``False`` values. Characters such as
empty strings `''` or :attr:`numpy.inf` are not considered NA values
(unless you set ``pandas.options.mode.use_inf_as_na = True``).

Returns
-------
numpy.ndarray[bool]
    A boolean array of whether my values are NA.

See Also
--------
Index.notna : Boolean inverse of isna.
Index.dropna : Omit entries with missing values.
isna : Top-level isna.
Series.isna : Detect missing values in Series object.

Examples
--------
Show which entries in a pandas.Index are NA. The result is an
array.

&gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])
&gt;&gt;&gt; idx
Float64Index([5.2, 6.0, nan], dtype='float64')
&gt;&gt;&gt; idx.isna()
array([False, False,  True])

Empty strings are not considered NA values. None is considered an NA
value.

&gt;&gt;&gt; idx = pd.Index(['black', '', 'red', None])
&gt;&gt;&gt; idx
Index(['black', '', 'red', None], dtype='object')
&gt;&gt;&gt; idx.isna()
array([False, False, False,  True])

For datetimes, `NaT` (Not a Time) is considered as an NA value.

&gt;&gt;&gt; idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),
...                         pd.Timestamp(''), None, pd.NaT])
&gt;&gt;&gt; idx
DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],
              dtype='datetime64[ns]', freq=None)
&gt;&gt;&gt; idx.isna()
array([False,  True,  True,  True])
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a6260e49a18c70ae48399f5a4b037273a">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2838</span>    <span class="keyword">def </span>isna(self) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 2839</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2840</span><span class="stringliteral">        Detect missing values.</span></div>
<div class="line"><span class="lineno"> 2841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2842</span><span class="stringliteral">        Return a boolean same-sized object indicating if the values are NA.</span></div>
<div class="line"><span class="lineno"> 2843</span><span class="stringliteral">        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get</span></div>
<div class="line"><span class="lineno"> 2844</span><span class="stringliteral">        mapped to ``True`` values.</span></div>
<div class="line"><span class="lineno"> 2845</span><span class="stringliteral">        Everything else get mapped to ``False`` values. Characters such as</span></div>
<div class="line"><span class="lineno"> 2846</span><span class="stringliteral">        empty strings `&#39;&#39;` or :attr:`numpy.inf` are not considered NA values</span></div>
<div class="line"><span class="lineno"> 2847</span><span class="stringliteral">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span></div>
<div class="line"><span class="lineno"> 2848</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2849</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2850</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2851</span><span class="stringliteral">        numpy.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 2852</span><span class="stringliteral">            A boolean array of whether my values are NA.</span></div>
<div class="line"><span class="lineno"> 2853</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2854</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2855</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2856</span><span class="stringliteral">        Index.notna : Boolean inverse of isna.</span></div>
<div class="line"><span class="lineno"> 2857</span><span class="stringliteral">        Index.dropna : Omit entries with missing values.</span></div>
<div class="line"><span class="lineno"> 2858</span><span class="stringliteral">        isna : Top-level isna.</span></div>
<div class="line"><span class="lineno"> 2859</span><span class="stringliteral">        Series.isna : Detect missing values in Series object.</span></div>
<div class="line"><span class="lineno"> 2860</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2861</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2862</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2863</span><span class="stringliteral">        Show which entries in a pandas.Index are NA. The result is an</span></div>
<div class="line"><span class="lineno"> 2864</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 2865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2866</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])</span></div>
<div class="line"><span class="lineno"> 2867</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2868</span><span class="stringliteral">        Float64Index([5.2, 6.0, nan], dtype=&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno"> 2869</span><span class="stringliteral">        &gt;&gt;&gt; idx.isna()</span></div>
<div class="line"><span class="lineno"> 2870</span><span class="stringliteral">        array([False, False,  True])</span></div>
<div class="line"><span class="lineno"> 2871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2872</span><span class="stringliteral">        Empty strings are not considered NA values. None is considered an NA</span></div>
<div class="line"><span class="lineno"> 2873</span><span class="stringliteral">        value.</span></div>
<div class="line"><span class="lineno"> 2874</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2875</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None])</span></div>
<div class="line"><span class="lineno"> 2876</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2877</span><span class="stringliteral">        Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 2878</span><span class="stringliteral">        &gt;&gt;&gt; idx.isna()</span></div>
<div class="line"><span class="lineno"> 2879</span><span class="stringliteral">        array([False, False, False,  True])</span></div>
<div class="line"><span class="lineno"> 2880</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2881</span><span class="stringliteral">        For datetimes, `NaT` (Not a Time) is considered as an NA value.</span></div>
<div class="line"><span class="lineno"> 2882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2883</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.DatetimeIndex([pd.Timestamp(&#39;1940-04-25&#39;),</span></div>
<div class="line"><span class="lineno"> 2884</span><span class="stringliteral">        ...                         pd.Timestamp(&#39;&#39;), None, pd.NaT])</span></div>
<div class="line"><span class="lineno"> 2885</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2886</span><span class="stringliteral">        DatetimeIndex([&#39;1940-04-25&#39;, &#39;NaT&#39;, &#39;NaT&#39;, &#39;NaT&#39;],</span></div>
<div class="line"><span class="lineno"> 2887</span><span class="stringliteral">                      dtype=&#39;datetime64[ns]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 2888</span><span class="stringliteral">        &gt;&gt;&gt; idx.isna()</span></div>
<div class="line"><span class="lineno"> 2889</span><span class="stringliteral">        array([False,  True,  True,  True])</span></div>
<div class="line"><span class="lineno"> 2890</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2891</span>        <span class="keywordflow">return</span> self._isnan</div>
<div class="line"><span class="lineno"> 2892</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae8620d33cd791d4eba5a75975089a3dc" name="ae8620d33cd791d4eba5a75975089a3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8620d33cd791d4eba5a75975089a3dc">&#9670;&#160;</a></span>join() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index.join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level &#160;</td>
          <td class="paramname"><em>level</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_indexers</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4601</span>    ) -&gt; Index | tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4602</span>        ...</div>
<div class="line"><span class="lineno"> 4603</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8dd35900072816ec401542e67d521656" name="a8dd35900072816ec401542e67d521656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd35900072816ec401542e67d521656">&#9670;&#160;</a></span>join() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level &#160;</td>
          <td class="paramname"><em>level</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[False] &#160;</td>
          <td class="paramname"><em>return_indexers</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4589</span>    ) -&gt; Index:</div>
<div class="line"><span class="lineno"> 4590</span>        ...</div>
<div class="line"><span class="lineno"> 4591</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aedb127469563520eedc2c96f4a66dc63" name="aedb127469563520eedc2c96f4a66dc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb127469563520eedc2c96f4a66dc63">&#9670;&#160;</a></span>join() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index.join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*<a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level &#160;</td>
          <td class="paramname"><em>level</em> = <code>...</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Literal[True]&#160;</td>
          <td class="paramname"><em>return_indexers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>...</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 4577</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4578</span>        ...</div>
<div class="line"><span class="lineno"> 4579</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5f31319518966aa33ff864e5d6809516" name="a5f31319518966aa33ff864e5d6809516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f31319518966aa33ff864e5d6809516">&#9670;&#160;</a></span>join() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> | tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index.join </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>how</em> = <code>&quot;left&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Level &#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_indexers</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>sort</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute join_index and indexers to conform data structures to the new index.

Parameters
----------
other : Index
how : {'left', 'right', 'inner', 'outer'}
level : int or level name, default None
return_indexers : bool, default False
sort : bool, default False
    Sort the join keys lexicographically in the result Index. If False,
    the order of the join keys depends on the join type (how keyword).

Returns
-------
join_index, (left_indexer, right_indexer)
</pre> <div class="fragment"><div class="line"><span class="lineno"> 4614</span>    ) -&gt; Index | tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4615</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4616</span><span class="stringliteral">        Compute join_index and indexers to conform data structures to the new index.</span></div>
<div class="line"><span class="lineno"> 4617</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4618</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4619</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4620</span><span class="stringliteral">        other : Index</span></div>
<div class="line"><span class="lineno"> 4621</span><span class="stringliteral">        how : {&#39;left&#39;, &#39;right&#39;, &#39;inner&#39;, &#39;outer&#39;}</span></div>
<div class="line"><span class="lineno"> 4622</span><span class="stringliteral">        level : int or level name, default None</span></div>
<div class="line"><span class="lineno"> 4623</span><span class="stringliteral">        return_indexers : bool, default False</span></div>
<div class="line"><span class="lineno"> 4624</span><span class="stringliteral">        sort : bool, default False</span></div>
<div class="line"><span class="lineno"> 4625</span><span class="stringliteral">            Sort the join keys lexicographically in the result Index. If False,</span></div>
<div class="line"><span class="lineno"> 4626</span><span class="stringliteral">            the order of the join keys depends on the join type (how keyword).</span></div>
<div class="line"><span class="lineno"> 4627</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4628</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4629</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4630</span><span class="stringliteral">        join_index, (left_indexer, right_indexer)</span></div>
<div class="line"><span class="lineno"> 4631</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4632</span>        other = ensure_index(other)</div>
<div class="line"><span class="lineno"> 4633</span> </div>
<div class="line"><span class="lineno"> 4634</span>        <span class="keywordflow">if</span> isinstance(self, ABCDatetimeIndex) <span class="keywordflow">and</span> isinstance(other, ABCDatetimeIndex):</div>
<div class="line"><span class="lineno"> 4635</span>            <span class="keywordflow">if</span> (self.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>) ^ (other.tz <span class="keywordflow">is</span> <span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno"> 4636</span>                <span class="comment"># Raise instead of casting to object below.</span></div>
<div class="line"><span class="lineno"> 4637</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Cannot join tz-naive with tz-aware DatetimeIndex&quot;</span>)</div>
<div class="line"><span class="lineno"> 4638</span> </div>
<div class="line"><span class="lineno"> 4639</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> <span class="keywordflow">not</span> other._is_multi:</div>
<div class="line"><span class="lineno"> 4640</span>            <span class="comment"># We have specific handling for MultiIndex below</span></div>
<div class="line"><span class="lineno"> 4641</span>            pself, pother = self._maybe_promote(other)</div>
<div class="line"><span class="lineno"> 4642</span>            <span class="keywordflow">if</span> pself <span class="keywordflow">is</span> <span class="keywordflow">not</span> self <span class="keywordflow">or</span> pother <span class="keywordflow">is</span> <span class="keywordflow">not</span> other:</div>
<div class="line"><span class="lineno"> 4643</span>                <span class="keywordflow">return</span> pself.join(</div>
<div class="line"><span class="lineno"> 4644</span>                    pother, how=how, level=level, return_indexers=<span class="keyword">True</span>, sort=sort</div>
<div class="line"><span class="lineno"> 4645</span>                )</div>
<div class="line"><span class="lineno"> 4646</span> </div>
<div class="line"><span class="lineno"> 4647</span>        lindexer: np.ndarray | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4648</span>        rindexer: np.ndarray | <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4649</span> </div>
<div class="line"><span class="lineno"> 4650</span>        <span class="comment"># try to figure out the join level</span></div>
<div class="line"><span class="lineno"> 4651</span>        <span class="comment"># GH3662</span></div>
<div class="line"><span class="lineno"> 4652</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> (self._is_multi <span class="keywordflow">or</span> other._is_multi):</div>
<div class="line"><span class="lineno"> 4653</span> </div>
<div class="line"><span class="lineno"> 4654</span>            <span class="comment"># have the same levels/names so a simple join</span></div>
<div class="line"><span class="lineno"> 4655</span>            <span class="keywordflow">if</span> self.names == other.names:</div>
<div class="line"><span class="lineno"> 4656</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4657</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4658</span>                <span class="keywordflow">return</span> self._join_multi(other, how=how)</div>
<div class="line"><span class="lineno"> 4659</span> </div>
<div class="line"><span class="lineno"> 4660</span>        <span class="comment"># join on the level</span></div>
<div class="line"><span class="lineno"> 4661</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> (self._is_multi <span class="keywordflow">or</span> other._is_multi):</div>
<div class="line"><span class="lineno"> 4662</span>            <span class="keywordflow">return</span> self._join_level(other, level, how=how)</div>
<div class="line"><span class="lineno"> 4663</span> </div>
<div class="line"><span class="lineno"> 4664</span>        <span class="keywordflow">if</span> len(other) == 0:</div>
<div class="line"><span class="lineno"> 4665</span>            <span class="keywordflow">if</span> how <span class="keywordflow">in</span> (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;outer&quot;</span>):</div>
<div class="line"><span class="lineno"> 4666</span>                join_index = self._view()</div>
<div class="line"><span class="lineno"> 4667</span>                rindexer = np.broadcast_to(np.intp(-1), len(join_index))</div>
<div class="line"><span class="lineno"> 4668</span>                <span class="keywordflow">return</span> join_index, <span class="keywordtype">None</span>, rindexer</div>
<div class="line"><span class="lineno"> 4669</span>            <span class="keywordflow">elif</span> how <span class="keywordflow">in</span> (<span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;inner&quot;</span>, <span class="stringliteral">&quot;cross&quot;</span>):</div>
<div class="line"><span class="lineno"> 4670</span>                join_index = other._view()</div>
<div class="line"><span class="lineno"> 4671</span>                lindexer = np.array([])</div>
<div class="line"><span class="lineno"> 4672</span>                <span class="keywordflow">return</span> join_index, lindexer, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4673</span> </div>
<div class="line"><span class="lineno"> 4674</span>        <span class="keywordflow">if</span> len(self) == 0:</div>
<div class="line"><span class="lineno"> 4675</span>            <span class="keywordflow">if</span> how <span class="keywordflow">in</span> (<span class="stringliteral">&quot;right&quot;</span>, <span class="stringliteral">&quot;outer&quot;</span>):</div>
<div class="line"><span class="lineno"> 4676</span>                join_index = other._view()</div>
<div class="line"><span class="lineno"> 4677</span>                lindexer = np.broadcast_to(np.intp(-1), len(join_index))</div>
<div class="line"><span class="lineno"> 4678</span>                <span class="keywordflow">return</span> join_index, lindexer, <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4679</span>            <span class="keywordflow">elif</span> how <span class="keywordflow">in</span> (<span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;inner&quot;</span>, <span class="stringliteral">&quot;cross&quot;</span>):</div>
<div class="line"><span class="lineno"> 4680</span>                join_index = self._view()</div>
<div class="line"><span class="lineno"> 4681</span>                rindexer = np.array([])</div>
<div class="line"><span class="lineno"> 4682</span>                <span class="keywordflow">return</span> join_index, <span class="keywordtype">None</span>, rindexer</div>
<div class="line"><span class="lineno"> 4683</span> </div>
<div class="line"><span class="lineno"> 4684</span>        <span class="keywordflow">if</span> self._join_precedence &lt; other._join_precedence:</div>
<div class="line"><span class="lineno"> 4685</span>            how = {<span class="stringliteral">&quot;right&quot;</span>: <span class="stringliteral">&quot;left&quot;</span>, <span class="stringliteral">&quot;left&quot;</span>: <span class="stringliteral">&quot;right&quot;</span>}.get(how, how)</div>
<div class="line"><span class="lineno"> 4686</span>            join_index, lidx, ridx = other.join(</div>
<div class="line"><span class="lineno"> 4687</span>                self, how=how, level=level, return_indexers=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 4688</span>            )</div>
<div class="line"><span class="lineno"> 4689</span>            lidx, ridx = ridx, lidx</div>
<div class="line"><span class="lineno"> 4690</span>            <span class="keywordflow">return</span> join_index, lidx, ridx</div>
<div class="line"><span class="lineno"> 4691</span> </div>
<div class="line"><span class="lineno"> 4692</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 4693</span>            dtype = self._find_common_type_compat(other)</div>
<div class="line"><span class="lineno"> 4694</span>            this = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 4695</span>            other = other.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 4696</span>            <span class="keywordflow">return</span> this.join(other, how=how, return_indexers=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno"> 4697</span> </div>
<div class="line"><span class="lineno"> 4698</span>        _validate_join_method(how)</div>
<div class="line"><span class="lineno"> 4699</span> </div>
<div class="line"><span class="lineno"> 4700</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.is_unique <span class="keywordflow">and</span> <span class="keywordflow">not</span> other.is_unique:</div>
<div class="line"><span class="lineno"> 4701</span>            <span class="keywordflow">return</span> self._join_non_unique(other, how=how)</div>
<div class="line"><span class="lineno"> 4702</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> self.is_unique <span class="keywordflow">or</span> <span class="keywordflow">not</span> other.is_unique:</div>
<div class="line"><span class="lineno"> 4703</span>            <span class="keywordflow">if</span> self.is_monotonic_increasing <span class="keywordflow">and</span> other.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 4704</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_interval_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 4705</span>                    <span class="comment"># otherwise we will fall through to _join_via_get_indexer</span></div>
<div class="line"><span class="lineno"> 4706</span>                    <span class="comment"># GH#39133</span></div>
<div class="line"><span class="lineno"> 4707</span>                    <span class="comment"># go through object dtype for ea till engine is supported properly</span></div>
<div class="line"><span class="lineno"> 4708</span>                    <span class="keywordflow">return</span> self._join_monotonic(other, how=how)</div>
<div class="line"><span class="lineno"> 4709</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4710</span>                <span class="keywordflow">return</span> self._join_non_unique(other, how=how)</div>
<div class="line"><span class="lineno"> 4711</span>        <span class="keywordflow">elif</span> (</div>
<div class="line"><span class="lineno"> 4712</span>            self.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 4713</span>            <span class="keywordflow">and</span> other.is_monotonic_increasing</div>
<div class="line"><span class="lineno"> 4714</span>            <span class="keywordflow">and</span> self._can_use_libjoin</div>
<div class="line"><span class="lineno"> 4715</span>            <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno"> 4716</span>                <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 4717</span>                <span class="keywordflow">or</span> <span class="keywordflow">not</span> any(is_categorical_dtype(dtype) <span class="keywordflow">for</span> dtype <span class="keywordflow">in</span> self.dtypes)</div>
<div class="line"><span class="lineno"> 4718</span>            )</div>
<div class="line"><span class="lineno"> 4719</span>            <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_categorical_dtype(self.dtype)</div>
<div class="line"><span class="lineno"> 4720</span>        ):</div>
<div class="line"><span class="lineno"> 4721</span>            <span class="comment"># Categorical is monotonic if data are ordered as categories, but join can</span></div>
<div class="line"><span class="lineno"> 4722</span>            <span class="comment">#  not handle this in case of not lexicographically monotonic GH#38502</span></div>
<div class="line"><span class="lineno"> 4723</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 4724</span>                <span class="keywordflow">return</span> self._join_monotonic(other, how=how)</div>
<div class="line"><span class="lineno"> 4725</span>            <span class="keywordflow">except</span> TypeError:</div>
<div class="line"><span class="lineno"> 4726</span>                <span class="comment"># object dtype; non-comparable objects</span></div>
<div class="line"><span class="lineno"> 4727</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 4728</span> </div>
<div class="line"><span class="lineno"> 4729</span>        <span class="keywordflow">return</span> self._join_via_get_indexer(other, how, sort)</div>
<div class="line"><span class="lineno"> 4730</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7d81e57a458584d71ccfb16a034ba7ec" name="a7d81e57a458584d71ccfb16a034ba7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d81e57a458584d71ccfb16a034ba7ec">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>na_action</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Map values using an input mapping or function.

Parameters
----------
mapper : function, dict, or Series
    Mapping correspondence.
na_action : {None, 'ignore'}
    If 'ignore', propagate NA values, without passing them to the
    mapping correspondence.

Returns
-------
applied : Union[Index, MultiIndex], inferred
    The output of the mapping function applied to the index.
    If the function returns a tuple with more than one element
    a MultiIndex will be returned.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a24bda6cae5330d3973b6a57dd920ca6e">pandas.core.indexes.category.CategoricalIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1extension_1_1_extension_index.html#a2ce0713c08b9193202c0bb31fa4701a7">pandas.core.indexes.extension.ExtensionIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6383</span>    <span class="keyword">def </span>map(self, mapper, na_action=None):</div>
<div class="line"><span class="lineno"> 6384</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6385</span><span class="stringliteral">        Map values using an input mapping or function.</span></div>
<div class="line"><span class="lineno"> 6386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6387</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6388</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6389</span><span class="stringliteral">        mapper : function, dict, or Series</span></div>
<div class="line"><span class="lineno"> 6390</span><span class="stringliteral">            Mapping correspondence.</span></div>
<div class="line"><span class="lineno"> 6391</span><span class="stringliteral">        na_action : {None, &#39;ignore&#39;}</span></div>
<div class="line"><span class="lineno"> 6392</span><span class="stringliteral">            If &#39;ignore&#39;, propagate NA values, without passing them to the</span></div>
<div class="line"><span class="lineno"> 6393</span><span class="stringliteral">            mapping correspondence.</span></div>
<div class="line"><span class="lineno"> 6394</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6395</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6396</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6397</span><span class="stringliteral">        applied : Union[Index, MultiIndex], inferred</span></div>
<div class="line"><span class="lineno"> 6398</span><span class="stringliteral">            The output of the mapping function applied to the index.</span></div>
<div class="line"><span class="lineno"> 6399</span><span class="stringliteral">            If the function returns a tuple with more than one element</span></div>
<div class="line"><span class="lineno"> 6400</span><span class="stringliteral">            a MultiIndex will be returned.</span></div>
<div class="line"><span class="lineno"> 6401</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6402</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepandas_1_1core_1_1indexes_1_1multi.html">pandas.core.indexes.multi</a> <span class="keyword">import</span> MultiIndex</div>
<div class="line"><span class="lineno"> 6403</span> </div>
<div class="line"><span class="lineno"> 6404</span>        new_values = self._map_values(mapper, na_action=na_action)</div>
<div class="line"><span class="lineno"> 6405</span> </div>
<div class="line"><span class="lineno"> 6406</span>        <span class="comment"># we can return a MultiIndex</span></div>
<div class="line"><span class="lineno"> 6407</span>        <span class="keywordflow">if</span> new_values.size <span class="keywordflow">and</span> isinstance(new_values[0], tuple):</div>
<div class="line"><span class="lineno"> 6408</span>            <span class="keywordflow">if</span> isinstance(self, MultiIndex):</div>
<div class="line"><span class="lineno"> 6409</span>                names = self.names</div>
<div class="line"><span class="lineno"> 6410</span>            <span class="keywordflow">elif</span> self.name:</div>
<div class="line"><span class="lineno"> 6411</span>                names = [self.name] * len(new_values[0])</div>
<div class="line"><span class="lineno"> 6412</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6413</span>                names = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6414</span>            <span class="keywordflow">return</span> MultiIndex.from_tuples(new_values, names=names)</div>
<div class="line"><span class="lineno"> 6415</span> </div>
<div class="line"><span class="lineno"> 6416</span>        dtype = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6417</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> new_values.size:</div>
<div class="line"><span class="lineno"> 6418</span>            <span class="comment"># empty</span></div>
<div class="line"><span class="lineno"> 6419</span>            dtype = self.dtype</div>
<div class="line"><span class="lineno"> 6420</span> </div>
<div class="line"><span class="lineno"> 6421</span>        <span class="comment"># e.g. if we are floating and new_values is all ints, then we</span></div>
<div class="line"><span class="lineno"> 6422</span>        <span class="comment">#  don&#39;t want to cast back to floating.  But if we are UInt64</span></div>
<div class="line"><span class="lineno"> 6423</span>        <span class="comment">#  and new_values is all ints, we want to try.</span></div>
<div class="line"><span class="lineno"> 6424</span>        same_dtype = lib.infer_dtype(new_values, skipna=<span class="keyword">False</span>) == self.inferred_type</div>
<div class="line"><span class="lineno"> 6425</span>        <span class="keywordflow">if</span> same_dtype:</div>
<div class="line"><span class="lineno"> 6426</span>            new_values = maybe_cast_pointwise_result(</div>
<div class="line"><span class="lineno"> 6427</span>                new_values, self.dtype, same_dtype=same_dtype</div>
<div class="line"><span class="lineno"> 6428</span>            )</div>
<div class="line"><span class="lineno"> 6429</span> </div>
<div class="line"><span class="lineno"> 6430</span>        <span class="keywordflow">if</span> self._is_backward_compat_public_numeric_index <span class="keywordflow">and</span> is_numeric_dtype(</div>
<div class="line"><span class="lineno"> 6431</span>            new_values.dtype</div>
<div class="line"><span class="lineno"> 6432</span>        ):</div>
<div class="line"><span class="lineno"> 6433</span>            <span class="keywordflow">return</span> self._constructor(</div>
<div class="line"><span class="lineno"> 6434</span>                new_values, dtype=dtype, copy=<span class="keyword">False</span>, name=self.name</div>
<div class="line"><span class="lineno"> 6435</span>            )</div>
<div class="line"><span class="lineno"> 6436</span> </div>
<div class="line"><span class="lineno"> 6437</span>        <span class="keywordflow">return</span> Index._with_infer(new_values, dtype=dtype, copy=<span class="keyword">False</span>, name=self.name)</div>
<div class="line"><span class="lineno"> 6438</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a413e9a58c5415feb5962d3640e1ed3f5" name="a413e9a58c5415feb5962d3640e1ed3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413e9a58c5415feb5962d3640e1ed3f5">&#9670;&#160;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.max </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the maximum value of the Index.

Parameters
----------
axis : int, optional
    For compatibility with NumPy. Only 0 or None are allowed.
skipna : bool, default True
    Exclude NA/null values when showing the result.
*args, **kwargs
    Additional arguments and keywords for compatibility with NumPy.

Returns
-------
scalar
    Maximum value.

See Also
--------
Index.min : Return the minimum value in an Index.
Series.max : Return the maximum value in a Series.
DataFrame.max : Return the maximum values in a DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([3, 2, 1])
&gt;&gt;&gt; idx.max()
3

&gt;&gt;&gt; idx = pd.Index(['c', 'b', 'a'])
&gt;&gt;&gt; idx.max()
'c'

For a MultiIndex, the maximum is determined lexicographically.

&gt;&gt;&gt; idx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])
&gt;&gt;&gt; idx.max()
('b', 2)
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a94d6c656c68ad1acf7ff2bba4d25633e">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a4950d5cba61941efa448f0cda4b3ee0a">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7230</span>    <span class="keyword">def </span>max(self, axis=None, skipna=True, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 7231</span>        nv.validate_max(args, kwargs)</div>
<div class="line"><span class="lineno"> 7232</span>        nv.validate_minmax_axis(axis)</div>
<div class="line"><span class="lineno"> 7233</span> </div>
<div class="line"><span class="lineno"> 7234</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno"> 7235</span>            <span class="keywordflow">return</span> self._na_value</div>
<div class="line"><span class="lineno"> 7236</span> </div>
<div class="line"><span class="lineno"> 7237</span>        <span class="keywordflow">if</span> len(self) <span class="keywordflow">and</span> self.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 7238</span>            <span class="comment"># quick check</span></div>
<div class="line"><span class="lineno"> 7239</span>            last = self[-1]</div>
<div class="line"><span class="lineno"> 7240</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isna(last):</div>
<div class="line"><span class="lineno"> 7241</span>                <span class="keywordflow">return</span> last</div>
<div class="line"><span class="lineno"> 7242</span> </div>
<div class="line"><span class="lineno"> 7243</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 7244</span>            <span class="comment"># Take advantage of cache</span></div>
<div class="line"><span class="lineno"> 7245</span>            mask = self._isnan</div>
<div class="line"><span class="lineno"> 7246</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> skipna <span class="keywordflow">or</span> mask.all():</div>
<div class="line"><span class="lineno"> 7247</span>                <span class="keywordflow">return</span> self._na_value</div>
<div class="line"><span class="lineno"> 7248</span> </div>
<div class="line"><span class="lineno"> 7249</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self._values, np.ndarray):</div>
<div class="line"><span class="lineno"> 7250</span>            <span class="comment"># &quot;ExtensionArray&quot; has no attribute &quot;max&quot;</span></div>
<div class="line"><span class="lineno"> 7251</span>            <span class="keywordflow">return</span> self._values.max(skipna=skipna)  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 7252</span> </div>
<div class="line"><span class="lineno"> 7253</span>        <span class="keywordflow">return</span> super().max(skipna=skipna)</div>
<div class="line"><span class="lineno"> 7254</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aae3b04e914bd501a99cd79acfe983ecb" name="aae3b04e914bd501a99cd79acfe983ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3b04e914bd501a99cd79acfe983ecb">&#9670;&#160;</a></span>memory_usage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.memory_usage </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>deep</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a23d868e0535a0b7a874ad40520677554">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a53be602b87910a3059ac52576f672877">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a4596c9cbaeebc2578a9e027352c6d506">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5181</span>    <span class="keyword">def </span>memory_usage(self, deep: bool = <span class="keyword">False</span>) -&gt; int:</div>
<div class="line"><span class="lineno"> 5182</span>        result = self._memory_usage(deep=deep)</div>
<div class="line"><span class="lineno"> 5183</span> </div>
<div class="line"><span class="lineno"> 5184</span>        <span class="comment"># include our engine hashtable</span></div>
<div class="line"><span class="lineno"> 5185</span>        result += self._engine.sizeof(deep=deep)</div>
<div class="line"><span class="lineno"> 5186</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 5187</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a49b3f856f0483747a90463a07a060073" name="a49b3f856f0483747a90463a07a060073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b3f856f0483747a90463a07a060073">&#9670;&#160;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.min </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skipna</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the minimum value of the Index.

Parameters
----------
axis : {None}
    Dummy argument for consistency with Series.
skipna : bool, default True
    Exclude NA/null values when showing the result.
*args, **kwargs
    Additional arguments and keywords for compatibility with NumPy.

Returns
-------
scalar
    Minimum value.

See Also
--------
Index.max : Return the maximum value of the object.
Series.min : Return the minimum value in a Series.
DataFrame.min : Return the minimum values in a DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([3, 2, 1])
&gt;&gt;&gt; idx.min()
1

&gt;&gt;&gt; idx = pd.Index(['c', 'b', 'a'])
&gt;&gt;&gt; idx.min()
'a'

For a MultiIndex, the minimum is determined lexicographically.

&gt;&gt;&gt; idx = pd.MultiIndex.from_product([('a', 'b'), (2, 1)])
&gt;&gt;&gt; idx.min()
('a', 1)
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a3a836a24e9b1491cdaeb4d509bf6eab7">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8d0ed77592dc6a38781b8bca8bb51769">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7204</span>    <span class="keyword">def </span>min(self, axis=None, skipna=True, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 7205</span>        nv.validate_min(args, kwargs)</div>
<div class="line"><span class="lineno"> 7206</span>        nv.validate_minmax_axis(axis)</div>
<div class="line"><span class="lineno"> 7207</span> </div>
<div class="line"><span class="lineno"> 7208</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno"> 7209</span>            <span class="keywordflow">return</span> self._na_value</div>
<div class="line"><span class="lineno"> 7210</span> </div>
<div class="line"><span class="lineno"> 7211</span>        <span class="keywordflow">if</span> len(self) <span class="keywordflow">and</span> self.is_monotonic_increasing:</div>
<div class="line"><span class="lineno"> 7212</span>            <span class="comment"># quick check</span></div>
<div class="line"><span class="lineno"> 7213</span>            first = self[0]</div>
<div class="line"><span class="lineno"> 7214</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isna(first):</div>
<div class="line"><span class="lineno"> 7215</span>                <span class="keywordflow">return</span> first</div>
<div class="line"><span class="lineno"> 7216</span> </div>
<div class="line"><span class="lineno"> 7217</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> self.hasnans:</div>
<div class="line"><span class="lineno"> 7218</span>            <span class="comment"># Take advantage of cache</span></div>
<div class="line"><span class="lineno"> 7219</span>            mask = self._isnan</div>
<div class="line"><span class="lineno"> 7220</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> skipna <span class="keywordflow">or</span> mask.all():</div>
<div class="line"><span class="lineno"> 7221</span>                <span class="keywordflow">return</span> self._na_value</div>
<div class="line"><span class="lineno"> 7222</span> </div>
<div class="line"><span class="lineno"> 7223</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._is_multi <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self._values, np.ndarray):</div>
<div class="line"><span class="lineno"> 7224</span>            <span class="comment"># &quot;ExtensionArray&quot; has no attribute &quot;min&quot;</span></div>
<div class="line"><span class="lineno"> 7225</span>            <span class="keywordflow">return</span> self._values.min(skipna=skipna)  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 7226</span> </div>
<div class="line"><span class="lineno"> 7227</span>        <span class="keywordflow">return</span> super().min(skipna=skipna)</div>
<div class="line"><span class="lineno"> 7228</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a979e8567cfbe07a32d0f53107d24892c" name="a979e8567cfbe07a32d0f53107d24892c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979e8567cfbe07a32d0f53107d24892c">&#9670;&#160;</a></span>name() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Hashable pandas.core.indexes.base.Index.name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return Index or MultiIndex name.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1736</span>    <span class="keyword">def </span>name(self) -&gt; Hashable:</div>
<div class="line"><span class="lineno"> 1737</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1738</span><span class="stringliteral">        Return Index or MultiIndex name.</span></div>
<div class="line"><span class="lineno"> 1739</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1740</span>        <span class="keywordflow">return</span> self._name</div>
<div class="line"><span class="lineno"> 1741</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a605b2a0ca7b7735a13cc7db6d790d49a" name="a605b2a0ca7b7735a13cc7db6d790d49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605b2a0ca7b7735a13cc7db6d790d49a">&#9670;&#160;</a></span>name() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index.name </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1743</span>    <span class="keyword">def </span>name(self, value: Hashable) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1744</span>        <span class="keywordflow">if</span> self._no_setting_name:</div>
<div class="line"><span class="lineno"> 1745</span>            <span class="comment"># Used in MultiIndex.levels to avoid silently ignoring name updates.</span></div>
<div class="line"><span class="lineno"> 1746</span>            <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line"><span class="lineno"> 1747</span>                <span class="stringliteral">&quot;Cannot set name on a level of a MultiIndex. Use &quot;</span></div>
<div class="line"><span class="lineno"> 1748</span>                <span class="stringliteral">&quot;&#39;MultiIndex.set_names&#39; instead.&quot;</span></div>
<div class="line"><span class="lineno"> 1749</span>            )</div>
<div class="line"><span class="lineno"> 1750</span>        maybe_extract_name(value, <span class="keywordtype">None</span>, type(self))</div>
<div class="line"><span class="lineno"> 1751</span>        self._name = value</div>
<div class="line"><span class="lineno"> 1752</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="add0097bb44007439e46044fa7ef902c8" name="add0097bb44007439e46044fa7ef902c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0097bb44007439e46044fa7ef902c8">&#9670;&#160;</a></span>nlevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> int pandas.core.indexes.base.Index.nlevels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Number of levels.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a2b7ec81c25da4da51a5d15167ebe54c3">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2019</span>    <span class="keyword">def </span>nlevels(self) -&gt; int:</div>
<div class="line"><span class="lineno"> 2020</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2021</span><span class="stringliteral">        Number of levels.</span></div>
<div class="line"><span class="lineno"> 2022</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2023</span>        <span class="keywordflow">return</span> 1</div>
<div class="line"><span class="lineno"> 2024</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aba9b00f5246b0879baaf10e730d7a21a" name="aba9b00f5246b0879baaf10e730d7a21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9b00f5246b0879baaf10e730d7a21a">&#9670;&#160;</a></span>notna()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> npt.NDArray[np.bool_] pandas.core.indexes.base.Index.notna </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Detect existing (non-missing) values.

Return a boolean same-sized object indicating if the values are not NA.
Non-missing values get mapped to ``True``. Characters such as empty
strings ``''`` or :attr:`numpy.inf` are not considered NA values
(unless you set ``pandas.options.mode.use_inf_as_na = True``).
NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``
values.

Returns
-------
numpy.ndarray[bool]
    Boolean array to indicate which entries are not NA.

See Also
--------
Index.notnull : Alias of notna.
Index.isna: Inverse of notna.
notna : Top-level notna.

Examples
--------
Show which entries in an Index are not NA. The result is an
array.

&gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])
&gt;&gt;&gt; idx
Float64Index([5.2, 6.0, nan], dtype='float64')
&gt;&gt;&gt; idx.notna()
array([ True,  True, False])

Empty strings are not considered NA values. None is considered a NA
value.

&gt;&gt;&gt; idx = pd.Index(['black', '', 'red', None])
&gt;&gt;&gt; idx
Index(['black', '', 'red', None], dtype='object')
&gt;&gt;&gt; idx.notna()
array([ True,  True,  True, False])
</pre> <div class="fragment"><div class="line"><span class="lineno"> 2896</span>    <span class="keyword">def </span>notna(self) -&gt; npt.NDArray[np.bool_]:</div>
<div class="line"><span class="lineno"> 2897</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2898</span><span class="stringliteral">        Detect existing (non-missing) values.</span></div>
<div class="line"><span class="lineno"> 2899</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2900</span><span class="stringliteral">        Return a boolean same-sized object indicating if the values are not NA.</span></div>
<div class="line"><span class="lineno"> 2901</span><span class="stringliteral">        Non-missing values get mapped to ``True``. Characters such as empty</span></div>
<div class="line"><span class="lineno"> 2902</span><span class="stringliteral">        strings ``&#39;&#39;`` or :attr:`numpy.inf` are not considered NA values</span></div>
<div class="line"><span class="lineno"> 2903</span><span class="stringliteral">        (unless you set ``pandas.options.mode.use_inf_as_na = True``).</span></div>
<div class="line"><span class="lineno"> 2904</span><span class="stringliteral">        NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``</span></div>
<div class="line"><span class="lineno"> 2905</span><span class="stringliteral">        values.</span></div>
<div class="line"><span class="lineno"> 2906</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2907</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2908</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2909</span><span class="stringliteral">        numpy.ndarray[bool]</span></div>
<div class="line"><span class="lineno"> 2910</span><span class="stringliteral">            Boolean array to indicate which entries are not NA.</span></div>
<div class="line"><span class="lineno"> 2911</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2912</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 2913</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2914</span><span class="stringliteral">        Index.notnull : Alias of notna.</span></div>
<div class="line"><span class="lineno"> 2915</span><span class="stringliteral">        Index.isna: Inverse of notna.</span></div>
<div class="line"><span class="lineno"> 2916</span><span class="stringliteral">        notna : Top-level notna.</span></div>
<div class="line"><span class="lineno"> 2917</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2918</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 2919</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 2920</span><span class="stringliteral">        Show which entries in an Index are not NA. The result is an</span></div>
<div class="line"><span class="lineno"> 2921</span><span class="stringliteral">        array.</span></div>
<div class="line"><span class="lineno"> 2922</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2923</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([5.2, 6.0, np.NaN])</span></div>
<div class="line"><span class="lineno"> 2924</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2925</span><span class="stringliteral">        Float64Index([5.2, 6.0, nan], dtype=&#39;float64&#39;)</span></div>
<div class="line"><span class="lineno"> 2926</span><span class="stringliteral">        &gt;&gt;&gt; idx.notna()</span></div>
<div class="line"><span class="lineno"> 2927</span><span class="stringliteral">        array([ True,  True, False])</span></div>
<div class="line"><span class="lineno"> 2928</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2929</span><span class="stringliteral">        Empty strings are not considered NA values. None is considered a NA</span></div>
<div class="line"><span class="lineno"> 2930</span><span class="stringliteral">        value.</span></div>
<div class="line"><span class="lineno"> 2931</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2932</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None])</span></div>
<div class="line"><span class="lineno"> 2933</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 2934</span><span class="stringliteral">        Index([&#39;black&#39;, &#39;&#39;, &#39;red&#39;, None], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 2935</span><span class="stringliteral">        &gt;&gt;&gt; idx.notna()</span></div>
<div class="line"><span class="lineno"> 2936</span><span class="stringliteral">        array([ True,  True,  True, False])</span></div>
<div class="line"><span class="lineno"> 2937</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2938</span>        <span class="keywordflow">return</span> ~self.isna()</div>
<div class="line"><span class="lineno"> 2939</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae73e5369a94a97ee0a7947c9d3c95cba" name="ae73e5369a94a97ee0a7947c9d3c95cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73e5369a94a97ee0a7947c9d3c95cba">&#9670;&#160;</a></span>putmask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.putmask </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a new Index of the values set with the mask.

Returns
-------
Index

See Also
--------
numpy.ndarray.putmask : Changes elements of an array
    based on conditional and input values.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5465</span>    <span class="keyword">def </span>putmask(self, mask, value) -&gt; Index:</div>
<div class="line"><span class="lineno"> 5466</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5467</span><span class="stringliteral">        Return a new Index of the values set with the mask.</span></div>
<div class="line"><span class="lineno"> 5468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5469</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5470</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5471</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 5472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5473</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5474</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5475</span><span class="stringliteral">        numpy.ndarray.putmask : Changes elements of an array</span></div>
<div class="line"><span class="lineno"> 5476</span><span class="stringliteral">            based on conditional and input values.</span></div>
<div class="line"><span class="lineno"> 5477</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5478</span>        mask, noop = validate_putmask(self._values, mask)</div>
<div class="line"><span class="lineno"> 5479</span>        <span class="keywordflow">if</span> noop:</div>
<div class="line"><span class="lineno"> 5480</span>            <span class="keywordflow">return</span> self.copy()</div>
<div class="line"><span class="lineno"> 5481</span> </div>
<div class="line"><span class="lineno"> 5482</span>        <span class="keywordflow">if</span> self.dtype != object <span class="keywordflow">and</span> is_valid_na_for_dtype(value, self.dtype):</div>
<div class="line"><span class="lineno"> 5483</span>            <span class="comment"># e.g. None -&gt; np.nan, see also Block._standardize_fill_value</span></div>
<div class="line"><span class="lineno"> 5484</span>            value = self._na_value</div>
<div class="line"><span class="lineno"> 5485</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 5486</span>            converted = self._validate_fill_value(value)</div>
<div class="line"><span class="lineno"> 5487</span>        <span class="keywordflow">except</span> (LossySetitemError, ValueError, TypeError) <span class="keyword">as</span> err:</div>
<div class="line"><span class="lineno"> 5488</span>            <span class="keywordflow">if</span> is_object_dtype(self):  <span class="comment"># pragma: no cover</span></div>
<div class="line"><span class="lineno"> 5489</span>                <span class="keywordflow">raise</span> err</div>
<div class="line"><span class="lineno"> 5490</span> </div>
<div class="line"><span class="lineno"> 5491</span>            dtype = self._find_common_type_compat(value)</div>
<div class="line"><span class="lineno"> 5492</span>            <span class="keywordflow">return</span> self.astype(dtype).putmask(mask, value)</div>
<div class="line"><span class="lineno"> 5493</span> </div>
<div class="line"><span class="lineno"> 5494</span>        values = self._values.copy()</div>
<div class="line"><span class="lineno"> 5495</span> </div>
<div class="line"><span class="lineno"> 5496</span>        <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno"> 5497</span>            converted = setitem_datetimelike_compat(values, mask.sum(), converted)</div>
<div class="line"><span class="lineno"> 5498</span>            np.putmask(values, mask, converted)</div>
<div class="line"><span class="lineno"> 5499</span> </div>
<div class="line"><span class="lineno"> 5500</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5501</span>            <span class="comment"># Note: we use the original value here, not converted, as</span></div>
<div class="line"><span class="lineno"> 5502</span>            <span class="comment">#  _validate_fill_value is not idempotent</span></div>
<div class="line"><span class="lineno"> 5503</span>            values._putmask(mask, value)</div>
<div class="line"><span class="lineno"> 5504</span> </div>
<div class="line"><span class="lineno"> 5505</span>        <span class="keywordflow">return</span> self._shallow_copy(values)</div>
<div class="line"><span class="lineno"> 5506</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a63697423c8bd64935ff3fcb7f9b9c704" name="a63697423c8bd64935ff3fcb7f9b9c704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63697423c8bd64935ff3fcb7f9b9c704">&#9670;&#160;</a></span>ravel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.ravel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>order</em> = <code>&quot;C&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an ndarray of the flattened values of the underlying data.

Returns
-------
numpy.ndarray
    Flattened array.

See Also
--------
numpy.ndarray.ravel : Return a flattened array.
</pre> <div class="fragment"><div class="line"><span class="lineno">  995</span>    <span class="keyword">def </span>ravel(self, order=&quot;C&quot;):</div>
<div class="line"><span class="lineno">  996</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  997</span><span class="stringliteral">        Return an ndarray of the flattened values of the underlying data.</span></div>
<div class="line"><span class="lineno">  998</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  999</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1000</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1001</span><span class="stringliteral">        numpy.ndarray</span></div>
<div class="line"><span class="lineno"> 1002</span><span class="stringliteral">            Flattened array.</span></div>
<div class="line"><span class="lineno"> 1003</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1004</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1005</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1006</span><span class="stringliteral">        numpy.ndarray.ravel : Return a flattened array.</span></div>
<div class="line"><span class="lineno"> 1007</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1008</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1009</span>            <span class="stringliteral">&quot;Index.ravel returning ndarray is deprecated; in a future version &quot;</span></div>
<div class="line"><span class="lineno"> 1010</span>            <span class="stringliteral">&quot;this will return a view on self.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1011</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 1012</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1013</span>        )</div>
<div class="line"><span class="lineno"> 1014</span>        <span class="keywordflow">if</span> needs_i8_conversion(self.dtype):</div>
<div class="line"><span class="lineno"> 1015</span>            <span class="comment"># Item &quot;ndarray[Any, Any]&quot; of &quot;Union[ExtensionArray, ndarray[Any, Any]]&quot;</span></div>
<div class="line"><span class="lineno"> 1016</span>            <span class="comment"># has no attribute &quot;_ndarray&quot;</span></div>
<div class="line"><span class="lineno"> 1017</span>            values = self._data._ndarray  <span class="comment"># type: ignore[union-attr]</span></div>
<div class="line"><span class="lineno"> 1018</span>        <span class="keywordflow">elif</span> is_interval_dtype(self.dtype):</div>
<div class="line"><span class="lineno"> 1019</span>            values = np.asarray(self._data)</div>
<div class="line"><span class="lineno"> 1020</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1021</span>            values = self._get_engine_target()</div>
<div class="line"><span class="lineno"> 1022</span>        <span class="keywordflow">return</span> values.ravel(order=order)</div>
<div class="line"><span class="lineno"> 1023</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa49df0503460de6359ea6f35fdea3181" name="aa49df0503460de6359ea6f35fdea3181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49df0503460de6359ea6f35fdea3181">&#9670;&#160;</a></span>reindex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a>, npt.NDArray[np.intp] | None] pandas.core.indexes.base.Index.reindex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create index with target's values.

Parameters
----------
target : an iterable
method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
    * default: exact matches only.
    * pad / ffill: find the PREVIOUS index value if no exact match.
    * backfill / bfill: use NEXT index value if no exact match
    * nearest: use the NEAREST index value if no exact match. Tied
      distances are broken by preferring the larger index value.
level : int, optional
    Level of multiindex.
limit : int, optional
    Maximum number of consecutive labels in ``target`` to match for
    inexact matches.
tolerance : int or float, optional
    Maximum distance between original and new labels for inexact
    matches. The values of the index at the matching locations must
    satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.

    Tolerance may be a scalar value, which applies the same tolerance
    to all values, or list-like, which applies variable tolerance per
    element. List-like includes list, tuple, array, Series, and must be
    the same size as the index and its dtype must exactly match the
    index's type.

Returns
-------
new_index : pd.Index
    Resulting index.
indexer : np.ndarray[np.intp] or None
    Indices of output values in original index.

Raises
------
TypeError
    If ``method`` passed along with ``level``.
ValueError
    If non-unique multi-index
ValueError
    If non-unique index and ``method`` or ``limit`` passed.

See Also
--------
Series.reindex : Conform Series to new index with optional filling logic.
DataFrame.reindex : Conform DataFrame to new index with optional filling logic.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['car', 'bike', 'train', 'tractor'])
&gt;&gt;&gt; idx
Index(['car', 'bike', 'train', 'tractor'], dtype='object')
&gt;&gt;&gt; idx.reindex(['car', 'bike'])
(Index(['car', 'bike'], dtype='object'), array([0, 1]))
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#aa7ba487529a40d7384ed433aaa57edb2">pandas.core.indexes.category.CategoricalIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 4363</span>    ) -&gt; tuple[Index, npt.NDArray[np.intp] | <span class="keywordtype">None</span>]:</div>
<div class="line"><span class="lineno"> 4364</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4365</span><span class="stringliteral">        Create index with target&#39;s values.</span></div>
<div class="line"><span class="lineno"> 4366</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4367</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 4368</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 4369</span><span class="stringliteral">        target : an iterable</span></div>
<div class="line"><span class="lineno"> 4370</span><span class="stringliteral">        method : {None, &#39;pad&#39;/&#39;ffill&#39;, &#39;backfill&#39;/&#39;bfill&#39;, &#39;nearest&#39;}, optional</span></div>
<div class="line"><span class="lineno"> 4371</span><span class="stringliteral">            * default: exact matches only.</span></div>
<div class="line"><span class="lineno"> 4372</span><span class="stringliteral">            * pad / ffill: find the PREVIOUS index value if no exact match.</span></div>
<div class="line"><span class="lineno"> 4373</span><span class="stringliteral">            * backfill / bfill: use NEXT index value if no exact match</span></div>
<div class="line"><span class="lineno"> 4374</span><span class="stringliteral">            * nearest: use the NEAREST index value if no exact match. Tied</span></div>
<div class="line"><span class="lineno"> 4375</span><span class="stringliteral">              distances are broken by preferring the larger index value.</span></div>
<div class="line"><span class="lineno"> 4376</span><span class="stringliteral">        level : int, optional</span></div>
<div class="line"><span class="lineno"> 4377</span><span class="stringliteral">            Level of multiindex.</span></div>
<div class="line"><span class="lineno"> 4378</span><span class="stringliteral">        limit : int, optional</span></div>
<div class="line"><span class="lineno"> 4379</span><span class="stringliteral">            Maximum number of consecutive labels in ``target`` to match for</span></div>
<div class="line"><span class="lineno"> 4380</span><span class="stringliteral">            inexact matches.</span></div>
<div class="line"><span class="lineno"> 4381</span><span class="stringliteral">        tolerance : int or float, optional</span></div>
<div class="line"><span class="lineno"> 4382</span><span class="stringliteral">            Maximum distance between original and new labels for inexact</span></div>
<div class="line"><span class="lineno"> 4383</span><span class="stringliteral">            matches. The values of the index at the matching locations must</span></div>
<div class="line"><span class="lineno"> 4384</span><span class="stringliteral">            satisfy the equation ``abs(index[indexer] - target) &lt;= tolerance``.</span></div>
<div class="line"><span class="lineno"> 4385</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4386</span><span class="stringliteral">            Tolerance may be a scalar value, which applies the same tolerance</span></div>
<div class="line"><span class="lineno"> 4387</span><span class="stringliteral">            to all values, or list-like, which applies variable tolerance per</span></div>
<div class="line"><span class="lineno"> 4388</span><span class="stringliteral">            element. List-like includes list, tuple, array, Series, and must be</span></div>
<div class="line"><span class="lineno"> 4389</span><span class="stringliteral">            the same size as the index and its dtype must exactly match the</span></div>
<div class="line"><span class="lineno"> 4390</span><span class="stringliteral">            index&#39;s type.</span></div>
<div class="line"><span class="lineno"> 4391</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4392</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 4393</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 4394</span><span class="stringliteral">        new_index : pd.Index</span></div>
<div class="line"><span class="lineno"> 4395</span><span class="stringliteral">            Resulting index.</span></div>
<div class="line"><span class="lineno"> 4396</span><span class="stringliteral">        indexer : np.ndarray[np.intp] or None</span></div>
<div class="line"><span class="lineno"> 4397</span><span class="stringliteral">            Indices of output values in original index.</span></div>
<div class="line"><span class="lineno"> 4398</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4399</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 4400</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 4401</span><span class="stringliteral">        TypeError</span></div>
<div class="line"><span class="lineno"> 4402</span><span class="stringliteral">            If ``method`` passed along with ``level``.</span></div>
<div class="line"><span class="lineno"> 4403</span><span class="stringliteral">        ValueError</span></div>
<div class="line"><span class="lineno"> 4404</span><span class="stringliteral">            If non-unique multi-index</span></div>
<div class="line"><span class="lineno"> 4405</span><span class="stringliteral">        ValueError</span></div>
<div class="line"><span class="lineno"> 4406</span><span class="stringliteral">            If non-unique index and ``method`` or ``limit`` passed.</span></div>
<div class="line"><span class="lineno"> 4407</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4408</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 4409</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4410</span><span class="stringliteral">        Series.reindex : Conform Series to new index with optional filling logic.</span></div>
<div class="line"><span class="lineno"> 4411</span><span class="stringliteral">        DataFrame.reindex : Conform DataFrame to new index with optional filling logic.</span></div>
<div class="line"><span class="lineno"> 4412</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 4413</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 4414</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 4415</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;])</span></div>
<div class="line"><span class="lineno"> 4416</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 4417</span><span class="stringliteral">        Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 4418</span><span class="stringliteral">        &gt;&gt;&gt; idx.reindex([&#39;car&#39;, &#39;bike&#39;])</span></div>
<div class="line"><span class="lineno"> 4419</span><span class="stringliteral">        (Index([&#39;car&#39;, &#39;bike&#39;], dtype=&#39;object&#39;), array([0, 1]))</span></div>
<div class="line"><span class="lineno"> 4420</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 4421</span>        <span class="comment"># GH6552: preserve names when reindexing to non-named target</span></div>
<div class="line"><span class="lineno"> 4422</span>        <span class="comment"># (i.e. neither Index nor Series).</span></div>
<div class="line"><span class="lineno"> 4423</span>        preserve_names = <span class="keywordflow">not</span> hasattr(target, <span class="stringliteral">&quot;name&quot;</span>)</div>
<div class="line"><span class="lineno"> 4424</span> </div>
<div class="line"><span class="lineno"> 4425</span>        <span class="comment"># GH7774: preserve dtype/tz if target is empty and not an Index.</span></div>
<div class="line"><span class="lineno"> 4426</span>        target = ensure_has_len(target)  <span class="comment"># target may be an iterator</span></div>
<div class="line"><span class="lineno"> 4427</span> </div>
<div class="line"><span class="lineno"> 4428</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(target, Index) <span class="keywordflow">and</span> len(target) == 0:</div>
<div class="line"><span class="lineno"> 4429</span>            <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 4430</span>                <span class="comment"># &quot;Index&quot; has no attribute &quot;levels&quot;; maybe &quot;nlevels&quot;?</span></div>
<div class="line"><span class="lineno"> 4431</span>                idx = self.levels[level]  <span class="comment"># type: ignore[attr-defined]</span></div>
<div class="line"><span class="lineno"> 4432</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4433</span>                idx = self</div>
<div class="line"><span class="lineno"> 4434</span>            target = idx[:0]</div>
<div class="line"><span class="lineno"> 4435</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4436</span>            target = ensure_index(target)</div>
<div class="line"><span class="lineno"> 4437</span> </div>
<div class="line"><span class="lineno"> 4438</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> (</div>
<div class="line"><span class="lineno"> 4439</span>            isinstance(self, ABCMultiIndex) <span class="keywordflow">or</span> isinstance(target, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 4440</span>        ):</div>
<div class="line"><span class="lineno"> 4441</span>            <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4442</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Fill method not supported if level passed&quot;</span>)</div>
<div class="line"><span class="lineno"> 4443</span> </div>
<div class="line"><span class="lineno"> 4444</span>            <span class="comment"># TODO: tests where passing `keep_order=not self._is_multi`</span></div>
<div class="line"><span class="lineno"> 4445</span>            <span class="comment">#  makes a difference for non-MultiIndex case</span></div>
<div class="line"><span class="lineno"> 4446</span>            target, indexer, _ = self._join_level(</div>
<div class="line"><span class="lineno"> 4447</span>                target, level, how=<span class="stringliteral">&quot;right&quot;</span>, keep_order=<span class="keywordflow">not</span> self._is_multi</div>
<div class="line"><span class="lineno"> 4448</span>            )</div>
<div class="line"><span class="lineno"> 4449</span> </div>
<div class="line"><span class="lineno"> 4450</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4451</span>            <span class="keywordflow">if</span> self.equals(target):</div>
<div class="line"><span class="lineno"> 4452</span>                indexer = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 4453</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4454</span>                <span class="keywordflow">if</span> self._index_as_unique:</div>
<div class="line"><span class="lineno"> 4455</span>                    indexer = self.get_indexer(</div>
<div class="line"><span class="lineno"> 4456</span>                        target, method=method, limit=limit, tolerance=tolerance</div>
<div class="line"><span class="lineno"> 4457</span>                    )</div>
<div class="line"><span class="lineno"> 4458</span>                <span class="keywordflow">elif</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 4459</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;cannot handle a non-unique multi-index!&quot;</span>)</div>
<div class="line"><span class="lineno"> 4460</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 4461</span>                    <span class="keywordflow">if</span> method <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> limit <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 4462</span>                        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno"> 4463</span>                            <span class="stringliteral">&quot;cannot reindex a non-unique index &quot;</span></div>
<div class="line"><span class="lineno"> 4464</span>                            <span class="stringliteral">&quot;with a method or limit&quot;</span></div>
<div class="line"><span class="lineno"> 4465</span>                        )</div>
<div class="line"><span class="lineno"> 4466</span>                    indexer, _ = self.get_indexer_non_unique(target)</div>
<div class="line"><span class="lineno"> 4467</span> </div>
<div class="line"><span class="lineno"> 4468</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.is_unique:</div>
<div class="line"><span class="lineno"> 4469</span>                    <span class="comment"># GH#42568</span></div>
<div class="line"><span class="lineno"> 4470</span>                    warnings.warn(</div>
<div class="line"><span class="lineno"> 4471</span>                        <span class="stringliteral">&quot;reindexing with a non-unique Index is deprecated and &quot;</span></div>
<div class="line"><span class="lineno"> 4472</span>                        <span class="stringliteral">&quot;will raise in a future version.&quot;</span>,</div>
<div class="line"><span class="lineno"> 4473</span>                        FutureWarning,</div>
<div class="line"><span class="lineno"> 4474</span>                        stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 4475</span>                    )</div>
<div class="line"><span class="lineno"> 4476</span> </div>
<div class="line"><span class="lineno"> 4477</span>        target = self._wrap_reindex_result(target, indexer, preserve_names)</div>
<div class="line"><span class="lineno"> 4478</span>        <span class="keywordflow">return</span> target, indexer</div>
<div class="line"><span class="lineno"> 4479</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a929c0b566c56a9b6f3af237f33590ae6" name="a929c0b566c56a9b6f3af237f33590ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929c0b566c56a9b6f3af237f33590ae6">&#9670;&#160;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.rename </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>inplace</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Alter Index or MultiIndex name.

Able to set new names without level. Defaults to returning new index.
Length of names must match number of levels in MultiIndex.

Parameters
----------
name : label or list of labels
    Name(s) to set.
inplace : bool, default False
    Modifies the object directly, instead of creating a new Index or
    MultiIndex.

Returns
-------
Index or None
    The same type as the caller or None if ``inplace=True``.

See Also
--------
Index.set_names : Able to set new names partially and by level.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['A', 'C', 'A', 'B'], name='score')
&gt;&gt;&gt; idx.rename('grade')
Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')

&gt;&gt;&gt; idx = pd.MultiIndex.from_product([['python', 'cobra'],
...                                   [2018, 2019]],
...                                   names=['kind', 'year'])
&gt;&gt;&gt; idx
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           names=['kind', 'year'])
&gt;&gt;&gt; idx.rename(['species', 'year'])
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           names=['species', 'year'])
&gt;&gt;&gt; idx.rename('species')
Traceback (most recent call last):
TypeError: Must pass list-like as `names`.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1964</span>    <span class="keyword">def </span>rename(self, name, inplace=False):</div>
<div class="line"><span class="lineno"> 1965</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1966</span><span class="stringliteral">        Alter Index or MultiIndex name.</span></div>
<div class="line"><span class="lineno"> 1967</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1968</span><span class="stringliteral">        Able to set new names without level. Defaults to returning new index.</span></div>
<div class="line"><span class="lineno"> 1969</span><span class="stringliteral">        Length of names must match number of levels in MultiIndex.</span></div>
<div class="line"><span class="lineno"> 1970</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1971</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1972</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1973</span><span class="stringliteral">        name : label or list of labels</span></div>
<div class="line"><span class="lineno"> 1974</span><span class="stringliteral">            Name(s) to set.</span></div>
<div class="line"><span class="lineno"> 1975</span><span class="stringliteral">        inplace : bool, default False</span></div>
<div class="line"><span class="lineno"> 1976</span><span class="stringliteral">            Modifies the object directly, instead of creating a new Index or</span></div>
<div class="line"><span class="lineno"> 1977</span><span class="stringliteral">            MultiIndex.</span></div>
<div class="line"><span class="lineno"> 1978</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1979</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1980</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1981</span><span class="stringliteral">        Index or None</span></div>
<div class="line"><span class="lineno"> 1982</span><span class="stringliteral">            The same type as the caller or None if ``inplace=True``.</span></div>
<div class="line"><span class="lineno"> 1983</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1984</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1985</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1986</span><span class="stringliteral">        Index.set_names : Able to set new names partially and by level.</span></div>
<div class="line"><span class="lineno"> 1987</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1988</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1989</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1990</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;], name=&#39;score&#39;)</span></div>
<div class="line"><span class="lineno"> 1991</span><span class="stringliteral">        &gt;&gt;&gt; idx.rename(&#39;grade&#39;)</span></div>
<div class="line"><span class="lineno"> 1992</span><span class="stringliteral">        Index([&#39;A&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;], dtype=&#39;object&#39;, name=&#39;grade&#39;)</span></div>
<div class="line"><span class="lineno"> 1993</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1994</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.MultiIndex.from_product([[&#39;python&#39;, &#39;cobra&#39;],</span></div>
<div class="line"><span class="lineno"> 1995</span><span class="stringliteral">        ...                                   [2018, 2019]],</span></div>
<div class="line"><span class="lineno"> 1996</span><span class="stringliteral">        ...                                   names=[&#39;kind&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 1997</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 1998</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1999</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 2000</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 2001</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 2002</span><span class="stringliteral">                   names=[&#39;kind&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 2003</span><span class="stringliteral">        &gt;&gt;&gt; idx.rename([&#39;species&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 2004</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 2005</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 2006</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 2007</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 2008</span><span class="stringliteral">                   names=[&#39;species&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 2009</span><span class="stringliteral">        &gt;&gt;&gt; idx.rename(&#39;species&#39;)</span></div>
<div class="line"><span class="lineno"> 2010</span><span class="stringliteral">        Traceback (most recent call last):</span></div>
<div class="line"><span class="lineno"> 2011</span><span class="stringliteral">        TypeError: Must pass list-like as `names`.</span></div>
<div class="line"><span class="lineno"> 2012</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2013</span>        <span class="keywordflow">return</span> self.set_names([name], inplace=inplace)</div>
<div class="line"><span class="lineno"> 2014</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0d018340edd883764366684191d07bec" name="a0d018340edd883764366684191d07bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d018340edd883764366684191d07bec">&#9670;&#160;</a></span>repeat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.repeat </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>repeats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>axis</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a6e8d1207a975a0255977a9467591adb2">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1258</span>    <span class="keyword">def </span>repeat(self, repeats, axis=None):</div>
<div class="line"><span class="lineno"> 1259</span>        repeats = ensure_platform_int(repeats)</div>
<div class="line"><span class="lineno"> 1260</span>        nv.validate_repeat((), {<span class="stringliteral">&quot;axis&quot;</span>: axis})</div>
<div class="line"><span class="lineno"> 1261</span>        res_values = self._values.repeat(repeats)</div>
<div class="line"><span class="lineno"> 1262</span> </div>
<div class="line"><span class="lineno"> 1263</span>        <span class="comment"># _constructor so RangeIndex-&gt;Int64Index</span></div>
<div class="line"><span class="lineno"> 1264</span>        <span class="keywordflow">return</span> self._constructor._simple_new(res_values, name=self.name)</div>
<div class="line"><span class="lineno"> 1265</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0f6ae31c0ddc828de69ebdfb0184f509" name="a0f6ae31c0ddc828de69ebdfb0184f509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6ae31c0ddc828de69ebdfb0184f509">&#9670;&#160;</a></span>set_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.set_names </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>inplace</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Set Index or MultiIndex name.

Able to set new names partially and by level.

Parameters
----------

names : label or list of label or dict-like for MultiIndex
    Name(s) to set.

    .. versionchanged:: 1.3.0

level : int, label or list of int or label, optional
    If the index is a MultiIndex and names is not dict-like, level(s) to set
    (None for all levels). Otherwise level must be None.

    .. versionchanged:: 1.3.0

inplace : bool, default False
    Modifies the object directly, instead of creating a new Index or
    MultiIndex.

Returns
-------
Index or None
    The same type as the caller or None if ``inplace=True``.

See Also
--------
Index.rename : Able to set new names without level.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx
Int64Index([1, 2, 3, 4], dtype='int64')
&gt;&gt;&gt; idx.set_names('quarter')
Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')

&gt;&gt;&gt; idx = pd.MultiIndex.from_product([['python', 'cobra'],
...                                   [2018, 2019]])
&gt;&gt;&gt; idx
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           )
&gt;&gt;&gt; idx.set_names(['kind', 'year'], inplace=True)
&gt;&gt;&gt; idx
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           names=['kind', 'year'])
&gt;&gt;&gt; idx.set_names('species', level=0)
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           names=['species', 'year'])

When renaming levels with a dict, levels can not be passed.

&gt;&gt;&gt; idx.set_names({'kind': 'snake'})
MultiIndex([('python', 2018),
            ('python', 2019),
            ( 'cobra', 2018),
            ( 'cobra', 2019)],
           names=['snake', 'year'])
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#af10a939ead1e17da17af62e2f6efba0b">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1854</span>    <span class="keyword">def </span>set_names(self, names, level=None, inplace: bool = <span class="keyword">False</span>):</div>
<div class="line"><span class="lineno"> 1855</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1856</span><span class="stringliteral">        Set Index or MultiIndex name.</span></div>
<div class="line"><span class="lineno"> 1857</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1858</span><span class="stringliteral">        Able to set new names partially and by level.</span></div>
<div class="line"><span class="lineno"> 1859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1860</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1861</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1862</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1863</span><span class="stringliteral">        names : label or list of label or dict-like for MultiIndex</span></div>
<div class="line"><span class="lineno"> 1864</span><span class="stringliteral">            Name(s) to set.</span></div>
<div class="line"><span class="lineno"> 1865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1866</span><span class="stringliteral">            .. versionchanged:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 1867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1868</span><span class="stringliteral">        level : int, label or list of int or label, optional</span></div>
<div class="line"><span class="lineno"> 1869</span><span class="stringliteral">            If the index is a MultiIndex and names is not dict-like, level(s) to set</span></div>
<div class="line"><span class="lineno"> 1870</span><span class="stringliteral">            (None for all levels). Otherwise level must be None.</span></div>
<div class="line"><span class="lineno"> 1871</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1872</span><span class="stringliteral">            .. versionchanged:: 1.3.0</span></div>
<div class="line"><span class="lineno"> 1873</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1874</span><span class="stringliteral">        inplace : bool, default False</span></div>
<div class="line"><span class="lineno"> 1875</span><span class="stringliteral">            Modifies the object directly, instead of creating a new Index or</span></div>
<div class="line"><span class="lineno"> 1876</span><span class="stringliteral">            MultiIndex.</span></div>
<div class="line"><span class="lineno"> 1877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1878</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1879</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1880</span><span class="stringliteral">        Index or None</span></div>
<div class="line"><span class="lineno"> 1881</span><span class="stringliteral">            The same type as the caller or None if ``inplace=True``.</span></div>
<div class="line"><span class="lineno"> 1882</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1883</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1884</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1885</span><span class="stringliteral">        Index.rename : Able to set new names without level.</span></div>
<div class="line"><span class="lineno"> 1886</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1887</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1888</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1889</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 1890</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 1891</span><span class="stringliteral">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 1892</span><span class="stringliteral">        &gt;&gt;&gt; idx.set_names(&#39;quarter&#39;)</span></div>
<div class="line"><span class="lineno"> 1893</span><span class="stringliteral">        Int64Index([1, 2, 3, 4], dtype=&#39;int64&#39;, name=&#39;quarter&#39;)</span></div>
<div class="line"><span class="lineno"> 1894</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1895</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.MultiIndex.from_product([[&#39;python&#39;, &#39;cobra&#39;],</span></div>
<div class="line"><span class="lineno"> 1896</span><span class="stringliteral">        ...                                   [2018, 2019]])</span></div>
<div class="line"><span class="lineno"> 1897</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 1898</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1899</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 1900</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1901</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 1902</span><span class="stringliteral">                   )</span></div>
<div class="line"><span class="lineno"> 1903</span><span class="stringliteral">        &gt;&gt;&gt; idx.set_names([&#39;kind&#39;, &#39;year&#39;], inplace=True)</span></div>
<div class="line"><span class="lineno"> 1904</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 1905</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1906</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 1907</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1908</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 1909</span><span class="stringliteral">                   names=[&#39;kind&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 1910</span><span class="stringliteral">        &gt;&gt;&gt; idx.set_names(&#39;species&#39;, level=0)</span></div>
<div class="line"><span class="lineno"> 1911</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1912</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 1913</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1914</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 1915</span><span class="stringliteral">                   names=[&#39;species&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 1916</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1917</span><span class="stringliteral">        When renaming levels with a dict, levels can not be passed.</span></div>
<div class="line"><span class="lineno"> 1918</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1919</span><span class="stringliteral">        &gt;&gt;&gt; idx.set_names({&#39;kind&#39;: &#39;snake&#39;})</span></div>
<div class="line"><span class="lineno"> 1920</span><span class="stringliteral">        MultiIndex([(&#39;python&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1921</span><span class="stringliteral">                    (&#39;python&#39;, 2019),</span></div>
<div class="line"><span class="lineno"> 1922</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2018),</span></div>
<div class="line"><span class="lineno"> 1923</span><span class="stringliteral">                    ( &#39;cobra&#39;, 2019)],</span></div>
<div class="line"><span class="lineno"> 1924</span><span class="stringliteral">                   names=[&#39;snake&#39;, &#39;year&#39;])</span></div>
<div class="line"><span class="lineno"> 1925</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1926</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 1927</span>            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Level must be None for non-MultiIndex&quot;</span>)</div>
<div class="line"><span class="lineno"> 1928</span> </div>
<div class="line"><span class="lineno"> 1929</span>        <span class="keywordflow">elif</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_list_like(level) <span class="keywordflow">and</span> is_list_like(names):</div>
<div class="line"><span class="lineno"> 1930</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Names must be a string when a single level is provided.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1931</span> </div>
<div class="line"><span class="lineno"> 1932</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_list_like(names) <span class="keywordflow">and</span> level <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> self.nlevels &gt; 1:</div>
<div class="line"><span class="lineno"> 1933</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Must pass list-like as `names`.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1934</span> </div>
<div class="line"><span class="lineno"> 1935</span>        <span class="keywordflow">elif</span> is_dict_like(names) <span class="keywordflow">and</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 1936</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Can only pass dict-like as `names` for MultiIndex.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1937</span> </div>
<div class="line"><span class="lineno"> 1938</span>        <span class="keywordflow">elif</span> is_dict_like(names) <span class="keywordflow">and</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1939</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Can not pass level for dictlike `names`.&quot;</span>)</div>
<div class="line"><span class="lineno"> 1940</span> </div>
<div class="line"><span class="lineno"> 1941</span>        <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex) <span class="keywordflow">and</span> is_dict_like(names) <span class="keywordflow">and</span> level <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1942</span>            <span class="comment"># Transform dict to list of new names and corresponding levels</span></div>
<div class="line"><span class="lineno"> 1943</span>            level, names_adjusted = [], []</div>
<div class="line"><span class="lineno"> 1944</span>            <span class="keywordflow">for</span> i, name <span class="keywordflow">in</span> enumerate(self.names):</div>
<div class="line"><span class="lineno"> 1945</span>                <span class="keywordflow">if</span> name <span class="keywordflow">in</span> names.keys():</div>
<div class="line"><span class="lineno"> 1946</span>                    level.append(i)</div>
<div class="line"><span class="lineno"> 1947</span>                    names_adjusted.append(names[name])</div>
<div class="line"><span class="lineno"> 1948</span>            names = names_adjusted</div>
<div class="line"><span class="lineno"> 1949</span> </div>
<div class="line"><span class="lineno"> 1950</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_list_like(names):</div>
<div class="line"><span class="lineno"> 1951</span>            names = [names]</div>
<div class="line"><span class="lineno"> 1952</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_list_like(level):</div>
<div class="line"><span class="lineno"> 1953</span>            level = [level]</div>
<div class="line"><span class="lineno"> 1954</span> </div>
<div class="line"><span class="lineno"> 1955</span>        <span class="keywordflow">if</span> inplace:</div>
<div class="line"><span class="lineno"> 1956</span>            idx = self</div>
<div class="line"><span class="lineno"> 1957</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1958</span>            idx = self._view()</div>
<div class="line"><span class="lineno"> 1959</span> </div>
<div class="line"><span class="lineno"> 1960</span>        idx._set_names(names, level=level)</div>
<div class="line"><span class="lineno"> 1961</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> inplace:</div>
<div class="line"><span class="lineno"> 1962</span>            <span class="keywordflow">return</span> idx</div>
<div class="line"><span class="lineno"> 1963</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a08f86e4c407fa32badff6a06444a1b02" name="a08f86e4c407fa32badff6a06444a1b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f86e4c407fa32badff6a06444a1b02">&#9670;&#160;</a></span>set_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> None pandas.core.indexes.base.Index.set_value </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Fast lookup of value from 1-dimensional ndarray.

.. deprecated:: 1.0

Notes
-----
Only use this if you know what you're doing.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5992</span>    <span class="keyword">def </span>set_value(self, arr, key, value) -&gt; None:</div>
<div class="line"><span class="lineno"> 5993</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5994</span><span class="stringliteral">        Fast lookup of value from 1-dimensional ndarray.</span></div>
<div class="line"><span class="lineno"> 5995</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5996</span><span class="stringliteral">        .. deprecated:: 1.0</span></div>
<div class="line"><span class="lineno"> 5997</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5998</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 5999</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 6000</span><span class="stringliteral">        Only use this if you know what you&#39;re doing.</span></div>
<div class="line"><span class="lineno"> 6001</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6002</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 6003</span>            (</div>
<div class="line"><span class="lineno"> 6004</span>                <span class="stringliteral">&quot;The &#39;set_value&#39; method is deprecated, and &quot;</span></div>
<div class="line"><span class="lineno"> 6005</span>                <span class="stringliteral">&quot;will be removed in a future version.&quot;</span></div>
<div class="line"><span class="lineno"> 6006</span>            ),</div>
<div class="line"><span class="lineno"> 6007</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 6008</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 6009</span>        )</div>
<div class="line"><span class="lineno"> 6010</span>        loc = self._engine.get_loc(key)</div>
<div class="line"><span class="lineno"> 6011</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> can_hold_element(arr, value):</div>
<div class="line"><span class="lineno"> 6012</span>            <span class="keywordflow">raise</span> ValueError</div>
<div class="line"><span class="lineno"> 6013</span>        arr[loc] = value</div>
<div class="line"><span class="lineno"> 6014</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4d01a0b717b64937123a99e01a7f624" name="ad4d01a0b717b64937123a99e01a7f624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d01a0b717b64937123a99e01a7f624">&#9670;&#160;</a></span>shape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Shape pandas.core.indexes.base.Index.shape </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a tuple of the shape of the underlying data.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a876b12dd3b2f50f177f605f714f8614c">pandas.core.base.IndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 7259</span>    <span class="keyword">def </span>shape(self) -&gt; Shape:</div>
<div class="line"><span class="lineno"> 7260</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7261</span><span class="stringliteral">        Return a tuple of the shape of the underlying data.</span></div>
<div class="line"><span class="lineno"> 7262</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 7263</span>        <span class="comment"># See GH#27775, GH#27384 for history/reasoning in how this is defined.</span></div>
<div class="line"><span class="lineno"> 7264</span>        <span class="keywordflow">return</span> (len(self),)</div>
<div class="line"><span class="lineno"> 7265</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa437b90ba8ed1fa0e98499dd531553b" name="aaa437b90ba8ed1fa0e98499dd531553b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa437b90ba8ed1fa0e98499dd531553b">&#9670;&#160;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.shift </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>periods</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>freq</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Shift index by desired number of time frequency increments.

This method is for shifting the values of datetime-like indexes
by a specified time increment a given number of times.

Parameters
----------
periods : int, default 1
    Number of periods (or increments) to shift by,
    can be positive or negative.
freq : pandas.DateOffset, pandas.Timedelta or str, optional
    Frequency increment to shift by.
    If None, the index is shifted by its own `freq` attribute.
    Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.

Returns
-------
pandas.Index
    Shifted index.

See Also
--------
Series.shift : Shift values of Series.

Notes
-----
This method is only implemented for datetime-like index classes,
i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.

Examples
--------
Put the first 5 month starts of 2011 into an index.

&gt;&gt;&gt; month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')
&gt;&gt;&gt; month_starts
DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',
               '2011-05-01'],
              dtype='datetime64[ns]', freq='MS')

Shift the index by 10 days.

&gt;&gt;&gt; month_starts.shift(10, freq='D')
DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',
               '2011-05-11'],
              dtype='datetime64[ns]', freq=None)

The default value of `freq` is the `freq` attribute of the index,
which is 'MS' (month start) in this example.

&gt;&gt;&gt; month_starts.shift(10)
DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',
               '2012-03-01'],
              dtype='datetime64[ns]', freq='MS')
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a4b75ce105121e3ada869331413122b78">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5825</span>    <span class="keyword">def </span>shift(self, periods=1, freq=None):</div>
<div class="line"><span class="lineno"> 5826</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5827</span><span class="stringliteral">        Shift index by desired number of time frequency increments.</span></div>
<div class="line"><span class="lineno"> 5828</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5829</span><span class="stringliteral">        This method is for shifting the values of datetime-like indexes</span></div>
<div class="line"><span class="lineno"> 5830</span><span class="stringliteral">        by a specified time increment a given number of times.</span></div>
<div class="line"><span class="lineno"> 5831</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5832</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5833</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5834</span><span class="stringliteral">        periods : int, default 1</span></div>
<div class="line"><span class="lineno"> 5835</span><span class="stringliteral">            Number of periods (or increments) to shift by,</span></div>
<div class="line"><span class="lineno"> 5836</span><span class="stringliteral">            can be positive or negative.</span></div>
<div class="line"><span class="lineno"> 5837</span><span class="stringliteral">        freq : pandas.DateOffset, pandas.Timedelta or str, optional</span></div>
<div class="line"><span class="lineno"> 5838</span><span class="stringliteral">            Frequency increment to shift by.</span></div>
<div class="line"><span class="lineno"> 5839</span><span class="stringliteral">            If None, the index is shifted by its own `freq` attribute.</span></div>
<div class="line"><span class="lineno"> 5840</span><span class="stringliteral">            Offset aliases are valid strings, e.g., &#39;D&#39;, &#39;W&#39;, &#39;M&#39; etc.</span></div>
<div class="line"><span class="lineno"> 5841</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5842</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5843</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5844</span><span class="stringliteral">        pandas.Index</span></div>
<div class="line"><span class="lineno"> 5845</span><span class="stringliteral">            Shifted index.</span></div>
<div class="line"><span class="lineno"> 5846</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5847</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5848</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5849</span><span class="stringliteral">        Series.shift : Shift values of Series.</span></div>
<div class="line"><span class="lineno"> 5850</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5851</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 5852</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 5853</span><span class="stringliteral">        This method is only implemented for datetime-like index classes,</span></div>
<div class="line"><span class="lineno"> 5854</span><span class="stringliteral">        i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.</span></div>
<div class="line"><span class="lineno"> 5855</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5856</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5857</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5858</span><span class="stringliteral">        Put the first 5 month starts of 2011 into an index.</span></div>
<div class="line"><span class="lineno"> 5859</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5860</span><span class="stringliteral">        &gt;&gt;&gt; month_starts = pd.date_range(&#39;1/1/2011&#39;, periods=5, freq=&#39;MS&#39;)</span></div>
<div class="line"><span class="lineno"> 5861</span><span class="stringliteral">        &gt;&gt;&gt; month_starts</span></div>
<div class="line"><span class="lineno"> 5862</span><span class="stringliteral">        DatetimeIndex([&#39;2011-01-01&#39;, &#39;2011-02-01&#39;, &#39;2011-03-01&#39;, &#39;2011-04-01&#39;,</span></div>
<div class="line"><span class="lineno"> 5863</span><span class="stringliteral">                       &#39;2011-05-01&#39;],</span></div>
<div class="line"><span class="lineno"> 5864</span><span class="stringliteral">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</span></div>
<div class="line"><span class="lineno"> 5865</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5866</span><span class="stringliteral">        Shift the index by 10 days.</span></div>
<div class="line"><span class="lineno"> 5867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5868</span><span class="stringliteral">        &gt;&gt;&gt; month_starts.shift(10, freq=&#39;D&#39;)</span></div>
<div class="line"><span class="lineno"> 5869</span><span class="stringliteral">        DatetimeIndex([&#39;2011-01-11&#39;, &#39;2011-02-11&#39;, &#39;2011-03-11&#39;, &#39;2011-04-11&#39;,</span></div>
<div class="line"><span class="lineno"> 5870</span><span class="stringliteral">                       &#39;2011-05-11&#39;],</span></div>
<div class="line"><span class="lineno"> 5871</span><span class="stringliteral">                      dtype=&#39;datetime64[ns]&#39;, freq=None)</span></div>
<div class="line"><span class="lineno"> 5872</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5873</span><span class="stringliteral">        The default value of `freq` is the `freq` attribute of the index,</span></div>
<div class="line"><span class="lineno"> 5874</span><span class="stringliteral">        which is &#39;MS&#39; (month start) in this example.</span></div>
<div class="line"><span class="lineno"> 5875</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5876</span><span class="stringliteral">        &gt;&gt;&gt; month_starts.shift(10)</span></div>
<div class="line"><span class="lineno"> 5877</span><span class="stringliteral">        DatetimeIndex([&#39;2011-11-01&#39;, &#39;2011-12-01&#39;, &#39;2012-01-01&#39;, &#39;2012-02-01&#39;,</span></div>
<div class="line"><span class="lineno"> 5878</span><span class="stringliteral">                       &#39;2012-03-01&#39;],</span></div>
<div class="line"><span class="lineno"> 5879</span><span class="stringliteral">                      dtype=&#39;datetime64[ns]&#39;, freq=&#39;MS&#39;)</span></div>
<div class="line"><span class="lineno"> 5880</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5881</span>        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 5882</span>            f<span class="stringliteral">&quot;This method is only implemented for DatetimeIndex, PeriodIndex and &quot;</span></div>
<div class="line"><span class="lineno"> 5883</span>            f<span class="stringliteral">&quot;TimedeltaIndex; Got type {type(self).__name__}&quot;</span></div>
<div class="line"><span class="lineno"> 5884</span>        )</div>
<div class="line"><span class="lineno"> 5885</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6ff9e39c42982dba799539a4c7a2e83" name="aa6ff9e39c42982dba799539a4c7a2e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ff9e39c42982dba799539a4c7a2e83">&#9670;&#160;</a></span>slice_indexer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> slice pandas.core.indexes.base.Index.slice_indexer </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | None &#160;</td>
          <td class="paramname"><em>start</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | None &#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int | None &#160;</td>
          <td class="paramname"><em>step</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the slice indexer for input labels and step.

Index needs to be ordered and unique.

Parameters
----------
start : label, default None
    If None, defaults to the beginning.
end : label, default None
    If None, defaults to the end.
step : int, default None
kind : str, default None

    .. deprecated:: 1.4.0

Returns
-------
indexer : slice

Raises
------
KeyError : If key does not exist, or key is not unique and index is
    not ordered.

Notes
-----
This function assumes that the data is sorted, so use at your own peril

Examples
--------
This is a method on all index types. For example you can do:

&gt;&gt;&gt; idx = pd.Index(list('abcd'))
&gt;&gt;&gt; idx.slice_indexer(start='b', end='c')
slice(1, 3, None)

&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])
&gt;&gt;&gt; idx.slice_indexer(start='b', end=('c', 'g'))
slice(1, 3, None)
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#afc250267d01ef5ba8d2a2bdc0f4e8b5b">pandas.core.indexes.datetimes.DatetimeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6558</span>    ) -&gt; slice:</div>
<div class="line"><span class="lineno"> 6559</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6560</span><span class="stringliteral">        Compute the slice indexer for input labels and step.</span></div>
<div class="line"><span class="lineno"> 6561</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6562</span><span class="stringliteral">        Index needs to be ordered and unique.</span></div>
<div class="line"><span class="lineno"> 6563</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6564</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6565</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6566</span><span class="stringliteral">        start : label, default None</span></div>
<div class="line"><span class="lineno"> 6567</span><span class="stringliteral">            If None, defaults to the beginning.</span></div>
<div class="line"><span class="lineno"> 6568</span><span class="stringliteral">        end : label, default None</span></div>
<div class="line"><span class="lineno"> 6569</span><span class="stringliteral">            If None, defaults to the end.</span></div>
<div class="line"><span class="lineno"> 6570</span><span class="stringliteral">        step : int, default None</span></div>
<div class="line"><span class="lineno"> 6571</span><span class="stringliteral">        kind : str, default None</span></div>
<div class="line"><span class="lineno"> 6572</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6573</span><span class="stringliteral">            .. deprecated:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 6574</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6575</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6576</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6577</span><span class="stringliteral">        indexer : slice</span></div>
<div class="line"><span class="lineno"> 6578</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6579</span><span class="stringliteral">        Raises</span></div>
<div class="line"><span class="lineno"> 6580</span><span class="stringliteral">        ------</span></div>
<div class="line"><span class="lineno"> 6581</span><span class="stringliteral">        KeyError : If key does not exist, or key is not unique and index is</span></div>
<div class="line"><span class="lineno"> 6582</span><span class="stringliteral">            not ordered.</span></div>
<div class="line"><span class="lineno"> 6583</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6584</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 6585</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 6586</span><span class="stringliteral">        This function assumes that the data is sorted, so use at your own peril</span></div>
<div class="line"><span class="lineno"> 6587</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6588</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 6589</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6590</span><span class="stringliteral">        This is a method on all index types. For example you can do:</span></div>
<div class="line"><span class="lineno"> 6591</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6592</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abcd&#39;))</span></div>
<div class="line"><span class="lineno"> 6593</span><span class="stringliteral">        &gt;&gt;&gt; idx.slice_indexer(start=&#39;b&#39;, end=&#39;c&#39;)</span></div>
<div class="line"><span class="lineno"> 6594</span><span class="stringliteral">        slice(1, 3, None)</span></div>
<div class="line"><span class="lineno"> 6595</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6596</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([list(&#39;abcd&#39;), list(&#39;efgh&#39;)])</span></div>
<div class="line"><span class="lineno"> 6597</span><span class="stringliteral">        &gt;&gt;&gt; idx.slice_indexer(start=&#39;b&#39;, end=(&#39;c&#39;, &#39;g&#39;))</span></div>
<div class="line"><span class="lineno"> 6598</span><span class="stringliteral">        slice(1, 3, None)</span></div>
<div class="line"><span class="lineno"> 6599</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6600</span>        self._deprecated_arg(kind, <span class="stringliteral">&quot;kind&quot;</span>, <span class="stringliteral">&quot;slice_indexer&quot;</span>)</div>
<div class="line"><span class="lineno"> 6601</span> </div>
<div class="line"><span class="lineno"> 6602</span>        start_slice, end_slice = self.slice_locs(start, end, step=step)</div>
<div class="line"><span class="lineno"> 6603</span> </div>
<div class="line"><span class="lineno"> 6604</span>        <span class="comment"># return a slice</span></div>
<div class="line"><span class="lineno"> 6605</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(start_slice):</div>
<div class="line"><span class="lineno"> 6606</span>            <span class="keywordflow">raise</span> AssertionError(<span class="stringliteral">&quot;Start slice bound is non-scalar&quot;</span>)</div>
<div class="line"><span class="lineno"> 6607</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_scalar(end_slice):</div>
<div class="line"><span class="lineno"> 6608</span>            <span class="keywordflow">raise</span> AssertionError(<span class="stringliteral">&quot;End slice bound is non-scalar&quot;</span>)</div>
<div class="line"><span class="lineno"> 6609</span> </div>
<div class="line"><span class="lineno"> 6610</span>        <span class="keywordflow">return</span> slice(start_slice, end_slice, step)</div>
<div class="line"><span class="lineno"> 6611</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ac2625ecfe9f2ace46206b38bf3b27f" name="a2ac2625ecfe9f2ace46206b38bf3b27f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac2625ecfe9f2ace46206b38bf3b27f">&#9670;&#160;</a></span>slice_locs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> tuple[int, int] pandas.core.indexes.base.Index.slice_locs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute slice locations for input labels.

Parameters
----------
start : label, default None
    If None, defaults to the beginning.
end : label, default None
    If None, defaults to the end.
step : int, defaults None
    If None, defaults to 1.
kind : {'loc', 'getitem'} or None

    .. deprecated:: 1.4.0

Returns
-------
start, end : int

See Also
--------
Index.get_loc : Get location for a single label.

Notes
-----
This method only works if the index is monotonic or unique.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(list('abcd'))
&gt;&gt;&gt; idx.slice_locs(start='b', end='c')
(1, 3)
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a4a75974b17205b87671779c6097b0755">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 6755</span>    ) -&gt; tuple[int, int]:</div>
<div class="line"><span class="lineno"> 6756</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6757</span><span class="stringliteral">        Compute slice locations for input labels.</span></div>
<div class="line"><span class="lineno"> 6758</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6759</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 6760</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 6761</span><span class="stringliteral">        start : label, default None</span></div>
<div class="line"><span class="lineno"> 6762</span><span class="stringliteral">            If None, defaults to the beginning.</span></div>
<div class="line"><span class="lineno"> 6763</span><span class="stringliteral">        end : label, default None</span></div>
<div class="line"><span class="lineno"> 6764</span><span class="stringliteral">            If None, defaults to the end.</span></div>
<div class="line"><span class="lineno"> 6765</span><span class="stringliteral">        step : int, defaults None</span></div>
<div class="line"><span class="lineno"> 6766</span><span class="stringliteral">            If None, defaults to 1.</span></div>
<div class="line"><span class="lineno"> 6767</span><span class="stringliteral">        kind : {&#39;loc&#39;, &#39;getitem&#39;} or None</span></div>
<div class="line"><span class="lineno"> 6768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6769</span><span class="stringliteral">            .. deprecated:: 1.4.0</span></div>
<div class="line"><span class="lineno"> 6770</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6771</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 6772</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 6773</span><span class="stringliteral">        start, end : int</span></div>
<div class="line"><span class="lineno"> 6774</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6775</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 6776</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6777</span><span class="stringliteral">        Index.get_loc : Get location for a single label.</span></div>
<div class="line"><span class="lineno"> 6778</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6779</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 6780</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 6781</span><span class="stringliteral">        This method only works if the index is monotonic or unique.</span></div>
<div class="line"><span class="lineno"> 6782</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 6783</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 6784</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 6785</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index(list(&#39;abcd&#39;))</span></div>
<div class="line"><span class="lineno"> 6786</span><span class="stringliteral">        &gt;&gt;&gt; idx.slice_locs(start=&#39;b&#39;, end=&#39;c&#39;)</span></div>
<div class="line"><span class="lineno"> 6787</span><span class="stringliteral">        (1, 3)</span></div>
<div class="line"><span class="lineno"> 6788</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 6789</span>        self._deprecated_arg(kind, <span class="stringliteral">&quot;kind&quot;</span>, <span class="stringliteral">&quot;slice_locs&quot;</span>)</div>
<div class="line"><span class="lineno"> 6790</span>        inc = step <span class="keywordflow">is</span> <span class="keywordtype">None</span> <span class="keywordflow">or</span> step &gt;= 0</div>
<div class="line"><span class="lineno"> 6791</span> </div>
<div class="line"><span class="lineno"> 6792</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> inc:</div>
<div class="line"><span class="lineno"> 6793</span>            <span class="comment"># If it&#39;s a reverse slice, temporarily swap bounds.</span></div>
<div class="line"><span class="lineno"> 6794</span>            start, end = end, start</div>
<div class="line"><span class="lineno"> 6795</span> </div>
<div class="line"><span class="lineno"> 6796</span>        <span class="comment"># GH 16785: If start and end happen to be date strings with UTC offsets</span></div>
<div class="line"><span class="lineno"> 6797</span>        <span class="comment"># attempt to parse and check that the offsets are the same</span></div>
<div class="line"><span class="lineno"> 6798</span>        <span class="keywordflow">if</span> isinstance(start, (str, datetime)) <span class="keywordflow">and</span> isinstance(end, (str, datetime)):</div>
<div class="line"><span class="lineno"> 6799</span>            <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 6800</span>                ts_start = Timestamp(start)</div>
<div class="line"><span class="lineno"> 6801</span>                ts_end = Timestamp(end)</div>
<div class="line"><span class="lineno"> 6802</span>            <span class="keywordflow">except</span> (ValueError, TypeError):</div>
<div class="line"><span class="lineno"> 6803</span>                <span class="keywordflow">pass</span></div>
<div class="line"><span class="lineno"> 6804</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 6805</span>                <span class="keywordflow">if</span> <span class="keywordflow">not</span> tz_compare(ts_start.tzinfo, ts_end.tzinfo):</div>
<div class="line"><span class="lineno"> 6806</span>                    <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Both dates must have the same UTC offset&quot;</span>)</div>
<div class="line"><span class="lineno"> 6807</span> </div>
<div class="line"><span class="lineno"> 6808</span>        start_slice = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6809</span>        <span class="keywordflow">if</span> start <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6810</span>            start_slice = self.get_slice_bound(start, <span class="stringliteral">&quot;left&quot;</span>)</div>
<div class="line"><span class="lineno"> 6811</span>        <span class="keywordflow">if</span> start_slice <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6812</span>            start_slice = 0</div>
<div class="line"><span class="lineno"> 6813</span> </div>
<div class="line"><span class="lineno"> 6814</span>        end_slice = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno"> 6815</span>        <span class="keywordflow">if</span> end <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6816</span>            end_slice = self.get_slice_bound(end, <span class="stringliteral">&quot;right&quot;</span>)</div>
<div class="line"><span class="lineno"> 6817</span>        <span class="keywordflow">if</span> end_slice <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 6818</span>            end_slice = len(self)</div>
<div class="line"><span class="lineno"> 6819</span> </div>
<div class="line"><span class="lineno"> 6820</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> inc:</div>
<div class="line"><span class="lineno"> 6821</span>            <span class="comment"># Bounds at this moment are swapped, swap them back and shift by 1.</span></div>
<div class="line"><span class="lineno"> 6822</span>            <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 6823</span>            <span class="comment"># slice_locs(&#39;B&#39;, &#39;A&#39;, step=-1): s=&#39;B&#39;, e=&#39;A&#39;</span></div>
<div class="line"><span class="lineno"> 6824</span>            <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 6825</span>            <span class="comment">#              s=&#39;A&#39;                 e=&#39;B&#39;</span></div>
<div class="line"><span class="lineno"> 6826</span>            <span class="comment"># AFTER SWAP:    |                     |</span></div>
<div class="line"><span class="lineno"> 6827</span>            <span class="comment">#                v ------------------&gt; V</span></div>
<div class="line"><span class="lineno"> 6828</span>            <span class="comment">#           -----------------------------------</span></div>
<div class="line"><span class="lineno"> 6829</span>            <span class="comment">#           | | |A|A|A|A| | | | | |B|B| | | | |</span></div>
<div class="line"><span class="lineno"> 6830</span>            <span class="comment">#           -----------------------------------</span></div>
<div class="line"><span class="lineno"> 6831</span>            <span class="comment">#              ^ &lt;------------------ ^</span></div>
<div class="line"><span class="lineno"> 6832</span>            <span class="comment"># SHOULD BE:   |                     |</span></div>
<div class="line"><span class="lineno"> 6833</span>            <span class="comment">#           end=s-1              start=e-1</span></div>
<div class="line"><span class="lineno"> 6834</span>            <span class="comment">#</span></div>
<div class="line"><span class="lineno"> 6835</span>            end_slice, start_slice = start_slice - 1, end_slice - 1</div>
<div class="line"><span class="lineno"> 6836</span> </div>
<div class="line"><span class="lineno"> 6837</span>            <span class="comment"># i == -1 triggers ``len(self) + i`` selection that points to the</span></div>
<div class="line"><span class="lineno"> 6838</span>            <span class="comment"># last element, not before-the-first one, subtracting len(self)</span></div>
<div class="line"><span class="lineno"> 6839</span>            <span class="comment"># compensates that.</span></div>
<div class="line"><span class="lineno"> 6840</span>            <span class="keywordflow">if</span> end_slice == -1:</div>
<div class="line"><span class="lineno"> 6841</span>                end_slice -= len(self)</div>
<div class="line"><span class="lineno"> 6842</span>            <span class="keywordflow">if</span> start_slice == -1:</div>
<div class="line"><span class="lineno"> 6843</span>                start_slice -= len(self)</div>
<div class="line"><span class="lineno"> 6844</span> </div>
<div class="line"><span class="lineno"> 6845</span>        <span class="keywordflow">return</span> start_slice, end_slice</div>
<div class="line"><span class="lineno"> 6846</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a65dd03a5291f205bda3867d89e7fd1a8" name="a65dd03a5291f205bda3867d89e7fd1a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dd03a5291f205bda3867d89e7fd1a8">&#9670;&#160;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.sort </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Use sort_values instead.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5819</span>    <span class="keyword">def </span>sort(self, *args, **kwargs):</div>
<div class="line"><span class="lineno"> 5820</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5821</span><span class="stringliteral">        Use sort_values instead.</span></div>
<div class="line"><span class="lineno"> 5822</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5823</span>        <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;cannot sort an Index object in-place, use sort_values instead&quot;</span>)</div>
<div class="line"><span class="lineno"> 5824</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a514e382098f15b8b7a9041b76c65fcf9" name="a514e382098f15b8b7a9041b76c65fcf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514e382098f15b8b7a9041b76c65fcf9">&#9670;&#160;</a></span>sort_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.sort_values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>return_indexer</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#a9f7b26ddd8c81fdac304a936133ec018">str_t</a> &#160;</td>
          <td class="paramname"><em>na_position</em> = <code>&quot;last&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callable | None &#160;</td>
          <td class="paramname"><em>key</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return a sorted copy of the index.

Return a sorted copy of the index, and optionally return the indices
that sorted the index itself.

Parameters
----------
return_indexer : bool, default False
    Should the indices that would sort the index be returned.
ascending : bool, default True
    Should the index values be sorted in an ascending order.
na_position : {'first' or 'last'}, default 'last'
    Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at
    the end.

    .. versionadded:: 1.2.0

key : callable, optional
    If not None, apply the key function to the index values
    before sorting. This is similar to the `key` argument in the
    builtin :meth:`sorted` function, with the notable difference that
    this `key` function should be *vectorized*. It should expect an
    ``Index`` and return an ``Index`` of the same shape.

    .. versionadded:: 1.1.0

Returns
-------
sorted_index : pandas.Index
    Sorted copy of the index.
indexer : numpy.ndarray, optional
    The indices that the index itself was sorted by.

See Also
--------
Series.sort_values : Sort values of a Series.
DataFrame.sort_values : Sort values in a DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index([10, 100, 1, 1000])
&gt;&gt;&gt; idx
Int64Index([10, 100, 1, 1000], dtype='int64')

Sort values in ascending order (default behavior).

&gt;&gt;&gt; idx.sort_values()
Int64Index([1, 10, 100, 1000], dtype='int64')

Sort values in descending order, and also get the indices `idx` was
sorted by.

&gt;&gt;&gt; idx.sort_values(ascending=False, return_indexer=True)
(Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a7c3132850b3287bf2d33d0cbcae753da">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5741</span>    ):</div>
<div class="line"><span class="lineno"> 5742</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5743</span><span class="stringliteral">        Return a sorted copy of the index.</span></div>
<div class="line"><span class="lineno"> 5744</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5745</span><span class="stringliteral">        Return a sorted copy of the index, and optionally return the indices</span></div>
<div class="line"><span class="lineno"> 5746</span><span class="stringliteral">        that sorted the index itself.</span></div>
<div class="line"><span class="lineno"> 5747</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5748</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5749</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5750</span><span class="stringliteral">        return_indexer : bool, default False</span></div>
<div class="line"><span class="lineno"> 5751</span><span class="stringliteral">            Should the indices that would sort the index be returned.</span></div>
<div class="line"><span class="lineno"> 5752</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 5753</span><span class="stringliteral">            Should the index values be sorted in an ascending order.</span></div>
<div class="line"><span class="lineno"> 5754</span><span class="stringliteral">        na_position : {&#39;first&#39; or &#39;last&#39;}, default &#39;last&#39;</span></div>
<div class="line"><span class="lineno"> 5755</span><span class="stringliteral">            Argument &#39;first&#39; puts NaNs at the beginning, &#39;last&#39; puts NaNs at</span></div>
<div class="line"><span class="lineno"> 5756</span><span class="stringliteral">            the end.</span></div>
<div class="line"><span class="lineno"> 5757</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5758</span><span class="stringliteral">            .. versionadded:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 5759</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5760</span><span class="stringliteral">        key : callable, optional</span></div>
<div class="line"><span class="lineno"> 5761</span><span class="stringliteral">            If not None, apply the key function to the index values</span></div>
<div class="line"><span class="lineno"> 5762</span><span class="stringliteral">            before sorting. This is similar to the `key` argument in the</span></div>
<div class="line"><span class="lineno"> 5763</span><span class="stringliteral">            builtin :meth:`sorted` function, with the notable difference that</span></div>
<div class="line"><span class="lineno"> 5764</span><span class="stringliteral">            this `key` function should be *vectorized*. It should expect an</span></div>
<div class="line"><span class="lineno"> 5765</span><span class="stringliteral">            ``Index`` and return an ``Index`` of the same shape.</span></div>
<div class="line"><span class="lineno"> 5766</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5767</span><span class="stringliteral">            .. versionadded:: 1.1.0</span></div>
<div class="line"><span class="lineno"> 5768</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5769</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5770</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5771</span><span class="stringliteral">        sorted_index : pandas.Index</span></div>
<div class="line"><span class="lineno"> 5772</span><span class="stringliteral">            Sorted copy of the index.</span></div>
<div class="line"><span class="lineno"> 5773</span><span class="stringliteral">        indexer : numpy.ndarray, optional</span></div>
<div class="line"><span class="lineno"> 5774</span><span class="stringliteral">            The indices that the index itself was sorted by.</span></div>
<div class="line"><span class="lineno"> 5775</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5776</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5777</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5778</span><span class="stringliteral">        Series.sort_values : Sort values of a Series.</span></div>
<div class="line"><span class="lineno"> 5779</span><span class="stringliteral">        DataFrame.sort_values : Sort values in a DataFrame.</span></div>
<div class="line"><span class="lineno"> 5780</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5781</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5782</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5783</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([10, 100, 1, 1000])</span></div>
<div class="line"><span class="lineno"> 5784</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 5785</span><span class="stringliteral">        Int64Index([10, 100, 1, 1000], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5786</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5787</span><span class="stringliteral">        Sort values in ascending order (default behavior).</span></div>
<div class="line"><span class="lineno"> 5788</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5789</span><span class="stringliteral">        &gt;&gt;&gt; idx.sort_values()</span></div>
<div class="line"><span class="lineno"> 5790</span><span class="stringliteral">        Int64Index([1, 10, 100, 1000], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 5791</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5792</span><span class="stringliteral">        Sort values in descending order, and also get the indices `idx` was</span></div>
<div class="line"><span class="lineno"> 5793</span><span class="stringliteral">        sorted by.</span></div>
<div class="line"><span class="lineno"> 5794</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5795</span><span class="stringliteral">        &gt;&gt;&gt; idx.sort_values(ascending=False, return_indexer=True)</span></div>
<div class="line"><span class="lineno"> 5796</span><span class="stringliteral">        (Int64Index([1000, 100, 10, 1], dtype=&#39;int64&#39;), array([3, 1, 0, 2]))</span></div>
<div class="line"><span class="lineno"> 5797</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5798</span>        idx = ensure_key_mapped(self, key)</div>
<div class="line"><span class="lineno"> 5799</span> </div>
<div class="line"><span class="lineno"> 5800</span>        <span class="comment"># GH 35584. Sort missing values according to na_position kwarg</span></div>
<div class="line"><span class="lineno"> 5801</span>        <span class="comment"># ignore na_position for MultiIndex</span></div>
<div class="line"><span class="lineno"> 5802</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 5803</span>            _as = nargsort(</div>
<div class="line"><span class="lineno"> 5804</span>                items=idx, ascending=ascending, na_position=na_position, key=key</div>
<div class="line"><span class="lineno"> 5805</span>            )</div>
<div class="line"><span class="lineno"> 5806</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5807</span>            _as = idx.argsort()</div>
<div class="line"><span class="lineno"> 5808</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> ascending:</div>
<div class="line"><span class="lineno"> 5809</span>                _as = _as[::-1]</div>
<div class="line"><span class="lineno"> 5810</span> </div>
<div class="line"><span class="lineno"> 5811</span>        sorted_index = self.take(_as)</div>
<div class="line"><span class="lineno"> 5812</span> </div>
<div class="line"><span class="lineno"> 5813</span>        <span class="keywordflow">if</span> return_indexer:</div>
<div class="line"><span class="lineno"> 5814</span>            <span class="keywordflow">return</span> sorted_index, _as</div>
<div class="line"><span class="lineno"> 5815</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 5816</span>            <span class="keywordflow">return</span> sorted_index</div>
<div class="line"><span class="lineno"> 5817</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2796389d83ddd71eb4ab883440fe92ee" name="a2796389d83ddd71eb4ab883440fe92ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2796389d83ddd71eb4ab883440fe92ee">&#9670;&#160;</a></span>sortlevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.sortlevel </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ascending</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort_remaining</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">For internal compatibility with the Index API.

Sort the Index. This is for compat with MultiIndex

Parameters
----------
ascending : bool, default True
    False to sort in descending order

level, sort_remaining are compat parameters

Returns
-------
Index
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad1d7b6a2ad6759c4d59f9dd97ea00d80">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2059</span>    <span class="keyword">def </span>sortlevel(self, level=None, ascending=True, sort_remaining=None):</div>
<div class="line"><span class="lineno"> 2060</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2061</span><span class="stringliteral">        For internal compatibility with the Index API.</span></div>
<div class="line"><span class="lineno"> 2062</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2063</span><span class="stringliteral">        Sort the Index. This is for compat with MultiIndex</span></div>
<div class="line"><span class="lineno"> 2064</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2065</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 2066</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 2067</span><span class="stringliteral">        ascending : bool, default True</span></div>
<div class="line"><span class="lineno"> 2068</span><span class="stringliteral">            False to sort in descending order</span></div>
<div class="line"><span class="lineno"> 2069</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2070</span><span class="stringliteral">        level, sort_remaining are compat parameters</span></div>
<div class="line"><span class="lineno"> 2071</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 2072</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 2073</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 2074</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 2075</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 2076</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(ascending, (list, bool)):</div>
<div class="line"><span class="lineno"> 2077</span>            <span class="keywordflow">raise</span> TypeError(</div>
<div class="line"><span class="lineno"> 2078</span>                <span class="stringliteral">&quot;ascending must be a single bool value or&quot;</span></div>
<div class="line"><span class="lineno"> 2079</span>                <span class="stringliteral">&quot;a list of bool values of length 1&quot;</span></div>
<div class="line"><span class="lineno"> 2080</span>            )</div>
<div class="line"><span class="lineno"> 2081</span> </div>
<div class="line"><span class="lineno"> 2082</span>        <span class="keywordflow">if</span> isinstance(ascending, list):</div>
<div class="line"><span class="lineno"> 2083</span>            <span class="keywordflow">if</span> len(ascending) != 1:</div>
<div class="line"><span class="lineno"> 2084</span>                <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;ascending must be a list of bool values of length 1&quot;</span>)</div>
<div class="line"><span class="lineno"> 2085</span>            ascending = ascending[0]</div>
<div class="line"><span class="lineno"> 2086</span> </div>
<div class="line"><span class="lineno"> 2087</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(ascending, bool):</div>
<div class="line"><span class="lineno"> 2088</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;ascending must be a bool value&quot;</span>)</div>
<div class="line"><span class="lineno"> 2089</span> </div>
<div class="line"><span class="lineno"> 2090</span>        <span class="keywordflow">return</span> self.sort_values(return_indexer=<span class="keyword">True</span>, ascending=ascending)</div>
<div class="line"><span class="lineno"> 2091</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a14fe656490ff335d108334eb8d1cde3c" name="a14fe656490ff335d108334eb8d1cde3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14fe656490ff335d108334eb8d1cde3c">&#9670;&#160;</a></span>symmetric_difference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>result_name</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Compute the symmetric difference of two Index objects.

Parameters
----------
other : Index or array-like
result_name : str
sort : False or None, default None
    Whether to sort the resulting index. By default, the
    values are attempted to be sorted, but any TypeError from
    incomparable elements is caught by pandas.

    * None : Attempt to sort the result, but catch any TypeErrors
      from comparing incomparable elements.
    * False : Do not sort the result.

Returns
-------
symmetric_difference : Index

Notes
-----
``symmetric_difference`` contains elements that appear in either
``idx1`` or ``idx2`` but not both. Equivalent to the Index created by
``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates
dropped.

Examples
--------
&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx2 = pd.Index([2, 3, 4, 5])
&gt;&gt;&gt; idx1.symmetric_difference(idx2)
Int64Index([1, 5], dtype='int64')
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#ab3fc1ba53622c37365d9772707a2e38a">pandas.core.indexes.range.RangeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3644</span>    <span class="keyword">def </span>symmetric_difference(self, other, result_name=None, sort=None):</div>
<div class="line"><span class="lineno"> 3645</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3646</span><span class="stringliteral">        Compute the symmetric difference of two Index objects.</span></div>
<div class="line"><span class="lineno"> 3647</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3648</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3649</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3650</span><span class="stringliteral">        other : Index or array-like</span></div>
<div class="line"><span class="lineno"> 3651</span><span class="stringliteral">        result_name : str</span></div>
<div class="line"><span class="lineno"> 3652</span><span class="stringliteral">        sort : False or None, default None</span></div>
<div class="line"><span class="lineno"> 3653</span><span class="stringliteral">            Whether to sort the resulting index. By default, the</span></div>
<div class="line"><span class="lineno"> 3654</span><span class="stringliteral">            values are attempted to be sorted, but any TypeError from</span></div>
<div class="line"><span class="lineno"> 3655</span><span class="stringliteral">            incomparable elements is caught by pandas.</span></div>
<div class="line"><span class="lineno"> 3656</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3657</span><span class="stringliteral">            * None : Attempt to sort the result, but catch any TypeErrors</span></div>
<div class="line"><span class="lineno"> 3658</span><span class="stringliteral">              from comparing incomparable elements.</span></div>
<div class="line"><span class="lineno"> 3659</span><span class="stringliteral">            * False : Do not sort the result.</span></div>
<div class="line"><span class="lineno"> 3660</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3661</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3662</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3663</span><span class="stringliteral">        symmetric_difference : Index</span></div>
<div class="line"><span class="lineno"> 3664</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3665</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno"> 3666</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno"> 3667</span><span class="stringliteral">        ``symmetric_difference`` contains elements that appear in either</span></div>
<div class="line"><span class="lineno"> 3668</span><span class="stringliteral">        ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by</span></div>
<div class="line"><span class="lineno"> 3669</span><span class="stringliteral">        ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates</span></div>
<div class="line"><span class="lineno"> 3670</span><span class="stringliteral">        dropped.</span></div>
<div class="line"><span class="lineno"> 3671</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3672</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3673</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3674</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 3675</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([2, 3, 4, 5])</span></div>
<div class="line"><span class="lineno"> 3676</span><span class="stringliteral">        &gt;&gt;&gt; idx1.symmetric_difference(idx2)</span></div>
<div class="line"><span class="lineno"> 3677</span><span class="stringliteral">        Int64Index([1, 5], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 3678</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3679</span>        self._validate_sort_keyword(sort)</div>
<div class="line"><span class="lineno"> 3680</span>        self._assert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3681</span>        other, result_name_update = self._convert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3682</span>        <span class="keywordflow">if</span> result_name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3683</span>            result_name = result_name_update</div>
<div class="line"><span class="lineno"> 3684</span> </div>
<div class="line"><span class="lineno"> 3685</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 3686</span>            self._deprecate_dti_setop(other, <span class="stringliteral">&quot;symmetric_difference&quot;</span>)</div>
<div class="line"><span class="lineno"> 3687</span> </div>
<div class="line"><span class="lineno"> 3688</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self._should_compare(other):</div>
<div class="line"><span class="lineno"> 3689</span>            <span class="keywordflow">return</span> self.union(other, sort=sort).rename(result_name)</div>
<div class="line"><span class="lineno"> 3690</span> </div>
<div class="line"><span class="lineno"> 3691</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 3692</span>            dtype = self._find_common_type_compat(other)</div>
<div class="line"><span class="lineno"> 3693</span>            this = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3694</span>            that = other.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3695</span>            <span class="keywordflow">return</span> this.symmetric_difference(that, sort=sort).rename(result_name)</div>
<div class="line"><span class="lineno"> 3696</span> </div>
<div class="line"><span class="lineno"> 3697</span>        this = self.unique()</div>
<div class="line"><span class="lineno"> 3698</span>        other = other.unique()</div>
<div class="line"><span class="lineno"> 3699</span>        indexer = this.get_indexer_for(other)</div>
<div class="line"><span class="lineno"> 3700</span> </div>
<div class="line"><span class="lineno"> 3701</span>        <span class="comment"># {this} minus {other}</span></div>
<div class="line"><span class="lineno"> 3702</span>        common_indexer = indexer.take((indexer != -1).nonzero()[0])</div>
<div class="line"><span class="lineno"> 3703</span>        left_indexer = np.setdiff1d(</div>
<div class="line"><span class="lineno"> 3704</span>            np.arange(this.size), common_indexer, assume_unique=<span class="keyword">True</span></div>
<div class="line"><span class="lineno"> 3705</span>        )</div>
<div class="line"><span class="lineno"> 3706</span>        left_diff = this._values.take(left_indexer)</div>
<div class="line"><span class="lineno"> 3707</span> </div>
<div class="line"><span class="lineno"> 3708</span>        <span class="comment"># {other} minus {this}</span></div>
<div class="line"><span class="lineno"> 3709</span>        right_indexer = (indexer == -1).nonzero()[0]</div>
<div class="line"><span class="lineno"> 3710</span>        right_diff = other._values.take(right_indexer)</div>
<div class="line"><span class="lineno"> 3711</span> </div>
<div class="line"><span class="lineno"> 3712</span>        res_values = concat_compat([left_diff, right_diff])</div>
<div class="line"><span class="lineno"> 3713</span>        res_values = _maybe_try_sort(res_values, sort)</div>
<div class="line"><span class="lineno"> 3714</span> </div>
<div class="line"><span class="lineno"> 3715</span>        <span class="comment"># pass dtype so we retain object dtype</span></div>
<div class="line"><span class="lineno"> 3716</span>        result = Index(res_values, name=result_name, dtype=res_values.dtype)</div>
<div class="line"><span class="lineno"> 3717</span> </div>
<div class="line"><span class="lineno"> 3718</span>        <span class="keywordflow">if</span> self._is_multi:</div>
<div class="line"><span class="lineno"> 3719</span>            self = cast(<span class="stringliteral">&quot;MultiIndex&quot;</span>, self)</div>
<div class="line"><span class="lineno"> 3720</span>            <span class="keywordflow">if</span> len(result) == 0:</div>
<div class="line"><span class="lineno"> 3721</span>                <span class="comment"># On equal symmetric_difference MultiIndexes the difference is empty.</span></div>
<div class="line"><span class="lineno"> 3722</span>                <span class="comment"># Therefore, an empty MultiIndex is returned GH#13490</span></div>
<div class="line"><span class="lineno"> 3723</span>                <span class="keywordflow">return</span> type(self)(</div>
<div class="line"><span class="lineno"> 3724</span>                    levels=[[] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(self.nlevels)],</div>
<div class="line"><span class="lineno"> 3725</span>                    codes=[[] <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(self.nlevels)],</div>
<div class="line"><span class="lineno"> 3726</span>                    names=result.name,</div>
<div class="line"><span class="lineno"> 3727</span>                )</div>
<div class="line"><span class="lineno"> 3728</span>            <span class="keywordflow">return</span> type(self).from_tuples(result, names=result.name)</div>
<div class="line"><span class="lineno"> 3729</span> </div>
<div class="line"><span class="lineno"> 3730</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 3731</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4acae5a2f01a74e5510fba2a0d958c58" name="a4acae5a2f01a74e5510fba2a0d958c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4acae5a2f01a74e5510fba2a0d958c58">&#9670;&#160;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.take </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &#160;</td>
          <td class="paramname"><em>axis</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>allow_fill</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fill_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a9d6bc121f64e0e36ce5fc02c0b054f99">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#ae2dc7652c1f2ba1c0662da0b9bc25ef1">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1172</span>    ):</div>
<div class="line"><span class="lineno"> 1173</span>        <span class="keywordflow">if</span> kwargs:</div>
<div class="line"><span class="lineno"> 1174</span>            nv.validate_take((), kwargs)</div>
<div class="line"><span class="lineno"> 1175</span>        <span class="keywordflow">if</span> is_scalar(indices):</div>
<div class="line"><span class="lineno"> 1176</span>            <span class="keywordflow">raise</span> TypeError(<span class="stringliteral">&quot;Expected indices to be array-like&quot;</span>)</div>
<div class="line"><span class="lineno"> 1177</span>        indices = ensure_platform_int(indices)</div>
<div class="line"><span class="lineno"> 1178</span>        allow_fill = self._maybe_disallow_fill(allow_fill, fill_value, indices)</div>
<div class="line"><span class="lineno"> 1179</span> </div>
<div class="line"><span class="lineno"> 1180</span>        <span class="comment"># Note: we discard fill_value and use self._na_value, only relevant</span></div>
<div class="line"><span class="lineno"> 1181</span>        <span class="comment">#  in the case where allow_fill is True and fill_value is not None</span></div>
<div class="line"><span class="lineno"> 1182</span>        values = self._values</div>
<div class="line"><span class="lineno"> 1183</span>        <span class="keywordflow">if</span> isinstance(values, np.ndarray):</div>
<div class="line"><span class="lineno"> 1184</span>            taken = algos.take(</div>
<div class="line"><span class="lineno"> 1185</span>                values, indices, allow_fill=allow_fill, fill_value=self._na_value</div>
<div class="line"><span class="lineno"> 1186</span>            )</div>
<div class="line"><span class="lineno"> 1187</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1188</span>            <span class="comment"># algos.take passes &#39;axis&#39; keyword which not all EAs accept</span></div>
<div class="line"><span class="lineno"> 1189</span>            taken = values.take(</div>
<div class="line"><span class="lineno"> 1190</span>                indices, allow_fill=allow_fill, fill_value=self._na_value</div>
<div class="line"><span class="lineno"> 1191</span>            )</div>
<div class="line"><span class="lineno"> 1192</span>        <span class="comment"># _constructor so RangeIndex-&gt;Int64Index</span></div>
<div class="line"><span class="lineno"> 1193</span>        <span class="keywordflow">return</span> self._constructor._simple_new(taken, name=self.name)</div>
<div class="line"><span class="lineno"> 1194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0114ff045cc2d8a50f2394e1162f11c6" name="a0114ff045cc2d8a50f2394e1162f11c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0114ff045cc2d8a50f2394e1162f11c6">&#9670;&#160;</a></span>to_flat_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.to_flat_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Identity method.

This is implemented for compatibility with subclass implementations
when chaining.

Returns
-------
pd.Index
    Caller.

See Also
--------
MultiIndex.to_flat_index : Subclass implementation.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a410e956d736f5ba47764a2b45b61a3ce">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1579</span>    <span class="keyword">def </span>to_flat_index(self: _IndexT) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 1580</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1581</span><span class="stringliteral">        Identity method.</span></div>
<div class="line"><span class="lineno"> 1582</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1583</span><span class="stringliteral">        This is implemented for compatibility with subclass implementations</span></div>
<div class="line"><span class="lineno"> 1584</span><span class="stringliteral">        when chaining.</span></div>
<div class="line"><span class="lineno"> 1585</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1586</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1587</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1588</span><span class="stringliteral">        pd.Index</span></div>
<div class="line"><span class="lineno"> 1589</span><span class="stringliteral">            Caller.</span></div>
<div class="line"><span class="lineno"> 1590</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1591</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1592</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1593</span><span class="stringliteral">        MultiIndex.to_flat_index : Subclass implementation.</span></div>
<div class="line"><span class="lineno"> 1594</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1595</span>        <span class="keywordflow">return</span> self</div>
<div class="line"><span class="lineno"> 1596</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a54d82e4535ac4015c47bfde741f81c36" name="a54d82e4535ac4015c47bfde741f81c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d82e4535ac4015c47bfde741f81c36">&#9670;&#160;</a></span>to_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> DataFrame pandas.core.indexes.base.Index.to_frame </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &#160;</td>
          <td class="paramname"><em>index</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>lib.no_default</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a DataFrame with a column containing the Index.

Parameters
----------
index : bool, default True
    Set the index of the returned DataFrame as the original Index.

name : object, default None
    The passed name should substitute for the index name (if it has
    one).

Returns
-------
DataFrame
    DataFrame containing the original Index data.

See Also
--------
Index.to_series : Convert an Index to a Series.
Series.to_frame : Convert Series to DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')
&gt;&gt;&gt; idx.to_frame()
       animal
animal
Ant       Ant
Bear     Bear
Cow       Cow

By default, the original Index is reused. To enforce a new Index:

&gt;&gt;&gt; idx.to_frame(index=False)
    animal
0   Ant
1  Bear
2   Cow

To override the name of the resulting column, specify `name`:

&gt;&gt;&gt; idx.to_frame(index=False, name='zoo')
    zoo
0   Ant
1  Bear
2   Cow
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#aa0dd51a4387d687a5673fb95a2359769">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1662</span>    ) -&gt; DataFrame:</div>
<div class="line"><span class="lineno"> 1663</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1664</span><span class="stringliteral">        Create a DataFrame with a column containing the Index.</span></div>
<div class="line"><span class="lineno"> 1665</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1666</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1667</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1668</span><span class="stringliteral">        index : bool, default True</span></div>
<div class="line"><span class="lineno"> 1669</span><span class="stringliteral">            Set the index of the returned DataFrame as the original Index.</span></div>
<div class="line"><span class="lineno"> 1670</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1671</span><span class="stringliteral">        name : object, default None</span></div>
<div class="line"><span class="lineno"> 1672</span><span class="stringliteral">            The passed name should substitute for the index name (if it has</span></div>
<div class="line"><span class="lineno"> 1673</span><span class="stringliteral">            one).</span></div>
<div class="line"><span class="lineno"> 1674</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1675</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1676</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1677</span><span class="stringliteral">        DataFrame</span></div>
<div class="line"><span class="lineno"> 1678</span><span class="stringliteral">            DataFrame containing the original Index data.</span></div>
<div class="line"><span class="lineno"> 1679</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1680</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1681</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1682</span><span class="stringliteral">        Index.to_series : Convert an Index to a Series.</span></div>
<div class="line"><span class="lineno"> 1683</span><span class="stringliteral">        Series.to_frame : Convert Series to DataFrame.</span></div>
<div class="line"><span class="lineno"> 1684</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1685</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1686</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1687</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;Ant&#39;, &#39;Bear&#39;, &#39;Cow&#39;], name=&#39;animal&#39;)</span></div>
<div class="line"><span class="lineno"> 1688</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_frame()</span></div>
<div class="line"><span class="lineno"> 1689</span><span class="stringliteral">               animal</span></div>
<div class="line"><span class="lineno"> 1690</span><span class="stringliteral">        animal</span></div>
<div class="line"><span class="lineno"> 1691</span><span class="stringliteral">        Ant       Ant</span></div>
<div class="line"><span class="lineno"> 1692</span><span class="stringliteral">        Bear     Bear</span></div>
<div class="line"><span class="lineno"> 1693</span><span class="stringliteral">        Cow       Cow</span></div>
<div class="line"><span class="lineno"> 1694</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1695</span><span class="stringliteral">        By default, the original Index is reused. To enforce a new Index:</span></div>
<div class="line"><span class="lineno"> 1696</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1697</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_frame(index=False)</span></div>
<div class="line"><span class="lineno"> 1698</span><span class="stringliteral">            animal</span></div>
<div class="line"><span class="lineno"> 1699</span><span class="stringliteral">        0   Ant</span></div>
<div class="line"><span class="lineno"> 1700</span><span class="stringliteral">        1  Bear</span></div>
<div class="line"><span class="lineno"> 1701</span><span class="stringliteral">        2   Cow</span></div>
<div class="line"><span class="lineno"> 1702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1703</span><span class="stringliteral">        To override the name of the resulting column, specify `name`:</span></div>
<div class="line"><span class="lineno"> 1704</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1705</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_frame(index=False, name=&#39;zoo&#39;)</span></div>
<div class="line"><span class="lineno"> 1706</span><span class="stringliteral">            zoo</span></div>
<div class="line"><span class="lineno"> 1707</span><span class="stringliteral">        0   Ant</span></div>
<div class="line"><span class="lineno"> 1708</span><span class="stringliteral">        1  Bear</span></div>
<div class="line"><span class="lineno"> 1709</span><span class="stringliteral">        2   Cow</span></div>
<div class="line"><span class="lineno"> 1710</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1711</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> DataFrame</div>
<div class="line"><span class="lineno"> 1712</span> </div>
<div class="line"><span class="lineno"> 1713</span>        <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1714</span>            warnings.warn(</div>
<div class="line"><span class="lineno"> 1715</span>                <span class="stringliteral">&quot;Explicitly passing `name=None` currently preserves the Index&#39;s name &quot;</span></div>
<div class="line"><span class="lineno"> 1716</span>                <span class="stringliteral">&quot;or uses a default name of 0. This behaviour is deprecated, and in &quot;</span></div>
<div class="line"><span class="lineno"> 1717</span>                <span class="stringliteral">&quot;the future `None` will be used as the name of the resulting &quot;</span></div>
<div class="line"><span class="lineno"> 1718</span>                <span class="stringliteral">&quot;DataFrame column.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1719</span>                FutureWarning,</div>
<div class="line"><span class="lineno"> 1720</span>                stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1721</span>            )</div>
<div class="line"><span class="lineno"> 1722</span>            name = lib.no_default</div>
<div class="line"><span class="lineno"> 1723</span> </div>
<div class="line"><span class="lineno"> 1724</span>        <span class="keywordflow">if</span> name <span class="keywordflow">is</span> lib.no_default:</div>
<div class="line"><span class="lineno"> 1725</span>            name = self._get_level_names()</div>
<div class="line"><span class="lineno"> 1726</span>        result = DataFrame({name: self._values.copy()})</div>
<div class="line"><span class="lineno"> 1727</span> </div>
<div class="line"><span class="lineno"> 1728</span>        <span class="keywordflow">if</span> index:</div>
<div class="line"><span class="lineno"> 1729</span>            result.index = self</div>
<div class="line"><span class="lineno"> 1730</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1731</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a510319047221a98c0711ab2c7143d3a5" name="a510319047221a98c0711ab2c7143d3a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510319047221a98c0711ab2c7143d3a5">&#9670;&#160;</a></span>to_native_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> np.ndarray pandas.core.indexes.base.Index.to_native_types </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slicer</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Format specified values of `self` and return them.

.. deprecated:: 1.2.0

Parameters
----------
slicer : int, array-like
    An indexer into `self` that specifies which values
    are used in the formatting process.
kwargs : dict
    Options for specifying how the values should be formatted.
    These options include the following:

    1) na_rep : str
        The value that serves as a placeholder for NULL values
    2) quoting : bool or None
        Whether or not there are quoted values in `self`
    3) date_format : str
        The format used to represent date-like values.

Returns
-------
numpy.ndarray
    Formatted values.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1488</span>    <span class="keyword">def </span>to_native_types(self, slicer=None, **kwargs) -&gt; np.ndarray:</div>
<div class="line"><span class="lineno"> 1489</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1490</span><span class="stringliteral">        Format specified values of `self` and return them.</span></div>
<div class="line"><span class="lineno"> 1491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1492</span><span class="stringliteral">        .. deprecated:: 1.2.0</span></div>
<div class="line"><span class="lineno"> 1493</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1494</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1495</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1496</span><span class="stringliteral">        slicer : int, array-like</span></div>
<div class="line"><span class="lineno"> 1497</span><span class="stringliteral">            An indexer into `self` that specifies which values</span></div>
<div class="line"><span class="lineno"> 1498</span><span class="stringliteral">            are used in the formatting process.</span></div>
<div class="line"><span class="lineno"> 1499</span><span class="stringliteral">        kwargs : dict</span></div>
<div class="line"><span class="lineno"> 1500</span><span class="stringliteral">            Options for specifying how the values should be formatted.</span></div>
<div class="line"><span class="lineno"> 1501</span><span class="stringliteral">            These options include the following:</span></div>
<div class="line"><span class="lineno"> 1502</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1503</span><span class="stringliteral">            1) na_rep : str</span></div>
<div class="line"><span class="lineno"> 1504</span><span class="stringliteral">                The value that serves as a placeholder for NULL values</span></div>
<div class="line"><span class="lineno"> 1505</span><span class="stringliteral">            2) quoting : bool or None</span></div>
<div class="line"><span class="lineno"> 1506</span><span class="stringliteral">                Whether or not there are quoted values in `self`</span></div>
<div class="line"><span class="lineno"> 1507</span><span class="stringliteral">            3) date_format : str</span></div>
<div class="line"><span class="lineno"> 1508</span><span class="stringliteral">                The format used to represent date-like values.</span></div>
<div class="line"><span class="lineno"> 1509</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1510</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1511</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1512</span><span class="stringliteral">        numpy.ndarray</span></div>
<div class="line"><span class="lineno"> 1513</span><span class="stringliteral">            Formatted values.</span></div>
<div class="line"><span class="lineno"> 1514</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1515</span>        warnings.warn(</div>
<div class="line"><span class="lineno"> 1516</span>            <span class="stringliteral">&quot;The &#39;to_native_types&#39; method is deprecated and will be removed in &quot;</span></div>
<div class="line"><span class="lineno"> 1517</span>            <span class="stringliteral">&quot;a future version. Use &#39;astype(str)&#39; instead.&quot;</span>,</div>
<div class="line"><span class="lineno"> 1518</span>            FutureWarning,</div>
<div class="line"><span class="lineno"> 1519</span>            stacklevel=find_stack_level(),</div>
<div class="line"><span class="lineno"> 1520</span>        )</div>
<div class="line"><span class="lineno"> 1521</span>        values = self</div>
<div class="line"><span class="lineno"> 1522</span>        <span class="keywordflow">if</span> slicer <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1523</span>            values = values[slicer]</div>
<div class="line"><span class="lineno"> 1524</span>        <span class="keywordflow">return</span> values._format_native_types(**kwargs)</div>
<div class="line"><span class="lineno"> 1525</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae71c5a6568f71daad5207d82f6a4ae24" name="ae71c5a6568f71daad5207d82f6a4ae24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71c5a6568f71daad5207d82f6a4ae24">&#9670;&#160;</a></span>to_series()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Series pandas.core.indexes.base.Index.to_series </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable &#160;</td>
          <td class="paramname"><em>name</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a Series with both index and values equal to the index keys.

Useful with map for returning an indexer based on an index.

Parameters
----------
index : Index, optional
    Index of resulting Series. If None, defaults to original index.
name : str, optional
    Name of resulting Series. If None, defaults to name of original
    index.

Returns
-------
Series
    The dtype will be based on the type of the Index values.

See Also
--------
Index.to_frame : Convert an Index to a DataFrame.
Series.to_frame : Convert Series to DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')

By default, the original Index and original name is reused.

&gt;&gt;&gt; idx.to_series()
animal
Ant      Ant
Bear    Bear
Cow      Cow
Name: animal, dtype: object

To enforce a new Index, specify new labels to ``index``:

&gt;&gt;&gt; idx.to_series(index=[0, 1, 2])
0     Ant
1    Bear
2     Cow
Name: animal, dtype: object

To override the name of the resulting column, specify `name`:

&gt;&gt;&gt; idx.to_series(name='zoo')
animal
Ant      Ant
Bear    Bear
Cow      Cow
Name: zoo, dtype: object
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a69999f8b3159d5f5e15e12960ee2feb6">pandas.core.indexes.datetimes.DatetimeIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1597</span>    <span class="keyword">def </span>to_series(self, index=None, name: Hashable = <span class="keywordtype">None</span>) -&gt; Series:</div>
<div class="line"><span class="lineno"> 1598</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1599</span><span class="stringliteral">        Create a Series with both index and values equal to the index keys.</span></div>
<div class="line"><span class="lineno"> 1600</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1601</span><span class="stringliteral">        Useful with map for returning an indexer based on an index.</span></div>
<div class="line"><span class="lineno"> 1602</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1603</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1604</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1605</span><span class="stringliteral">        index : Index, optional</span></div>
<div class="line"><span class="lineno"> 1606</span><span class="stringliteral">            Index of resulting Series. If None, defaults to original index.</span></div>
<div class="line"><span class="lineno"> 1607</span><span class="stringliteral">        name : str, optional</span></div>
<div class="line"><span class="lineno"> 1608</span><span class="stringliteral">            Name of resulting Series. If None, defaults to name of original</span></div>
<div class="line"><span class="lineno"> 1609</span><span class="stringliteral">            index.</span></div>
<div class="line"><span class="lineno"> 1610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1611</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 1612</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 1613</span><span class="stringliteral">        Series</span></div>
<div class="line"><span class="lineno"> 1614</span><span class="stringliteral">            The dtype will be based on the type of the Index values.</span></div>
<div class="line"><span class="lineno"> 1615</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1616</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 1617</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1618</span><span class="stringliteral">        Index.to_frame : Convert an Index to a DataFrame.</span></div>
<div class="line"><span class="lineno"> 1619</span><span class="stringliteral">        Series.to_frame : Convert Series to DataFrame.</span></div>
<div class="line"><span class="lineno"> 1620</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1621</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 1622</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 1623</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;Ant&#39;, &#39;Bear&#39;, &#39;Cow&#39;], name=&#39;animal&#39;)</span></div>
<div class="line"><span class="lineno"> 1624</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1625</span><span class="stringliteral">        By default, the original Index and original name is reused.</span></div>
<div class="line"><span class="lineno"> 1626</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1627</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_series()</span></div>
<div class="line"><span class="lineno"> 1628</span><span class="stringliteral">        animal</span></div>
<div class="line"><span class="lineno"> 1629</span><span class="stringliteral">        Ant      Ant</span></div>
<div class="line"><span class="lineno"> 1630</span><span class="stringliteral">        Bear    Bear</span></div>
<div class="line"><span class="lineno"> 1631</span><span class="stringliteral">        Cow      Cow</span></div>
<div class="line"><span class="lineno"> 1632</span><span class="stringliteral">        Name: animal, dtype: object</span></div>
<div class="line"><span class="lineno"> 1633</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1634</span><span class="stringliteral">        To enforce a new Index, specify new labels to ``index``:</span></div>
<div class="line"><span class="lineno"> 1635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1636</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_series(index=[0, 1, 2])</span></div>
<div class="line"><span class="lineno"> 1637</span><span class="stringliteral">        0     Ant</span></div>
<div class="line"><span class="lineno"> 1638</span><span class="stringliteral">        1    Bear</span></div>
<div class="line"><span class="lineno"> 1639</span><span class="stringliteral">        2     Cow</span></div>
<div class="line"><span class="lineno"> 1640</span><span class="stringliteral">        Name: animal, dtype: object</span></div>
<div class="line"><span class="lineno"> 1641</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1642</span><span class="stringliteral">        To override the name of the resulting column, specify `name`:</span></div>
<div class="line"><span class="lineno"> 1643</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1644</span><span class="stringliteral">        &gt;&gt;&gt; idx.to_series(name=&#39;zoo&#39;)</span></div>
<div class="line"><span class="lineno"> 1645</span><span class="stringliteral">        animal</span></div>
<div class="line"><span class="lineno"> 1646</span><span class="stringliteral">        Ant      Ant</span></div>
<div class="line"><span class="lineno"> 1647</span><span class="stringliteral">        Bear    Bear</span></div>
<div class="line"><span class="lineno"> 1648</span><span class="stringliteral">        Cow      Cow</span></div>
<div class="line"><span class="lineno"> 1649</span><span class="stringliteral">        Name: zoo, dtype: object</span></div>
<div class="line"><span class="lineno"> 1650</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1651</span>        <span class="keyword">from</span> pandas <span class="keyword">import</span> Series</div>
<div class="line"><span class="lineno"> 1652</span> </div>
<div class="line"><span class="lineno"> 1653</span>        <span class="keywordflow">if</span> index <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1654</span>            index = self._view()</div>
<div class="line"><span class="lineno"> 1655</span>        <span class="keywordflow">if</span> name <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 1656</span>            name = self.name</div>
<div class="line"><span class="lineno"> 1657</span> </div>
<div class="line"><span class="lineno"> 1658</span>        <span class="keywordflow">return</span> Series(self._values.copy(), index=index, name=name)</div>
<div class="line"><span class="lineno"> 1659</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af18c8c90884dde0f8aa296919c0ebfa6" name="af18c8c90884dde0f8aa296919c0ebfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18c8c90884dde0f8aa296919c0ebfa6">&#9670;&#160;</a></span>union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.union </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sort</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Form the union of two Index objects.

If the Index objects are incompatible, both Index objects will be
cast to dtype('object') first.

    .. versionchanged:: 0.25.0

Parameters
----------
other : Index or array-like
sort : bool or None, default None
    Whether to sort the resulting Index.

    * None : Sort the result, except when

      1. `self` and `other` are equal.
      2. `self` or `other` has length 0.
      3. Some values in `self` or `other` cannot be compared.
         A RuntimeWarning is issued in this case.

    * False : do not sort the result.

Returns
-------
union : Index

Examples
--------
Union matching dtypes

&gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])
&gt;&gt;&gt; idx1.union(idx2)
Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')

Union mismatched dtypes

&gt;&gt;&gt; idx1 = pd.Index(['a', 'b', 'c', 'd'])
&gt;&gt;&gt; idx2 = pd.Index([1, 2, 3, 4])
&gt;&gt;&gt; idx1.union(idx2)
Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')

MultiIndex case

&gt;&gt;&gt; idx1 = pd.MultiIndex.from_arrays(
...     [[1, 1, 2, 2], ["Red", "Blue", "Red", "Blue"]]
... )
&gt;&gt;&gt; idx1
MultiIndex([(1,  'Red'),
    (1, 'Blue'),
    (2,  'Red'),
    (2, 'Blue')],
   )
&gt;&gt;&gt; idx2 = pd.MultiIndex.from_arrays(
...     [[3, 3, 2, 2], ["Red", "Green", "Red", "Green"]]
... )
&gt;&gt;&gt; idx2
MultiIndex([(3,   'Red'),
    (3, 'Green'),
    (2,   'Red'),
    (2, 'Green')],
   )
&gt;&gt;&gt; idx1.union(idx2)
MultiIndex([(1,  'Blue'),
    (1,   'Red'),
    (2,  'Blue'),
    (2, 'Green'),
    (2,   'Red'),
    (3, 'Green'),
    (3,   'Red')],
   )
&gt;&gt;&gt; idx1.union(idx2, sort=False)
MultiIndex([(1,   'Red'),
    (1,  'Blue'),
    (2,   'Red'),
    (2,  'Blue'),
    (3,   'Red'),
    (3, 'Green'),
    (2, 'Green')],
   )
</pre> <div class="fragment"><div class="line"><span class="lineno"> 3243</span>    <span class="keyword">def </span>union(self, other, sort=None):</div>
<div class="line"><span class="lineno"> 3244</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3245</span><span class="stringliteral">        Form the union of two Index objects.</span></div>
<div class="line"><span class="lineno"> 3246</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3247</span><span class="stringliteral">        If the Index objects are incompatible, both Index objects will be</span></div>
<div class="line"><span class="lineno"> 3248</span><span class="stringliteral">        cast to dtype(&#39;object&#39;) first.</span></div>
<div class="line"><span class="lineno"> 3249</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3250</span><span class="stringliteral">            .. versionchanged:: 0.25.0</span></div>
<div class="line"><span class="lineno"> 3251</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3252</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3253</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3254</span><span class="stringliteral">        other : Index or array-like</span></div>
<div class="line"><span class="lineno"> 3255</span><span class="stringliteral">        sort : bool or None, default None</span></div>
<div class="line"><span class="lineno"> 3256</span><span class="stringliteral">            Whether to sort the resulting Index.</span></div>
<div class="line"><span class="lineno"> 3257</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3258</span><span class="stringliteral">            * None : Sort the result, except when</span></div>
<div class="line"><span class="lineno"> 3259</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3260</span><span class="stringliteral">              1. `self` and `other` are equal.</span></div>
<div class="line"><span class="lineno"> 3261</span><span class="stringliteral">              2. `self` or `other` has length 0.</span></div>
<div class="line"><span class="lineno"> 3262</span><span class="stringliteral">              3. Some values in `self` or `other` cannot be compared.</span></div>
<div class="line"><span class="lineno"> 3263</span><span class="stringliteral">                 A RuntimeWarning is issued in this case.</span></div>
<div class="line"><span class="lineno"> 3264</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3265</span><span class="stringliteral">            * False : do not sort the result.</span></div>
<div class="line"><span class="lineno"> 3266</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3267</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3268</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3269</span><span class="stringliteral">        union : Index</span></div>
<div class="line"><span class="lineno"> 3270</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3271</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 3272</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3273</span><span class="stringliteral">        Union matching dtypes</span></div>
<div class="line"><span class="lineno"> 3274</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3275</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 3276</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([3, 4, 5, 6])</span></div>
<div class="line"><span class="lineno"> 3277</span><span class="stringliteral">        &gt;&gt;&gt; idx1.union(idx2)</span></div>
<div class="line"><span class="lineno"> 3278</span><span class="stringliteral">        Int64Index([1, 2, 3, 4, 5, 6], dtype=&#39;int64&#39;)</span></div>
<div class="line"><span class="lineno"> 3279</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3280</span><span class="stringliteral">        Union mismatched dtypes</span></div>
<div class="line"><span class="lineno"> 3281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3282</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span></div>
<div class="line"><span class="lineno"> 3283</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.Index([1, 2, 3, 4])</span></div>
<div class="line"><span class="lineno"> 3284</span><span class="stringliteral">        &gt;&gt;&gt; idx1.union(idx2)</span></div>
<div class="line"><span class="lineno"> 3285</span><span class="stringliteral">        Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, 1, 2, 3, 4], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 3286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3287</span><span class="stringliteral">        MultiIndex case</span></div>
<div class="line"><span class="lineno"> 3288</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3289</span><span class="stringliteral">        &gt;&gt;&gt; idx1 = pd.MultiIndex.from_arrays(</span></div>
<div class="line"><span class="lineno"> 3290</span><span class="stringliteral">        ...     [[1, 1, 2, 2], [&quot;Red&quot;, &quot;Blue&quot;, &quot;Red&quot;, &quot;Blue&quot;]]</span></div>
<div class="line"><span class="lineno"> 3291</span><span class="stringliteral">        ... )</span></div>
<div class="line"><span class="lineno"> 3292</span><span class="stringliteral">        &gt;&gt;&gt; idx1</span></div>
<div class="line"><span class="lineno"> 3293</span><span class="stringliteral">        MultiIndex([(1,  &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3294</span><span class="stringliteral">            (1, &#39;Blue&#39;),</span></div>
<div class="line"><span class="lineno"> 3295</span><span class="stringliteral">            (2,  &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3296</span><span class="stringliteral">            (2, &#39;Blue&#39;)],</span></div>
<div class="line"><span class="lineno"> 3297</span><span class="stringliteral">           )</span></div>
<div class="line"><span class="lineno"> 3298</span><span class="stringliteral">        &gt;&gt;&gt; idx2 = pd.MultiIndex.from_arrays(</span></div>
<div class="line"><span class="lineno"> 3299</span><span class="stringliteral">        ...     [[3, 3, 2, 2], [&quot;Red&quot;, &quot;Green&quot;, &quot;Red&quot;, &quot;Green&quot;]]</span></div>
<div class="line"><span class="lineno"> 3300</span><span class="stringliteral">        ... )</span></div>
<div class="line"><span class="lineno"> 3301</span><span class="stringliteral">        &gt;&gt;&gt; idx2</span></div>
<div class="line"><span class="lineno"> 3302</span><span class="stringliteral">        MultiIndex([(3,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3303</span><span class="stringliteral">            (3, &#39;Green&#39;),</span></div>
<div class="line"><span class="lineno"> 3304</span><span class="stringliteral">            (2,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3305</span><span class="stringliteral">            (2, &#39;Green&#39;)],</span></div>
<div class="line"><span class="lineno"> 3306</span><span class="stringliteral">           )</span></div>
<div class="line"><span class="lineno"> 3307</span><span class="stringliteral">        &gt;&gt;&gt; idx1.union(idx2)</span></div>
<div class="line"><span class="lineno"> 3308</span><span class="stringliteral">        MultiIndex([(1,  &#39;Blue&#39;),</span></div>
<div class="line"><span class="lineno"> 3309</span><span class="stringliteral">            (1,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3310</span><span class="stringliteral">            (2,  &#39;Blue&#39;),</span></div>
<div class="line"><span class="lineno"> 3311</span><span class="stringliteral">            (2, &#39;Green&#39;),</span></div>
<div class="line"><span class="lineno"> 3312</span><span class="stringliteral">            (2,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3313</span><span class="stringliteral">            (3, &#39;Green&#39;),</span></div>
<div class="line"><span class="lineno"> 3314</span><span class="stringliteral">            (3,   &#39;Red&#39;)],</span></div>
<div class="line"><span class="lineno"> 3315</span><span class="stringliteral">           )</span></div>
<div class="line"><span class="lineno"> 3316</span><span class="stringliteral">        &gt;&gt;&gt; idx1.union(idx2, sort=False)</span></div>
<div class="line"><span class="lineno"> 3317</span><span class="stringliteral">        MultiIndex([(1,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3318</span><span class="stringliteral">            (1,  &#39;Blue&#39;),</span></div>
<div class="line"><span class="lineno"> 3319</span><span class="stringliteral">            (2,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3320</span><span class="stringliteral">            (2,  &#39;Blue&#39;),</span></div>
<div class="line"><span class="lineno"> 3321</span><span class="stringliteral">            (3,   &#39;Red&#39;),</span></div>
<div class="line"><span class="lineno"> 3322</span><span class="stringliteral">            (3, &#39;Green&#39;),</span></div>
<div class="line"><span class="lineno"> 3323</span><span class="stringliteral">            (2, &#39;Green&#39;)],</span></div>
<div class="line"><span class="lineno"> 3324</span><span class="stringliteral">           )</span></div>
<div class="line"><span class="lineno"> 3325</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3326</span>        self._validate_sort_keyword(sort)</div>
<div class="line"><span class="lineno"> 3327</span>        self._assert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3328</span>        other, result_name = self._convert_can_do_setop(other)</div>
<div class="line"><span class="lineno"> 3329</span> </div>
<div class="line"><span class="lineno"> 3330</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> is_dtype_equal(self.dtype, other.dtype):</div>
<div class="line"><span class="lineno"> 3331</span>            <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno"> 3332</span>                isinstance(self, ABCMultiIndex)</div>
<div class="line"><span class="lineno"> 3333</span>                <span class="keywordflow">and</span> <span class="keywordflow">not</span> is_object_dtype(unpack_nested_dtype(other))</div>
<div class="line"><span class="lineno"> 3334</span>                <span class="keywordflow">and</span> len(other) &gt; 0</div>
<div class="line"><span class="lineno"> 3335</span>            ):</div>
<div class="line"><span class="lineno"> 3336</span>                <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 3337</span>                    <span class="stringliteral">&quot;Can only union MultiIndex with MultiIndex or Index of tuples, &quot;</span></div>
<div class="line"><span class="lineno"> 3338</span>                    <span class="stringliteral">&quot;try mi.to_flat_index().union(other) instead.&quot;</span></div>
<div class="line"><span class="lineno"> 3339</span>                )</div>
<div class="line"><span class="lineno"> 3340</span>            self._deprecate_dti_setop(other, <span class="stringliteral">&quot;union&quot;</span>)</div>
<div class="line"><span class="lineno"> 3341</span> </div>
<div class="line"><span class="lineno"> 3342</span>            dtype = self._find_common_type_compat(other)</div>
<div class="line"><span class="lineno"> 3343</span>            left = self.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3344</span>            right = other.astype(dtype, copy=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno"> 3345</span>            <span class="keywordflow">return</span> left.union(right, sort=sort)</div>
<div class="line"><span class="lineno"> 3346</span> </div>
<div class="line"><span class="lineno"> 3347</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> len(other) <span class="keywordflow">or</span> self.equals(other):</div>
<div class="line"><span class="lineno"> 3348</span>            <span class="comment"># NB: whether this (and the `if not len(self)` check below) come before</span></div>
<div class="line"><span class="lineno"> 3349</span>            <span class="comment">#  or after the is_dtype_equal check above affects the returned dtype</span></div>
<div class="line"><span class="lineno"> 3350</span>            <span class="keywordflow">return</span> self._get_reconciled_name_object(other)</div>
<div class="line"><span class="lineno"> 3351</span> </div>
<div class="line"><span class="lineno"> 3352</span>        <span class="keywordflow">elif</span> <span class="keywordflow">not</span> len(self):</div>
<div class="line"><span class="lineno"> 3353</span>            <span class="keywordflow">return</span> other._get_reconciled_name_object(self)</div>
<div class="line"><span class="lineno"> 3354</span> </div>
<div class="line"><span class="lineno"> 3355</span>        result = self._union(other, sort=sort)</div>
<div class="line"><span class="lineno"> 3356</span> </div>
<div class="line"><span class="lineno"> 3357</span>        <span class="keywordflow">return</span> self._wrap_setop_result(other, result)</div>
<div class="line"><span class="lineno"> 3358</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f22b33fc0d79997f4625ff43718ec0c" name="a2f22b33fc0d79997f4625ff43718ec0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f22b33fc0d79997f4625ff43718ec0c">&#9670;&#160;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a> pandas.core.indexes.base.Index.unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepandas_1_1core_1_1indexes_1_1base.html#ad18ae3ece0aa5d2a00494c97feb74576">_IndexT</a>&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Hashable | None &#160;</td>
          <td class="paramname"><em>level</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return unique values in the index.

Unique values are returned in order of appearance, this does NOT sort.

Parameters
----------
level : int or hashable, optional
    Only return values from specified level (for MultiIndex).
    If int, gets the level by integer position, else by level name.

Returns
-------
Index

See Also
--------
unique : Numpy array of unique values in that column.
Series.unique : Return unique values of Series object.
</pre> 
<p>Reimplemented from <a class="el" href="classpandas_1_1core_1_1base_1_1_index_ops_mixin.html#a3cd4b635228ad3251902f98a5365fbff">pandas.core.base.IndexOpsMixin</a>.</p>

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ae61a80908267a0eaf218089d97615366">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 3004</span>    <span class="keyword">def </span>unique(self: _IndexT, level: Hashable | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>) -&gt; _IndexT:</div>
<div class="line"><span class="lineno"> 3005</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3006</span><span class="stringliteral">        Return unique values in the index.</span></div>
<div class="line"><span class="lineno"> 3007</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3008</span><span class="stringliteral">        Unique values are returned in order of appearance, this does NOT sort.</span></div>
<div class="line"><span class="lineno"> 3009</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3010</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 3011</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 3012</span><span class="stringliteral">        level : int or hashable, optional</span></div>
<div class="line"><span class="lineno"> 3013</span><span class="stringliteral">            Only return values from specified level (for MultiIndex).</span></div>
<div class="line"><span class="lineno"> 3014</span><span class="stringliteral">            If int, gets the level by integer position, else by level name.</span></div>
<div class="line"><span class="lineno"> 3015</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3016</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 3017</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 3018</span><span class="stringliteral">        Index</span></div>
<div class="line"><span class="lineno"> 3019</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 3020</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 3021</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 3022</span><span class="stringliteral">        unique : Numpy array of unique values in that column.</span></div>
<div class="line"><span class="lineno"> 3023</span><span class="stringliteral">        Series.unique : Return unique values of Series object.</span></div>
<div class="line"><span class="lineno"> 3024</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 3025</span>        <span class="keywordflow">if</span> level <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno"> 3026</span>            self._validate_index_level(level)</div>
<div class="line"><span class="lineno"> 3027</span> </div>
<div class="line"><span class="lineno"> 3028</span>        <span class="keywordflow">if</span> self.is_unique:</div>
<div class="line"><span class="lineno"> 3029</span>            <span class="keywordflow">return</span> self._view()</div>
<div class="line"><span class="lineno"> 3030</span> </div>
<div class="line"><span class="lineno"> 3031</span>        result = super().unique()</div>
<div class="line"><span class="lineno"> 3032</span>        <span class="keywordflow">return</span> self._shallow_copy(result)</div>
<div class="line"><span class="lineno"> 3033</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a80b355d17e64e3584619d1a87c6689d6" name="a80b355d17e64e3584619d1a87c6689d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b355d17e64e3584619d1a87c6689d6">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.indexes.base.Index.values </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an array representing the data in the Index.

.. warning::

   We recommend using :attr:`Index.array` or
   :meth:`Index.to_numpy`, depending on whether you need
   a reference to the underlying data or a NumPy array.

Returns
-------
array: numpy.ndarray or ExtensionArray

See Also
--------
Index.array : Reference to the underlying data.
Index.to_numpy : A NumPy array representing the underlying data.
</pre> 
<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#ae68485e7ec16dc9ea5aac769ab8c5751">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ae09c97798114b3138c2b3cb03efd2ed6">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a402f14c8df3cd9ba57d7ac8f8e4223d6">pandas.core.indexes.period.PeriodIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 5100</span>    <span class="keyword">def </span>values(self) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno"> 5101</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5102</span><span class="stringliteral">        Return an array representing the data in the Index.</span></div>
<div class="line"><span class="lineno"> 5103</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5104</span><span class="stringliteral">        .. warning::</span></div>
<div class="line"><span class="lineno"> 5105</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5106</span><span class="stringliteral">           We recommend using :attr:`Index.array` or</span></div>
<div class="line"><span class="lineno"> 5107</span><span class="stringliteral">           :meth:`Index.to_numpy`, depending on whether you need</span></div>
<div class="line"><span class="lineno"> 5108</span><span class="stringliteral">           a reference to the underlying data or a NumPy array.</span></div>
<div class="line"><span class="lineno"> 5109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5110</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5111</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5112</span><span class="stringliteral">        array: numpy.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno"> 5113</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5114</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5115</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5116</span><span class="stringliteral">        Index.array : Reference to the underlying data.</span></div>
<div class="line"><span class="lineno"> 5117</span><span class="stringliteral">        Index.to_numpy : A NumPy array representing the underlying data.</span></div>
<div class="line"><span class="lineno"> 5118</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5119</span>        <span class="keywordflow">return</span> self._data</div>
<div class="line"><span class="lineno"> 5120</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab772a111da653666c2456e4ad06e4011" name="ab772a111da653666c2456e4ad06e4011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab772a111da653666c2456e4ad06e4011">&#9670;&#160;</a></span>view()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.view </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a15dcfc1bb58928eb4570a603ffbce7c2">pandas.core.indexes.multi.MultiIndex</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1024</span>    <span class="keyword">def </span>view(self, cls=None):</div>
<div class="line"><span class="lineno"> 1025</span> </div>
<div class="line"><span class="lineno"> 1026</span>        <span class="comment"># we need to see if we are subclassing an</span></div>
<div class="line"><span class="lineno"> 1027</span>        <span class="comment"># index type here</span></div>
<div class="line"><span class="lineno"> 1028</span>        <span class="keywordflow">if</span> cls <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> <span class="keywordflow">not</span> hasattr(cls, <span class="stringliteral">&quot;_typ&quot;</span>):</div>
<div class="line"><span class="lineno"> 1029</span>            dtype = cls</div>
<div class="line"><span class="lineno"> 1030</span>            <span class="keywordflow">if</span> isinstance(cls, str):</div>
<div class="line"><span class="lineno"> 1031</span>                dtype = pandas_dtype(cls)</div>
<div class="line"><span class="lineno"> 1032</span> </div>
<div class="line"><span class="lineno"> 1033</span>            <span class="keywordflow">if</span> isinstance(dtype, (np.dtype, ExtensionDtype)) <span class="keywordflow">and</span> needs_i8_conversion(</div>
<div class="line"><span class="lineno"> 1034</span>                dtype</div>
<div class="line"><span class="lineno"> 1035</span>            ):</div>
<div class="line"><span class="lineno"> 1036</span>                <span class="keywordflow">if</span> dtype.kind == <span class="stringliteral">&quot;m&quot;</span> <span class="keywordflow">and</span> dtype != <span class="stringliteral">&quot;m8[ns]&quot;</span>:</div>
<div class="line"><span class="lineno"> 1037</span>                    <span class="comment"># e.g. m8[s]</span></div>
<div class="line"><span class="lineno"> 1038</span>                    <span class="keywordflow">return</span> self._data.view(cls)</div>
<div class="line"><span class="lineno"> 1039</span> </div>
<div class="line"><span class="lineno"> 1040</span>                idx_cls = self._dtype_to_subclass(dtype)</div>
<div class="line"><span class="lineno"> 1041</span>                <span class="comment"># NB: we only get here for subclasses that override</span></div>
<div class="line"><span class="lineno"> 1042</span>                <span class="comment">#  _data_cls such that it is a type and not a tuple</span></div>
<div class="line"><span class="lineno"> 1043</span>                <span class="comment">#  of types.</span></div>
<div class="line"><span class="lineno"> 1044</span>                arr_cls = idx_cls._data_cls</div>
<div class="line"><span class="lineno"> 1045</span>                arr = arr_cls(self._data.view(<span class="stringliteral">&quot;i8&quot;</span>), dtype=dtype)</div>
<div class="line"><span class="lineno"> 1046</span>                <span class="keywordflow">return</span> idx_cls._simple_new(arr, name=self.name)</div>
<div class="line"><span class="lineno"> 1047</span> </div>
<div class="line"><span class="lineno"> 1048</span>            result = self._data.view(cls)</div>
<div class="line"><span class="lineno"> 1049</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1050</span>            result = self._view()</div>
<div class="line"><span class="lineno"> 1051</span>        <span class="keywordflow">if</span> isinstance(result, Index):</div>
<div class="line"><span class="lineno"> 1052</span>            result._id = self._id</div>
<div class="line"><span class="lineno"> 1053</span>        <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno"> 1054</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a286cea8fd60b36ec217693030aed9012" name="a286cea8fd60b36ec217693030aed9012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286cea8fd60b36ec217693030aed9012">&#9670;&#160;</a></span>where()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.where </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Replace values where the condition is False.

The replacement is taken from other.

Parameters
----------
cond : bool array-like with the same length as self
    Condition to select the values on.
other : scalar, or array-like, default None
    Replacement if the condition is False.

Returns
-------
pandas.Index
    A copy of self with values replaced from other
    where the condition is False.

See Also
--------
Series.where : Same method for Series.
DataFrame.where : Same method for DataFrame.

Examples
--------
&gt;&gt;&gt; idx = pd.Index(['car', 'bike', 'train', 'tractor'])
&gt;&gt;&gt; idx
Index(['car', 'bike', 'train', 'tractor'], dtype='object')
&gt;&gt;&gt; idx.where(idx.isin(['car', 'train']), 'other')
Index(['car', 'other', 'train', 'other'], dtype='object')
</pre> <div class="fragment"><div class="line"><span class="lineno"> 5189</span>    <span class="keyword">def </span>where(self, cond, other=None) -&gt; Index:</div>
<div class="line"><span class="lineno"> 5190</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5191</span><span class="stringliteral">        Replace values where the condition is False.</span></div>
<div class="line"><span class="lineno"> 5192</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5193</span><span class="stringliteral">        The replacement is taken from other.</span></div>
<div class="line"><span class="lineno"> 5194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5195</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 5196</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 5197</span><span class="stringliteral">        cond : bool array-like with the same length as self</span></div>
<div class="line"><span class="lineno"> 5198</span><span class="stringliteral">            Condition to select the values on.</span></div>
<div class="line"><span class="lineno"> 5199</span><span class="stringliteral">        other : scalar, or array-like, default None</span></div>
<div class="line"><span class="lineno"> 5200</span><span class="stringliteral">            Replacement if the condition is False.</span></div>
<div class="line"><span class="lineno"> 5201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5202</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno"> 5203</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno"> 5204</span><span class="stringliteral">        pandas.Index</span></div>
<div class="line"><span class="lineno"> 5205</span><span class="stringliteral">            A copy of self with values replaced from other</span></div>
<div class="line"><span class="lineno"> 5206</span><span class="stringliteral">            where the condition is False.</span></div>
<div class="line"><span class="lineno"> 5207</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5208</span><span class="stringliteral">        See Also</span></div>
<div class="line"><span class="lineno"> 5209</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5210</span><span class="stringliteral">        Series.where : Same method for Series.</span></div>
<div class="line"><span class="lineno"> 5211</span><span class="stringliteral">        DataFrame.where : Same method for DataFrame.</span></div>
<div class="line"><span class="lineno"> 5212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 5213</span><span class="stringliteral">        Examples</span></div>
<div class="line"><span class="lineno"> 5214</span><span class="stringliteral">        --------</span></div>
<div class="line"><span class="lineno"> 5215</span><span class="stringliteral">        &gt;&gt;&gt; idx = pd.Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;])</span></div>
<div class="line"><span class="lineno"> 5216</span><span class="stringliteral">        &gt;&gt;&gt; idx</span></div>
<div class="line"><span class="lineno"> 5217</span><span class="stringliteral">        Index([&#39;car&#39;, &#39;bike&#39;, &#39;train&#39;, &#39;tractor&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 5218</span><span class="stringliteral">        &gt;&gt;&gt; idx.where(idx.isin([&#39;car&#39;, &#39;train&#39;]), &#39;other&#39;)</span></div>
<div class="line"><span class="lineno"> 5219</span><span class="stringliteral">        Index([&#39;car&#39;, &#39;other&#39;, &#39;train&#39;, &#39;other&#39;], dtype=&#39;object&#39;)</span></div>
<div class="line"><span class="lineno"> 5220</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 5221</span>        <span class="keywordflow">if</span> isinstance(self, ABCMultiIndex):</div>
<div class="line"><span class="lineno"> 5222</span>            <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line"><span class="lineno"> 5223</span>                <span class="stringliteral">&quot;.where is not supported for MultiIndex operations&quot;</span></div>
<div class="line"><span class="lineno"> 5224</span>            )</div>
<div class="line"><span class="lineno"> 5225</span>        cond = np.asarray(cond, dtype=bool)</div>
<div class="line"><span class="lineno"> 5226</span>        <span class="keywordflow">return</span> self.putmask(~cond, other)</div>
<div class="line"><span class="lineno"> 5227</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a05aae8eda9d31004df02be5178ce1fc6" name="a05aae8eda9d31004df02be5178ce1fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05aae8eda9d31004df02be5178ce1fc6">&#9670;&#160;</a></span>_accessors</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dict pandas.core.indexes.base.Index._accessors = {&quot;str&quot;}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9458743a4a7f5c0dfac3520684062804" name="a9458743a4a7f5c0dfac3520684062804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9458743a4a7f5c0dfac3520684062804">&#9670;&#160;</a></span>_attributes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list pandas.core.indexes.base.Index._attributes = [&quot;name&quot;]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac32a12ed2d32d56e2e70922cb634c375" name="ac32a12ed2d32d56e2e70922cb634c375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32a12ed2d32d56e2e70922cb634c375">&#9670;&#160;</a></span>_can_hold_strings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexes.base.Index._can_hold_strings = True</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#abea3581244abec4cb6354ea7f73f2c25">pandas.core.indexes.category.CategoricalIndex</a>.</p>

</div>
</div>
<a id="a6f620a9a15678d770bfa5facf62f212b" name="a6f620a9a15678d770bfa5facf62f212b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f620a9a15678d770bfa5facf62f212b">&#9670;&#160;</a></span>_comparables</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list pandas.core.indexes.base.Index._comparables = [&quot;name&quot;]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98a3191708ce47ff3341186cc0af42be" name="a98a3191708ce47ff3341186cc0af42be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a3191708ce47ff3341186cc0af42be">&#9670;&#160;</a></span>_data <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpandas_1_1core_1_1arrays_1_1base_1_1_extension_array.html">ExtensionArray</a> pandas.core.indexes.base.Index._data | np.ndarray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#aff4e36701012a6e631cae546fa38ba1c">pandas.core.indexes.range.RangeIndex</a>.</p>

</div>
</div>
<a id="aec59fbfc1e0fea18e0ac79017b8a7ed1" name="aec59fbfc1e0fea18e0ac79017b8a7ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec59fbfc1e0fea18e0ac79017b8a7ed1">&#9670;&#160;</a></span>_data <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#aff4e36701012a6e631cae546fa38ba1c">pandas.core.indexes.range.RangeIndex</a>.</p>

</div>
</div>
<a id="a891d552bc01c6f433888d9134b2010af" name="a891d552bc01c6f433888d9134b2010af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891d552bc01c6f433888d9134b2010af">&#9670;&#160;</a></span>_data_cls <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pandas.core.indexes.base.Index._data_cls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  (</div>
<div class="line">        np.ndarray,</div>
<div class="line">        ExtensionArray,</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad06490c50902ec2100f537ad226edc96" name="ad06490c50902ec2100f537ad226edc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06490c50902ec2100f537ad226edc96">&#9670;&#160;</a></span>_data_cls <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._data_cls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acd25b951980c40690cc5f33b7475cba8" name="acd25b951980c40690cc5f33b7475cba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd25b951980c40690cc5f33b7475cba8">&#9670;&#160;</a></span>_formatter_func</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._formatter_func</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a36426ed27802c26f3fe206e2702ef76e">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a76dd114b63b041224c6c9effbeaa2fbd">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a89af4f9c3042537ffa4298ba54c29e2c">pandas.core.indexes.datetimes.DatetimeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a2ee40da4871fdc4cc1ce1bb6309331a1">pandas.core.indexes.multi.MultiIndex</a>.</p>

</div>
</div>
<a id="a04055aed79b8044489b5152bd9e8b5c3" name="a04055aed79b8044489b5152bd9e8b5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04055aed79b8044489b5152bd9e8b5c3">&#9670;&#160;</a></span>_hidden_attrs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple pandas.core.indexes.base.Index._hidden_attrs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=  (</div>
<div class="line">        PandasObject._hidden_attrs</div>
<div class="line">        | IndexOpsMixin._hidden_attrs</div>
<div class="line">        | frozenset([<span class="stringliteral">&quot;contains&quot;</span>, <span class="stringliteral">&quot;set_value&quot;</span>])</div>
<div class="line">    )</div>
</div><!-- fragment -->
</div>
</div>
<a id="a75021533c394fd113f641ba7f038d335" name="a75021533c394fd113f641ba7f038d335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75021533c394fd113f641ba7f038d335">&#9670;&#160;</a></span>_id <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">object pandas.core.indexes.base.Index._id = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0b09379759ea599131ee56ba8ddbba5" name="aa0b09379759ea599131ee56ba8ddbba5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b09379759ea599131ee56ba8ddbba5">&#9670;&#160;</a></span>_id <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af73231a672b7fb2838868bdf3eccdbfe" name="af73231a672b7fb2838868bdf3eccdbfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73231a672b7fb2838868bdf3eccdbfe">&#9670;&#160;</a></span>_is_backward_compat_public_numeric_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexes.base.Index._is_backward_compat_public_numeric_index = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afed5edd50792ceccc9c66350944a4a03" name="afed5edd50792ceccc9c66350944a4a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed5edd50792ceccc9c66350944a4a03">&#9670;&#160;</a></span>_is_numeric_dtype</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexes.base.Index._is_numeric_dtype = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e0b60d1efa60e7134f67f532785fce" name="ab7e0b60d1efa60e7134f67f532785fce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e0b60d1efa60e7134f67f532785fce">&#9670;&#160;</a></span>_join_precedence</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int pandas.core.indexes.base.Index._join_precedence = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa591db6e26b93e8529fcde91d2f04428" name="aa591db6e26b93e8529fcde91d2f04428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa591db6e26b93e8529fcde91d2f04428">&#9670;&#160;</a></span>_name <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Hashable pandas.core.indexes.base.Index._name = None</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aba78217120b7c58e123180c90178f582" name="aba78217120b7c58e123180c90178f582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba78217120b7c58e123180c90178f582">&#9670;&#160;</a></span>_name <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7393d95bc48316b158792b1acb768aab" name="a7393d95bc48316b158792b1acb768aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7393d95bc48316b158792b1acb768aab">&#9670;&#160;</a></span>_no_setting_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexes.base.Index._no_setting_name = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e3176c73933475321981e0452a288ca" name="a8e3176c73933475321981e0452a288ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3176c73933475321981e0452a288ca">&#9670;&#160;</a></span>_range</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._range</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4e2dd23b29bfd34c67d7f50df6dc7b1" name="ac4e2dd23b29bfd34c67d7f50df6dc7b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e2dd23b29bfd34c67d7f50df6dc7b1">&#9670;&#160;</a></span>_requires_unique_msg <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._requires_unique_msg</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b8305c50b11b342b3778b45c76c928a" name="a0b8305c50b11b342b3778b45c76c928a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8305c50b11b342b3778b45c76c928a">&#9670;&#160;</a></span>_requires_unique_msg <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a09dc54c97265b31bbbe2b25730d404e0">str</a> pandas.core.indexes.base.Index._requires_unique_msg = &quot;Reindexing only valid with uniquely valued <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> objects&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2786c41936290dba55f184420ee987f0" name="a2786c41936290dba55f184420ee987f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2786c41936290dba55f184420ee987f0">&#9670;&#160;</a></span>_supports_partial_string_indexing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pandas.core.indexes.base.Index._supports_partial_string_indexing = False</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a67dd4af4c1377a81c16675eec6e825a4" name="a67dd4af4c1377a81c16675eec6e825a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dd4af4c1377a81c16675eec6e825a4">&#9670;&#160;</a></span>_typ <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a09dc54c97265b31bbbe2b25730d404e0">str</a> pandas.core.indexes.base.Index._typ = &quot;index&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70dd104387bbd169760b23ece055a416" name="a70dd104387bbd169760b23ece055a416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70dd104387bbd169760b23ece055a416">&#9670;&#160;</a></span>_typ <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._typ</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8205121019db1c2670b43c14dbb20cb" name="aa8205121019db1c2670b43c14dbb20cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8205121019db1c2670b43c14dbb20cb">&#9670;&#160;</a></span>_values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index._values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a67e29d5dedb60765410baaf63a8b02ab">pandas.core.indexes.multi.MultiIndex</a>.</p>

</div>
</div>
<a id="a94270472703ead5d5c3b3695c0a5e993" name="a94270472703ead5d5c3b3695c0a5e993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94270472703ead5d5c3b3695c0a5e993">&#9670;&#160;</a></span>categories</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.categories</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a89f0dd01f7221293308ad6cc8d05f842" name="a89f0dd01f7221293308ad6cc8d05f842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f0dd01f7221293308ad6cc8d05f842">&#9670;&#160;</a></span>dtype</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.dtype</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a022680e8955b0fe4d760a4feaf6cf093">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a8f212b8253bdbd9417b9c7fed9a9a601">pandas.core.indexes.range.RangeIndex</a>.</p>

</div>
</div>
<a id="a2d050d983339a26ec4a5e1623de2c9e8" name="a2d050d983339a26ec4a5e1623de2c9e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d050d983339a26ec4a5e1623de2c9e8">&#9670;&#160;</a></span>dtypes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.dtypes</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a3ea689f6d5cb442d9b2fe2530f720553">pandas.core.indexes.multi.MultiIndex</a>.</p>

</div>
</div>
<a id="ad3491922d3e3feb92c84c6677c076613" name="ad3491922d3e3feb92c84c6677c076613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3491922d3e3feb92c84c6677c076613">&#9670;&#160;</a></span>get_level_values</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html">Index</a> pandas.core.indexes.base.Index.get_level_values = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#abd2bf62078de48efb3f4262354d47eb8">_get_level_values</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a8dc15f7752f272645dec605794b83510">pandas.core.indexes.multi.MultiIndex</a>.</p>

</div>
</div>
<a id="a9d5d2aa158db3fb9863d50f4cc731a02" name="a9d5d2aa158db3fb9863d50f4cc731a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5d2aa158db3fb9863d50f4cc731a02">&#9670;&#160;</a></span>hasnans</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.hasnans</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_index_ops_mixin.html#a2cca65b0a2e669dd7f92c9ea9445313b">pandas.core.indexes.datetimelike.DatetimeIndexOpsMixin</a>.</p>

</div>
</div>
<a id="a082a4e5f6d9ebe6b049f8e600c7b9ca1" name="a082a4e5f6d9ebe6b049f8e600c7b9ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082a4e5f6d9ebe6b049f8e600c7b9ca1">&#9670;&#160;</a></span>inferred_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.inferred_type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1category_1_1_categorical_index.html#a2c5b93b95a1c47583a3e57d733f04736">pandas.core.indexes.category.CategoricalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimes_1_1_datetime_index.html#a224cbd96ebcd6f4cb7211c090d7d443b">pandas.core.indexes.datetimes.DatetimeIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1interval_1_1_interval_index.html#a0ea92ad33a82b076a9cafa9dc5a042f0">pandas.core.indexes.interval.IntervalIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ad57b8c298c5a2190ed6e93dd879d04b6">pandas.core.indexes.multi.MultiIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1numeric_1_1_numeric_index.html#ab9988a87e6742ff69dff4bfd5cefc62d">pandas.core.indexes.numeric.NumericIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a733482aece5a1b0bed4b976a206975af">pandas.core.indexes.period.PeriodIndex</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1range_1_1_range_index.html#a2d65ffa08bcb17232e56ba7caf7e0ce3">pandas.core.indexes.range.RangeIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1timedeltas_1_1_timedelta_index.html#af5688402cfe2f64073e0eb549d72682d">pandas.core.indexes.timedeltas.TimedeltaIndex</a>.</p>

</div>
</div>
<a id="a9df08ca45336f952d726a61ecbad99f0" name="a9df08ca45336f952d726a61ecbad99f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df08ca45336f952d726a61ecbad99f0">&#9670;&#160;</a></span>isnull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">npt.NDArray[np.bool_] pandas.core.indexes.base.Index.isnull = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a4fb4a4fc94bfe6bad9e0df500a5919c2">isna</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff207e0d287fb46016e9beb32ef8c28" name="a3ff207e0d287fb46016e9beb32ef8c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff207e0d287fb46016e9beb32ef8c28">&#9670;&#160;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.name</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad59caf1a94a85baf8bf557179f7f3a56" name="ad59caf1a94a85baf8bf557179f7f3a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59caf1a94a85baf8bf557179f7f3a56">&#9670;&#160;</a></span>nlevels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.nlevels</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#a2b7ec81c25da4da51a5d15167ebe54c3">pandas.core.indexes.multi.MultiIndex</a>.</p>

</div>
</div>
<a id="a60673e509ddd0884ec45dcc00dad6f6d" name="a60673e509ddd0884ec45dcc00dad6f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60673e509ddd0884ec45dcc00dad6f6d">&#9670;&#160;</a></span>notnull</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">npt.NDArray[np.bool_] pandas.core.indexes.base.Index.notnull = <a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#aba9b00f5246b0879baaf10e730d7a21a">notna</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a09dc54c97265b31bbbe2b25730d404e0" name="a09dc54c97265b31bbbe2b25730d404e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dc54c97265b31bbbe2b25730d404e0">&#9670;&#160;</a></span>str</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.str = <a class="el" href="classpandas_1_1core_1_1accessor_1_1_cached_accessor.html">CachedAccessor</a>(&quot;str&quot;, <a class="el" href="classpandas_1_1core_1_1strings_1_1accessor_1_1_string_methods.html">StringMethods</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89499184bef657d1692356012545f1f6" name="a89499184bef657d1692356012545f1f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89499184bef657d1692356012545f1f6">&#9670;&#160;</a></span>tz</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.tz</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a644cfdf7877cdf1c4bfd5dab621586bd" name="a644cfdf7877cdf1c4bfd5dab621586bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644cfdf7877cdf1c4bfd5dab621586bd">&#9670;&#160;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.values</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classpandas_1_1core_1_1indexes_1_1datetimelike_1_1_datetime_timedelta_mixin.html#ae68485e7ec16dc9ea5aac769ab8c5751">pandas.core.indexes.datetimelike.DatetimeTimedeltaMixin</a>, <a class="el" href="classpandas_1_1core_1_1indexes_1_1multi_1_1_multi_index.html#ae09c97798114b3138c2b3cb03efd2ed6">pandas.core.indexes.multi.MultiIndex</a>, and <a class="el" href="classpandas_1_1core_1_1indexes_1_1period_1_1_period_index.html#a402f14c8df3cd9ba57d7ac8f8e4223d6">pandas.core.indexes.period.PeriodIndex</a>.</p>

</div>
</div>
<h2 class="groupheader">Property Documentation</h2>
<a id="aeb583e3bb8a437f0d1a6fb0b82510359" name="aeb583e3bb8a437f0d1a6fb0b82510359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb583e3bb8a437f0d1a6fb0b82510359">&#9670;&#160;</a></span>names</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.indexes.base.Index.names = property(fset=<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#a5698e03a836f4b2113d3002def90aba7">_set_names</a>, fget=<a class="el" href="classpandas_1_1core_1_1indexes_1_1base_1_1_index.html#af81701ab0c850457a0738bf314235a92">_get_names</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/pandas/core/indexes/<a class="el" href="pandas_2core_2indexes_2base_8py.html">base.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
