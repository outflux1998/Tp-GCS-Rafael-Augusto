<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: sklearn.manifold._spectral_embedding Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacesklearn.html">sklearn</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1manifold.html">manifold</a></li><li class="navelem"><a class="el" href="namespacesklearn_1_1manifold_1_1__spectral__embedding.html">_spectral_embedding</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">sklearn.manifold._spectral_embedding Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsklearn_1_1manifold_1_1__spectral__embedding_1_1_spectral_embedding.html">SpectralEmbedding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a510a0f85d876503d502146628fe0607f" id="r_a510a0f85d876503d502146628fe0607f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1manifold_1_1__spectral__embedding.html#a510a0f85d876503d502146628fe0607f">_graph_connected_component</a> (graph, node_id)</td></tr>
<tr class="separator:a510a0f85d876503d502146628fe0607f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf1b00171896933c9aefcbcddeb617a" id="r_afbf1b00171896933c9aefcbcddeb617a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1manifold_1_1__spectral__embedding.html#afbf1b00171896933c9aefcbcddeb617a">_graph_is_connected</a> (graph)</td></tr>
<tr class="separator:afbf1b00171896933c9aefcbcddeb617a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b9d3c115d2842c65c706f80240313" id="r_a5e2b9d3c115d2842c65c706f80240313"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1manifold_1_1__spectral__embedding.html#a5e2b9d3c115d2842c65c706f80240313">_set_diag</a> (laplacian, value, norm_laplacian)</td></tr>
<tr class="separator:a5e2b9d3c115d2842c65c706f80240313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7dbcb53e19f3e8723828cf69eb7bc1" id="r_acd7dbcb53e19f3e8723828cf69eb7bc1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesklearn_1_1manifold_1_1__spectral__embedding.html#acd7dbcb53e19f3e8723828cf69eb7bc1">spectral_embedding</a> (adjacency, *n_components=8, eigen_solver=None, random_state=None, eigen_tol=&quot;auto&quot;, norm_laplacian=True, drop_first=True)</td></tr>
<tr class="separator:acd7dbcb53e19f3e8723828cf69eb7bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Spectral Embedding.</pre> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a510a0f85d876503d502146628fe0607f" name="a510a0f85d876503d502146628fe0607f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510a0f85d876503d502146628fe0607f">&#9670;&#160;</a></span>_graph_connected_component()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.manifold._spectral_embedding._graph_connected_component </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>node_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the largest graph connected components that contains one
given node.

Parameters
----------
graph : array-like of shape (n_samples, n_samples)
    Adjacency matrix of the graph, non-zero weight means an edge
    between the nodes.

node_id : int
    The index of the query node of the graph.

Returns
-------
connected_components_matrix : array-like of shape (n_samples,)
    An array of bool value indicating the indexes of the nodes
    belonging to the largest connected components of the given query
    node.
</pre> <div class="fragment"><div class="line"><span class="lineno">   32</span><span class="keyword">def </span>_graph_connected_component(graph, node_id):</div>
<div class="line"><span class="lineno">   33</span>    <span class="stringliteral">&quot;&quot;&quot;Find the largest graph connected components that contains one</span></div>
<div class="line"><span class="lineno">   34</span><span class="stringliteral">    given node.</span></div>
<div class="line"><span class="lineno">   35</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   36</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   37</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   38</span><span class="stringliteral">    graph : array-like of shape (n_samples, n_samples)</span></div>
<div class="line"><span class="lineno">   39</span><span class="stringliteral">        Adjacency matrix of the graph, non-zero weight means an edge</span></div>
<div class="line"><span class="lineno">   40</span><span class="stringliteral">        between the nodes.</span></div>
<div class="line"><span class="lineno">   41</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   42</span><span class="stringliteral">    node_id : int</span></div>
<div class="line"><span class="lineno">   43</span><span class="stringliteral">        The index of the query node of the graph.</span></div>
<div class="line"><span class="lineno">   44</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   45</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   46</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   47</span><span class="stringliteral">    connected_components_matrix : array-like of shape (n_samples,)</span></div>
<div class="line"><span class="lineno">   48</span><span class="stringliteral">        An array of bool value indicating the indexes of the nodes</span></div>
<div class="line"><span class="lineno">   49</span><span class="stringliteral">        belonging to the largest connected components of the given query</span></div>
<div class="line"><span class="lineno">   50</span><span class="stringliteral">        node.</span></div>
<div class="line"><span class="lineno">   51</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   52</span>    n_node = graph.shape[0]</div>
<div class="line"><span class="lineno">   53</span>    <span class="keywordflow">if</span> sparse.issparse(graph):</div>
<div class="line"><span class="lineno">   54</span>        <span class="comment"># speed up row-wise access to boolean connection mask</span></div>
<div class="line"><span class="lineno">   55</span>        graph = graph.tocsr()</div>
<div class="line"><span class="lineno">   56</span>    connected_nodes = np.zeros(n_node, dtype=bool)</div>
<div class="line"><span class="lineno">   57</span>    nodes_to_explore = np.zeros(n_node, dtype=bool)</div>
<div class="line"><span class="lineno">   58</span>    nodes_to_explore[node_id] = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">for</span> _ <span class="keywordflow">in</span> range(n_node):</div>
<div class="line"><span class="lineno">   60</span>        last_num_component = connected_nodes.sum()</div>
<div class="line"><span class="lineno">   61</span>        np.logical_or(connected_nodes, nodes_to_explore, out=connected_nodes)</div>
<div class="line"><span class="lineno">   62</span>        <span class="keywordflow">if</span> last_num_component &gt;= connected_nodes.sum():</div>
<div class="line"><span class="lineno">   63</span>            <span class="keywordflow">break</span></div>
<div class="line"><span class="lineno">   64</span>        indices = np.where(nodes_to_explore)[0]</div>
<div class="line"><span class="lineno">   65</span>        nodes_to_explore.fill(<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">   66</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> indices:</div>
<div class="line"><span class="lineno">   67</span>            <span class="keywordflow">if</span> sparse.issparse(graph):</div>
<div class="line"><span class="lineno">   68</span>                neighbors = graph[i].toarray().ravel()</div>
<div class="line"><span class="lineno">   69</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   70</span>                neighbors = graph[i]</div>
<div class="line"><span class="lineno">   71</span>            np.logical_or(nodes_to_explore, neighbors, out=nodes_to_explore)</div>
<div class="line"><span class="lineno">   72</span>    <span class="keywordflow">return</span> connected_nodes</div>
<div class="line"><span class="lineno">   73</span> </div>
<div class="line"><span class="lineno">   74</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="afbf1b00171896933c9aefcbcddeb617a" name="afbf1b00171896933c9aefcbcddeb617a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf1b00171896933c9aefcbcddeb617a">&#9670;&#160;</a></span>_graph_is_connected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.manifold._spectral_embedding._graph_is_connected </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return whether the graph is connected (True) or Not (False).

Parameters
----------
graph : {array-like, sparse matrix} of shape (n_samples, n_samples)
    Adjacency matrix of the graph, non-zero weight means an edge
    between the nodes.

Returns
-------
is_connected : bool
    True means the graph is fully connected and False means not.
</pre> <div class="fragment"><div class="line"><span class="lineno">   75</span><span class="keyword">def </span>_graph_is_connected(graph):</div>
<div class="line"><span class="lineno">   76</span>    <span class="stringliteral">&quot;&quot;&quot;Return whether the graph is connected (True) or Not (False).</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    graph : {array-like, sparse matrix} of shape (n_samples, n_samples)</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">        Adjacency matrix of the graph, non-zero weight means an edge</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">        between the nodes.</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    is_connected : bool</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">        True means the graph is fully connected and False means not.</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">if</span> sparse.isspmatrix(graph):</div>
<div class="line"><span class="lineno">   90</span>        <span class="comment"># sparse graph, find all the connected components</span></div>
<div class="line"><span class="lineno">   91</span>        n_connected_components, _ = connected_components(graph)</div>
<div class="line"><span class="lineno">   92</span>        <span class="keywordflow">return</span> n_connected_components == 1</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">   94</span>        <span class="comment"># dense graph, find all connected components start from node 0</span></div>
<div class="line"><span class="lineno">   95</span>        <span class="keywordflow">return</span> _graph_connected_component(graph, 0).sum() == graph.shape[0]</div>
<div class="line"><span class="lineno">   96</span> </div>
<div class="line"><span class="lineno">   97</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5e2b9d3c115d2842c65c706f80240313" name="a5e2b9d3c115d2842c65c706f80240313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2b9d3c115d2842c65c706f80240313">&#9670;&#160;</a></span>_set_diag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.manifold._spectral_embedding._set_diag </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>laplacian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm_laplacian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Set the diagonal of the laplacian matrix and convert it to a
sparse format well suited for eigenvalue decomposition.

Parameters
----------
laplacian : {ndarray, sparse matrix}
    The graph laplacian.

value : float
    The value of the diagonal.

norm_laplacian : bool
    Whether the value of the diagonal should be changed or not.

Returns
-------
laplacian : {array, sparse matrix}
    An array of matrix in a form that is well suited to fast
    eigenvalue decomposition, depending on the band width of the
    matrix.
</pre> <div class="fragment"><div class="line"><span class="lineno">   98</span><span class="keyword">def </span>_set_diag(laplacian, value, norm_laplacian):</div>
<div class="line"><span class="lineno">   99</span>    <span class="stringliteral">&quot;&quot;&quot;Set the diagonal of the laplacian matrix and convert it to a</span></div>
<div class="line"><span class="lineno">  100</span><span class="stringliteral">    sparse format well suited for eigenvalue decomposition.</span></div>
<div class="line"><span class="lineno">  101</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  102</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  103</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  104</span><span class="stringliteral">    laplacian : {ndarray, sparse matrix}</span></div>
<div class="line"><span class="lineno">  105</span><span class="stringliteral">        The graph laplacian.</span></div>
<div class="line"><span class="lineno">  106</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  107</span><span class="stringliteral">    value : float</span></div>
<div class="line"><span class="lineno">  108</span><span class="stringliteral">        The value of the diagonal.</span></div>
<div class="line"><span class="lineno">  109</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  110</span><span class="stringliteral">    norm_laplacian : bool</span></div>
<div class="line"><span class="lineno">  111</span><span class="stringliteral">        Whether the value of the diagonal should be changed or not.</span></div>
<div class="line"><span class="lineno">  112</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  113</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  114</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  115</span><span class="stringliteral">    laplacian : {array, sparse matrix}</span></div>
<div class="line"><span class="lineno">  116</span><span class="stringliteral">        An array of matrix in a form that is well suited to fast</span></div>
<div class="line"><span class="lineno">  117</span><span class="stringliteral">        eigenvalue decomposition, depending on the band width of the</span></div>
<div class="line"><span class="lineno">  118</span><span class="stringliteral">        matrix.</span></div>
<div class="line"><span class="lineno">  119</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  120</span>    n_nodes = laplacian.shape[0]</div>
<div class="line"><span class="lineno">  121</span>    <span class="comment"># We need all entries in the diagonal to values</span></div>
<div class="line"><span class="lineno">  122</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.isspmatrix(laplacian):</div>
<div class="line"><span class="lineno">  123</span>        <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  124</span>            laplacian.flat[:: n_nodes + 1] = value</div>
<div class="line"><span class="lineno">  125</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  126</span>        laplacian = laplacian.tocoo()</div>
<div class="line"><span class="lineno">  127</span>        <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  128</span>            diag_idx = laplacian.row == laplacian.col</div>
<div class="line"><span class="lineno">  129</span>            laplacian.data[diag_idx] = value</div>
<div class="line"><span class="lineno">  130</span>        <span class="comment"># If the matrix has a small number of diagonals (as in the</span></div>
<div class="line"><span class="lineno">  131</span>        <span class="comment"># case of structured matrices coming from images), the</span></div>
<div class="line"><span class="lineno">  132</span>        <span class="comment"># dia format might be best suited for matvec products:</span></div>
<div class="line"><span class="lineno">  133</span>        n_diags = np.unique(laplacian.row - laplacian.col).size</div>
<div class="line"><span class="lineno">  134</span>        <span class="keywordflow">if</span> n_diags &lt;= 7:</div>
<div class="line"><span class="lineno">  135</span>            <span class="comment"># 3 or less outer diagonals on each side</span></div>
<div class="line"><span class="lineno">  136</span>            laplacian = laplacian.todia()</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  138</span>            <span class="comment"># csr has the fastest matvec and is thus best suited to</span></div>
<div class="line"><span class="lineno">  139</span>            <span class="comment"># arpack</span></div>
<div class="line"><span class="lineno">  140</span>            laplacian = laplacian.tocsr()</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">return</span> laplacian</div>
<div class="line"><span class="lineno">  142</span> </div>
<div class="line"><span class="lineno">  143</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acd7dbcb53e19f3e8723828cf69eb7bc1" name="acd7dbcb53e19f3e8723828cf69eb7bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7dbcb53e19f3e8723828cf69eb7bc1">&#9670;&#160;</a></span>spectral_embedding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sklearn.manifold._spectral_embedding.spectral_embedding </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>adjacency</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>n_components</em> = <code>8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigen_solver</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>random_state</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eigen_tol</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>norm_laplacian</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>drop_first</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Project the sample on the first eigenvectors of the graph Laplacian.

The adjacency matrix is used to compute a normalized graph Laplacian
whose spectrum (especially the eigenvectors associated to the
smallest eigenvalues) has an interpretation in terms of minimal
number of cuts necessary to split the graph into comparably sized
components.

This embedding can also 'work' even if the ``adjacency`` variable is
not strictly the adjacency matrix of a graph but more generally
an affinity or similarity matrix between samples (for instance the
heat kernel of a euclidean distance matrix or a k-NN matrix).

However care must taken to always make the affinity matrix symmetric
so that the eigenvector decomposition works as expected.

Note : Laplacian Eigenmaps is the actual algorithm implemented here.

Read more in the :ref:`User Guide &lt;spectral_embedding&gt;`.

Parameters
----------
adjacency : {array-like, sparse graph} of shape (n_samples, n_samples)
    The adjacency matrix of the graph to embed.

n_components : int, default=8
    The dimension of the projection subspace.

eigen_solver : {'arpack', 'lobpcg', 'amg'}, default=None
    The eigenvalue decomposition strategy to use. AMG requires pyamg
    to be installed. It can be faster on very large, sparse problems,
    but may also lead to instabilities. If None, then ``'arpack'`` is
    used.

random_state : int, RandomState instance or None, default=None
    A pseudo random number generator used for the initialization
    of the lobpcg eigen vectors decomposition when `eigen_solver ==
    'amg'`, and for the K-Means initialization. Use an int to make
    the results deterministic across calls (See
    :term:`Glossary &lt;random_state&gt;`).

    .. note::
        When using `eigen_solver == 'amg'`,
        it is necessary to also fix the global numpy seed with
        `np.random.seed(int)` to get deterministic results. See
        https://github.com/pyamg/pyamg/issues/139 for further
        information.

eigen_tol : float, default="auto"
    Stopping criterion for eigendecomposition of the Laplacian matrix.
    If `eigen_tol="auto"` then the passed tolerance will depend on the
    `eigen_solver`:

    - If `eigen_solver="arpack"`, then `eigen_tol=0.0`;
    - If `eigen_solver="lobpcg"` or `eigen_solver="amg"`, then
      `eigen_tol=None` which configures the underlying `lobpcg` solver to
      automatically resolve the value according to their heuristics. See,
      :func:`scipy.sparse.linalg.lobpcg` for details.

    Note that when using `eigen_solver="amg"` values of `tol&lt;1e-5` may lead
    to convergence issues and should be avoided.

    .. versionadded:: 1.2
       Added 'auto' option.

norm_laplacian : bool, default=True
    If True, then compute symmetric normalized Laplacian.

drop_first : bool, default=True
    Whether to drop the first eigenvector. For spectral embedding, this
    should be True as the first eigenvector should be constant vector for
    connected graph, but for spectral clustering, this should be kept as
    False to retain the first eigenvector.

Returns
-------
embedding : ndarray of shape (n_samples, n_components)
    The reduced samples.

Notes
-----
Spectral Embedding (Laplacian Eigenmaps) is most useful when the graph
has one connected component. If there graph has many components, the first
few eigenvectors will simply uncover the connected components of the graph.

References
----------
* https://en.wikipedia.org/wiki/LOBPCG

* :doi:`"Toward the Optimal Preconditioned Eigensolver: Locally Optimal
  Block Preconditioned Conjugate Gradient Method",
  Andrew V. Knyazev
  &lt;10.1137/S1064827500366124&gt;`
</pre> <div class="fragment"><div class="line"><span class="lineno">  153</span>):</div>
<div class="line"><span class="lineno">  154</span>    <span class="stringliteral">&quot;&quot;&quot;Project the sample on the first eigenvectors of the graph Laplacian.</span></div>
<div class="line"><span class="lineno">  155</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  156</span><span class="stringliteral">    The adjacency matrix is used to compute a normalized graph Laplacian</span></div>
<div class="line"><span class="lineno">  157</span><span class="stringliteral">    whose spectrum (especially the eigenvectors associated to the</span></div>
<div class="line"><span class="lineno">  158</span><span class="stringliteral">    smallest eigenvalues) has an interpretation in terms of minimal</span></div>
<div class="line"><span class="lineno">  159</span><span class="stringliteral">    number of cuts necessary to split the graph into comparably sized</span></div>
<div class="line"><span class="lineno">  160</span><span class="stringliteral">    components.</span></div>
<div class="line"><span class="lineno">  161</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  162</span><span class="stringliteral">    This embedding can also &#39;work&#39; even if the ``adjacency`` variable is</span></div>
<div class="line"><span class="lineno">  163</span><span class="stringliteral">    not strictly the adjacency matrix of a graph but more generally</span></div>
<div class="line"><span class="lineno">  164</span><span class="stringliteral">    an affinity or similarity matrix between samples (for instance the</span></div>
<div class="line"><span class="lineno">  165</span><span class="stringliteral">    heat kernel of a euclidean distance matrix or a k-NN matrix).</span></div>
<div class="line"><span class="lineno">  166</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  167</span><span class="stringliteral">    However care must taken to always make the affinity matrix symmetric</span></div>
<div class="line"><span class="lineno">  168</span><span class="stringliteral">    so that the eigenvector decomposition works as expected.</span></div>
<div class="line"><span class="lineno">  169</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  170</span><span class="stringliteral">    Note : Laplacian Eigenmaps is the actual algorithm implemented here.</span></div>
<div class="line"><span class="lineno">  171</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  172</span><span class="stringliteral">    Read more in the :ref:`User Guide &lt;spectral_embedding&gt;`.</span></div>
<div class="line"><span class="lineno">  173</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  174</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  175</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  176</span><span class="stringliteral">    adjacency : {array-like, sparse graph} of shape (n_samples, n_samples)</span></div>
<div class="line"><span class="lineno">  177</span><span class="stringliteral">        The adjacency matrix of the graph to embed.</span></div>
<div class="line"><span class="lineno">  178</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  179</span><span class="stringliteral">    n_components : int, default=8</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">        The dimension of the projection subspace.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    eigen_solver : {&#39;arpack&#39;, &#39;lobpcg&#39;, &#39;amg&#39;}, default=None</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        The eigenvalue decomposition strategy to use. AMG requires pyamg</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        to be installed. It can be faster on very large, sparse problems,</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">        but may also lead to instabilities. If None, then ``&#39;arpack&#39;`` is</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">        used.</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">    random_state : int, RandomState instance or None, default=None</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">        A pseudo random number generator used for the initialization</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        of the lobpcg eigen vectors decomposition when `eigen_solver ==</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        &#39;amg&#39;`, and for the K-Means initialization. Use an int to make</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">        the results deterministic across calls (See</span></div>
<div class="line"><span class="lineno">  193</span><span class="stringliteral">        :term:`Glossary &lt;random_state&gt;`).</span></div>
<div class="line"><span class="lineno">  194</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  195</span><span class="stringliteral">        .. note::</span></div>
<div class="line"><span class="lineno">  196</span><span class="stringliteral">            When using `eigen_solver == &#39;amg&#39;`,</span></div>
<div class="line"><span class="lineno">  197</span><span class="stringliteral">            it is necessary to also fix the global numpy seed with</span></div>
<div class="line"><span class="lineno">  198</span><span class="stringliteral">            `np.random.seed(int)` to get deterministic results. See</span></div>
<div class="line"><span class="lineno">  199</span><span class="stringliteral">            https://github.com/pyamg/pyamg/issues/139 for further</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">            information.</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">    eigen_tol : float, default=&quot;auto&quot;</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        Stopping criterion for eigendecomposition of the Laplacian matrix.</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        If `eigen_tol=&quot;auto&quot;` then the passed tolerance will depend on the</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral">        `eigen_solver`:</span></div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        - If `eigen_solver=&quot;arpack&quot;`, then `eigen_tol=0.0`;</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        - If `eigen_solver=&quot;lobpcg&quot;` or `eigen_solver=&quot;amg&quot;`, then</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">          `eigen_tol=None` which configures the underlying `lobpcg` solver to</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">          automatically resolve the value according to their heuristics. See,</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">          :func:`scipy.sparse.linalg.lobpcg` for details.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">        Note that when using `eigen_solver=&quot;amg&quot;` values of `tol&lt;1e-5` may lead</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        to convergence issues and should be avoided.</span></div>
<div class="line"><span class="lineno">  215</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  216</span><span class="stringliteral">        .. versionadded:: 1.2</span></div>
<div class="line"><span class="lineno">  217</span><span class="stringliteral">           Added &#39;auto&#39; option.</span></div>
<div class="line"><span class="lineno">  218</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  219</span><span class="stringliteral">    norm_laplacian : bool, default=True</span></div>
<div class="line"><span class="lineno">  220</span><span class="stringliteral">        If True, then compute symmetric normalized Laplacian.</span></div>
<div class="line"><span class="lineno">  221</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  222</span><span class="stringliteral">    drop_first : bool, default=True</span></div>
<div class="line"><span class="lineno">  223</span><span class="stringliteral">        Whether to drop the first eigenvector. For spectral embedding, this</span></div>
<div class="line"><span class="lineno">  224</span><span class="stringliteral">        should be True as the first eigenvector should be constant vector for</span></div>
<div class="line"><span class="lineno">  225</span><span class="stringliteral">        connected graph, but for spectral clustering, this should be kept as</span></div>
<div class="line"><span class="lineno">  226</span><span class="stringliteral">        False to retain the first eigenvector.</span></div>
<div class="line"><span class="lineno">  227</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">    embedding : ndarray of shape (n_samples, n_components)</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        The reduced samples.</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">    Notes</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral">    -----</span></div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">    Spectral Embedding (Laplacian Eigenmaps) is most useful when the graph</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">    has one connected component. If there graph has many components, the first</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral">    few eigenvectors will simply uncover the connected components of the graph.</span></div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">    References</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">    * https://en.wikipedia.org/wiki/LOBPCG</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">    * :doi:`&quot;Toward the Optimal Preconditioned Eigensolver: Locally Optimal</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">      Block Preconditioned Conjugate Gradient Method&quot;,</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">      Andrew V. Knyazev</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">      &lt;10.1137/S1064827500366124&gt;`</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  248</span>    adjacency = check_symmetric(adjacency)</div>
<div class="line"><span class="lineno">  249</span> </div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  251</span>        <span class="keyword">from</span> pyamg <span class="keyword">import</span> smoothed_aggregation_solver</div>
<div class="line"><span class="lineno">  252</span>    <span class="keywordflow">except</span> ImportError <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">if</span> eigen_solver == <span class="stringliteral">&quot;amg&quot;</span>:</div>
<div class="line"><span class="lineno">  254</span>            <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  255</span>                <span class="stringliteral">&quot;The eigen_solver was set to &#39;amg&#39;, but pyamg is not available.&quot;</span></div>
<div class="line"><span class="lineno">  256</span>            ) <span class="keyword">from</span> e</div>
<div class="line"><span class="lineno">  257</span> </div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">if</span> eigen_solver <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  259</span>        eigen_solver = <span class="stringliteral">&quot;arpack&quot;</span></div>
<div class="line"><span class="lineno">  260</span>    <span class="keywordflow">elif</span> eigen_solver <span class="keywordflow">not</span> <span class="keywordflow">in</span> (<span class="stringliteral">&quot;arpack&quot;</span>, <span class="stringliteral">&quot;lobpcg&quot;</span>, <span class="stringliteral">&quot;amg&quot;</span>):</div>
<div class="line"><span class="lineno">  261</span>        <span class="keywordflow">raise</span> ValueError(</div>
<div class="line"><span class="lineno">  262</span>            <span class="stringliteral">&quot;Unknown value for eigen_solver: &#39;%s&#39;.&quot;</span></div>
<div class="line"><span class="lineno">  263</span>            <span class="stringliteral">&quot;Should be &#39;amg&#39;, &#39;arpack&#39;, or &#39;lobpcg&#39;&quot;</span> % eigen_solver</div>
<div class="line"><span class="lineno">  264</span>        )</div>
<div class="line"><span class="lineno">  265</span> </div>
<div class="line"><span class="lineno">  266</span>    random_state = check_random_state(random_state)</div>
<div class="line"><span class="lineno">  267</span> </div>
<div class="line"><span class="lineno">  268</span>    n_nodes = adjacency.shape[0]</div>
<div class="line"><span class="lineno">  269</span>    <span class="comment"># Whether to drop the first eigenvector</span></div>
<div class="line"><span class="lineno">  270</span>    <span class="keywordflow">if</span> drop_first:</div>
<div class="line"><span class="lineno">  271</span>        n_components = n_components + 1</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _graph_is_connected(adjacency):</div>
<div class="line"><span class="lineno">  274</span>        warnings.warn(</div>
<div class="line"><span class="lineno">  275</span>            <span class="stringliteral">&quot;Graph is not fully connected, spectral embedding may not work as expected.&quot;</span></div>
<div class="line"><span class="lineno">  276</span>        )</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>    laplacian, dd = csgraph_laplacian(</div>
<div class="line"><span class="lineno">  279</span>        adjacency, normed=norm_laplacian, return_diag=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  280</span>    )</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">if</span> (</div>
<div class="line"><span class="lineno">  282</span>        eigen_solver == <span class="stringliteral">&quot;arpack&quot;</span></div>
<div class="line"><span class="lineno">  283</span>        <span class="keywordflow">or</span> eigen_solver != <span class="stringliteral">&quot;lobpcg&quot;</span></div>
<div class="line"><span class="lineno">  284</span>        <span class="keywordflow">and</span> (<span class="keywordflow">not</span> sparse.isspmatrix(laplacian) <span class="keywordflow">or</span> n_nodes &lt; 5 * n_components)</div>
<div class="line"><span class="lineno">  285</span>    ):</div>
<div class="line"><span class="lineno">  286</span>        <span class="comment"># lobpcg used with eigen_solver=&#39;amg&#39; has bugs for low number of nodes</span></div>
<div class="line"><span class="lineno">  287</span>        <span class="comment"># for details see the source code in scipy:</span></div>
<div class="line"><span class="lineno">  288</span>        <span class="comment"># https://github.com/scipy/scipy/blob/v0.11.0/scipy/sparse/linalg/eigen</span></div>
<div class="line"><span class="lineno">  289</span>        <span class="comment"># /lobpcg/lobpcg.py#L237</span></div>
<div class="line"><span class="lineno">  290</span>        <span class="comment"># or matlab:</span></div>
<div class="line"><span class="lineno">  291</span>        <span class="comment"># https://www.mathworks.com/matlabcentral/fileexchange/48-lobpcg-m</span></div>
<div class="line"><span class="lineno">  292</span>        laplacian = _set_diag(laplacian, 1, norm_laplacian)</div>
<div class="line"><span class="lineno">  293</span> </div>
<div class="line"><span class="lineno">  294</span>        <span class="comment"># Here we&#39;ll use shift-invert mode for fast eigenvalues</span></div>
<div class="line"><span class="lineno">  295</span>        <span class="comment"># (see https://docs.scipy.org/doc/scipy/reference/tutorial/arpack.html</span></div>
<div class="line"><span class="lineno">  296</span>        <span class="comment">#  for a short explanation of what this means)</span></div>
<div class="line"><span class="lineno">  297</span>        <span class="comment"># Because the normalized Laplacian has eigenvalues between 0 and 2,</span></div>
<div class="line"><span class="lineno">  298</span>        <span class="comment"># I - L has eigenvalues between -1 and 1.  ARPACK is most efficient</span></div>
<div class="line"><span class="lineno">  299</span>        <span class="comment"># when finding eigenvalues of largest magnitude (keyword which=&#39;LM&#39;)</span></div>
<div class="line"><span class="lineno">  300</span>        <span class="comment"># and when these eigenvalues are very large compared to the rest.</span></div>
<div class="line"><span class="lineno">  301</span>        <span class="comment"># For very large, very sparse graphs, I - L can have many, many</span></div>
<div class="line"><span class="lineno">  302</span>        <span class="comment"># eigenvalues very near 1.0.  This leads to slow convergence.  So</span></div>
<div class="line"><span class="lineno">  303</span>        <span class="comment"># instead, we&#39;ll use ARPACK&#39;s shift-invert mode, asking for the</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="comment"># eigenvalues near 1.0.  This effectively spreads-out the spectrum</span></div>
<div class="line"><span class="lineno">  305</span>        <span class="comment"># near 1.0 and leads to much faster convergence: potentially an</span></div>
<div class="line"><span class="lineno">  306</span>        <span class="comment"># orders-of-magnitude speedup over simply using keyword which=&#39;LA&#39;</span></div>
<div class="line"><span class="lineno">  307</span>        <span class="comment"># in standard mode.</span></div>
<div class="line"><span class="lineno">  308</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  309</span>            <span class="comment"># We are computing the opposite of the laplacian inplace so as</span></div>
<div class="line"><span class="lineno">  310</span>            <span class="comment"># to spare a memory allocation of a possibly very large array</span></div>
<div class="line"><span class="lineno">  311</span>            tol = 0 <span class="keywordflow">if</span> eigen_tol == <span class="stringliteral">&quot;auto&quot;</span> <span class="keywordflow">else</span> eigen_tol</div>
<div class="line"><span class="lineno">  312</span>            laplacian *= -1</div>
<div class="line"><span class="lineno">  313</span>            v0 = _init_arpack_v0(laplacian.shape[0], random_state)</div>
<div class="line"><span class="lineno">  314</span>            _, diffusion_map = eigsh(</div>
<div class="line"><span class="lineno">  315</span>                laplacian, k=n_components, sigma=1.0, which=<span class="stringliteral">&quot;LM&quot;</span>, tol=tol, v0=v0</div>
<div class="line"><span class="lineno">  316</span>            )</div>
<div class="line"><span class="lineno">  317</span>            embedding = diffusion_map.T[n_components::-1]</div>
<div class="line"><span class="lineno">  318</span>            <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  319</span>                <span class="comment"># recover u = D^-1/2 x from the eigenvector output x</span></div>
<div class="line"><span class="lineno">  320</span>                embedding = embedding / dd</div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">except</span> RuntimeError:</div>
<div class="line"><span class="lineno">  322</span>            <span class="comment"># When submatrices are exactly singular, an LU decomposition</span></div>
<div class="line"><span class="lineno">  323</span>            <span class="comment"># in arpack fails. We fallback to lobpcg</span></div>
<div class="line"><span class="lineno">  324</span>            eigen_solver = <span class="stringliteral">&quot;lobpcg&quot;</span></div>
<div class="line"><span class="lineno">  325</span>            <span class="comment"># Revert the laplacian to its opposite to have lobpcg work</span></div>
<div class="line"><span class="lineno">  326</span>            laplacian *= -1</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>    <span class="keywordflow">elif</span> eigen_solver == <span class="stringliteral">&quot;amg&quot;</span>:</div>
<div class="line"><span class="lineno">  329</span>        <span class="comment"># Use AMG to get a preconditioner and speed up the eigenvalue</span></div>
<div class="line"><span class="lineno">  330</span>        <span class="comment"># problem.</span></div>
<div class="line"><span class="lineno">  331</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> sparse.issparse(laplacian):</div>
<div class="line"><span class="lineno">  332</span>            warnings.warn(<span class="stringliteral">&quot;AMG works better for sparse matrices&quot;</span>)</div>
<div class="line"><span class="lineno">  333</span>        laplacian = check_array(</div>
<div class="line"><span class="lineno">  334</span>            laplacian, dtype=[np.float64, np.float32], accept_sparse=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  335</span>        )</div>
<div class="line"><span class="lineno">  336</span>        laplacian = _set_diag(laplacian, 1, norm_laplacian)</div>
<div class="line"><span class="lineno">  337</span> </div>
<div class="line"><span class="lineno">  338</span>        <span class="comment"># The Laplacian matrix is always singular, having at least one zero</span></div>
<div class="line"><span class="lineno">  339</span>        <span class="comment"># eigenvalue, corresponding to the trivial eigenvector, which is a</span></div>
<div class="line"><span class="lineno">  340</span>        <span class="comment"># constant. Using a singular matrix for preconditioning may result in</span></div>
<div class="line"><span class="lineno">  341</span>        <span class="comment"># random failures in LOBPCG and is not supported by the existing</span></div>
<div class="line"><span class="lineno">  342</span>        <span class="comment"># theory:</span></div>
<div class="line"><span class="lineno">  343</span>        <span class="comment">#     see https://doi.org/10.1007/s10208-015-9297-1</span></div>
<div class="line"><span class="lineno">  344</span>        <span class="comment"># Shift the Laplacian so its diagononal is not all ones. The shift</span></div>
<div class="line"><span class="lineno">  345</span>        <span class="comment"># does change the eigenpairs however, so we&#39;ll feed the shifted</span></div>
<div class="line"><span class="lineno">  346</span>        <span class="comment"># matrix to the solver and afterward set it back to the original.</span></div>
<div class="line"><span class="lineno">  347</span>        diag_shift = 1e-5 * sparse.eye(laplacian.shape[0])</div>
<div class="line"><span class="lineno">  348</span>        laplacian += diag_shift</div>
<div class="line"><span class="lineno">  349</span>        ml = smoothed_aggregation_solver(check_array(laplacian, accept_sparse=<span class="stringliteral">&quot;csr&quot;</span>))</div>
<div class="line"><span class="lineno">  350</span>        laplacian -= diag_shift</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span>        M = ml.aspreconditioner()</div>
<div class="line"><span class="lineno">  353</span>        <span class="comment"># Create initial approximation X to eigenvectors</span></div>
<div class="line"><span class="lineno">  354</span>        X = random_state.standard_normal(size=(laplacian.shape[0], n_components + 1))</div>
<div class="line"><span class="lineno">  355</span>        X[:, 0] = dd.ravel()</div>
<div class="line"><span class="lineno">  356</span>        X = X.astype(laplacian.dtype)</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>        tol = <span class="keywordtype">None</span> <span class="keywordflow">if</span> eigen_tol == <span class="stringliteral">&quot;auto&quot;</span> <span class="keywordflow">else</span> eigen_tol</div>
<div class="line"><span class="lineno">  359</span>        _, diffusion_map = lobpcg(laplacian, X, M=M, tol=tol, largest=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  360</span>        embedding = diffusion_map.T</div>
<div class="line"><span class="lineno">  361</span>        <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  362</span>            <span class="comment"># recover u = D^-1/2 x from the eigenvector output x</span></div>
<div class="line"><span class="lineno">  363</span>            embedding = embedding / dd</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">if</span> embedding.shape[0] == 1:</div>
<div class="line"><span class="lineno">  365</span>            <span class="keywordflow">raise</span> ValueError</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>    <span class="keywordflow">if</span> eigen_solver == <span class="stringliteral">&quot;lobpcg&quot;</span>:</div>
<div class="line"><span class="lineno">  368</span>        laplacian = check_array(</div>
<div class="line"><span class="lineno">  369</span>            laplacian, dtype=[np.float64, np.float32], accept_sparse=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">  370</span>        )</div>
<div class="line"><span class="lineno">  371</span>        <span class="keywordflow">if</span> n_nodes &lt; 5 * n_components + 1:</div>
<div class="line"><span class="lineno">  372</span>            <span class="comment"># see note above under arpack why lobpcg has problems with small</span></div>
<div class="line"><span class="lineno">  373</span>            <span class="comment"># number of nodes</span></div>
<div class="line"><span class="lineno">  374</span>            <span class="comment"># lobpcg will fallback to eigh, so we short circuit it</span></div>
<div class="line"><span class="lineno">  375</span>            <span class="keywordflow">if</span> sparse.isspmatrix(laplacian):</div>
<div class="line"><span class="lineno">  376</span>                laplacian = laplacian.toarray()</div>
<div class="line"><span class="lineno">  377</span>            _, diffusion_map = eigh(laplacian, check_finite=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  378</span>            embedding = diffusion_map.T[:n_components]</div>
<div class="line"><span class="lineno">  379</span>            <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  380</span>                <span class="comment"># recover u = D^-1/2 x from the eigenvector output x</span></div>
<div class="line"><span class="lineno">  381</span>                embedding = embedding / dd</div>
<div class="line"><span class="lineno">  382</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  383</span>            laplacian = _set_diag(laplacian, 1, norm_laplacian)</div>
<div class="line"><span class="lineno">  384</span>            <span class="comment"># We increase the number of eigenvectors requested, as lobpcg</span></div>
<div class="line"><span class="lineno">  385</span>            <span class="comment"># doesn&#39;t behave well in low dimension and create initial</span></div>
<div class="line"><span class="lineno">  386</span>            <span class="comment"># approximation X to eigenvectors</span></div>
<div class="line"><span class="lineno">  387</span>            X = random_state.standard_normal(</div>
<div class="line"><span class="lineno">  388</span>                size=(laplacian.shape[0], n_components + 1)</div>
<div class="line"><span class="lineno">  389</span>            )</div>
<div class="line"><span class="lineno">  390</span>            X[:, 0] = dd.ravel()</div>
<div class="line"><span class="lineno">  391</span>            X = X.astype(laplacian.dtype)</div>
<div class="line"><span class="lineno">  392</span>            tol = <span class="keywordtype">None</span> <span class="keywordflow">if</span> eigen_tol == <span class="stringliteral">&quot;auto&quot;</span> <span class="keywordflow">else</span> eigen_tol</div>
<div class="line"><span class="lineno">  393</span>            _, diffusion_map = lobpcg(</div>
<div class="line"><span class="lineno">  394</span>                laplacian, X, tol=tol, largest=<span class="keyword">False</span>, maxiter=2000</div>
<div class="line"><span class="lineno">  395</span>            )</div>
<div class="line"><span class="lineno">  396</span>            embedding = diffusion_map.T[:n_components]</div>
<div class="line"><span class="lineno">  397</span>            <span class="keywordflow">if</span> norm_laplacian:</div>
<div class="line"><span class="lineno">  398</span>                <span class="comment"># recover u = D^-1/2 x from the eigenvector output x</span></div>
<div class="line"><span class="lineno">  399</span>                embedding = embedding / dd</div>
<div class="line"><span class="lineno">  400</span>            <span class="keywordflow">if</span> embedding.shape[0] == 1:</div>
<div class="line"><span class="lineno">  401</span>                <span class="keywordflow">raise</span> ValueError</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>    embedding = _deterministic_vector_sign_flip(embedding)</div>
<div class="line"><span class="lineno">  404</span>    <span class="keywordflow">if</span> drop_first:</div>
<div class="line"><span class="lineno">  405</span>        <span class="keywordflow">return</span> embedding[1:n_components].T</div>
<div class="line"><span class="lineno">  406</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  407</span>        <span class="keywordflow">return</span> embedding[:n_components].T</div>
<div class="line"><span class="lineno">  408</span> </div>
<div class="line"><span class="lineno">  409</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
