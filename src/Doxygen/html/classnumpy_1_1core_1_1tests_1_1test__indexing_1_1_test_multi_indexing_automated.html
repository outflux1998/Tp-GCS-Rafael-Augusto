<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: numpy.core.tests.test_indexing.TestMultiIndexingAutomated Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacenumpy.html">numpy</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1tests.html">tests</a></li><li class="navelem"><a class="el" href="namespacenumpy_1_1core_1_1tests_1_1test__indexing.html">test_indexing</a></li><li class="navelem"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html">TestMultiIndexingAutomated</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">numpy.core.tests.test_indexing.TestMultiIndexingAutomated Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a10c61720ffd2c2640804c4927f9ae034" id="r_a10c61720ffd2c2640804c4927f9ae034"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a10c61720ffd2c2640804c4927f9ae034">setup_method</a> (self)</td></tr>
<tr class="separator:a10c61720ffd2c2640804c4927f9ae034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575b713fc22bdfdcd8d8c074e948e695" id="r_a575b713fc22bdfdcd8d8c074e948e695"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a575b713fc22bdfdcd8d8c074e948e695">test_boolean</a> (self)</td></tr>
<tr class="separator:a575b713fc22bdfdcd8d8c074e948e695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4df90359847af7ca252c2300e8265d" id="r_a4a4df90359847af7ca252c2300e8265d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a4a4df90359847af7ca252c2300e8265d">test_multidim</a> (self)</td></tr>
<tr class="separator:a4a4df90359847af7ca252c2300e8265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a803bc76d173be60ad904c4ee932771" id="r_a0a803bc76d173be60ad904c4ee932771"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a0a803bc76d173be60ad904c4ee932771">test_1d</a> (self)</td></tr>
<tr class="separator:a0a803bc76d173be60ad904c4ee932771"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9b8cf096dcad6b41774ddefa30c70414" id="r_a9b8cf096dcad6b41774ddefa30c70414"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a9b8cf096dcad6b41774ddefa30c70414">a</a></td></tr>
<tr class="separator:a9b8cf096dcad6b41774ddefa30c70414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878205ba5dd5b4f95cb4047f9e3be49b" id="r_a878205ba5dd5b4f95cb4047f9e3be49b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a878205ba5dd5b4f95cb4047f9e3be49b">b</a></td></tr>
<tr class="separator:a878205ba5dd5b4f95cb4047f9e3be49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a274e1e8a87850cd999b1e77924833" id="r_a81a274e1e8a87850cd999b1e77924833"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a81a274e1e8a87850cd999b1e77924833">complex_indices</a></td></tr>
<tr class="separator:a81a274e1e8a87850cd999b1e77924833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d0ef566c5f3b6025f6d7d2d0b1166e" id="r_aa5d0ef566c5f3b6025f6d7d2d0b1166e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#aa5d0ef566c5f3b6025f6d7d2d0b1166e">simple_indices</a></td></tr>
<tr class="separator:aa5d0ef566c5f3b6025f6d7d2d0b1166e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eb4baf53b4a71ff974dfd7f0681649" id="r_a02eb4baf53b4a71ff974dfd7f0681649"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a02eb4baf53b4a71ff974dfd7f0681649">fill_indices</a></td></tr>
<tr class="separator:a02eb4baf53b4a71ff974dfd7f0681649"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9ed25e5e6dc85ba3c9f9caf83437fc19" id="r_a9ed25e5e6dc85ba3c9f9caf83437fc19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a9ed25e5e6dc85ba3c9f9caf83437fc19">_get_multi_index</a> (self, arr, <a class="el" href="namespacenumpy_1_1core_1_1numeric.html#a9b57e299af9537cd1030c654e4be8abb">indices</a>)</td></tr>
<tr class="separator:a9ed25e5e6dc85ba3c9f9caf83437fc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac884e0b15c0e23679112d695603257b7" id="r_ac884e0b15c0e23679112d695603257b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#ac884e0b15c0e23679112d695603257b7">_check_multi_index</a> (self, arr, index)</td></tr>
<tr class="separator:ac884e0b15c0e23679112d695603257b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41458e76352765c1040cf7f3a6a3ad50" id="r_a41458e76352765c1040cf7f3a6a3ad50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a41458e76352765c1040cf7f3a6a3ad50">_check_single_index</a> (self, arr, index)</td></tr>
<tr class="separator:a41458e76352765c1040cf7f3a6a3ad50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35422b59c1dcf307ff154a1db09bb644" id="r_a35422b59c1dcf307ff154a1db09bb644"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classnumpy_1_1core_1_1tests_1_1test__indexing_1_1_test_multi_indexing_automated.html#a35422b59c1dcf307ff154a1db09bb644">_compare_index_result</a> (self, arr, index, mimic_get, no_copy)</td></tr>
<tr class="separator:a35422b59c1dcf307ff154a1db09bb644"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">These tests use code to mimic the C-Code indexing for selection.

NOTE:

    * This still lacks tests for complex item setting.
    * If you change behavior of indexing, you might want to modify
      these tests to try more combinations.
    * Behavior was written to match numpy version 1.8. (though a
      first version matched 1.7.)
    * Only tuple indices are supported by the mimicking code.
      (and tested as of writing this)
    * Error types should match most of the time as long as there
      is only one error. For multiple errors, what gets raised
      will usually not be the same one. They are *not* tested.

Update 2016-11-30: It is probably not worth maintaining this test
indefinitely and it can be dropped if maintenance becomes a burden.</pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ac884e0b15c0e23679112d695603257b7" name="ac884e0b15c0e23679112d695603257b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac884e0b15c0e23679112d695603257b7">&#9670;&#160;</a></span>_check_multi_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated._check_multi_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check a multi index item getting and simple setting.

Parameters
----------
arr : ndarray
    Array to be indexed, must be a reshaped arange.
index : tuple of indexing objects
    Index being tested.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1098</span>    <span class="keyword">def </span>_check_multi_index(self, arr, index):</div>
<div class="line"><span class="lineno"> 1099</span>        <span class="stringliteral">&quot;&quot;&quot;Check a multi index item getting and simple setting.</span></div>
<div class="line"><span class="lineno"> 1100</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1101</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1102</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1103</span><span class="stringliteral">        arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1104</span><span class="stringliteral">            Array to be indexed, must be a reshaped arange.</span></div>
<div class="line"><span class="lineno"> 1105</span><span class="stringliteral">        index : tuple of indexing objects</span></div>
<div class="line"><span class="lineno"> 1106</span><span class="stringliteral">            Index being tested.</span></div>
<div class="line"><span class="lineno"> 1107</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1108</span>        <span class="comment"># Test item getting</span></div>
<div class="line"><span class="lineno"> 1109</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1110</span>            mimic_get, no_copy = self._get_multi_index(arr, index)</div>
<div class="line"><span class="lineno"> 1111</span>        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1112</span>            <span class="keywordflow">if</span> HAS_REFCOUNT:</div>
<div class="line"><span class="lineno"> 1113</span>                prev_refcount = sys.getrefcount(arr)</div>
<div class="line"><span class="lineno"> 1114</span>            assert_raises(type(e), arr.__getitem__, index)</div>
<div class="line"><span class="lineno"> 1115</span>            assert_raises(type(e), arr.__setitem__, index, 0)</div>
<div class="line"><span class="lineno"> 1116</span>            <span class="keywordflow">if</span> HAS_REFCOUNT:</div>
<div class="line"><span class="lineno"> 1117</span>                assert_equal(prev_refcount, sys.getrefcount(arr))</div>
<div class="line"><span class="lineno"> 1118</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1119</span> </div>
<div class="line"><span class="lineno"> 1120</span>        self._compare_index_result(arr, index, mimic_get, no_copy)</div>
<div class="line"><span class="lineno"> 1121</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a41458e76352765c1040cf7f3a6a3ad50" name="a41458e76352765c1040cf7f3a6a3ad50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41458e76352765c1040cf7f3a6a3ad50">&#9670;&#160;</a></span>_check_single_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated._check_single_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check a single index item getting and simple setting.

Parameters
----------
arr : ndarray
    Array to be indexed, must be an arange.
index : indexing object
    Index being tested. Must be a single index and not a tuple
    of indexing objects (see also `_check_multi_index`).
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1122</span>    <span class="keyword">def </span>_check_single_index(self, arr, index):</div>
<div class="line"><span class="lineno"> 1123</span>        <span class="stringliteral">&quot;&quot;&quot;Check a single index item getting and simple setting.</span></div>
<div class="line"><span class="lineno"> 1124</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno"> 1125</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno"> 1126</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno"> 1127</span><span class="stringliteral">        arr : ndarray</span></div>
<div class="line"><span class="lineno"> 1128</span><span class="stringliteral">            Array to be indexed, must be an arange.</span></div>
<div class="line"><span class="lineno"> 1129</span><span class="stringliteral">        index : indexing object</span></div>
<div class="line"><span class="lineno"> 1130</span><span class="stringliteral">            Index being tested. Must be a single index and not a tuple</span></div>
<div class="line"><span class="lineno"> 1131</span><span class="stringliteral">            of indexing objects (see also `_check_multi_index`).</span></div>
<div class="line"><span class="lineno"> 1132</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1133</span>        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1134</span>            mimic_get, no_copy = self._get_multi_index(arr, (index,))</div>
<div class="line"><span class="lineno"> 1135</span>        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line"><span class="lineno"> 1136</span>            <span class="keywordflow">if</span> HAS_REFCOUNT:</div>
<div class="line"><span class="lineno"> 1137</span>                prev_refcount = sys.getrefcount(arr)</div>
<div class="line"><span class="lineno"> 1138</span>            assert_raises(type(e), arr.__getitem__, index)</div>
<div class="line"><span class="lineno"> 1139</span>            assert_raises(type(e), arr.__setitem__, index, 0)</div>
<div class="line"><span class="lineno"> 1140</span>            <span class="keywordflow">if</span> HAS_REFCOUNT:</div>
<div class="line"><span class="lineno"> 1141</span>                assert_equal(prev_refcount, sys.getrefcount(arr))</div>
<div class="line"><span class="lineno"> 1142</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1143</span> </div>
<div class="line"><span class="lineno"> 1144</span>        self._compare_index_result(arr, index, mimic_get, no_copy)</div>
<div class="line"><span class="lineno"> 1145</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a35422b59c1dcf307ff154a1db09bb644" name="a35422b59c1dcf307ff154a1db09bb644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35422b59c1dcf307ff154a1db09bb644">&#9670;&#160;</a></span>_compare_index_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated._compare_index_result </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mimic_get</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>no_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compare mimicked result to indexing result.
</pre> <div class="fragment"><div class="line"><span class="lineno"> 1146</span>    <span class="keyword">def </span>_compare_index_result(self, arr, index, mimic_get, no_copy):</div>
<div class="line"><span class="lineno"> 1147</span>        <span class="stringliteral">&quot;&quot;&quot;Compare mimicked result to indexing result.</span></div>
<div class="line"><span class="lineno"> 1148</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno"> 1149</span>        arr = arr.copy()</div>
<div class="line"><span class="lineno"> 1150</span>        indexed_arr = arr[index]</div>
<div class="line"><span class="lineno"> 1151</span>        assert_array_equal(indexed_arr, mimic_get)</div>
<div class="line"><span class="lineno"> 1152</span>        <span class="comment"># Check if we got a view, unless its a 0-sized or 0-d array.</span></div>
<div class="line"><span class="lineno"> 1153</span>        <span class="comment"># (then its not a view, and that does not matter)</span></div>
<div class="line"><span class="lineno"> 1154</span>        <span class="keywordflow">if</span> indexed_arr.size != 0 <span class="keywordflow">and</span> indexed_arr.ndim != 0:</div>
<div class="line"><span class="lineno"> 1155</span>            assert_(np.may_share_memory(indexed_arr, arr) == no_copy)</div>
<div class="line"><span class="lineno"> 1156</span>            <span class="comment"># Check reference count of the original array</span></div>
<div class="line"><span class="lineno"> 1157</span>            <span class="keywordflow">if</span> HAS_REFCOUNT:</div>
<div class="line"><span class="lineno"> 1158</span>                <span class="keywordflow">if</span> no_copy:</div>
<div class="line"><span class="lineno"> 1159</span>                    <span class="comment"># refcount increases by one:</span></div>
<div class="line"><span class="lineno"> 1160</span>                    assert_equal(sys.getrefcount(arr), 3)</div>
<div class="line"><span class="lineno"> 1161</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1162</span>                    assert_equal(sys.getrefcount(arr), 2)</div>
<div class="line"><span class="lineno"> 1163</span> </div>
<div class="line"><span class="lineno"> 1164</span>        <span class="comment"># Test non-broadcast setitem:</span></div>
<div class="line"><span class="lineno"> 1165</span>        b = arr.copy()</div>
<div class="line"><span class="lineno"> 1166</span>        b[index] = mimic_get + 1000</div>
<div class="line"><span class="lineno"> 1167</span>        <span class="keywordflow">if</span> b.size == 0:</div>
<div class="line"><span class="lineno"> 1168</span>            <span class="keywordflow">return</span>  <span class="comment"># nothing to compare here...</span></div>
<div class="line"><span class="lineno"> 1169</span>        <span class="keywordflow">if</span> no_copy <span class="keywordflow">and</span> indexed_arr.ndim != 0:</div>
<div class="line"><span class="lineno"> 1170</span>            <span class="comment"># change indexed_arr in-place to manipulate original:</span></div>
<div class="line"><span class="lineno"> 1171</span>            indexed_arr += 1000</div>
<div class="line"><span class="lineno"> 1172</span>            assert_array_equal(arr, b)</div>
<div class="line"><span class="lineno"> 1173</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno"> 1174</span>        <span class="comment"># Use the fact that the array is originally an arange:</span></div>
<div class="line"><span class="lineno"> 1175</span>        arr.flat[indexed_arr.ravel()] += 1000</div>
<div class="line"><span class="lineno"> 1176</span>        assert_array_equal(arr, b)</div>
<div class="line"><span class="lineno"> 1177</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9ed25e5e6dc85ba3c9f9caf83437fc19" name="a9ed25e5e6dc85ba3c9f9caf83437fc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed25e5e6dc85ba3c9f9caf83437fc19">&#9670;&#160;</a></span>_get_multi_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated._get_multi_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Mimic multi dimensional indexing.

Parameters
----------
arr : ndarray
    Array to be indexed.
indices : tuple of index objects

Returns
-------
out : ndarray
    An array equivalent to the indexing operation (but always a copy).
    `arr[indices]` should be identical.
no_copy : bool
    Whether the indexing operation requires a copy. If this is `True`,
    `np.may_share_memory(arr, arr[indices])` should be `True` (with
    some exceptions for scalars and possibly 0-d arrays).

Notes
-----
While the function may mostly match the errors of normal indexing this
is generally not the case.
</pre> <div class="fragment"><div class="line"><span class="lineno">  859</span>    <span class="keyword">def </span>_get_multi_index(self, arr, indices):</div>
<div class="line"><span class="lineno">  860</span>        <span class="stringliteral">&quot;&quot;&quot;Mimic multi dimensional indexing.</span></div>
<div class="line"><span class="lineno">  861</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  862</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  863</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  864</span><span class="stringliteral">        arr : ndarray</span></div>
<div class="line"><span class="lineno">  865</span><span class="stringliteral">            Array to be indexed.</span></div>
<div class="line"><span class="lineno">  866</span><span class="stringliteral">        indices : tuple of index objects</span></div>
<div class="line"><span class="lineno">  867</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  868</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  869</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  870</span><span class="stringliteral">        out : ndarray</span></div>
<div class="line"><span class="lineno">  871</span><span class="stringliteral">            An array equivalent to the indexing operation (but always a copy).</span></div>
<div class="line"><span class="lineno">  872</span><span class="stringliteral">            `arr[indices]` should be identical.</span></div>
<div class="line"><span class="lineno">  873</span><span class="stringliteral">        no_copy : bool</span></div>
<div class="line"><span class="lineno">  874</span><span class="stringliteral">            Whether the indexing operation requires a copy. If this is `True`,</span></div>
<div class="line"><span class="lineno">  875</span><span class="stringliteral">            `np.may_share_memory(arr, arr[indices])` should be `True` (with</span></div>
<div class="line"><span class="lineno">  876</span><span class="stringliteral">            some exceptions for scalars and possibly 0-d arrays).</span></div>
<div class="line"><span class="lineno">  877</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  878</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  879</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  880</span><span class="stringliteral">        While the function may mostly match the errors of normal indexing this</span></div>
<div class="line"><span class="lineno">  881</span><span class="stringliteral">        is generally not the case.</span></div>
<div class="line"><span class="lineno">  882</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  883</span>        in_indices = list(indices)</div>
<div class="line"><span class="lineno">  884</span>        indices = []</div>
<div class="line"><span class="lineno">  885</span>        <span class="comment"># if False, this is a fancy or boolean index</span></div>
<div class="line"><span class="lineno">  886</span>        no_copy = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  887</span>        <span class="comment"># number of fancy/scalar indexes that are not consecutive</span></div>
<div class="line"><span class="lineno">  888</span>        num_fancy = 0</div>
<div class="line"><span class="lineno">  889</span>        <span class="comment"># number of dimensions indexed by a &quot;fancy&quot; index</span></div>
<div class="line"><span class="lineno">  890</span>        fancy_dim = 0</div>
<div class="line"><span class="lineno">  891</span>        <span class="comment"># NOTE: This is a funny twist (and probably OK to change).</span></div>
<div class="line"><span class="lineno">  892</span>        <span class="comment"># The boolean array has illegal indexes, but this is</span></div>
<div class="line"><span class="lineno">  893</span>        <span class="comment"># allowed if the broadcast fancy-indices are 0-sized.</span></div>
<div class="line"><span class="lineno">  894</span>        <span class="comment"># This variable is to catch that case.</span></div>
<div class="line"><span class="lineno">  895</span>        error_unless_broadcast_to_empty = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  896</span> </div>
<div class="line"><span class="lineno">  897</span>        <span class="comment"># We need to handle Ellipsis and make arrays from indices, also</span></div>
<div class="line"><span class="lineno">  898</span>        <span class="comment"># check if this is fancy indexing (set no_copy).</span></div>
<div class="line"><span class="lineno">  899</span>        ndim = 0</div>
<div class="line"><span class="lineno">  900</span>        ellipsis_pos = <span class="keywordtype">None</span>  <span class="comment"># define here mostly to replace all but first.</span></div>
<div class="line"><span class="lineno">  901</span>        <span class="keywordflow">for</span> i, indx <span class="keywordflow">in</span> enumerate(in_indices):</div>
<div class="line"><span class="lineno">  902</span>            <span class="keywordflow">if</span> indx <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  903</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  904</span>            <span class="keywordflow">if</span> isinstance(indx, np.ndarray) <span class="keywordflow">and</span> indx.dtype == bool:</div>
<div class="line"><span class="lineno">  905</span>                no_copy = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  906</span>                <span class="keywordflow">if</span> indx.ndim == 0:</div>
<div class="line"><span class="lineno">  907</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  908</span>                <span class="comment"># boolean indices can have higher dimensions</span></div>
<div class="line"><span class="lineno">  909</span>                ndim += indx.ndim</div>
<div class="line"><span class="lineno">  910</span>                fancy_dim += indx.ndim</div>
<div class="line"><span class="lineno">  911</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  912</span>            <span class="keywordflow">if</span> indx <span class="keywordflow">is</span> Ellipsis:</div>
<div class="line"><span class="lineno">  913</span>                <span class="keywordflow">if</span> ellipsis_pos <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  914</span>                    ellipsis_pos = i</div>
<div class="line"><span class="lineno">  915</span>                    <span class="keywordflow">continue</span>  <span class="comment"># do not increment ndim counter</span></div>
<div class="line"><span class="lineno">  916</span>                <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  917</span>            <span class="keywordflow">if</span> isinstance(indx, slice):</div>
<div class="line"><span class="lineno">  918</span>                ndim += 1</div>
<div class="line"><span class="lineno">  919</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  920</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(indx, np.ndarray):</div>
<div class="line"><span class="lineno">  921</span>                <span class="comment"># This could be open for changes in numpy.</span></div>
<div class="line"><span class="lineno">  922</span>                <span class="comment"># numpy should maybe raise an error if casting to intp</span></div>
<div class="line"><span class="lineno">  923</span>                <span class="comment"># is not safe. It rejects np.array([1., 2.]) but not</span></div>
<div class="line"><span class="lineno">  924</span>                <span class="comment"># [1., 2.] as index (same for ie. np.take).</span></div>
<div class="line"><span class="lineno">  925</span>                <span class="comment"># (Note the importance of empty lists if changing this here)</span></div>
<div class="line"><span class="lineno">  926</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  927</span>                    indx = np.array(indx, dtype=np.intp)</div>
<div class="line"><span class="lineno">  928</span>                <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno">  929</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  930</span>                in_indices[i] = indx</div>
<div class="line"><span class="lineno">  931</span>            <span class="keywordflow">elif</span> indx.dtype.kind != <span class="stringliteral">&#39;b&#39;</span> <span class="keywordflow">and</span> indx.dtype.kind != <span class="stringliteral">&#39;i&#39;</span>:</div>
<div class="line"><span class="lineno">  932</span>                <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&#39;arrays used as indices must be of &#39;</span></div>
<div class="line"><span class="lineno">  933</span>                                 <span class="stringliteral">&#39;integer (or boolean) type&#39;</span>)</div>
<div class="line"><span class="lineno">  934</span>            <span class="keywordflow">if</span> indx.ndim != 0:</div>
<div class="line"><span class="lineno">  935</span>                no_copy = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  936</span>            ndim += 1</div>
<div class="line"><span class="lineno">  937</span>            fancy_dim += 1</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>        <span class="keywordflow">if</span> arr.ndim - ndim &lt; 0:</div>
<div class="line"><span class="lineno">  940</span>            <span class="comment"># we can&#39;t take more dimensions then we have, not even for 0-d</span></div>
<div class="line"><span class="lineno">  941</span>            <span class="comment"># arrays.  since a[()] makes sense, but not a[(),]. We will</span></div>
<div class="line"><span class="lineno">  942</span>            <span class="comment"># raise an error later on, unless a broadcasting error occurs</span></div>
<div class="line"><span class="lineno">  943</span>            <span class="comment"># first.</span></div>
<div class="line"><span class="lineno">  944</span>            <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  945</span> </div>
<div class="line"><span class="lineno">  946</span>        <span class="keywordflow">if</span> ndim == 0 <span class="keywordflow">and</span> <span class="keywordtype">None</span> <span class="keywordflow">not</span> <span class="keywordflow">in</span> in_indices:</div>
<div class="line"><span class="lineno">  947</span>            <span class="comment"># Well we have no indexes or one Ellipsis. This is legal.</span></div>
<div class="line"><span class="lineno">  948</span>            <span class="keywordflow">return</span> arr.copy(), no_copy</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span>        <span class="keywordflow">if</span> ellipsis_pos <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  951</span>            in_indices[ellipsis_pos:ellipsis_pos+1] = ([slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>)] *</div>
<div class="line"><span class="lineno">  952</span>                                                       (arr.ndim - ndim))</div>
<div class="line"><span class="lineno">  953</span> </div>
<div class="line"><span class="lineno">  954</span>        <span class="keywordflow">for</span> ax, indx <span class="keywordflow">in</span> enumerate(in_indices):</div>
<div class="line"><span class="lineno">  955</span>            <span class="keywordflow">if</span> isinstance(indx, slice):</div>
<div class="line"><span class="lineno">  956</span>                <span class="comment"># convert to an index array</span></div>
<div class="line"><span class="lineno">  957</span>                indx = np.arange(*indx.indices(arr.shape[ax]))</div>
<div class="line"><span class="lineno">  958</span>                indices.append([<span class="stringliteral">&#39;s&#39;</span>, indx])</div>
<div class="line"><span class="lineno">  959</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  960</span>            <span class="keywordflow">elif</span> indx <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  961</span>                <span class="comment"># this is like taking a slice with one element from a new axis:</span></div>
<div class="line"><span class="lineno">  962</span>                indices.append([<span class="stringliteral">&#39;n&#39;</span>, np.array([0], dtype=np.intp)])</div>
<div class="line"><span class="lineno">  963</span>                arr = arr.reshape((arr.shape[:ax] + (1,) + arr.shape[ax:]))</div>
<div class="line"><span class="lineno">  964</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  965</span>            <span class="keywordflow">if</span> isinstance(indx, np.ndarray) <span class="keywordflow">and</span> indx.dtype == bool:</div>
<div class="line"><span class="lineno">  966</span>                <span class="keywordflow">if</span> indx.shape != arr.shape[ax:ax+indx.ndim]:</div>
<div class="line"><span class="lineno">  967</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  968</span> </div>
<div class="line"><span class="lineno">  969</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno">  970</span>                    flat_indx = np.ravel_multi_index(np.nonzero(indx),</div>
<div class="line"><span class="lineno">  971</span>                                    arr.shape[ax:ax+indx.ndim], mode=<span class="stringliteral">&#39;raise&#39;</span>)</div>
<div class="line"><span class="lineno">  972</span>                <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno">  973</span>                    error_unless_broadcast_to_empty = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  974</span>                    <span class="comment"># fill with 0s instead, and raise error later</span></div>
<div class="line"><span class="lineno">  975</span>                    flat_indx = np.array([0]*indx.sum(), dtype=np.intp)</div>
<div class="line"><span class="lineno">  976</span>                <span class="comment"># concatenate axis into a single one:</span></div>
<div class="line"><span class="lineno">  977</span>                <span class="keywordflow">if</span> indx.ndim != 0:</div>
<div class="line"><span class="lineno">  978</span>                    arr = arr.reshape((arr.shape[:ax]</div>
<div class="line"><span class="lineno">  979</span>                                  + (np.prod(arr.shape[ax:ax+indx.ndim]),)</div>
<div class="line"><span class="lineno">  980</span>                                  + arr.shape[ax+indx.ndim:]))</div>
<div class="line"><span class="lineno">  981</span>                    indx = flat_indx</div>
<div class="line"><span class="lineno">  982</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  983</span>                    <span class="comment"># This could be changed, a 0-d boolean index can</span></div>
<div class="line"><span class="lineno">  984</span>                    <span class="comment"># make sense (even outside the 0-d indexed array case)</span></div>
<div class="line"><span class="lineno">  985</span>                    <span class="comment"># Note that originally this is could be interpreted as</span></div>
<div class="line"><span class="lineno">  986</span>                    <span class="comment"># integer in the full integer special case.</span></div>
<div class="line"><span class="lineno">  987</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  988</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  989</span>                <span class="comment"># If the index is a singleton, the bounds check is done</span></div>
<div class="line"><span class="lineno">  990</span>                <span class="comment"># before the broadcasting. This used to be different in &lt;1.9</span></div>
<div class="line"><span class="lineno">  991</span>                <span class="keywordflow">if</span> indx.ndim == 0:</div>
<div class="line"><span class="lineno">  992</span>                    <span class="keywordflow">if</span> indx &gt;= arr.shape[ax] <span class="keywordflow">or</span> indx &lt; -arr.shape[ax]:</div>
<div class="line"><span class="lineno">  993</span>                        <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno">  994</span>            <span class="keywordflow">if</span> indx.ndim == 0:</div>
<div class="line"><span class="lineno">  995</span>                <span class="comment"># The index is a scalar. This used to be two fold, but if</span></div>
<div class="line"><span class="lineno">  996</span>                <span class="comment"># fancy indexing was active, the check was done later,</span></div>
<div class="line"><span class="lineno">  997</span>                <span class="comment"># possibly after broadcasting it away (1.7. or earlier).</span></div>
<div class="line"><span class="lineno">  998</span>                <span class="comment"># Now it is always done.</span></div>
<div class="line"><span class="lineno">  999</span>                <span class="keywordflow">if</span> indx &gt;= arr.shape[ax] <span class="keywordflow">or</span> indx &lt; - arr.shape[ax]:</div>
<div class="line"><span class="lineno"> 1000</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 1001</span>            <span class="keywordflow">if</span> (len(indices) &gt; 0 <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno"> 1002</span>                    indices[-1][0] == <span class="stringliteral">&#39;f&#39;</span> <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno"> 1003</span>                    ax != ellipsis_pos):</div>
<div class="line"><span class="lineno"> 1004</span>                <span class="comment"># NOTE: There could still have been a 0-sized Ellipsis</span></div>
<div class="line"><span class="lineno"> 1005</span>                <span class="comment"># between them. Checked that with ellipsis_pos.</span></div>
<div class="line"><span class="lineno"> 1006</span>                indices[-1].append(indx)</div>
<div class="line"><span class="lineno"> 1007</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1008</span>                <span class="comment"># We have a fancy index that is not after an existing one.</span></div>
<div class="line"><span class="lineno"> 1009</span>                <span class="comment"># NOTE: A 0-d array triggers this as well, while one may</span></div>
<div class="line"><span class="lineno"> 1010</span>                <span class="comment"># expect it to not trigger it, since a scalar would not be</span></div>
<div class="line"><span class="lineno"> 1011</span>                <span class="comment"># considered fancy indexing.</span></div>
<div class="line"><span class="lineno"> 1012</span>                num_fancy += 1</div>
<div class="line"><span class="lineno"> 1013</span>                indices.append([<span class="stringliteral">&#39;f&#39;</span>, indx])</div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1015</span>        <span class="keywordflow">if</span> num_fancy &gt; 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> no_copy:</div>
<div class="line"><span class="lineno"> 1016</span>            <span class="comment"># We have to flush the fancy indexes left</span></div>
<div class="line"><span class="lineno"> 1017</span>            new_indices = indices[:]</div>
<div class="line"><span class="lineno"> 1018</span>            axes = list(range(arr.ndim))</div>
<div class="line"><span class="lineno"> 1019</span>            fancy_axes = []</div>
<div class="line"><span class="lineno"> 1020</span>            new_indices.insert(0, [<span class="stringliteral">&#39;f&#39;</span>])</div>
<div class="line"><span class="lineno"> 1021</span>            ni = 0</div>
<div class="line"><span class="lineno"> 1022</span>            ai = 0</div>
<div class="line"><span class="lineno"> 1023</span>            <span class="keywordflow">for</span> indx <span class="keywordflow">in</span> indices:</div>
<div class="line"><span class="lineno"> 1024</span>                ni += 1</div>
<div class="line"><span class="lineno"> 1025</span>                <span class="keywordflow">if</span> indx[0] == <span class="stringliteral">&#39;f&#39;</span>:</div>
<div class="line"><span class="lineno"> 1026</span>                    new_indices[0].extend(indx[1:])</div>
<div class="line"><span class="lineno"> 1027</span>                    del new_indices[ni]</div>
<div class="line"><span class="lineno"> 1028</span>                    ni -= 1</div>
<div class="line"><span class="lineno"> 1029</span>                    <span class="keywordflow">for</span> ax <span class="keywordflow">in</span> range(ai, ai + len(indx[1:])):</div>
<div class="line"><span class="lineno"> 1030</span>                        fancy_axes.append(ax)</div>
<div class="line"><span class="lineno"> 1031</span>                        axes.remove(ax)</div>
<div class="line"><span class="lineno"> 1032</span>                ai += len(indx) - 1  <span class="comment"># axis we are at</span></div>
<div class="line"><span class="lineno"> 1033</span>            indices = new_indices</div>
<div class="line"><span class="lineno"> 1034</span>            <span class="comment"># and now we need to transpose arr:</span></div>
<div class="line"><span class="lineno"> 1035</span>            arr = arr.transpose(*(fancy_axes + axes))</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span>        <span class="comment"># We only have one &#39;f&#39; index now and arr is transposed accordingly.</span></div>
<div class="line"><span class="lineno"> 1038</span>        <span class="comment"># Now handle newaxis by reshaping...</span></div>
<div class="line"><span class="lineno"> 1039</span>        ax = 0</div>
<div class="line"><span class="lineno"> 1040</span>        <span class="keywordflow">for</span> indx <span class="keywordflow">in</span> indices:</div>
<div class="line"><span class="lineno"> 1041</span>            <span class="keywordflow">if</span> indx[0] == <span class="stringliteral">&#39;f&#39;</span>:</div>
<div class="line"><span class="lineno"> 1042</span>                <span class="keywordflow">if</span> len(indx) == 1:</div>
<div class="line"><span class="lineno"> 1043</span>                    <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1044</span>                <span class="comment"># First of all, reshape arr to combine fancy axes into one:</span></div>
<div class="line"><span class="lineno"> 1045</span>                orig_shape = arr.shape</div>
<div class="line"><span class="lineno"> 1046</span>                orig_slice = orig_shape[ax:ax + len(indx[1:])]</div>
<div class="line"><span class="lineno"> 1047</span>                arr = arr.reshape((arr.shape[:ax]</div>
<div class="line"><span class="lineno"> 1048</span>                                    + (np.prod(orig_slice).astype(int),)</div>
<div class="line"><span class="lineno"> 1049</span>                                    + arr.shape[ax + len(indx[1:]):]))</div>
<div class="line"><span class="lineno"> 1050</span> </div>
<div class="line"><span class="lineno"> 1051</span>                <span class="comment"># Check if broadcasting works</span></div>
<div class="line"><span class="lineno"> 1052</span>                res = np.broadcast(*indx[1:])</div>
<div class="line"><span class="lineno"> 1053</span>                <span class="comment"># unfortunately the indices might be out of bounds. So check</span></div>
<div class="line"><span class="lineno"> 1054</span>                <span class="comment"># that first, and use mode=&#39;wrap&#39; then. However only if</span></div>
<div class="line"><span class="lineno"> 1055</span>                <span class="comment"># there are any indices...</span></div>
<div class="line"><span class="lineno"> 1056</span>                <span class="keywordflow">if</span> res.size != 0:</div>
<div class="line"><span class="lineno"> 1057</span>                    <span class="keywordflow">if</span> error_unless_broadcast_to_empty:</div>
<div class="line"><span class="lineno"> 1058</span>                        <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 1059</span>                    <span class="keywordflow">for</span> _indx, _size <span class="keywordflow">in</span> zip(indx[1:], orig_slice):</div>
<div class="line"><span class="lineno"> 1060</span>                        <span class="keywordflow">if</span> _indx.size == 0:</div>
<div class="line"><span class="lineno"> 1061</span>                            <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1062</span>                        <span class="keywordflow">if</span> np.any(_indx &gt;= _size) <span class="keywordflow">or</span> np.any(_indx &lt; -_size):</div>
<div class="line"><span class="lineno"> 1063</span>                                <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 1064</span>                <span class="keywordflow">if</span> len(indx[1:]) == len(orig_slice):</div>
<div class="line"><span class="lineno"> 1065</span>                    <span class="keywordflow">if</span> np.product(orig_slice) == 0:</div>
<div class="line"><span class="lineno"> 1066</span>                        <span class="comment"># Work around for a crash or IndexError with &#39;wrap&#39;</span></div>
<div class="line"><span class="lineno"> 1067</span>                        <span class="comment"># in some 0-sized cases.</span></div>
<div class="line"><span class="lineno"> 1068</span>                        <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1069</span>                            mi = np.ravel_multi_index(indx[1:], orig_slice,</div>
<div class="line"><span class="lineno"> 1070</span>                                                      mode=<span class="stringliteral">&#39;raise&#39;</span>)</div>
<div class="line"><span class="lineno"> 1071</span>                        <span class="keywordflow">except</span> Exception:</div>
<div class="line"><span class="lineno"> 1072</span>                            <span class="comment"># This happens with 0-sized orig_slice (sometimes?)</span></div>
<div class="line"><span class="lineno"> 1073</span>                            <span class="comment"># here it is a ValueError, but indexing gives a:</span></div>
<div class="line"><span class="lineno"> 1074</span>                            <span class="keywordflow">raise</span> IndexError(<span class="stringliteral">&#39;invalid index into 0-sized&#39;</span>)</div>
<div class="line"><span class="lineno"> 1075</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1076</span>                        mi = np.ravel_multi_index(indx[1:], orig_slice,</div>
<div class="line"><span class="lineno"> 1077</span>                                                  mode=<span class="stringliteral">&#39;wrap&#39;</span>)</div>
<div class="line"><span class="lineno"> 1078</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno"> 1079</span>                    <span class="comment"># Maybe never happens...</span></div>
<div class="line"><span class="lineno"> 1080</span>                    <span class="keywordflow">raise</span> ValueError</div>
<div class="line"><span class="lineno"> 1081</span>                arr = arr.take(mi.ravel(), axis=ax)</div>
<div class="line"><span class="lineno"> 1082</span>                <span class="keywordflow">try</span>:</div>
<div class="line"><span class="lineno"> 1083</span>                    arr = arr.reshape((arr.shape[:ax]</div>
<div class="line"><span class="lineno"> 1084</span>                                        + mi.shape</div>
<div class="line"><span class="lineno"> 1085</span>                                        + arr.shape[ax+1:]))</div>
<div class="line"><span class="lineno"> 1086</span>                <span class="keywordflow">except</span> ValueError:</div>
<div class="line"><span class="lineno"> 1087</span>                    <span class="comment"># too many dimensions, probably</span></div>
<div class="line"><span class="lineno"> 1088</span>                    <span class="keywordflow">raise</span> IndexError</div>
<div class="line"><span class="lineno"> 1089</span>                ax += mi.ndim</div>
<div class="line"><span class="lineno"> 1090</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno"> 1091</span> </div>
<div class="line"><span class="lineno"> 1092</span>            <span class="comment"># If we are here, we have a 1D array for take:</span></div>
<div class="line"><span class="lineno"> 1093</span>            arr = arr.take(indx[1], axis=ax)</div>
<div class="line"><span class="lineno"> 1094</span>            ax += 1</div>
<div class="line"><span class="lineno"> 1095</span> </div>
<div class="line"><span class="lineno"> 1096</span>        <span class="keywordflow">return</span> arr, no_copy</div>
<div class="line"><span class="lineno"> 1097</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a10c61720ffd2c2640804c4927f9ae034" name="a10c61720ffd2c2640804c4927f9ae034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c61720ffd2c2640804c4927f9ae034">&#9670;&#160;</a></span>setup_method()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.setup_method </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  830</span>    <span class="keyword">def </span>setup_method(self):</div>
<div class="line"><span class="lineno">  831</span>        self.a = np.arange(np.prod([3, 1, 5, 6])).reshape(3, 1, 5, 6)</div>
<div class="line"><span class="lineno">  832</span>        self.b = np.empty((3, 0, 5, 6))</div>
<div class="line"><span class="lineno">  833</span>        self.complex_indices = [<span class="stringliteral">&#39;skip&#39;</span>, Ellipsis,</div>
<div class="line"><span class="lineno">  834</span>            0,</div>
<div class="line"><span class="lineno">  835</span>            <span class="comment"># Boolean indices, up to 3-d for some special cases of eating up</span></div>
<div class="line"><span class="lineno">  836</span>            <span class="comment"># dimensions, also need to test all False</span></div>
<div class="line"><span class="lineno">  837</span>            np.array([<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>]),</div>
<div class="line"><span class="lineno">  838</span>            np.array([[<span class="keyword">True</span>, <span class="keyword">False</span>], [<span class="keyword">False</span>, <span class="keyword">True</span>]]),</div>
<div class="line"><span class="lineno">  839</span>            np.array([[[<span class="keyword">False</span>, <span class="keyword">False</span>], [<span class="keyword">False</span>, <span class="keyword">False</span>]]]),</div>
<div class="line"><span class="lineno">  840</span>            <span class="comment"># Some slices:</span></div>
<div class="line"><span class="lineno">  841</span>            slice(-5, 5, 2),</div>
<div class="line"><span class="lineno">  842</span>            slice(1, 1, 100),</div>
<div class="line"><span class="lineno">  843</span>            slice(4, -1, -2),</div>
<div class="line"><span class="lineno">  844</span>            slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>, -3),</div>
<div class="line"><span class="lineno">  845</span>            <span class="comment"># Some Fancy indexes:</span></div>
<div class="line"><span class="lineno">  846</span>            np.empty((0, 1, 1), dtype=np.intp),  <span class="comment"># empty and can be broadcast</span></div>
<div class="line"><span class="lineno">  847</span>            np.array([0, 1, -2]),</div>
<div class="line"><span class="lineno">  848</span>            np.array([[2], [0], [1]]),</div>
<div class="line"><span class="lineno">  849</span>            np.array([[0, -1], [0, 1]], dtype=np.dtype(<span class="stringliteral">&#39;intp&#39;</span>).newbyteorder()),</div>
<div class="line"><span class="lineno">  850</span>            np.array([2, -1], dtype=np.int8),</div>
<div class="line"><span class="lineno">  851</span>            np.zeros([1]*31, dtype=int),  <span class="comment"># trigger too large array.</span></div>
<div class="line"><span class="lineno">  852</span>            np.array([0., 1.])]  <span class="comment"># invalid datatype</span></div>
<div class="line"><span class="lineno">  853</span>        <span class="comment"># Some simpler indices that still cover a bit more</span></div>
<div class="line"><span class="lineno">  854</span>        self.simple_indices = [Ellipsis, <span class="keywordtype">None</span>, -1, [1], np.array([<span class="keyword">True</span>]),</div>
<div class="line"><span class="lineno">  855</span>                               <span class="stringliteral">&#39;skip&#39;</span>]</div>
<div class="line"><span class="lineno">  856</span>        <span class="comment"># Very simple ones to fill the rest:</span></div>
<div class="line"><span class="lineno">  857</span>        self.fill_indices = [slice(<span class="keywordtype">None</span>, <span class="keywordtype">None</span>), 0]</div>
<div class="line"><span class="lineno">  858</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a803bc76d173be60ad904c4ee932771" name="a0a803bc76d173be60ad904c4ee932771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a803bc76d173be60ad904c4ee932771">&#9670;&#160;</a></span>test_1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.test_1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1225</span>    <span class="keyword">def </span>test_1d(self):</div>
<div class="line"><span class="lineno"> 1226</span>        a = np.arange(10)</div>
<div class="line"><span class="lineno"> 1227</span>        <span class="keywordflow">for</span> index <span class="keywordflow">in</span> self.complex_indices:</div>
<div class="line"><span class="lineno"> 1228</span>            self._check_single_index(a, index)</div>
<div class="line"><span class="lineno"> 1229</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a575b713fc22bdfdcd8d8c074e948e695" name="a575b713fc22bdfdcd8d8c074e948e695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575b713fc22bdfdcd8d8c074e948e695">&#9670;&#160;</a></span>test_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.test_boolean </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1178</span>    <span class="keyword">def </span>test_boolean(self):</div>
<div class="line"><span class="lineno"> 1179</span>        a = np.array(5)</div>
<div class="line"><span class="lineno"> 1180</span>        assert_equal(a[np.array(<span class="keyword">True</span>)], 5)</div>
<div class="line"><span class="lineno"> 1181</span>        a[np.array(<span class="keyword">True</span>)] = 1</div>
<div class="line"><span class="lineno"> 1182</span>        assert_equal(a, 1)</div>
<div class="line"><span class="lineno"> 1183</span>        <span class="comment"># NOTE: This is different from normal broadcasting, as</span></div>
<div class="line"><span class="lineno"> 1184</span>        <span class="comment"># arr[boolean_array] works like in a multi index. Which means</span></div>
<div class="line"><span class="lineno"> 1185</span>        <span class="comment"># it is aligned to the left. This is probably correct for</span></div>
<div class="line"><span class="lineno"> 1186</span>        <span class="comment"># consistency with arr[boolean_array,] also no broadcasting</span></div>
<div class="line"><span class="lineno"> 1187</span>        <span class="comment"># is done at all</span></div>
<div class="line"><span class="lineno"> 1188</span>        self._check_multi_index(</div>
<div class="line"><span class="lineno"> 1189</span>            self.a, (np.zeros_like(self.a, dtype=bool),))</div>
<div class="line"><span class="lineno"> 1190</span>        self._check_multi_index(</div>
<div class="line"><span class="lineno"> 1191</span>            self.a, (np.zeros_like(self.a, dtype=bool)[..., 0],))</div>
<div class="line"><span class="lineno"> 1192</span>        self._check_multi_index(</div>
<div class="line"><span class="lineno"> 1193</span>            self.a, (np.zeros_like(self.a, dtype=bool)[<span class="keywordtype">None</span>, ...],))</div>
<div class="line"><span class="lineno"> 1194</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4a4df90359847af7ca252c2300e8265d" name="a4a4df90359847af7ca252c2300e8265d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4df90359847af7ca252c2300e8265d">&#9670;&#160;</a></span>test_multidim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.test_multidim </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno"> 1195</span>    <span class="keyword">def </span>test_multidim(self):</div>
<div class="line"><span class="lineno"> 1196</span>        <span class="comment"># Automatically test combinations with complex indexes on 2nd (or 1st)</span></div>
<div class="line"><span class="lineno"> 1197</span>        <span class="comment"># spot and the simple ones in one other spot.</span></div>
<div class="line"><span class="lineno"> 1198</span>        <span class="keyword">with</span> warnings.catch_warnings():</div>
<div class="line"><span class="lineno"> 1199</span>            <span class="comment"># This is so that np.array(True) is not accepted in a full integer</span></div>
<div class="line"><span class="lineno"> 1200</span>            <span class="comment"># index, when running the file separately.</span></div>
<div class="line"><span class="lineno"> 1201</span>            warnings.filterwarnings(<span class="stringliteral">&#39;error&#39;</span>, <span class="stringliteral">&#39;&#39;</span>, DeprecationWarning)</div>
<div class="line"><span class="lineno"> 1202</span>            warnings.filterwarnings(<span class="stringliteral">&#39;error&#39;</span>, <span class="stringliteral">&#39;&#39;</span>, np.VisibleDeprecationWarning)</div>
<div class="line"><span class="lineno"> 1203</span> </div>
<div class="line"><span class="lineno"> 1204</span>            <span class="keyword">def </span>isskip(idx):</div>
<div class="line"><span class="lineno"> 1205</span>                <span class="keywordflow">return</span> isinstance(idx, str) <span class="keywordflow">and</span> idx == <span class="stringliteral">&quot;skip&quot;</span></div>
<div class="line"><span class="lineno"> 1206</span> </div>
<div class="line"><span class="lineno"> 1207</span>            <span class="keywordflow">for</span> simple_pos <span class="keywordflow">in</span> [0, 2, 3]:</div>
<div class="line"><span class="lineno"> 1208</span>                tocheck = [self.fill_indices, self.complex_indices,</div>
<div class="line"><span class="lineno"> 1209</span>                           self.fill_indices, self.fill_indices]</div>
<div class="line"><span class="lineno"> 1210</span>                tocheck[simple_pos] = self.simple_indices</div>
<div class="line"><span class="lineno"> 1211</span>                <span class="keywordflow">for</span> index <span class="keywordflow">in</span> product(*tocheck):</div>
<div class="line"><span class="lineno"> 1212</span>                    index = tuple(i <span class="keywordflow">for</span> i <span class="keywordflow">in</span> index <span class="keywordflow">if</span> <span class="keywordflow">not</span> isskip(i))</div>
<div class="line"><span class="lineno"> 1213</span>                    self._check_multi_index(self.a, index)</div>
<div class="line"><span class="lineno"> 1214</span>                    self._check_multi_index(self.b, index)</div>
<div class="line"><span class="lineno"> 1215</span> </div>
<div class="line"><span class="lineno"> 1216</span>        <span class="comment"># Check very simple item getting:</span></div>
<div class="line"><span class="lineno"> 1217</span>        self._check_multi_index(self.a, (0, 0, 0, 0))</div>
<div class="line"><span class="lineno"> 1218</span>        self._check_multi_index(self.b, (0, 0, 0, 0))</div>
<div class="line"><span class="lineno"> 1219</span>        <span class="comment"># Also check (simple cases of) too many indices:</span></div>
<div class="line"><span class="lineno"> 1220</span>        assert_raises(IndexError, self.a.__getitem__, (0, 0, 0, 0, 0))</div>
<div class="line"><span class="lineno"> 1221</span>        assert_raises(IndexError, self.a.__setitem__, (0, 0, 0, 0, 0), 0)</div>
<div class="line"><span class="lineno"> 1222</span>        assert_raises(IndexError, self.a.__getitem__, (0, 0, [1], 0, 0))</div>
<div class="line"><span class="lineno"> 1223</span>        assert_raises(IndexError, self.a.__setitem__, (0, 0, [1], 0, 0), 0)</div>
<div class="line"><span class="lineno"> 1224</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9b8cf096dcad6b41774ddefa30c70414" name="a9b8cf096dcad6b41774ddefa30c70414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8cf096dcad6b41774ddefa30c70414">&#9670;&#160;</a></span>a</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.a</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a878205ba5dd5b4f95cb4047f9e3be49b" name="a878205ba5dd5b4f95cb4047f9e3be49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878205ba5dd5b4f95cb4047f9e3be49b">&#9670;&#160;</a></span>b</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.b</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81a274e1e8a87850cd999b1e77924833" name="a81a274e1e8a87850cd999b1e77924833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a274e1e8a87850cd999b1e77924833">&#9670;&#160;</a></span>complex_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.complex_indices</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02eb4baf53b4a71ff974dfd7f0681649" name="a02eb4baf53b4a71ff974dfd7f0681649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eb4baf53b4a71ff974dfd7f0681649">&#9670;&#160;</a></span>fill_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.fill_indices</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d0ef566c5f3b6025f6d7d2d0b1166e" name="aa5d0ef566c5f3b6025f6d7d2d0b1166e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d0ef566c5f3b6025f6d7d2d0b1166e">&#9670;&#160;</a></span>simple_indices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">numpy.core.tests.test_indexing.TestMultiIndexingAutomated.simple_indices</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/numpy/core/tests/<a class="el" href="numpy_2core_2tests_2test__indexing_8py.html">test_indexing.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
