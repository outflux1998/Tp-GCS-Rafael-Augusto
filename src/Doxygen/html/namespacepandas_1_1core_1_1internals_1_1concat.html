<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: pandas.core.internals.concat Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacepandas.html">pandas</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core.html">core</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1internals.html">internals</a></li><li class="navelem"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html">concat</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pandas.core.internals.concat Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9814b8b14ab9c87863e4ab7ee4272111" id="r_a9814b8b14ab9c87863e4ab7ee4272111"><td class="memItemLeft" align="right" valign="top">Manager&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a9814b8b14ab9c87863e4ab7ee4272111">_concatenate_array_managers</a> (mgrs_indexers, list[Index] axes, int concat_axis, bool copy)</td></tr>
<tr class="separator:a9814b8b14ab9c87863e4ab7ee4272111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c1f8038b316e7454304c9663b7a738" id="r_a68c1f8038b316e7454304c9663b7a738"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a68c1f8038b316e7454304c9663b7a738">concat_arrays</a> (list to_concat)</td></tr>
<tr class="separator:a68c1f8038b316e7454304c9663b7a738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5000b573fd8d6d5d89af911187838bc0" id="r_a5000b573fd8d6d5d89af911187838bc0"><td class="memItemLeft" align="right" valign="top">Manager&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a5000b573fd8d6d5d89af911187838bc0">concatenate_managers</a> (mgrs_indexers, list[Index] axes, int concat_axis, bool copy)</td></tr>
<tr class="separator:a5000b573fd8d6d5d89af911187838bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ff5a0f932f5aa85a3c5e8b0d19908e" id="r_a94ff5a0f932f5aa85a3c5e8b0d19908e"><td class="memItemLeft" align="right" valign="top">list[tuple[<a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a>, dict[int, np.ndarray]]]&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a94ff5a0f932f5aa85a3c5e8b0d19908e">_maybe_reindex_columns_na_proxy</a> (list[Index] axes, list[tuple[<a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a>, dict[int, np.ndarray]]] mgrs_indexers)</td></tr>
<tr class="separator:a94ff5a0f932f5aa85a3c5e8b0d19908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af08018d3e1b0d946eb3cd26dd4227e" id="r_a1af08018d3e1b0d946eb3cd26dd4227e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a1af08018d3e1b0d946eb3cd26dd4227e">_get_mgr_concatenation_plan</a> (<a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a> mgr, dict[int, np.ndarray] indexers)</td></tr>
<tr class="separator:a1af08018d3e1b0d946eb3cd26dd4227e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa208ab2b54e534bf512867652b8df14" id="r_aaa208ab2b54e534bf512867652b8df14"><td class="memItemLeft" align="right" valign="top">ArrayLike&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#aaa208ab2b54e534bf512867652b8df14">_concatenate_join_units</a> (list[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>] join_units, int concat_axis, bool copy)</td></tr>
<tr class="separator:aaa208ab2b54e534bf512867652b8df14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2f78434e96f1224f7f36418214b544" id="r_a7a2f78434e96f1224f7f36418214b544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a7a2f78434e96f1224f7f36418214b544">_dtype_to_na_value</a> (DtypeObj dtype, bool has_none_blocks)</td></tr>
<tr class="separator:a7a2f78434e96f1224f7f36418214b544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f28da92cf1508e8a73518e588c4971" id="r_a01f28da92cf1508e8a73518e588c4971"><td class="memItemLeft" align="right" valign="top">DtypeObj&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a01f28da92cf1508e8a73518e588c4971">_get_empty_dtype</a> (Sequence[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>] join_units)</td></tr>
<tr class="separator:a01f28da92cf1508e8a73518e588c4971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff355ce8e0306119835e40ffdf11d02" id="r_acff355ce8e0306119835e40ffdf11d02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#acff355ce8e0306119835e40ffdf11d02">_is_uniform_join_units</a> (list[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>] join_units)</td></tr>
<tr class="separator:acff355ce8e0306119835e40ffdf11d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6838aa474a36c04b10adca2dc806bbd" id="r_af6838aa474a36c04b10adca2dc806bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#af6838aa474a36c04b10adca2dc806bbd">_is_uniform_reindex</a> (join_units)</td></tr>
<tr class="separator:af6838aa474a36c04b10adca2dc806bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f260518b7fa00795a9817907c98d095" id="r_a2f260518b7fa00795a9817907c98d095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a2f260518b7fa00795a9817907c98d095">_trim_join_unit</a> (<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a> join_unit, int length)</td></tr>
<tr class="separator:a2f260518b7fa00795a9817907c98d095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d3566ae5e0be63a19733316a0b540a" id="r_a14d3566ae5e0be63a19733316a0b540a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepandas_1_1core_1_1internals_1_1concat.html#a14d3566ae5e0be63a19733316a0b540a">_combine_concat_plans</a> (plans, int concat_axis)</td></tr>
<tr class="separator:a14d3566ae5e0be63a19733316a0b540a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a14d3566ae5e0be63a19733316a0b540a" name="a14d3566ae5e0be63a19733316a0b540a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d3566ae5e0be63a19733316a0b540a">&#9670;&#160;</a></span>_combine_concat_plans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.internals.concat._combine_concat_plans </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>plans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concat_axis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Combine multiple concatenation plans into one.

existing_plan is updated in-place.
</pre> <div class="fragment"><div class="line"><span class="lineno">  705</span><span class="keyword">def </span>_combine_concat_plans(plans, concat_axis: int):</div>
<div class="line"><span class="lineno">  706</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  707</span><span class="stringliteral">    Combine multiple concatenation plans into one.</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral">    existing_plan is updated in-place.</span></div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  711</span>    <span class="keywordflow">if</span> len(plans) == 1:</div>
<div class="line"><span class="lineno">  712</span>        <span class="keywordflow">for</span> p <span class="keywordflow">in</span> plans[0]:</div>
<div class="line"><span class="lineno">  713</span>            <span class="keywordflow">yield</span> p[0], [p[1]]</div>
<div class="line"><span class="lineno">  714</span> </div>
<div class="line"><span class="lineno">  715</span>    <span class="keywordflow">elif</span> concat_axis == 0:</div>
<div class="line"><span class="lineno">  716</span>        offset = 0</div>
<div class="line"><span class="lineno">  717</span>        <span class="keywordflow">for</span> plan <span class="keywordflow">in</span> plans:</div>
<div class="line"><span class="lineno">  718</span>            last_plc = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  719</span> </div>
<div class="line"><span class="lineno">  720</span>            <span class="keywordflow">for</span> plc, unit <span class="keywordflow">in</span> plan:</div>
<div class="line"><span class="lineno">  721</span>                <span class="keywordflow">yield</span> plc.add(offset), [unit]</div>
<div class="line"><span class="lineno">  722</span>                last_plc = plc</div>
<div class="line"><span class="lineno">  723</span> </div>
<div class="line"><span class="lineno">  724</span>            <span class="keywordflow">if</span> last_plc <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  725</span>                offset += last_plc.as_slice.stop</div>
<div class="line"><span class="lineno">  726</span> </div>
<div class="line"><span class="lineno">  727</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  728</span>        <span class="comment"># singleton list so we can modify it as a side-effect within _next_or_none</span></div>
<div class="line"><span class="lineno">  729</span>        num_ended = [0]</div>
<div class="line"><span class="lineno">  730</span> </div>
<div class="line"><span class="lineno">  731</span>        <span class="keyword">def </span>_next_or_none(seq):</div>
<div class="line"><span class="lineno">  732</span>            retval = next(seq, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  733</span>            <span class="keywordflow">if</span> retval <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  734</span>                num_ended[0] += 1</div>
<div class="line"><span class="lineno">  735</span>            <span class="keywordflow">return</span> retval</div>
<div class="line"><span class="lineno">  736</span> </div>
<div class="line"><span class="lineno">  737</span>        plans = list(map(iter, plans))</div>
<div class="line"><span class="lineno">  738</span>        next_items = list(map(_next_or_none, plans))</div>
<div class="line"><span class="lineno">  739</span> </div>
<div class="line"><span class="lineno">  740</span>        <span class="keywordflow">while</span> num_ended[0] != len(next_items):</div>
<div class="line"><span class="lineno">  741</span>            <span class="keywordflow">if</span> num_ended[0] &gt; 0:</div>
<div class="line"><span class="lineno">  742</span>                <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Plan shapes are not aligned&quot;</span>)</div>
<div class="line"><span class="lineno">  743</span> </div>
<div class="line"><span class="lineno">  744</span>            placements, units = zip(*next_items)</div>
<div class="line"><span class="lineno">  745</span> </div>
<div class="line"><span class="lineno">  746</span>            lengths = list(map(len, placements))</div>
<div class="line"><span class="lineno">  747</span>            min_len, max_len = min(lengths), max(lengths)</div>
<div class="line"><span class="lineno">  748</span> </div>
<div class="line"><span class="lineno">  749</span>            <span class="keywordflow">if</span> min_len == max_len:</div>
<div class="line"><span class="lineno">  750</span>                <span class="keywordflow">yield</span> placements[0], units</div>
<div class="line"><span class="lineno">  751</span>                next_items[:] = map(_next_or_none, plans)</div>
<div class="line"><span class="lineno">  752</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  753</span>                yielded_placement = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  754</span>                yielded_units = [<span class="keywordtype">None</span>] * len(next_items)</div>
<div class="line"><span class="lineno">  755</span>                <span class="keywordflow">for</span> i, (plc, unit) <span class="keywordflow">in</span> enumerate(next_items):</div>
<div class="line"><span class="lineno">  756</span>                    yielded_units[i] = unit</div>
<div class="line"><span class="lineno">  757</span>                    <span class="keywordflow">if</span> len(plc) &gt; min_len:</div>
<div class="line"><span class="lineno">  758</span>                        <span class="comment"># _trim_join_unit updates unit in place, so only</span></div>
<div class="line"><span class="lineno">  759</span>                        <span class="comment"># placement needs to be sliced to skip min_len.</span></div>
<div class="line"><span class="lineno">  760</span>                        next_items[i] = (plc[min_len:], _trim_join_unit(unit, min_len))</div>
<div class="line"><span class="lineno">  761</span>                    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  762</span>                        yielded_placement = plc</div>
<div class="line"><span class="lineno">  763</span>                        next_items[i] = _next_or_none(plans[i])</div>
<div class="line"><span class="lineno">  764</span> </div>
<div class="line"><span class="lineno">  765</span>                <span class="keywordflow">yield</span> yielded_placement, yielded_units</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9814b8b14ab9c87863e4ab7ee4272111" name="a9814b8b14ab9c87863e4ab7ee4272111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814b8b14ab9c87863e4ab7ee4272111">&#9670;&#160;</a></span>_concatenate_array_managers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> Manager pandas.core.internals.concat._concatenate_array_managers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mgrs_indexers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[Index]&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concat_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Concatenate array managers into one.

Parameters
----------
mgrs_indexers : list of (ArrayManager, {axis: indexer,...}) tuples
axes : list of Index
concat_axis : int
copy : bool

Returns
-------
ArrayManager
</pre> <div class="fragment"><div class="line"><span class="lineno">   74</span>) -&gt; Manager:</div>
<div class="line"><span class="lineno">   75</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   76</span><span class="stringliteral">    Concatenate array managers into one.</span></div>
<div class="line"><span class="lineno">   77</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   78</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">   79</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">   80</span><span class="stringliteral">    mgrs_indexers : list of (ArrayManager, {axis: indexer,...}) tuples</span></div>
<div class="line"><span class="lineno">   81</span><span class="stringliteral">    axes : list of Index</span></div>
<div class="line"><span class="lineno">   82</span><span class="stringliteral">    concat_axis : int</span></div>
<div class="line"><span class="lineno">   83</span><span class="stringliteral">    copy : bool</span></div>
<div class="line"><span class="lineno">   84</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">   85</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">   86</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">   87</span><span class="stringliteral">    ArrayManager</span></div>
<div class="line"><span class="lineno">   88</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">   89</span>    <span class="comment"># reindex all arrays</span></div>
<div class="line"><span class="lineno">   90</span>    mgrs = []</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">for</span> mgr, indexers <span class="keywordflow">in</span> mgrs_indexers:</div>
<div class="line"><span class="lineno">   92</span>        axis1_made_copy = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">   93</span>        <span class="keywordflow">for</span> ax, indexer <span class="keywordflow">in</span> indexers.items():</div>
<div class="line"><span class="lineno">   94</span>            mgr = mgr.reindex_indexer(</div>
<div class="line"><span class="lineno">   95</span>                axes[ax], indexer, axis=ax, allow_dups=<span class="keyword">True</span>, use_na_proxy=<span class="keyword">True</span></div>
<div class="line"><span class="lineno">   96</span>            )</div>
<div class="line"><span class="lineno">   97</span>            <span class="keywordflow">if</span> ax == 1 <span class="keywordflow">and</span> indexer <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">   98</span>                axis1_made_copy = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">   99</span>        <span class="keywordflow">if</span> copy <span class="keywordflow">and</span> concat_axis == 0 <span class="keywordflow">and</span> <span class="keywordflow">not</span> axis1_made_copy:</div>
<div class="line"><span class="lineno">  100</span>            <span class="comment"># for concat_axis 1 we will always get a copy through concat_arrays</span></div>
<div class="line"><span class="lineno">  101</span>            mgr = mgr.copy()</div>
<div class="line"><span class="lineno">  102</span>        mgrs.append(mgr)</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span>    <span class="keywordflow">if</span> concat_axis == 1:</div>
<div class="line"><span class="lineno">  105</span>        <span class="comment"># concatting along the rows -&gt; concat the reindexed arrays</span></div>
<div class="line"><span class="lineno">  106</span>        <span class="comment"># TODO(ArrayManager) doesn&#39;t yet preserve the correct dtype</span></div>
<div class="line"><span class="lineno">  107</span>        arrays = [</div>
<div class="line"><span class="lineno">  108</span>            concat_arrays([mgrs[i].arrays[j] <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(len(mgrs))])</div>
<div class="line"><span class="lineno">  109</span>            <span class="keywordflow">for</span> j <span class="keywordflow">in</span> range(len(mgrs[0].arrays))</div>
<div class="line"><span class="lineno">  110</span>        ]</div>
<div class="line"><span class="lineno">  111</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  112</span>        <span class="comment"># concatting along the columns -&gt; combine reindexed arrays in a single manager</span></div>
<div class="line"><span class="lineno">  113</span>        <span class="keyword">assert</span> concat_axis == 0</div>
<div class="line"><span class="lineno">  114</span>        arrays = list(itertools.chain.from_iterable([mgr.arrays <span class="keywordflow">for</span> mgr <span class="keywordflow">in</span> mgrs]))</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span>    new_mgr = ArrayManager(arrays, [axes[1], axes[0]], verify_integrity=<span class="keyword">False</span>)</div>
<div class="line"><span class="lineno">  117</span>    <span class="keywordflow">return</span> new_mgr</div>
<div class="line"><span class="lineno">  118</span> </div>
<div class="line"><span class="lineno">  119</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aaa208ab2b54e534bf512867652b8df14" name="aaa208ab2b54e534bf512867652b8df14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa208ab2b54e534bf512867652b8df14">&#9670;&#160;</a></span>_concatenate_join_units()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.internals.concat._concatenate_join_units </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>]&#160;</td>
          <td class="paramname"><em>join_units</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concat_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Concatenate values from several join units along selected axis.
</pre> <div class="fragment"><div class="line"><span class="lineno">  529</span>) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  530</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">    Concatenate values from several join units along selected axis.</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  533</span>    <span class="keywordflow">if</span> concat_axis == 0 <span class="keywordflow">and</span> len(join_units) &gt; 1:</div>
<div class="line"><span class="lineno">  534</span>        <span class="comment"># Concatenating join units along ax0 is handled in _merge_blocks.</span></div>
<div class="line"><span class="lineno">  535</span>        <span class="keywordflow">raise</span> AssertionError(<span class="stringliteral">&quot;Concatenating join units along axis0&quot;</span>)</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>    empty_dtype = _get_empty_dtype(join_units)</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>    has_none_blocks = any(unit.block.dtype.kind == <span class="stringliteral">&quot;V&quot;</span> <span class="keywordflow">for</span> unit <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  540</span>    upcasted_na = _dtype_to_na_value(empty_dtype, has_none_blocks)</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>    to_concat = [</div>
<div class="line"><span class="lineno">  543</span>        ju.get_reindexed_values(empty_dtype=empty_dtype, upcasted_na=upcasted_na)</div>
<div class="line"><span class="lineno">  544</span>        <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units</div>
<div class="line"><span class="lineno">  545</span>    ]</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>    <span class="keywordflow">if</span> len(to_concat) == 1:</div>
<div class="line"><span class="lineno">  548</span>        <span class="comment"># Only one block, nothing to concatenate.</span></div>
<div class="line"><span class="lineno">  549</span>        concat_values = to_concat[0]</div>
<div class="line"><span class="lineno">  550</span>        <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  551</span>            <span class="keywordflow">if</span> isinstance(concat_values, np.ndarray):</div>
<div class="line"><span class="lineno">  552</span>                <span class="comment"># non-reindexed (=not yet copied) arrays are made into a view</span></div>
<div class="line"><span class="lineno">  553</span>                <span class="comment"># in JoinUnit.get_reindexed_values</span></div>
<div class="line"><span class="lineno">  554</span>                <span class="keywordflow">if</span> concat_values.base <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  555</span>                    concat_values = concat_values.copy()</div>
<div class="line"><span class="lineno">  556</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  557</span>                concat_values = concat_values.copy()</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    <span class="keywordflow">elif</span> any(is_1d_only_ea_dtype(t.dtype) <span class="keywordflow">for</span> t <span class="keywordflow">in</span> to_concat):</div>
<div class="line"><span class="lineno">  560</span>        <span class="comment"># TODO(EA2D): special case not needed if all EAs used HybridBlocks</span></div>
<div class="line"><span class="lineno">  561</span>        <span class="comment"># NB: we are still assuming here that Hybrid blocks have shape (1, N)</span></div>
<div class="line"><span class="lineno">  562</span>        <span class="comment"># concatting with at least one EA means we are concatting a single column</span></div>
<div class="line"><span class="lineno">  563</span>        <span class="comment"># the non-EA values are 2D arrays with shape (1, n)</span></div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>        <span class="comment"># error: No overload variant of &quot;__getitem__&quot; of &quot;ExtensionArray&quot; matches</span></div>
<div class="line"><span class="lineno">  566</span>        <span class="comment"># argument type &quot;Tuple[int, slice]&quot;</span></div>
<div class="line"><span class="lineno">  567</span>        to_concat = [</div>
<div class="line"><span class="lineno">  568</span>            t</div>
<div class="line"><span class="lineno">  569</span>            <span class="keywordflow">if</span> is_1d_only_ea_dtype(t.dtype)</div>
<div class="line"><span class="lineno">  570</span>            <span class="keywordflow">else</span> t[0, :]  <span class="comment"># type: ignore[call-overload]</span></div>
<div class="line"><span class="lineno">  571</span>            <span class="keywordflow">for</span> t <span class="keywordflow">in</span> to_concat</div>
<div class="line"><span class="lineno">  572</span>        ]</div>
<div class="line"><span class="lineno">  573</span>        concat_values = concat_compat(to_concat, axis=0, ea_compat_axis=<span class="keyword">True</span>)</div>
<div class="line"><span class="lineno">  574</span>        concat_values = ensure_block_shape(concat_values, 2)</div>
<div class="line"><span class="lineno">  575</span> </div>
<div class="line"><span class="lineno">  576</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  577</span>        concat_values = concat_compat(to_concat, axis=concat_axis)</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>    <span class="keywordflow">return</span> concat_values</div>
<div class="line"><span class="lineno">  580</span> </div>
<div class="line"><span class="lineno">  581</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a7a2f78434e96f1224f7f36418214b544" name="a7a2f78434e96f1224f7f36418214b544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2f78434e96f1224f7f36418214b544">&#9670;&#160;</a></span>_dtype_to_na_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.internals.concat._dtype_to_na_value </td>
          <td>(</td>
          <td class="paramtype">DtypeObj&#160;</td>
          <td class="paramname"><em>dtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_none_blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Find the NA value to go with this dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno">  582</span><span class="keyword">def </span>_dtype_to_na_value(dtype: DtypeObj, has_none_blocks: bool):</div>
<div class="line"><span class="lineno">  583</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral">    Find the NA value to go with this dtype.</span></div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  586</span>    <span class="keywordflow">if</span> isinstance(dtype, ExtensionDtype):</div>
<div class="line"><span class="lineno">  587</span>        <span class="keywordflow">return</span> dtype.na_value</div>
<div class="line"><span class="lineno">  588</span>    <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;m&quot;</span>, <span class="stringliteral">&quot;M&quot;</span>]:</div>
<div class="line"><span class="lineno">  589</span>        <span class="keywordflow">return</span> dtype.type(<span class="stringliteral">&quot;NaT&quot;</span>)</div>
<div class="line"><span class="lineno">  590</span>    <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>]:</div>
<div class="line"><span class="lineno">  591</span>        <span class="keywordflow">return</span> dtype.type(<span class="stringliteral">&quot;NaN&quot;</span>)</div>
<div class="line"><span class="lineno">  592</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;b&quot;</span>:</div>
<div class="line"><span class="lineno">  593</span>        <span class="comment"># different from missing.na_value_for_dtype</span></div>
<div class="line"><span class="lineno">  594</span>        <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  595</span>    <span class="keywordflow">elif</span> dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]:</div>
<div class="line"><span class="lineno">  596</span>        <span class="keywordflow">if</span> <span class="keywordflow">not</span> has_none_blocks:</div>
<div class="line"><span class="lineno">  597</span>            <span class="comment"># different from missing.na_value_for_dtype</span></div>
<div class="line"><span class="lineno">  598</span>            <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  599</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno">  600</span>    <span class="keywordflow">elif</span> dtype.kind == <span class="stringliteral">&quot;O&quot;</span>:</div>
<div class="line"><span class="lineno">  601</span>        <span class="keywordflow">return</span> np.nan</div>
<div class="line"><span class="lineno">  602</span>    <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno">  603</span> </div>
<div class="line"><span class="lineno">  604</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a01f28da92cf1508e8a73518e588c4971" name="a01f28da92cf1508e8a73518e588c4971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01f28da92cf1508e8a73518e588c4971">&#9670;&#160;</a></span>_get_empty_dtype()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> DtypeObj pandas.core.internals.concat._get_empty_dtype </td>
          <td>(</td>
          <td class="paramtype">Sequence[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>]&#160;</td>
          <td class="paramname"><em>join_units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return dtype and N/A values to use when concatenating specified units.

Returned N/A value may be None which means there was no casting involved.

Returns
-------
dtype
</pre> <div class="fragment"><div class="line"><span class="lineno">  605</span><span class="keyword">def </span>_get_empty_dtype(join_units: Sequence[JoinUnit]) -&gt; DtypeObj:</div>
<div class="line"><span class="lineno">  606</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">    Return dtype and N/A values to use when concatenating specified units.</span></div>
<div class="line"><span class="lineno">  608</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  609</span><span class="stringliteral">    Returned N/A value may be None which means there was no casting involved.</span></div>
<div class="line"><span class="lineno">  610</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  611</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  612</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  613</span><span class="stringliteral">    dtype</span></div>
<div class="line"><span class="lineno">  614</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  615</span>    <span class="keywordflow">if</span> len(join_units) == 1:</div>
<div class="line"><span class="lineno">  616</span>        blk = join_units[0].block</div>
<div class="line"><span class="lineno">  617</span>        <span class="keywordflow">return</span> blk.dtype</div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>    <span class="keywordflow">if</span> _is_uniform_reindex(join_units):</div>
<div class="line"><span class="lineno">  620</span>        empty_dtype = join_units[0].block.dtype</div>
<div class="line"><span class="lineno">  621</span>        <span class="keywordflow">return</span> empty_dtype</div>
<div class="line"><span class="lineno">  622</span> </div>
<div class="line"><span class="lineno">  623</span>    has_none_blocks = any(unit.block.dtype.kind == <span class="stringliteral">&quot;V&quot;</span> <span class="keywordflow">for</span> unit <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  624</span> </div>
<div class="line"><span class="lineno">  625</span>    dtypes = [unit.dtype <span class="keywordflow">for</span> unit <span class="keywordflow">in</span> join_units <span class="keywordflow">if</span> <span class="keywordflow">not</span> unit.is_na]</div>
<div class="line"><span class="lineno">  626</span>    <span class="keywordflow">if</span> <span class="keywordflow">not</span> len(dtypes):</div>
<div class="line"><span class="lineno">  627</span>        dtypes = [unit.dtype <span class="keywordflow">for</span> unit <span class="keywordflow">in</span> join_units <span class="keywordflow">if</span> unit.block.dtype.kind != <span class="stringliteral">&quot;V&quot;</span>]</div>
<div class="line"><span class="lineno">  628</span> </div>
<div class="line"><span class="lineno">  629</span>    dtype = find_common_type(dtypes)</div>
<div class="line"><span class="lineno">  630</span>    <span class="keywordflow">if</span> has_none_blocks:</div>
<div class="line"><span class="lineno">  631</span>        dtype = ensure_dtype_can_hold_na(dtype)</div>
<div class="line"><span class="lineno">  632</span>    <span class="keywordflow">return</span> dtype</div>
<div class="line"><span class="lineno">  633</span> </div>
<div class="line"><span class="lineno">  634</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1af08018d3e1b0d946eb3cd26dd4227e" name="a1af08018d3e1b0d946eb3cd26dd4227e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af08018d3e1b0d946eb3cd26dd4227e">&#9670;&#160;</a></span>_get_mgr_concatenation_plan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pandas.core.internals.concat._get_mgr_concatenation_plan </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a>&#160;</td>
          <td class="paramname"><em>mgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dict[int, np.ndarray]&#160;</td>
          <td class="paramname"><em>indexers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Construct concatenation plan for given block manager and indexers.

Parameters
----------
mgr : BlockManager
indexers : dict of {axis: indexer}

Returns
-------
plan : list of (BlockPlacement, JoinUnit) tuples</pre> <div class="fragment"><div class="line"><span class="lineno">  278</span><span class="keyword">def </span>_get_mgr_concatenation_plan(mgr: BlockManager, indexers: dict[int, np.ndarray]):</div>
<div class="line"><span class="lineno">  279</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  280</span><span class="stringliteral">    Construct concatenation plan for given block manager and indexers.</span></div>
<div class="line"><span class="lineno">  281</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  282</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  283</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  284</span><span class="stringliteral">    mgr : BlockManager</span></div>
<div class="line"><span class="lineno">  285</span><span class="stringliteral">    indexers : dict of {axis: indexer}</span></div>
<div class="line"><span class="lineno">  286</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  287</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  288</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  289</span><span class="stringliteral">    plan : list of (BlockPlacement, JoinUnit) tuples</span></div>
<div class="line"><span class="lineno">  290</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  292</span>    <span class="comment"># Calculate post-reindex shape , save for item axis which will be separate</span></div>
<div class="line"><span class="lineno">  293</span>    <span class="comment"># for each block anyway.</span></div>
<div class="line"><span class="lineno">  294</span>    mgr_shape_list = list(mgr.shape)</div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">for</span> ax, indexer <span class="keywordflow">in</span> indexers.items():</div>
<div class="line"><span class="lineno">  296</span>        mgr_shape_list[ax] = len(indexer)</div>
<div class="line"><span class="lineno">  297</span>    mgr_shape = tuple(mgr_shape_list)</div>
<div class="line"><span class="lineno">  298</span> </div>
<div class="line"><span class="lineno">  299</span>    <span class="keyword">assert</span> 0 <span class="keywordflow">not</span> <span class="keywordflow">in</span> indexers</div>
<div class="line"><span class="lineno">  300</span> </div>
<div class="line"><span class="lineno">  301</span>    <span class="keywordflow">if</span> mgr.is_single_block:</div>
<div class="line"><span class="lineno">  302</span>        blk = mgr.blocks[0]</div>
<div class="line"><span class="lineno">  303</span>        <span class="keywordflow">return</span> [(blk.mgr_locs, JoinUnit(blk, mgr_shape, indexers))]</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span>    blknos = mgr.blknos</div>
<div class="line"><span class="lineno">  306</span>    blklocs = mgr.blklocs</div>
<div class="line"><span class="lineno">  307</span> </div>
<div class="line"><span class="lineno">  308</span>    plan = []</div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">for</span> blkno, placements <span class="keywordflow">in</span> libinternals.get_blkno_placements(blknos, group=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>        <span class="keyword">assert</span> placements.is_slice_like</div>
<div class="line"><span class="lineno">  312</span>        <span class="keyword">assert</span> blkno != -1</div>
<div class="line"><span class="lineno">  313</span> </div>
<div class="line"><span class="lineno">  314</span>        join_unit_indexers = indexers.copy()</div>
<div class="line"><span class="lineno">  315</span> </div>
<div class="line"><span class="lineno">  316</span>        shape_list = list(mgr_shape)</div>
<div class="line"><span class="lineno">  317</span>        shape_list[0] = len(placements)</div>
<div class="line"><span class="lineno">  318</span>        shape = tuple(shape_list)</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>        blk = mgr.blocks[blkno]</div>
<div class="line"><span class="lineno">  321</span>        ax0_blk_indexer = blklocs[placements.indexer]</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>        unit_no_ax0_reindexing = (</div>
<div class="line"><span class="lineno">  324</span>            len(placements) == len(blk.mgr_locs)</div>
<div class="line"><span class="lineno">  325</span>            <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  326</span>            <span class="comment"># Fastpath detection of join unit not</span></div>
<div class="line"><span class="lineno">  327</span>            <span class="comment"># needing to reindex its block: no ax0</span></div>
<div class="line"><span class="lineno">  328</span>            <span class="comment"># reindexing took place and block</span></div>
<div class="line"><span class="lineno">  329</span>            <span class="comment"># placement was sequential before.</span></div>
<div class="line"><span class="lineno">  330</span>            (</div>
<div class="line"><span class="lineno">  331</span>                (blk.mgr_locs.is_slice_like <span class="keywordflow">and</span> blk.mgr_locs.as_slice.step == 1)</div>
<div class="line"><span class="lineno">  332</span>                <span class="keywordflow">or</span></div>
<div class="line"><span class="lineno">  333</span>                <span class="comment"># Slow-ish detection: all indexer locs</span></div>
<div class="line"><span class="lineno">  334</span>                <span class="comment"># are sequential (and length match is</span></div>
<div class="line"><span class="lineno">  335</span>                <span class="comment"># checked above).</span></div>
<div class="line"><span class="lineno">  336</span>                (np.diff(ax0_blk_indexer) == 1).all()</div>
<div class="line"><span class="lineno">  337</span>            )</div>
<div class="line"><span class="lineno">  338</span>        )</div>
<div class="line"><span class="lineno">  339</span> </div>
<div class="line"><span class="lineno">  340</span>        <span class="comment"># Omit indexer if no item reindexing is required.</span></div>
<div class="line"><span class="lineno">  341</span>        <span class="keywordflow">if</span> unit_no_ax0_reindexing:</div>
<div class="line"><span class="lineno">  342</span>            join_unit_indexers.pop(0, <span class="keywordtype">None</span>)</div>
<div class="line"><span class="lineno">  343</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  344</span>            join_unit_indexers[0] = ax0_blk_indexer</div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        unit = JoinUnit(blk, shape, join_unit_indexers)</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>        plan.append((placements, unit))</div>
<div class="line"><span class="lineno">  349</span> </div>
<div class="line"><span class="lineno">  350</span>    <span class="keywordflow">return</span> plan</div>
<div class="line"><span class="lineno">  351</span> </div>
<div class="line"><span class="lineno">  352</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acff355ce8e0306119835e40ffdf11d02" name="acff355ce8e0306119835e40ffdf11d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff355ce8e0306119835e40ffdf11d02">&#9670;&#160;</a></span>_is_uniform_join_units()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.internals.concat._is_uniform_join_units </td>
          <td>(</td>
          <td class="paramtype">list[<a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>]&#160;</td>
          <td class="paramname"><em>join_units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Check if the join units consist of blocks of uniform type that can
be concatenated using Block.concat_same_type instead of the generic
_concatenate_join_units (which uses `concat_compat`).</pre> <div class="fragment"><div class="line"><span class="lineno">  635</span><span class="keyword">def </span>_is_uniform_join_units(join_units: list[JoinUnit]) -&gt; bool:</div>
<div class="line"><span class="lineno">  636</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">    Check if the join units consist of blocks of uniform type that can</span></div>
<div class="line"><span class="lineno">  638</span><span class="stringliteral">    be concatenated using Block.concat_same_type instead of the generic</span></div>
<div class="line"><span class="lineno">  639</span><span class="stringliteral">    _concatenate_join_units (which uses `concat_compat`).</span></div>
<div class="line"><span class="lineno">  640</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  641</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  642</span>    first = join_units[0].block</div>
<div class="line"><span class="lineno">  643</span>    <span class="keywordflow">if</span> first.dtype.kind == <span class="stringliteral">&quot;V&quot;</span>:</div>
<div class="line"><span class="lineno">  644</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  645</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  646</span>        <span class="comment"># exclude cases where a) ju.block is None or b) we have e.g. Int64+int64</span></div>
<div class="line"><span class="lineno">  647</span>        all(type(ju.block) <span class="keywordflow">is</span> type(first) <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  649</span>        <span class="comment"># e.g. DatetimeLikeBlock can be dt64 or td64, but these are not uniform</span></div>
<div class="line"><span class="lineno">  650</span>        all(</div>
<div class="line"><span class="lineno">  651</span>            is_dtype_equal(ju.block.dtype, first.dtype)</div>
<div class="line"><span class="lineno">  652</span>            <span class="comment"># GH#42092 we only want the dtype_equal check for non-numeric blocks</span></div>
<div class="line"><span class="lineno">  653</span>            <span class="comment">#  (for now, may change but that would need a deprecation)</span></div>
<div class="line"><span class="lineno">  654</span>            <span class="keywordflow">or</span> ju.block.dtype.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>]</div>
<div class="line"><span class="lineno">  655</span>            <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units</div>
<div class="line"><span class="lineno">  656</span>        )</div>
<div class="line"><span class="lineno">  657</span>        <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  658</span>        <span class="comment"># no blocks that would get missing values (can lead to type upcasts)</span></div>
<div class="line"><span class="lineno">  659</span>        <span class="comment"># unless we&#39;re an extension dtype.</span></div>
<div class="line"><span class="lineno">  660</span>        all(<span class="keywordflow">not</span> ju.is_na <span class="keywordflow">or</span> ju.block.is_extension <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  661</span>        <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  662</span>        <span class="comment"># no blocks with indexers (as then the dimensions do not fit)</span></div>
<div class="line"><span class="lineno">  663</span>        all(<span class="keywordflow">not</span> ju.indexers <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  664</span>        <span class="keywordflow">and</span></div>
<div class="line"><span class="lineno">  665</span>        <span class="comment"># only use this path when there is something to concatenate</span></div>
<div class="line"><span class="lineno">  666</span>        len(join_units) &gt; 1</div>
<div class="line"><span class="lineno">  667</span>    )</div>
<div class="line"><span class="lineno">  668</span> </div>
<div class="line"><span class="lineno">  669</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="af6838aa474a36c04b10adca2dc806bbd" name="af6838aa474a36c04b10adca2dc806bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6838aa474a36c04b10adca2dc806bbd">&#9670;&#160;</a></span>_is_uniform_reindex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> bool pandas.core.internals.concat._is_uniform_reindex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>join_units</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line"><span class="lineno">  670</span><span class="keyword">def </span>_is_uniform_reindex(join_units) -&gt; bool:</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">return</span> (</div>
<div class="line"><span class="lineno">  672</span>        <span class="comment"># TODO: should this be ju.block._can_hold_na?</span></div>
<div class="line"><span class="lineno">  673</span>        all(ju.block.is_extension <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units)</div>
<div class="line"><span class="lineno">  674</span>        <span class="keywordflow">and</span> len({ju.block.dtype.name <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units}) == 1</div>
<div class="line"><span class="lineno">  675</span>    )</div>
<div class="line"><span class="lineno">  676</span> </div>
<div class="line"><span class="lineno">  677</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a94ff5a0f932f5aa85a3c5e8b0d19908e" name="a94ff5a0f932f5aa85a3c5e8b0d19908e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ff5a0f932f5aa85a3c5e8b0d19908e">&#9670;&#160;</a></span>_maybe_reindex_columns_na_proxy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> list[tuple[<a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a>, dict[int, np.ndarray]]] pandas.core.internals.concat._maybe_reindex_columns_na_proxy </td>
          <td>(</td>
          <td class="paramtype">list[Index]&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[tuple[<a class="el" href="classpandas_1_1core_1_1internals_1_1managers_1_1_block_manager.html">BlockManager</a>, dict[int, np.ndarray]]]
&#160;</td>
          <td class="paramname"><em>mgrs_indexers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Reindex along columns so that all of the BlockManagers being concatenated
have matching columns.

Columns added in this reindexing have dtype=np.void, indicating they
should be ignored when choosing a column's final dtype.
</pre> <div class="fragment"><div class="line"><span class="lineno">  248</span>) -&gt; list[tuple[BlockManager, dict[int, np.ndarray]]]:</div>
<div class="line"><span class="lineno">  249</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  250</span><span class="stringliteral">    Reindex along columns so that all of the BlockManagers being concatenated</span></div>
<div class="line"><span class="lineno">  251</span><span class="stringliteral">    have matching columns.</span></div>
<div class="line"><span class="lineno">  252</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  253</span><span class="stringliteral">    Columns added in this reindexing have dtype=np.void, indicating they</span></div>
<div class="line"><span class="lineno">  254</span><span class="stringliteral">    should be ignored when choosing a column&#39;s final dtype.</span></div>
<div class="line"><span class="lineno">  255</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  256</span>    new_mgrs_indexers = []</div>
<div class="line"><span class="lineno">  257</span>    <span class="keywordflow">for</span> mgr, indexers <span class="keywordflow">in</span> mgrs_indexers:</div>
<div class="line"><span class="lineno">  258</span>        <span class="comment"># We only reindex for axis=0 (i.e. columns), as this can be done cheaply</span></div>
<div class="line"><span class="lineno">  259</span>        <span class="keywordflow">if</span> 0 <span class="keywordflow">in</span> indexers:</div>
<div class="line"><span class="lineno">  260</span>            new_mgr = mgr.reindex_indexer(</div>
<div class="line"><span class="lineno">  261</span>                axes[0],</div>
<div class="line"><span class="lineno">  262</span>                indexers[0],</div>
<div class="line"><span class="lineno">  263</span>                axis=0,</div>
<div class="line"><span class="lineno">  264</span>                copy=<span class="keyword">False</span>,</div>
<div class="line"><span class="lineno">  265</span>                only_slice=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  266</span>                allow_dups=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  267</span>                use_na_proxy=<span class="keyword">True</span>,</div>
<div class="line"><span class="lineno">  268</span>            )</div>
<div class="line"><span class="lineno">  269</span>            new_indexers = indexers.copy()</div>
<div class="line"><span class="lineno">  270</span>            del new_indexers[0]</div>
<div class="line"><span class="lineno">  271</span>            new_mgrs_indexers.append((new_mgr, new_indexers))</div>
<div class="line"><span class="lineno">  272</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  273</span>            new_mgrs_indexers.append((mgr, indexers))</div>
<div class="line"><span class="lineno">  274</span> </div>
<div class="line"><span class="lineno">  275</span>    <span class="keywordflow">return</span> new_mgrs_indexers</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2f260518b7fa00795a9817907c98d095" name="a2f260518b7fa00795a9817907c98d095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f260518b7fa00795a9817907c98d095">&#9670;&#160;</a></span>_trim_join_unit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"> <a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a> pandas.core.internals.concat._trim_join_unit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpandas_1_1core_1_1internals_1_1concat_1_1_join_unit.html">JoinUnit</a>&#160;</td>
          <td class="paramname"><em>join_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Reduce join_unit's shape along item axis to length.

Extra items that didn't fit are returned as a separate block.
</pre> <div class="fragment"><div class="line"><span class="lineno">  678</span><span class="keyword">def </span>_trim_join_unit(join_unit: JoinUnit, length: int) -&gt; JoinUnit:</div>
<div class="line"><span class="lineno">  679</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">    Reduce join_unit&#39;s shape along item axis to length.</span></div>
<div class="line"><span class="lineno">  681</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  682</span><span class="stringliteral">    Extra items that didn&#39;t fit are returned as a separate block.</span></div>
<div class="line"><span class="lineno">  683</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  684</span>    <span class="keywordflow">if</span> 0 <span class="keywordflow">not</span> <span class="keywordflow">in</span> join_unit.indexers:</div>
<div class="line"><span class="lineno">  685</span>        extra_indexers = join_unit.indexers</div>
<div class="line"><span class="lineno">  686</span> </div>
<div class="line"><span class="lineno">  687</span>        <span class="keywordflow">if</span> join_unit.block <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  688</span>            extra_block = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  689</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  690</span>            extra_block = join_unit.block.getitem_block(slice(length, <span class="keywordtype">None</span>))</div>
<div class="line"><span class="lineno">  691</span>            join_unit.block = join_unit.block.getitem_block(slice(length))</div>
<div class="line"><span class="lineno">  692</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  693</span>        extra_block = join_unit.block</div>
<div class="line"><span class="lineno">  694</span> </div>
<div class="line"><span class="lineno">  695</span>        extra_indexers = copy.copy(join_unit.indexers)</div>
<div class="line"><span class="lineno">  696</span>        extra_indexers[0] = extra_indexers[0][length:]</div>
<div class="line"><span class="lineno">  697</span>        join_unit.indexers[0] = join_unit.indexers[0][:length]</div>
<div class="line"><span class="lineno">  698</span> </div>
<div class="line"><span class="lineno">  699</span>    extra_shape = (join_unit.shape[0] - length,) + join_unit.shape[1:]</div>
<div class="line"><span class="lineno">  700</span>    join_unit.shape = (length,) + join_unit.shape[1:]</div>
<div class="line"><span class="lineno">  701</span> </div>
<div class="line"><span class="lineno">  702</span>    <span class="keywordflow">return</span> JoinUnit(block=extra_block, indexers=extra_indexers, shape=extra_shape)</div>
<div class="line"><span class="lineno">  703</span> </div>
<div class="line"><span class="lineno">  704</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a68c1f8038b316e7454304c9663b7a738" name="a68c1f8038b316e7454304c9663b7a738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c1f8038b316e7454304c9663b7a738">&#9670;&#160;</a></span>concat_arrays()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> ArrayLike pandas.core.internals.concat.concat_arrays </td>
          <td>(</td>
          <td class="paramtype">list&#160;</td>
          <td class="paramname"><em>to_concat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Alternative for concat_compat but specialized for use in the ArrayManager.

Differences: only deals with 1D arrays (no axis keyword), assumes
ensure_wrapped_if_datetimelike and does not skip empty arrays to determine
the dtype.
In addition ensures that all NullArrayProxies get replaced with actual
arrays.

Parameters
----------
to_concat : list of arrays

Returns
-------
np.ndarray or ExtensionArray
</pre> <div class="fragment"><div class="line"><span class="lineno">  120</span><span class="keyword">def </span>concat_arrays(to_concat: list) -&gt; ArrayLike:</div>
<div class="line"><span class="lineno">  121</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  122</span><span class="stringliteral">    Alternative for concat_compat but specialized for use in the ArrayManager.</span></div>
<div class="line"><span class="lineno">  123</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  124</span><span class="stringliteral">    Differences: only deals with 1D arrays (no axis keyword), assumes</span></div>
<div class="line"><span class="lineno">  125</span><span class="stringliteral">    ensure_wrapped_if_datetimelike and does not skip empty arrays to determine</span></div>
<div class="line"><span class="lineno">  126</span><span class="stringliteral">    the dtype.</span></div>
<div class="line"><span class="lineno">  127</span><span class="stringliteral">    In addition ensures that all NullArrayProxies get replaced with actual</span></div>
<div class="line"><span class="lineno">  128</span><span class="stringliteral">    arrays.</span></div>
<div class="line"><span class="lineno">  129</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  130</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  131</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  132</span><span class="stringliteral">    to_concat : list of arrays</span></div>
<div class="line"><span class="lineno">  133</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  134</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  135</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  136</span><span class="stringliteral">    np.ndarray or ExtensionArray</span></div>
<div class="line"><span class="lineno">  137</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  138</span>    <span class="comment"># ignore the all-NA proxies to determine the resulting dtype</span></div>
<div class="line"><span class="lineno">  139</span>    to_concat_no_proxy = [x <span class="keywordflow">for</span> x <span class="keywordflow">in</span> to_concat <span class="keywordflow">if</span> <span class="keywordflow">not</span> isinstance(x, NullArrayProxy)]</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>    dtypes = {x.dtype <span class="keywordflow">for</span> x <span class="keywordflow">in</span> to_concat_no_proxy}</div>
<div class="line"><span class="lineno">  142</span>    single_dtype = len(dtypes) == 1</div>
<div class="line"><span class="lineno">  143</span> </div>
<div class="line"><span class="lineno">  144</span>    <span class="keywordflow">if</span> single_dtype:</div>
<div class="line"><span class="lineno">  145</span>        target_dtype = to_concat_no_proxy[0].dtype</div>
<div class="line"><span class="lineno">  146</span>    <span class="keywordflow">elif</span> all(x.kind <span class="keywordflow">in</span> [<span class="stringliteral">&quot;i&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>] <span class="keywordflow">and</span> isinstance(x, np.dtype) <span class="keywordflow">for</span> x <span class="keywordflow">in</span> dtypes):</div>
<div class="line"><span class="lineno">  147</span>        <span class="comment"># GH#42092</span></div>
<div class="line"><span class="lineno">  148</span>        target_dtype = np.find_common_type(list(dtypes), [])</div>
<div class="line"><span class="lineno">  149</span>    <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  150</span>        target_dtype = find_common_type([arr.dtype <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> to_concat_no_proxy])</div>
<div class="line"><span class="lineno">  151</span> </div>
<div class="line"><span class="lineno">  152</span>    to_concat = [</div>
<div class="line"><span class="lineno">  153</span>        arr.to_array(target_dtype)</div>
<div class="line"><span class="lineno">  154</span>        <span class="keywordflow">if</span> isinstance(arr, NullArrayProxy)</div>
<div class="line"><span class="lineno">  155</span>        <span class="keywordflow">else</span> cast_to_common_type(arr, target_dtype)</div>
<div class="line"><span class="lineno">  156</span>        <span class="keywordflow">for</span> arr <span class="keywordflow">in</span> to_concat</div>
<div class="line"><span class="lineno">  157</span>    ]</div>
<div class="line"><span class="lineno">  158</span> </div>
<div class="line"><span class="lineno">  159</span>    <span class="keywordflow">if</span> isinstance(to_concat[0], ExtensionArray):</div>
<div class="line"><span class="lineno">  160</span>        cls = type(to_concat[0])</div>
<div class="line"><span class="lineno">  161</span>        <span class="keywordflow">return</span> cls._concat_same_type(to_concat)</div>
<div class="line"><span class="lineno">  162</span> </div>
<div class="line"><span class="lineno">  163</span>    result = np.concatenate(to_concat)</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    <span class="comment"># TODO decide on exact behaviour (we shouldn&#39;t do this only for empty result)</span></div>
<div class="line"><span class="lineno">  166</span>    <span class="comment"># see https://github.com/pandas-dev/pandas/issues/39817</span></div>
<div class="line"><span class="lineno">  167</span>    <span class="keywordflow">if</span> len(result) == 0:</div>
<div class="line"><span class="lineno">  168</span>        <span class="comment"># all empties -&gt; check for bool to not coerce to float</span></div>
<div class="line"><span class="lineno">  169</span>        kinds = {obj.dtype.kind <span class="keywordflow">for</span> obj <span class="keywordflow">in</span> to_concat_no_proxy}</div>
<div class="line"><span class="lineno">  170</span>        <span class="keywordflow">if</span> len(kinds) != 1:</div>
<div class="line"><span class="lineno">  171</span>            <span class="keywordflow">if</span> <span class="stringliteral">&quot;b&quot;</span> <span class="keywordflow">in</span> kinds:</div>
<div class="line"><span class="lineno">  172</span>                result = result.astype(object)</div>
<div class="line"><span class="lineno">  173</span>    <span class="keywordflow">return</span> result</div>
<div class="line"><span class="lineno">  174</span> </div>
<div class="line"><span class="lineno">  175</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5000b573fd8d6d5d89af911187838bc0" name="a5000b573fd8d6d5d89af911187838bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5000b573fd8d6d5d89af911187838bc0">&#9670;&#160;</a></span>concatenate_managers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"> Manager pandas.core.internals.concat.concatenate_managers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mgrs_indexers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">list[Index]&#160;</td>
          <td class="paramname"><em>axes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>concat_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool
&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Concatenate block managers into one.

Parameters
----------
mgrs_indexers : list of (BlockManager, {axis: indexer,...}) tuples
axes : list of Index
concat_axis : int
copy : bool

Returns
-------
BlockManager
</pre> <div class="fragment"><div class="line"><span class="lineno">  178</span>) -&gt; Manager:</div>
<div class="line"><span class="lineno">  179</span>    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  180</span><span class="stringliteral">    Concatenate block managers into one.</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral">    Parameters</span></div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">    ----------</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">    mgrs_indexers : list of (BlockManager, {axis: indexer,...}) tuples</span></div>
<div class="line"><span class="lineno">  185</span><span class="stringliteral">    axes : list of Index</span></div>
<div class="line"><span class="lineno">  186</span><span class="stringliteral">    concat_axis : int</span></div>
<div class="line"><span class="lineno">  187</span><span class="stringliteral">    copy : bool</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral">    Returns</span></div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">    -------</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">    BlockManager</span></div>
<div class="line"><span class="lineno">  192</span><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  193</span>    <span class="comment"># TODO(ArrayManager) this assumes that all managers are of the same type</span></div>
<div class="line"><span class="lineno">  194</span>    <span class="keywordflow">if</span> isinstance(mgrs_indexers[0][0], ArrayManager):</div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">return</span> _concatenate_array_managers(mgrs_indexers, axes, concat_axis, copy)</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>    mgrs_indexers = _maybe_reindex_columns_na_proxy(axes, mgrs_indexers)</div>
<div class="line"><span class="lineno">  198</span> </div>
<div class="line"><span class="lineno">  199</span>    concat_plans = [</div>
<div class="line"><span class="lineno">  200</span>        _get_mgr_concatenation_plan(mgr, indexers) <span class="keywordflow">for</span> mgr, indexers <span class="keywordflow">in</span> mgrs_indexers</div>
<div class="line"><span class="lineno">  201</span>    ]</div>
<div class="line"><span class="lineno">  202</span>    concat_plan = _combine_concat_plans(concat_plans, concat_axis)</div>
<div class="line"><span class="lineno">  203</span>    blocks = []</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">for</span> placement, join_units <span class="keywordflow">in</span> concat_plan:</div>
<div class="line"><span class="lineno">  206</span>        unit = join_units[0]</div>
<div class="line"><span class="lineno">  207</span>        blk = unit.block</div>
<div class="line"><span class="lineno">  208</span> </div>
<div class="line"><span class="lineno">  209</span>        <span class="keywordflow">if</span> len(join_units) == 1 <span class="keywordflow">and</span> <span class="keywordflow">not</span> join_units[0].indexers:</div>
<div class="line"><span class="lineno">  210</span>            values = blk.values</div>
<div class="line"><span class="lineno">  211</span>            <span class="keywordflow">if</span> copy:</div>
<div class="line"><span class="lineno">  212</span>                values = values.copy()</div>
<div class="line"><span class="lineno">  213</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  214</span>                values = values.view()</div>
<div class="line"><span class="lineno">  215</span>            fastpath = <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  216</span>        <span class="keywordflow">elif</span> _is_uniform_join_units(join_units):</div>
<div class="line"><span class="lineno">  217</span>            vals = [ju.block.values <span class="keywordflow">for</span> ju <span class="keywordflow">in</span> join_units]</div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> blk.is_extension:</div>
<div class="line"><span class="lineno">  220</span>                <span class="comment"># _is_uniform_join_units ensures a single dtype, so</span></div>
<div class="line"><span class="lineno">  221</span>                <span class="comment">#  we can use np.concatenate, which is more performant</span></div>
<div class="line"><span class="lineno">  222</span>                <span class="comment">#  than concat_compat</span></div>
<div class="line"><span class="lineno">  223</span>                values = np.concatenate(vals, axis=1)</div>
<div class="line"><span class="lineno">  224</span>            <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  225</span>                <span class="comment"># TODO(EA2D): special-casing not needed with 2D EAs</span></div>
<div class="line"><span class="lineno">  226</span>                values = concat_compat(vals, axis=1)</div>
<div class="line"><span class="lineno">  227</span>                values = ensure_block_shape(values, ndim=2)</div>
<div class="line"><span class="lineno">  228</span> </div>
<div class="line"><span class="lineno">  229</span>            values = ensure_wrapped_if_datetimelike(values)</div>
<div class="line"><span class="lineno">  230</span> </div>
<div class="line"><span class="lineno">  231</span>            fastpath = blk.values.dtype == values.dtype</div>
<div class="line"><span class="lineno">  232</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  233</span>            values = _concatenate_join_units(join_units, concat_axis, copy=copy)</div>
<div class="line"><span class="lineno">  234</span>            fastpath = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  235</span> </div>
<div class="line"><span class="lineno">  236</span>        <span class="keywordflow">if</span> fastpath:</div>
<div class="line"><span class="lineno">  237</span>            b = blk.make_block_same_class(values, placement=placement)</div>
<div class="line"><span class="lineno">  238</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  239</span>            b = new_block_2d(values, placement=placement)</div>
<div class="line"><span class="lineno">  240</span> </div>
<div class="line"><span class="lineno">  241</span>        blocks.append(b)</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>    <span class="keywordflow">return</span> BlockManager(tuple(blocks), axes)</div>
<div class="line"><span class="lineno">  244</span> </div>
<div class="line"><span class="lineno">  245</span> </div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
