<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tp_Gcs: matplotlib.backend_bases.RendererBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tp_Gcs<span id="projectnumber">&#160;1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacematplotlib.html">matplotlib</a></li><li class="navelem"><a class="el" href="namespacematplotlib_1_1backend__bases.html">backend_bases</a></li><li class="navelem"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html">RendererBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmatplotlib_1_1backend__bases_1_1_renderer_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">matplotlib.backend_bases.RendererBase Class Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for matplotlib.backend_bases.RendererBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classmatplotlib_1_1backend__bases_1_1_renderer_base.png" usemap="#matplotlib.backend_5Fbases.RendererBase_map" alt=""/>
  <map id="matplotlib.backend_5Fbases.RendererBase_map" name="matplotlib.backend_5Fbases.RendererBase_map">
<area href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html" alt="matplotlib.backends._backend_pdf_ps.RendererPDFPSBase" shape="rect" coords="362,56,714,80"/>
<area href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html" alt="matplotlib.backends.backend_agg.RendererAgg" shape="rect" coords="362,112,714,136"/>
<area href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html" alt="matplotlib.backends.backend_cairo.RendererCairo" shape="rect" coords="362,168,714,192"/>
<area href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html" alt="matplotlib.backends.backend_pgf.RendererPgf" shape="rect" coords="362,224,714,248"/>
<area href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html" alt="matplotlib.backends.backend_svg.RendererSVG" shape="rect" coords="362,280,714,304"/>
<area href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html" alt="matplotlib.backends.backend_template.RendererTemplate" shape="rect" coords="362,336,714,360"/>
<area href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html" alt="matplotlib.backends.backend_wx.RendererWx" shape="rect" coords="362,392,714,416"/>
<area href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html" alt="matplotlib.patheffects.PathEffectRenderer" shape="rect" coords="362,448,714,472"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b483e838a5bd7c66a4b647231012fde" id="r_a2b483e838a5bd7c66a4b647231012fde"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a2b483e838a5bd7c66a4b647231012fde">__init__</a> (self)</td></tr>
<tr class="separator:a2b483e838a5bd7c66a4b647231012fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bd6c68209c2c4068d0e91266b27802" id="r_ab0bd6c68209c2c4068d0e91266b27802"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#ab0bd6c68209c2c4068d0e91266b27802">open_group</a> (self, s, gid=None)</td></tr>
<tr class="separator:ab0bd6c68209c2c4068d0e91266b27802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf293d5150f738074cb32d3725e3f4fc" id="r_abf293d5150f738074cb32d3725e3f4fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#abf293d5150f738074cb32d3725e3f4fc">close_group</a> (self, s)</td></tr>
<tr class="separator:abf293d5150f738074cb32d3725e3f4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa72ab0fa075b939ec117cc10c5bd58" id="r_abaa72ab0fa075b939ec117cc10c5bd58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#abaa72ab0fa075b939ec117cc10c5bd58">draw_path</a> (self, gc, path, transform, rgbFace=None)</td></tr>
<tr class="separator:abaa72ab0fa075b939ec117cc10c5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5fca88d9795f8c2212afb95d1ebfb" id="r_a84b5fca88d9795f8c2212afb95d1ebfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a84b5fca88d9795f8c2212afb95d1ebfb">draw_markers</a> (self, gc, marker_path, marker_trans, path, <a class="el" href="__blas__subroutines_8h.html#ac2c81d916d6b7d6ad26c81ad7cfe575f">trans</a>, rgbFace=None)</td></tr>
<tr class="separator:a84b5fca88d9795f8c2212afb95d1ebfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179209eceeff4eb25a24de19a507edb1" id="r_a179209eceeff4eb25a24de19a507edb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a179209eceeff4eb25a24de19a507edb1">draw_path_collection</a> (self, gc, master_transform, paths, all_transforms, offsets, offset_trans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</td></tr>
<tr class="separator:a179209eceeff4eb25a24de19a507edb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae855a76770c81bedfd513d52478081" id="r_abae855a76770c81bedfd513d52478081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#abae855a76770c81bedfd513d52478081">draw_quad_mesh</a> (self, gc, master_transform, meshWidth, meshHeight, coordinates, offsets, offsetTrans, facecolors, antialiased, edgecolors)</td></tr>
<tr class="separator:abae855a76770c81bedfd513d52478081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be02775afa9971f0c0136e279f331df" id="r_a8be02775afa9971f0c0136e279f331df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a8be02775afa9971f0c0136e279f331df">draw_gouraud_triangle</a> (self, gc, points, colors, transform)</td></tr>
<tr class="separator:a8be02775afa9971f0c0136e279f331df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0fe27e8b7e79a96d3240d74d6c5cea" id="r_a3f0fe27e8b7e79a96d3240d74d6c5cea"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a3f0fe27e8b7e79a96d3240d74d6c5cea">draw_gouraud_triangles</a> (self, gc, triangles_array, colors_array, transform)</td></tr>
<tr class="separator:a3f0fe27e8b7e79a96d3240d74d6c5cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685b555f442f50426a70926e772c1bd3" id="r_a685b555f442f50426a70926e772c1bd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a685b555f442f50426a70926e772c1bd3">get_image_magnification</a> (self)</td></tr>
<tr class="separator:a685b555f442f50426a70926e772c1bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa835c7b5a00dd82a51494072f85f1e4e" id="r_aa835c7b5a00dd82a51494072f85f1e4e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#aa835c7b5a00dd82a51494072f85f1e4e">draw_image</a> (self, gc, x, y, im, transform=None)</td></tr>
<tr class="separator:aa835c7b5a00dd82a51494072f85f1e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27745a3b892e5c2ec892a0b503a1290" id="r_ae27745a3b892e5c2ec892a0b503a1290"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#ae27745a3b892e5c2ec892a0b503a1290">option_image_nocomposite</a> (self)</td></tr>
<tr class="separator:ae27745a3b892e5c2ec892a0b503a1290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16aef7c1964720d255a5f303588763e1" id="r_a16aef7c1964720d255a5f303588763e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a16aef7c1964720d255a5f303588763e1">option_scale_image</a> (self)</td></tr>
<tr class="separator:a16aef7c1964720d255a5f303588763e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3374939c440fe0ff9fa6fa8f8330fb11" id="r_a3374939c440fe0ff9fa6fa8f8330fb11"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a3374939c440fe0ff9fa6fa8f8330fb11">draw_tex</a> (self, gc, x, y, s, prop, angle, *mtext=None)</td></tr>
<tr class="separator:a3374939c440fe0ff9fa6fa8f8330fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf90d1255ec46894a498109fcba232" id="r_a5eaf90d1255ec46894a498109fcba232"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a5eaf90d1255ec46894a498109fcba232">draw_text</a> (self, gc, x, y, s, prop, angle, ismath=False, mtext=None)</td></tr>
<tr class="separator:a5eaf90d1255ec46894a498109fcba232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5949e6973c36e18d99075c10481b4d91" id="r_a5949e6973c36e18d99075c10481b4d91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a5949e6973c36e18d99075c10481b4d91">get_text_width_height_descent</a> (self, s, prop, ismath)</td></tr>
<tr class="separator:a5949e6973c36e18d99075c10481b4d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f438e3083fa2e4421bc236a24d6b081" id="r_a4f438e3083fa2e4421bc236a24d6b081"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a4f438e3083fa2e4421bc236a24d6b081">flipy</a> (self)</td></tr>
<tr class="separator:a4f438e3083fa2e4421bc236a24d6b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4069acee5688f39184ff2d93b97123ce" id="r_a4069acee5688f39184ff2d93b97123ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a4069acee5688f39184ff2d93b97123ce">get_canvas_width_height</a> (self)</td></tr>
<tr class="separator:a4069acee5688f39184ff2d93b97123ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97588e7597ca3f3081a35fa44d76302c" id="r_a97588e7597ca3f3081a35fa44d76302c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a97588e7597ca3f3081a35fa44d76302c">get_texmanager</a> (self)</td></tr>
<tr class="separator:a97588e7597ca3f3081a35fa44d76302c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e126c3f377d4c8636c2b92b28d1fab8" id="r_a2e126c3f377d4c8636c2b92b28d1fab8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a2e126c3f377d4c8636c2b92b28d1fab8">new_gc</a> (self)</td></tr>
<tr class="separator:a2e126c3f377d4c8636c2b92b28d1fab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127fe58cf106a6d048297da52a313f77" id="r_a127fe58cf106a6d048297da52a313f77"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a127fe58cf106a6d048297da52a313f77">points_to_pixels</a> (self, points)</td></tr>
<tr class="separator:a127fe58cf106a6d048297da52a313f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0547ce0393c194d1faba19e1a3ef4f" id="r_a9e0547ce0393c194d1faba19e1a3ef4f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a9e0547ce0393c194d1faba19e1a3ef4f">start_rasterizing</a> (self)</td></tr>
<tr class="separator:a9e0547ce0393c194d1faba19e1a3ef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93097cdf41f0f34380f5f8723803911" id="r_ad93097cdf41f0f34380f5f8723803911"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#ad93097cdf41f0f34380f5f8723803911">stop_rasterizing</a> (self)</td></tr>
<tr class="separator:ad93097cdf41f0f34380f5f8723803911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6beb00ce176a5b747083d7f458a0bd0" id="r_aa6beb00ce176a5b747083d7f458a0bd0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#aa6beb00ce176a5b747083d7f458a0bd0">start_filter</a> (self)</td></tr>
<tr class="separator:aa6beb00ce176a5b747083d7f458a0bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfb06429e71210e38e81a0ebcd83ef6" id="r_a1cfb06429e71210e38e81a0ebcd83ef6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a1cfb06429e71210e38e81a0ebcd83ef6">stop_filter</a> (self, filter_func)</td></tr>
<tr class="separator:a1cfb06429e71210e38e81a0ebcd83ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a17c473534904023236d40ef772cc239a" id="r_a17c473534904023236d40ef772cc239a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a17c473534904023236d40ef772cc239a">_iter_collection_raw_paths</a> (self, master_transform, paths, all_transforms)</td></tr>
<tr class="separator:a17c473534904023236d40ef772cc239a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5626c67cc5540e78d9b5837d2afa79" id="r_acc5626c67cc5540e78d9b5837d2afa79"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#acc5626c67cc5540e78d9b5837d2afa79">_iter_collection_uses_per_path</a> (self, paths, all_transforms, offsets, facecolors, edgecolors)</td></tr>
<tr class="separator:acc5626c67cc5540e78d9b5837d2afa79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4885c56245f1820b77fae84e386fc07" id="r_ad4885c56245f1820b77fae84e386fc07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#ad4885c56245f1820b77fae84e386fc07">_iter_collection</a> (self, gc, path_ids, offsets, offset_trans, facecolors, edgecolors, linewidths, linestyles, antialiaseds, urls, offset_position)</td></tr>
<tr class="separator:ad4885c56245f1820b77fae84e386fc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c01d6b9aabc164e4ae0ca31b7e21823" id="r_a1c01d6b9aabc164e4ae0ca31b7e21823"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a1c01d6b9aabc164e4ae0ca31b7e21823">_get_text_path_transform</a> (self, x, y, s, prop, angle, ismath)</td></tr>
<tr class="separator:a1c01d6b9aabc164e4ae0ca31b7e21823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71741eb7bd9319e756de3b1a9141cc97" id="r_a71741eb7bd9319e756de3b1a9141cc97"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a71741eb7bd9319e756de3b1a9141cc97">_draw_text_as_path</a> (self, gc, x, y, s, prop, angle, ismath)</td></tr>
<tr class="separator:a71741eb7bd9319e756de3b1a9141cc97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9867fb8180c35c8efffb6f84f84ccb16" id="r_a9867fb8180c35c8efffb6f84f84ccb16"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a9867fb8180c35c8efffb6f84f84ccb16">_draw_disabled</a> (self)</td></tr>
<tr class="separator:a9867fb8180c35c8efffb6f84f84ccb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a56481bcf7dda3fb3d391ef69e03c4e60" id="r_a56481bcf7dda3fb3d391ef69e03c4e60"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a56481bcf7dda3fb3d391ef69e03c4e60">_texmanager</a></td></tr>
<tr class="separator:a56481bcf7dda3fb3d391ef69e03c4e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccfad0a85e2dda1bb5f7f50cbdbf4c9" id="r_a6ccfad0a85e2dda1bb5f7f50cbdbf4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a6ccfad0a85e2dda1bb5f7f50cbdbf4c9">_text2path</a></td></tr>
<tr class="separator:a6ccfad0a85e2dda1bb5f7f50cbdbf4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7327683a5b666d0cd9c3c94b962e10ff" id="r_a7327683a5b666d0cd9c3c94b962e10ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a7327683a5b666d0cd9c3c94b962e10ff">_raster_depth</a></td></tr>
<tr class="separator:a7327683a5b666d0cd9c3c94b962e10ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2404cfcbab1234c60978bf806aa2a1ce" id="r_a2404cfcbab1234c60978bf806aa2a1ce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmatplotlib_1_1backend__bases_1_1_renderer_base.html#a2404cfcbab1234c60978bf806aa2a1ce">_rasterizing</a></td></tr>
<tr class="separator:a2404cfcbab1234c60978bf806aa2a1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">An abstract base class to handle drawing/rendering operations.

The following methods must be implemented in the backend for full
functionality (though just implementing `draw_path` alone would give a
highly capable backend):

* `draw_path`
* `draw_image`
* `draw_gouraud_triangle`

The following methods *should* be implemented in the backend for
optimization reasons:

* `draw_text`
* `draw_markers`
* `draw_path_collection`
* `draw_quad_mesh`
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2b483e838a5bd7c66a4b647231012fde" name="a2b483e838a5bd7c66a4b647231012fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b483e838a5bd7c66a4b647231012fde">&#9670;&#160;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a27aee51158527d6816db1b40c7c52cfa">matplotlib.backends.backend_wx.RendererWx</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a24f1daa4d1741c424fc1278a48fb2bfc">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a30fd2ad0d75c8472056e94c489b49721">matplotlib.backends.backend_template.RendererTemplate</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#ab45a78d6c03e2644d625644c09605b67">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a9b89158758b84e7dc162216300e3214b">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html#a28eb84fc183c530bfa1b92ea611f7da9">matplotlib.patheffects.PathEffectRenderer</a>, <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#a67b23ef82e3f890e8c9e62f604eb2edc">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#aa915c0e7eb074d802e6d7b9ccc1596e8">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a3313cb043b0e189d7acecd361b8f3164">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#aa08484bd43601250df6280e222c7b080">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  172</span>    <span class="keyword">def </span>__init__(self):</div>
<div class="line"><span class="lineno">  173</span>        super().__init__()</div>
<div class="line"><span class="lineno">  174</span>        self._texmanager = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  175</span>        self._text2path = textpath.TextToPath()</div>
<div class="line"><span class="lineno">  176</span>        self._raster_depth = 0</div>
<div class="line"><span class="lineno">  177</span>        self._rasterizing = <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  178</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9867fb8180c35c8efffb6f84f84ccb16" name="a9867fb8180c35c8efffb6f84f84ccb16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9867fb8180c35c8efffb6f84f84ccb16">&#9670;&#160;</a></span>_draw_disabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._draw_disabled </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Context manager to temporary disable drawing.

This is used for getting the drawn size of Artists.  This lets us
run the draw process to update any Python state but does not pay the
cost of the draw_XYZ calls on the canvas.
</pre> <div class="fragment"><div class="line"><span class="lineno">  706</span>    <span class="keyword">def </span>_draw_disabled(self):</div>
<div class="line"><span class="lineno">  707</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  708</span><span class="stringliteral">        Context manager to temporary disable drawing.</span></div>
<div class="line"><span class="lineno">  709</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  710</span><span class="stringliteral">        This is used for getting the drawn size of Artists.  This lets us</span></div>
<div class="line"><span class="lineno">  711</span><span class="stringliteral">        run the draw process to update any Python state but does not pay the</span></div>
<div class="line"><span class="lineno">  712</span><span class="stringliteral">        cost of the draw_XYZ calls on the canvas.</span></div>
<div class="line"><span class="lineno">  713</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  714</span>        no_ops = {</div>
<div class="line"><span class="lineno">  715</span>            meth_name: <span class="keyword">lambda</span> *args, **kwargs: <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  716</span>            <span class="keywordflow">for</span> meth_name <span class="keywordflow">in</span> dir(RendererBase)</div>
<div class="line"><span class="lineno">  717</span>            <span class="keywordflow">if</span> (meth_name.startswith(<span class="stringliteral">&quot;draw_&quot;</span>)</div>
<div class="line"><span class="lineno">  718</span>                <span class="keywordflow">or</span> meth_name <span class="keywordflow">in</span> [<span class="stringliteral">&quot;open_group&quot;</span>, <span class="stringliteral">&quot;close_group&quot;</span>])</div>
<div class="line"><span class="lineno">  719</span>        }</div>
<div class="line"><span class="lineno">  720</span> </div>
<div class="line"><span class="lineno">  721</span>        <span class="keywordflow">return</span> _setattr_cm(self, **no_ops)</div>
<div class="line"><span class="lineno">  722</span> </div>
<div class="line"><span class="lineno">  723</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a71741eb7bd9319e756de3b1a9141cc97" name="a71741eb7bd9319e756de3b1a9141cc97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71741eb7bd9319e756de3b1a9141cc97">&#9670;&#160;</a></span>_draw_text_as_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._draw_text_as_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ismath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Draw the text by converting them to paths using textpath module.

Parameters
----------
prop : `matplotlib.font_manager.FontProperties`
    The font property.
s : str
    The text to be converted.
usetex : bool
    Whether to use usetex mode.
ismath : bool or "TeX"
    If True, use mathtext parser. If "TeX", use *usetex* mode.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html#a0d4264f6f6decc08e88a43d884efc9b0">matplotlib.patheffects.PathEffectRenderer</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a50609b5fa1c6f21412f89f933e46bd1b">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  581</span>    <span class="keyword">def </span>_draw_text_as_path(self, gc, x, y, s, prop, angle, ismath):</div>
<div class="line"><span class="lineno">  582</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  583</span><span class="stringliteral">        Draw the text by converting them to paths using textpath module.</span></div>
<div class="line"><span class="lineno">  584</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  585</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  586</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  587</span><span class="stringliteral">        prop : `matplotlib.font_manager.FontProperties`</span></div>
<div class="line"><span class="lineno">  588</span><span class="stringliteral">            The font property.</span></div>
<div class="line"><span class="lineno">  589</span><span class="stringliteral">        s : str</span></div>
<div class="line"><span class="lineno">  590</span><span class="stringliteral">            The text to be converted.</span></div>
<div class="line"><span class="lineno">  591</span><span class="stringliteral">        usetex : bool</span></div>
<div class="line"><span class="lineno">  592</span><span class="stringliteral">            Whether to use usetex mode.</span></div>
<div class="line"><span class="lineno">  593</span><span class="stringliteral">        ismath : bool or &quot;TeX&quot;</span></div>
<div class="line"><span class="lineno">  594</span><span class="stringliteral">            If True, use mathtext parser. If &quot;TeX&quot;, use *usetex* mode.</span></div>
<div class="line"><span class="lineno">  595</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  596</span>        path, transform = self._get_text_path_transform(</div>
<div class="line"><span class="lineno">  597</span>            x, y, s, prop, angle, ismath)</div>
<div class="line"><span class="lineno">  598</span>        color = gc.get_rgb()</div>
<div class="line"><span class="lineno">  599</span>        gc.set_linewidth(0.0)</div>
<div class="line"><span class="lineno">  600</span>        self.draw_path(gc, path, transform, rgbFace=color)</div>
<div class="line"><span class="lineno">  601</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1c01d6b9aabc164e4ae0ca31b7e21823" name="a1c01d6b9aabc164e4ae0ca31b7e21823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c01d6b9aabc164e4ae0ca31b7e21823">&#9670;&#160;</a></span>_get_text_path_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._get_text_path_transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ismath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Return the text path and transform.

Parameters
----------
prop : `matplotlib.font_manager.FontProperties`
    The font property.
s : str
    The text to be converted.
ismath : bool or "TeX"
    If True, use mathtext parser. If "TeX", use *usetex* mode.
</pre> <div class="fragment"><div class="line"><span class="lineno">  547</span>    <span class="keyword">def </span>_get_text_path_transform(self, x, y, s, prop, angle, ismath):</div>
<div class="line"><span class="lineno">  548</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  549</span><span class="stringliteral">        Return the text path and transform.</span></div>
<div class="line"><span class="lineno">  550</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  551</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  552</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  553</span><span class="stringliteral">        prop : `matplotlib.font_manager.FontProperties`</span></div>
<div class="line"><span class="lineno">  554</span><span class="stringliteral">            The font property.</span></div>
<div class="line"><span class="lineno">  555</span><span class="stringliteral">        s : str</span></div>
<div class="line"><span class="lineno">  556</span><span class="stringliteral">            The text to be converted.</span></div>
<div class="line"><span class="lineno">  557</span><span class="stringliteral">        ismath : bool or &quot;TeX&quot;</span></div>
<div class="line"><span class="lineno">  558</span><span class="stringliteral">            If True, use mathtext parser. If &quot;TeX&quot;, use *usetex* mode.</span></div>
<div class="line"><span class="lineno">  559</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>        text2path = self._text2path</div>
<div class="line"><span class="lineno">  562</span>        fontsize = self.points_to_pixels(prop.get_size_in_points())</div>
<div class="line"><span class="lineno">  563</span>        verts, codes = text2path.get_text_path(prop, s, ismath=ismath)</div>
<div class="line"><span class="lineno">  564</span> </div>
<div class="line"><span class="lineno">  565</span>        path = Path(verts, codes)</div>
<div class="line"><span class="lineno">  566</span>        angle = np.deg2rad(angle)</div>
<div class="line"><span class="lineno">  567</span>        <span class="keywordflow">if</span> self.flipy():</div>
<div class="line"><span class="lineno">  568</span>            width, height = self.get_canvas_width_height()</div>
<div class="line"><span class="lineno">  569</span>            transform = (Affine2D()</div>
<div class="line"><span class="lineno">  570</span>                         .scale(fontsize / text2path.FONT_SCALE)</div>
<div class="line"><span class="lineno">  571</span>                         .rotate(angle)</div>
<div class="line"><span class="lineno">  572</span>                         .translate(x, height - y))</div>
<div class="line"><span class="lineno">  573</span>        <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  574</span>            transform = (Affine2D()</div>
<div class="line"><span class="lineno">  575</span>                         .scale(fontsize / text2path.FONT_SCALE)</div>
<div class="line"><span class="lineno">  576</span>                         .rotate(angle)</div>
<div class="line"><span class="lineno">  577</span>                         .translate(x, y))</div>
<div class="line"><span class="lineno">  578</span> </div>
<div class="line"><span class="lineno">  579</span>        <span class="keywordflow">return</span> path, transform</div>
<div class="line"><span class="lineno">  580</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4885c56245f1820b77fae84e386fc07" name="ad4885c56245f1820b77fae84e386fc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4885c56245f1820b77fae84e386fc07">&#9670;&#160;</a></span>_iter_collection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._iter_collection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edgecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linewidths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linestyles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>antialiaseds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>urls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset_position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper method (along with `_iter_collection_raw_paths`) to implement
`draw_path_collection` in a memory-efficient manner.

This method yields all of the path, offset and graphics context
combinations to draw the path collection.  The caller should already
have looped over the results of `_iter_collection_raw_paths` to draw
this collection.

The arguments should be the same as that passed into
`draw_path_collection`, with the exception of *path_ids*, which is a
list of arbitrary objects that the backend will use to reference one of
the paths created in the `_iter_collection_raw_paths` stage.

Each yielded result is of the form::

   xo, yo, path_id, gc, rgbFace

where *xo*, *yo* is an offset; *path_id* is one of the elements of
*path_ids*; *gc* is a graphics context and *rgbFace* is a color to
use for filling the path.
</pre> <div class="fragment"><div class="line"><span class="lineno">  372</span>                         antialiaseds, urls, offset_position):</div>
<div class="line"><span class="lineno">  373</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  374</span><span class="stringliteral">        Helper method (along with `_iter_collection_raw_paths`) to implement</span></div>
<div class="line"><span class="lineno">  375</span><span class="stringliteral">        `draw_path_collection` in a memory-efficient manner.</span></div>
<div class="line"><span class="lineno">  376</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  377</span><span class="stringliteral">        This method yields all of the path, offset and graphics context</span></div>
<div class="line"><span class="lineno">  378</span><span class="stringliteral">        combinations to draw the path collection.  The caller should already</span></div>
<div class="line"><span class="lineno">  379</span><span class="stringliteral">        have looped over the results of `_iter_collection_raw_paths` to draw</span></div>
<div class="line"><span class="lineno">  380</span><span class="stringliteral">        this collection.</span></div>
<div class="line"><span class="lineno">  381</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  382</span><span class="stringliteral">        The arguments should be the same as that passed into</span></div>
<div class="line"><span class="lineno">  383</span><span class="stringliteral">        `draw_path_collection`, with the exception of *path_ids*, which is a</span></div>
<div class="line"><span class="lineno">  384</span><span class="stringliteral">        list of arbitrary objects that the backend will use to reference one of</span></div>
<div class="line"><span class="lineno">  385</span><span class="stringliteral">        the paths created in the `_iter_collection_raw_paths` stage.</span></div>
<div class="line"><span class="lineno">  386</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  387</span><span class="stringliteral">        Each yielded result is of the form::</span></div>
<div class="line"><span class="lineno">  388</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  389</span><span class="stringliteral">           xo, yo, path_id, gc, rgbFace</span></div>
<div class="line"><span class="lineno">  390</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  391</span><span class="stringliteral">        where *xo*, *yo* is an offset; *path_id* is one of the elements of</span></div>
<div class="line"><span class="lineno">  392</span><span class="stringliteral">        *path_ids*; *gc* is a graphics context and *rgbFace* is a color to</span></div>
<div class="line"><span class="lineno">  393</span><span class="stringliteral">        use for filling the path.</span></div>
<div class="line"><span class="lineno">  394</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  395</span>        Npaths = len(path_ids)</div>
<div class="line"><span class="lineno">  396</span>        Noffsets = len(offsets)</div>
<div class="line"><span class="lineno">  397</span>        N = max(Npaths, Noffsets)</div>
<div class="line"><span class="lineno">  398</span>        Nfacecolors = len(facecolors)</div>
<div class="line"><span class="lineno">  399</span>        Nedgecolors = len(edgecolors)</div>
<div class="line"><span class="lineno">  400</span>        Nlinewidths = len(linewidths)</div>
<div class="line"><span class="lineno">  401</span>        Nlinestyles = len(linestyles)</div>
<div class="line"><span class="lineno">  402</span>        Nurls = len(urls)</div>
<div class="line"><span class="lineno">  403</span> </div>
<div class="line"><span class="lineno">  404</span>        <span class="keywordflow">if</span> (Nfacecolors == 0 <span class="keywordflow">and</span> Nedgecolors == 0) <span class="keywordflow">or</span> Npaths == 0:</div>
<div class="line"><span class="lineno">  405</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  406</span> </div>
<div class="line"><span class="lineno">  407</span>        gc0 = self.new_gc()</div>
<div class="line"><span class="lineno">  408</span>        gc0.copy_properties(gc)</div>
<div class="line"><span class="lineno">  409</span> </div>
<div class="line"><span class="lineno">  410</span>        <span class="keyword">def </span>cycle_or_default(seq, default=None):</div>
<div class="line"><span class="lineno">  411</span>            <span class="comment"># Cycle over *seq* if it is not empty; else always yield *default*.</span></div>
<div class="line"><span class="lineno">  412</span>            <span class="keywordflow">return</span> (itertools.cycle(seq) <span class="keywordflow">if</span> len(seq)</div>
<div class="line"><span class="lineno">  413</span>                    <span class="keywordflow">else</span> itertools.repeat(default))</div>
<div class="line"><span class="lineno">  414</span> </div>
<div class="line"><span class="lineno">  415</span>        pathids = cycle_or_default(path_ids)</div>
<div class="line"><span class="lineno">  416</span>        toffsets = cycle_or_default(offset_trans.transform(offsets), (0, 0))</div>
<div class="line"><span class="lineno">  417</span>        fcs = cycle_or_default(facecolors)</div>
<div class="line"><span class="lineno">  418</span>        ecs = cycle_or_default(edgecolors)</div>
<div class="line"><span class="lineno">  419</span>        lws = cycle_or_default(linewidths)</div>
<div class="line"><span class="lineno">  420</span>        lss = cycle_or_default(linestyles)</div>
<div class="line"><span class="lineno">  421</span>        aas = cycle_or_default(antialiaseds)</div>
<div class="line"><span class="lineno">  422</span>        urls = cycle_or_default(urls)</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>        <span class="keywordflow">if</span> Nedgecolors == 0:</div>
<div class="line"><span class="lineno">  425</span>            gc0.set_linewidth(0.0)</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>        <span class="keywordflow">for</span> pathid, (xo, yo), fc, ec, lw, ls, aa, url <span class="keywordflow">in</span> itertools.islice(</div>
<div class="line"><span class="lineno">  428</span>                zip(pathids, toffsets, fcs, ecs, lws, lss, aas, urls), N):</div>
<div class="line"><span class="lineno">  429</span>            <span class="keywordflow">if</span> <span class="keywordflow">not</span> (np.isfinite(xo) <span class="keywordflow">and</span> np.isfinite(yo)):</div>
<div class="line"><span class="lineno">  430</span>                <span class="keywordflow">continue</span></div>
<div class="line"><span class="lineno">  431</span>            <span class="keywordflow">if</span> Nedgecolors:</div>
<div class="line"><span class="lineno">  432</span>                <span class="keywordflow">if</span> Nlinewidths:</div>
<div class="line"><span class="lineno">  433</span>                    gc0.set_linewidth(lw)</div>
<div class="line"><span class="lineno">  434</span>                <span class="keywordflow">if</span> Nlinestyles:</div>
<div class="line"><span class="lineno">  435</span>                    gc0.set_dashes(*ls)</div>
<div class="line"><span class="lineno">  436</span>                <span class="keywordflow">if</span> len(ec) == 4 <span class="keywordflow">and</span> ec[3] == 0.0:</div>
<div class="line"><span class="lineno">  437</span>                    gc0.set_linewidth(0)</div>
<div class="line"><span class="lineno">  438</span>                <span class="keywordflow">else</span>:</div>
<div class="line"><span class="lineno">  439</span>                    gc0.set_foreground(ec)</div>
<div class="line"><span class="lineno">  440</span>            <span class="keywordflow">if</span> fc <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">and</span> len(fc) == 4 <span class="keywordflow">and</span> fc[3] == 0:</div>
<div class="line"><span class="lineno">  441</span>                fc = <span class="keywordtype">None</span></div>
<div class="line"><span class="lineno">  442</span>            gc0.set_antialiased(aa)</div>
<div class="line"><span class="lineno">  443</span>            <span class="keywordflow">if</span> Nurls:</div>
<div class="line"><span class="lineno">  444</span>                gc0.set_url(url)</div>
<div class="line"><span class="lineno">  445</span>            <span class="keywordflow">yield</span> xo, yo, pathid, gc0, fc</div>
<div class="line"><span class="lineno">  446</span>        gc0.restore()</div>
<div class="line"><span class="lineno">  447</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a17c473534904023236d40ef772cc239a" name="a17c473534904023236d40ef772cc239a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c473534904023236d40ef772cc239a">&#9670;&#160;</a></span>_iter_collection_raw_paths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._iter_collection_raw_paths </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>master_transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_transforms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Helper method (along with `_iter_collection`) to implement
`draw_path_collection` in a memory-efficient manner.

This method yields all of the base path/transform combinations, given a
master transform, a list of paths and list of transforms.

The arguments should be exactly what is passed in to
`draw_path_collection`.

The backend should take each yielded path and transform and create an
object that can be referenced (reused) later.
</pre> <div class="fragment"><div class="line"><span class="lineno">  325</span>                                   all_transforms):</div>
<div class="line"><span class="lineno">  326</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  327</span><span class="stringliteral">        Helper method (along with `_iter_collection`) to implement</span></div>
<div class="line"><span class="lineno">  328</span><span class="stringliteral">        `draw_path_collection` in a memory-efficient manner.</span></div>
<div class="line"><span class="lineno">  329</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  330</span><span class="stringliteral">        This method yields all of the base path/transform combinations, given a</span></div>
<div class="line"><span class="lineno">  331</span><span class="stringliteral">        master transform, a list of paths and list of transforms.</span></div>
<div class="line"><span class="lineno">  332</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  333</span><span class="stringliteral">        The arguments should be exactly what is passed in to</span></div>
<div class="line"><span class="lineno">  334</span><span class="stringliteral">        `draw_path_collection`.</span></div>
<div class="line"><span class="lineno">  335</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  336</span><span class="stringliteral">        The backend should take each yielded path and transform and create an</span></div>
<div class="line"><span class="lineno">  337</span><span class="stringliteral">        object that can be referenced (reused) later.</span></div>
<div class="line"><span class="lineno">  338</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  339</span>        Npaths = len(paths)</div>
<div class="line"><span class="lineno">  340</span>        Ntransforms = len(all_transforms)</div>
<div class="line"><span class="lineno">  341</span>        N = max(Npaths, Ntransforms)</div>
<div class="line"><span class="lineno">  342</span> </div>
<div class="line"><span class="lineno">  343</span>        <span class="keywordflow">if</span> Npaths == 0:</div>
<div class="line"><span class="lineno">  344</span>            <span class="keywordflow">return</span></div>
<div class="line"><span class="lineno">  345</span> </div>
<div class="line"><span class="lineno">  346</span>        transform = transforms.IdentityTransform()</div>
<div class="line"><span class="lineno">  347</span>        <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(N):</div>
<div class="line"><span class="lineno">  348</span>            path = paths[i % Npaths]</div>
<div class="line"><span class="lineno">  349</span>            <span class="keywordflow">if</span> Ntransforms:</div>
<div class="line"><span class="lineno">  350</span>                transform = Affine2D(all_transforms[i % Ntransforms])</div>
<div class="line"><span class="lineno">  351</span>            <span class="keywordflow">yield</span> path, transform + master_transform</div>
<div class="line"><span class="lineno">  352</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="acc5626c67cc5540e78d9b5837d2afa79" name="acc5626c67cc5540e78d9b5837d2afa79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5626c67cc5540e78d9b5837d2afa79">&#9670;&#160;</a></span>_iter_collection_uses_per_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._iter_collection_uses_per_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edgecolors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<pre class="fragment">Compute how many times each raw path object returned by
`_iter_collection_raw_paths` would be used when calling
`_iter_collection`. This is intended for the backend to decide
on the tradeoff between using the paths in-line and storing
them once and reusing. Rounds up in case the number of uses
is not the same for every path.
</pre> <div class="fragment"><div class="line"><span class="lineno">  354</span>                                       offsets, facecolors, edgecolors):</div>
<div class="line"><span class="lineno">  355</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  356</span><span class="stringliteral">        Compute how many times each raw path object returned by</span></div>
<div class="line"><span class="lineno">  357</span><span class="stringliteral">        `_iter_collection_raw_paths` would be used when calling</span></div>
<div class="line"><span class="lineno">  358</span><span class="stringliteral">        `_iter_collection`. This is intended for the backend to decide</span></div>
<div class="line"><span class="lineno">  359</span><span class="stringliteral">        on the tradeoff between using the paths in-line and storing</span></div>
<div class="line"><span class="lineno">  360</span><span class="stringliteral">        them once and reusing. Rounds up in case the number of uses</span></div>
<div class="line"><span class="lineno">  361</span><span class="stringliteral">        is not the same for every path.</span></div>
<div class="line"><span class="lineno">  362</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  363</span>        Npaths = len(paths)</div>
<div class="line"><span class="lineno">  364</span>        <span class="keywordflow">if</span> Npaths == 0 <span class="keywordflow">or</span> len(facecolors) == len(edgecolors) == 0:</div>
<div class="line"><span class="lineno">  365</span>            <span class="keywordflow">return</span> 0</div>
<div class="line"><span class="lineno">  366</span>        Npath_ids = max(Npaths, len(all_transforms))</div>
<div class="line"><span class="lineno">  367</span>        N = max(Npath_ids, len(offsets))</div>
<div class="line"><span class="lineno">  368</span>        <span class="keywordflow">return</span> (N + Npath_ids - 1) // Npath_ids</div>
<div class="line"><span class="lineno">  369</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abf293d5150f738074cb32d3725e3f4fc" name="abf293d5150f738074cb32d3725e3f4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf293d5150f738074cb32d3725e3f4fc">&#9670;&#160;</a></span>close_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.close_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Close a grouping element with label *s*.

Only used by the SVG renderer.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a6df1144f5c0d9904eeffe3836e605153">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  186</span>    <span class="keyword">def </span>close_group(self, s):</div>
<div class="line"><span class="lineno">  187</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  188</span><span class="stringliteral">        Close a grouping element with label *s*.</span></div>
<div class="line"><span class="lineno">  189</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  190</span><span class="stringliteral">        Only used by the SVG renderer.</span></div>
<div class="line"><span class="lineno">  191</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  192</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a8be02775afa9971f0c0136e279f331df" name="a8be02775afa9971f0c0136e279f331df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be02775afa9971f0c0136e279f331df">&#9670;&#160;</a></span>draw_gouraud_triangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_gouraud_triangle </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a Gouraud-shaded triangle.

Parameters
----------
gc : `.GraphicsContextBase`
    The graphics context.
points : (3, 2) array-like
    Array of (x, y) points for the triangle.
colors : (3, 4) array-like
    RGBA colors for each point of the triangle.
transform : `matplotlib.transforms.Transform`
    An affine transform to apply to the points.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a5eefba8791b39613d986d01c3264e04a">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a2927a7ba48b097dd5356325055dd74f8">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a9fbd1b5c9d783479513b133258c2376b">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  289</span>    <span class="keyword">def </span>draw_gouraud_triangle(self, gc, points, colors, transform):</div>
<div class="line"><span class="lineno">  290</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  291</span><span class="stringliteral">        Draw a Gouraud-shaded triangle.</span></div>
<div class="line"><span class="lineno">  292</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  293</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  294</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  295</span><span class="stringliteral">        gc : `.GraphicsContextBase`</span></div>
<div class="line"><span class="lineno">  296</span><span class="stringliteral">            The graphics context.</span></div>
<div class="line"><span class="lineno">  297</span><span class="stringliteral">        points : (3, 2) array-like</span></div>
<div class="line"><span class="lineno">  298</span><span class="stringliteral">            Array of (x, y) points for the triangle.</span></div>
<div class="line"><span class="lineno">  299</span><span class="stringliteral">        colors : (3, 4) array-like</span></div>
<div class="line"><span class="lineno">  300</span><span class="stringliteral">            RGBA colors for each point of the triangle.</span></div>
<div class="line"><span class="lineno">  301</span><span class="stringliteral">        transform : `matplotlib.transforms.Transform`</span></div>
<div class="line"><span class="lineno">  302</span><span class="stringliteral">            An affine transform to apply to the points.</span></div>
<div class="line"><span class="lineno">  303</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  304</span>        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno">  305</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a3f0fe27e8b7e79a96d3240d74d6c5cea" name="a3f0fe27e8b7e79a96d3240d74d6c5cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0fe27e8b7e79a96d3240d74d6c5cea">&#9670;&#160;</a></span>draw_gouraud_triangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_gouraud_triangles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>triangles_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>colors_array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a series of Gouraud triangles.

Parameters
----------
points : (N, 3, 2) array-like
    Array of *N* (x, y) points for the triangles.
colors : (N, 3, 4) array-like
    Array of *N* RGBA colors for each point of the triangles.
transform : `matplotlib.transforms.Transform`
    An affine transform to apply to the points.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#ae2721085ea827da96e238ac9b422a8e9">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a5fee983d9dbc11a5d8da52a1789c401b">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a8ef3cba6032c8c63644e7840c3028ea5">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  307</span>                               transform):</div>
<div class="line"><span class="lineno">  308</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  309</span><span class="stringliteral">        Draw a series of Gouraud triangles.</span></div>
<div class="line"><span class="lineno">  310</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  311</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  312</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  313</span><span class="stringliteral">        points : (N, 3, 2) array-like</span></div>
<div class="line"><span class="lineno">  314</span><span class="stringliteral">            Array of *N* (x, y) points for the triangles.</span></div>
<div class="line"><span class="lineno">  315</span><span class="stringliteral">        colors : (N, 3, 4) array-like</span></div>
<div class="line"><span class="lineno">  316</span><span class="stringliteral">            Array of *N* RGBA colors for each point of the triangles.</span></div>
<div class="line"><span class="lineno">  317</span><span class="stringliteral">        transform : `matplotlib.transforms.Transform`</span></div>
<div class="line"><span class="lineno">  318</span><span class="stringliteral">            An affine transform to apply to the points.</span></div>
<div class="line"><span class="lineno">  319</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  320</span>        transform = transform.frozen()</div>
<div class="line"><span class="lineno">  321</span>        <span class="keywordflow">for</span> tri, col <span class="keywordflow">in</span> zip(triangles_array, colors_array):</div>
<div class="line"><span class="lineno">  322</span>            self.draw_gouraud_triangle(gc, tri, col, transform)</div>
<div class="line"><span class="lineno">  323</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa835c7b5a00dd82a51494072f85f1e4e" name="aa835c7b5a00dd82a51494072f85f1e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa835c7b5a00dd82a51494072f85f1e4e">&#9670;&#160;</a></span>draw_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_image </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw an RGBA image.

Parameters
----------
gc : `.GraphicsContextBase`
    A graphics context with clipping information.

x : scalar
    The distance in physical units (i.e., dots or pixels) from the left
    hand side of the canvas.

y : scalar
    The distance in physical units (i.e., dots or pixels) from the
    bottom side of the canvas.

im : (N, M, 4) array-like of np.uint8
    An array of RGBA pixels.

transform : `matplotlib.transforms.Affine2DBase`
    If and only if the concrete backend is written such that
    `option_scale_image` returns ``True``, an affine transformation
    (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The
    translation vector of the transformation is given in physical units
    (i.e., dots or pixels). Note that the transformation does not
    override *x* and *y*, and has to be applied *before* translating
    the result by *x* and *y* (this can be accomplished by adding *x*
    and *y* to the translation vector defined by *transform*).
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a79b25d9335252ada80be004eb1251903">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a0ccef180fe07b0aa491045fead08be51">matplotlib.backends.backend_template.RendererTemplate</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a55239ecdb22eac834e580558e12aff71">matplotlib.backends.backend_wx.RendererWx</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a4008a8792ceb58f7ec85eda12c2c0e45">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#add38e637383ba23cc74521fc66eb9c2a">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a57b06323c0ea632d4e60d96282caba3b">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#aeb491e8b84d434b04ad9ba844ec92a5f">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  456</span>    <span class="keyword">def </span>draw_image(self, gc, x, y, im, transform=None):</div>
<div class="line"><span class="lineno">  457</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  458</span><span class="stringliteral">        Draw an RGBA image.</span></div>
<div class="line"><span class="lineno">  459</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  460</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  461</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  462</span><span class="stringliteral">        gc : `.GraphicsContextBase`</span></div>
<div class="line"><span class="lineno">  463</span><span class="stringliteral">            A graphics context with clipping information.</span></div>
<div class="line"><span class="lineno">  464</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  465</span><span class="stringliteral">        x : scalar</span></div>
<div class="line"><span class="lineno">  466</span><span class="stringliteral">            The distance in physical units (i.e., dots or pixels) from the left</span></div>
<div class="line"><span class="lineno">  467</span><span class="stringliteral">            hand side of the canvas.</span></div>
<div class="line"><span class="lineno">  468</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  469</span><span class="stringliteral">        y : scalar</span></div>
<div class="line"><span class="lineno">  470</span><span class="stringliteral">            The distance in physical units (i.e., dots or pixels) from the</span></div>
<div class="line"><span class="lineno">  471</span><span class="stringliteral">            bottom side of the canvas.</span></div>
<div class="line"><span class="lineno">  472</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  473</span><span class="stringliteral">        im : (N, M, 4) array-like of np.uint8</span></div>
<div class="line"><span class="lineno">  474</span><span class="stringliteral">            An array of RGBA pixels.</span></div>
<div class="line"><span class="lineno">  475</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  476</span><span class="stringliteral">        transform : `matplotlib.transforms.Affine2DBase`</span></div>
<div class="line"><span class="lineno">  477</span><span class="stringliteral">            If and only if the concrete backend is written such that</span></div>
<div class="line"><span class="lineno">  478</span><span class="stringliteral">            `option_scale_image` returns ``True``, an affine transformation</span></div>
<div class="line"><span class="lineno">  479</span><span class="stringliteral">            (i.e., an `.Affine2DBase`) *may* be passed to `draw_image`.  The</span></div>
<div class="line"><span class="lineno">  480</span><span class="stringliteral">            translation vector of the transformation is given in physical units</span></div>
<div class="line"><span class="lineno">  481</span><span class="stringliteral">            (i.e., dots or pixels). Note that the transformation does not</span></div>
<div class="line"><span class="lineno">  482</span><span class="stringliteral">            override *x* and *y*, and has to be applied *before* translating</span></div>
<div class="line"><span class="lineno">  483</span><span class="stringliteral">            the result by *x* and *y* (this can be accomplished by adding *x*</span></div>
<div class="line"><span class="lineno">  484</span><span class="stringliteral">            and *y* to the translation vector defined by *transform*).</span></div>
<div class="line"><span class="lineno">  485</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  486</span>        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno">  487</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a84b5fca88d9795f8c2212afb95d1ebfb" name="a84b5fca88d9795f8c2212afb95d1ebfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b5fca88d9795f8c2212afb95d1ebfb">&#9670;&#160;</a></span>draw_markers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_markers </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>marker_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>marker_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rgbFace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a marker at each of *path*'s vertices (excluding control points).

The base (fallback) implementation makes multiple calls to `draw_path`.
Backends may want to override this method in order to draw the marker
only once and reuse it multiple times.

Parameters
----------
gc : `.GraphicsContextBase`
    The graphics context.
marker_trans : `matplotlib.transforms.Transform`
    An affine transform applied to the marker.
trans : `matplotlib.transforms.Transform`
    An affine transform applied to the path.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html#a2c3748f73fa8eb76118a84cac7b3292c">matplotlib.patheffects.PathEffectRenderer</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#ab29e9ff51bda4d34dc69af6f78f4621c">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a4ff1cc5df393693c89e2b557e65c615d">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a5f75886be700b29a8ad011f4552a6f77">matplotlib.backends.backend_ps.RendererPS</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a2b852dd09dca5cf322a6f46577116ef2">matplotlib.backends.backend_svg.RendererSVG</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a0f0bd91776e1797c8149113ca4a480be">matplotlib.backends.backend_cairo.RendererCairo</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  198</span>                     trans, rgbFace=<span class="keywordtype">None</span>):</div>
<div class="line"><span class="lineno">  199</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  200</span><span class="stringliteral">        Draw a marker at each of *path*&#39;s vertices (excluding control points).</span></div>
<div class="line"><span class="lineno">  201</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  202</span><span class="stringliteral">        The base (fallback) implementation makes multiple calls to `draw_path`.</span></div>
<div class="line"><span class="lineno">  203</span><span class="stringliteral">        Backends may want to override this method in order to draw the marker</span></div>
<div class="line"><span class="lineno">  204</span><span class="stringliteral">        only once and reuse it multiple times.</span></div>
<div class="line"><span class="lineno">  205</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  206</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  207</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  208</span><span class="stringliteral">        gc : `.GraphicsContextBase`</span></div>
<div class="line"><span class="lineno">  209</span><span class="stringliteral">            The graphics context.</span></div>
<div class="line"><span class="lineno">  210</span><span class="stringliteral">        marker_trans : `matplotlib.transforms.Transform`</span></div>
<div class="line"><span class="lineno">  211</span><span class="stringliteral">            An affine transform applied to the marker.</span></div>
<div class="line"><span class="lineno">  212</span><span class="stringliteral">        trans : `matplotlib.transforms.Transform`</span></div>
<div class="line"><span class="lineno">  213</span><span class="stringliteral">            An affine transform applied to the path.</span></div>
<div class="line"><span class="lineno">  214</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  215</span>        <span class="keywordflow">for</span> vertices, codes <span class="keywordflow">in</span> path.iter_segments(trans, simplify=<span class="keyword">False</span>):</div>
<div class="line"><span class="lineno">  216</span>            <span class="keywordflow">if</span> len(vertices):</div>
<div class="line"><span class="lineno">  217</span>                x, y = vertices[-2:]</div>
<div class="line"><span class="lineno">  218</span>                self.draw_path(gc, marker_path,</div>
<div class="line"><span class="lineno">  219</span>                               marker_trans +</div>
<div class="line"><span class="lineno">  220</span>                               transforms.Affine2D().translate(x, y),</div>
<div class="line"><span class="lineno">  221</span>                               rgbFace)</div>
<div class="line"><span class="lineno">  222</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abaa72ab0fa075b939ec117cc10c5bd58" name="abaa72ab0fa075b939ec117cc10c5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa72ab0fa075b939ec117cc10c5bd58">&#9670;&#160;</a></span>draw_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_path </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rgbFace</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a `~.path.Path` instance using the given affine transform.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#a46e71de6631cecdfa0d598510a605e66">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a26fe0782e91f73217545d5ab61973f19">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a29df2ab6d8a86a69aafc8d0f242c8920">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a3e4bdd39b3e80a051c3e4b13316836cf">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#ac862e671995010ba90eb5d916bf82168">matplotlib.backends.backend_ps.RendererPS</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#ab023ae1a3a78a6dc1201d3bb280584f5">matplotlib.backends.backend_svg.RendererSVG</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a003e7ac39632c1432d0f876d210d8b65">matplotlib.backends.backend_template.RendererTemplate</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#ac72cac704e23ccbfbbd0b69bf4542d13">matplotlib.backends.backend_wx.RendererWx</a>, and <a class="el" href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html#ae7910399b21d7b05abd685b8ffa27fce">matplotlib.patheffects.PathEffectRenderer</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  193</span>    <span class="keyword">def </span>draw_path(self, gc, path, transform, rgbFace=None):</div>
<div class="line"><span class="lineno">  194</span>        <span class="stringliteral">&quot;&quot;&quot;Draw a `~.path.Path` instance using the given affine transform.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  195</span>        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"><span class="lineno">  196</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a179209eceeff4eb25a24de19a507edb1" name="a179209eceeff4eb25a24de19a507edb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a179209eceeff4eb25a24de19a507edb1">&#9670;&#160;</a></span>draw_path_collection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_path_collection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>master_transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>all_transforms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edgecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linewidths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linestyles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>antialiaseds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>urls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offset_position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a collection of *paths*.

Each path is first transformed by the corresponding entry
in *all_transforms* (a list of (3, 3) matrices) and then by
*master_transform*.  They are then translated by the corresponding
entry in *offsets*, which has been first transformed by *offset_trans*.

*facecolors*, *edgecolors*, *linewidths*, *linestyles*, and
*antialiased* are lists that set the corresponding properties.

*offset_position* is unused now, but the argument is kept for
backwards compatibility.

The base (fallback) implementation makes multiple calls to `draw_path`.
Backends may want to override this in order to render each set of
path data only once, and then reference that path multiple times with
the different offsets, colors, styles etc.  The generator methods
`_iter_collection_raw_paths` and `_iter_collection` are provided to
help with (and standardize) the implementation across backends.  It
is highly recommended to use those generators, so that changes to the
behavior of `draw_path_collection` can be made globally.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1patheffects_1_1_path_effect_renderer.html#ad3396521d7121f650d30315c17ba0452">matplotlib.patheffects.PathEffectRenderer</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#ae65f1133f39b584906f932a6ed5dcedf">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#af1844bfbe6f6a7eee348d70f8cf566e1">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a878480a14b830f736a032853cb1060b2">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  226</span>                             offset_position):</div>
<div class="line"><span class="lineno">  227</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  228</span><span class="stringliteral">        Draw a collection of *paths*.</span></div>
<div class="line"><span class="lineno">  229</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  230</span><span class="stringliteral">        Each path is first transformed by the corresponding entry</span></div>
<div class="line"><span class="lineno">  231</span><span class="stringliteral">        in *all_transforms* (a list of (3, 3) matrices) and then by</span></div>
<div class="line"><span class="lineno">  232</span><span class="stringliteral">        *master_transform*.  They are then translated by the corresponding</span></div>
<div class="line"><span class="lineno">  233</span><span class="stringliteral">        entry in *offsets*, which has been first transformed by *offset_trans*.</span></div>
<div class="line"><span class="lineno">  234</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  235</span><span class="stringliteral">        *facecolors*, *edgecolors*, *linewidths*, *linestyles*, and</span></div>
<div class="line"><span class="lineno">  236</span><span class="stringliteral">        *antialiased* are lists that set the corresponding properties.</span></div>
<div class="line"><span class="lineno">  237</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  238</span><span class="stringliteral">        *offset_position* is unused now, but the argument is kept for</span></div>
<div class="line"><span class="lineno">  239</span><span class="stringliteral">        backwards compatibility.</span></div>
<div class="line"><span class="lineno">  240</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  241</span><span class="stringliteral">        The base (fallback) implementation makes multiple calls to `draw_path`.</span></div>
<div class="line"><span class="lineno">  242</span><span class="stringliteral">        Backends may want to override this in order to render each set of</span></div>
<div class="line"><span class="lineno">  243</span><span class="stringliteral">        path data only once, and then reference that path multiple times with</span></div>
<div class="line"><span class="lineno">  244</span><span class="stringliteral">        the different offsets, colors, styles etc.  The generator methods</span></div>
<div class="line"><span class="lineno">  245</span><span class="stringliteral">        `_iter_collection_raw_paths` and `_iter_collection` are provided to</span></div>
<div class="line"><span class="lineno">  246</span><span class="stringliteral">        help with (and standardize) the implementation across backends.  It</span></div>
<div class="line"><span class="lineno">  247</span><span class="stringliteral">        is highly recommended to use those generators, so that changes to the</span></div>
<div class="line"><span class="lineno">  248</span><span class="stringliteral">        behavior of `draw_path_collection` can be made globally.</span></div>
<div class="line"><span class="lineno">  249</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  250</span>        path_ids = self._iter_collection_raw_paths(master_transform,</div>
<div class="line"><span class="lineno">  251</span>                                                   paths, all_transforms)</div>
<div class="line"><span class="lineno">  252</span> </div>
<div class="line"><span class="lineno">  253</span>        <span class="keywordflow">for</span> xo, yo, path_id, gc0, rgbFace <span class="keywordflow">in</span> self._iter_collection(</div>
<div class="line"><span class="lineno">  254</span>                gc, list(path_ids), offsets, offset_trans,</div>
<div class="line"><span class="lineno">  255</span>                facecolors, edgecolors, linewidths, linestyles,</div>
<div class="line"><span class="lineno">  256</span>                antialiaseds, urls, offset_position):</div>
<div class="line"><span class="lineno">  257</span>            path, transform = path_id</div>
<div class="line"><span class="lineno">  258</span>            <span class="comment"># Only apply another translation if we have an offset, else we</span></div>
<div class="line"><span class="lineno">  259</span>            <span class="comment"># reuse the initial transform.</span></div>
<div class="line"><span class="lineno">  260</span>            <span class="keywordflow">if</span> xo != 0 <span class="keywordflow">or</span> yo != 0:</div>
<div class="line"><span class="lineno">  261</span>                <span class="comment"># The transformation can be used by multiple paths. Since</span></div>
<div class="line"><span class="lineno">  262</span>                <span class="comment"># translate is a inplace operation, we need to copy the</span></div>
<div class="line"><span class="lineno">  263</span>                <span class="comment"># transformation by .frozen() before applying the translation.</span></div>
<div class="line"><span class="lineno">  264</span>                transform = transform.frozen()</div>
<div class="line"><span class="lineno">  265</span>                transform.translate(xo, yo)</div>
<div class="line"><span class="lineno">  266</span>            self.draw_path(gc0, path, transform, rgbFace)</div>
<div class="line"><span class="lineno">  267</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="abae855a76770c81bedfd513d52478081" name="abae855a76770c81bedfd513d52478081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae855a76770c81bedfd513d52478081">&#9670;&#160;</a></span>draw_quad_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_quad_mesh </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>master_transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>meshWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>meshHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coordinates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>offsetTrans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>facecolors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>antialiased</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>edgecolors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a quadmesh.

The base (fallback) implementation converts the quadmesh to paths and
then calls `draw_path_collection`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  270</span>                       antialiased, edgecolors):</div>
<div class="line"><span class="lineno">  271</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  272</span><span class="stringliteral">        Draw a quadmesh.</span></div>
<div class="line"><span class="lineno">  273</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  274</span><span class="stringliteral">        The base (fallback) implementation converts the quadmesh to paths and</span></div>
<div class="line"><span class="lineno">  275</span><span class="stringliteral">        then calls `draw_path_collection`.</span></div>
<div class="line"><span class="lineno">  276</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>        <span class="keyword">from</span> <a class="code hl_namespace" href="namespacematplotlib_1_1collections.html">matplotlib.collections</a> <span class="keyword">import</span> QuadMesh</div>
<div class="line"><span class="lineno">  279</span>        paths = QuadMesh._convert_mesh_to_paths(coordinates)</div>
<div class="line"><span class="lineno">  280</span> </div>
<div class="line"><span class="lineno">  281</span>        <span class="keywordflow">if</span> edgecolors <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  282</span>            edgecolors = facecolors</div>
<div class="line"><span class="lineno">  283</span>        linewidths = np.array([gc.get_linewidth()], float)</div>
<div class="line"><span class="lineno">  284</span> </div>
<div class="line"><span class="lineno">  285</span>        <span class="keywordflow">return</span> self.draw_path_collection(</div>
<div class="line"><span class="lineno">  286</span>            gc, master_transform, paths, [], offsets, offsetTrans, facecolors,</div>
<div class="line"><span class="lineno">  287</span>            edgecolors, linewidths, [], [antialiased], [<span class="keywordtype">None</span>], <span class="stringliteral">&#39;screen&#39;</span>)</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="ttc" id="anamespacematplotlib_1_1collections_html"><div class="ttname"><a href="namespacematplotlib_1_1collections.html">matplotlib.collections</a></div><div class="ttdef"><b>Definition</b> collections.py:1</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3374939c440fe0ff9fa6fa8f8330fb11" name="a3374939c440fe0ff9fa6fa8f8330fb11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3374939c440fe0ff9fa6fa8f8330fb11">&#9670;&#160;</a></span>draw_tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_tex </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>mtext</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment"></pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#ae2d3ebe2128d2bda79979c6f4404bdef">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#af87ea8d775ad519abf372254def5dedb">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a3c7b375f68d78a3297b6c07f6f02db90">matplotlib.backends.backend_ps.RendererPS</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a662b9fc225972efb1af329220cc6d29f">matplotlib.backends.backend_svg.RendererSVG</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a9743ce308eaed55cac3b8fb364c3131a">matplotlib.backends.backend_pgf.RendererPgf</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  505</span>    <span class="keyword">def </span>draw_tex(self, gc, x, y, s, prop, angle, *, mtext=None):</div>
<div class="line"><span class="lineno">  506</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  507</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  508</span>        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath=<span class="stringliteral">&quot;TeX&quot;</span>)</div>
<div class="line"><span class="lineno">  509</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5eaf90d1255ec46894a498109fcba232" name="a5eaf90d1255ec46894a498109fcba232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eaf90d1255ec46894a498109fcba232">&#9670;&#160;</a></span>draw_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.draw_text </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ismath</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mtext</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Draw a text instance.

Parameters
----------
gc : `.GraphicsContextBase`
    The graphics context.
x : float
    The x location of the text in display coords.
y : float
    The y location of the text baseline in display coords.
s : str
    The text string.
prop : `matplotlib.font_manager.FontProperties`
    The font properties.
angle : float
    The rotation angle in degrees anti-clockwise.
mtext : `matplotlib.text.Text`
    The original text object to be rendered.

Notes
-----
**Note for backend implementers:**

When you are trying to determine if you have gotten your bounding box
right (which is what enables the text layout/alignment to work
properly), it helps to change the line in text.py::

    if 0: bbox_artist(self, renderer)

to if 1, and then the actual bounding box will be plotted along with
your text.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#a33f86217d5521aa16e8864ebfe106735">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a18d137c55bab4a2dd32bd617e37fda64">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#ad594cbe1353b40fd5454ae58c94a530a">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a82b473bb29694baf9ea3ce920c9a780f">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#a8134de56b3ea98eb7772ba46c4ecbdff">matplotlib.backends.backend_ps.RendererPS</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#af075f7f87e612735e5116b4007b29d7d">matplotlib.backends.backend_svg.RendererSVG</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#afdda83627226a548b6e85eade569c468">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a5472cc3f979e8fc208d9e23c7cdcb1b7">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  510</span>    <span class="keyword">def </span>draw_text(self, gc, x, y, s, prop, angle, ismath=False, mtext=None):</div>
<div class="line"><span class="lineno">  511</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  512</span><span class="stringliteral">        Draw a text instance.</span></div>
<div class="line"><span class="lineno">  513</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  514</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  515</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  516</span><span class="stringliteral">        gc : `.GraphicsContextBase`</span></div>
<div class="line"><span class="lineno">  517</span><span class="stringliteral">            The graphics context.</span></div>
<div class="line"><span class="lineno">  518</span><span class="stringliteral">        x : float</span></div>
<div class="line"><span class="lineno">  519</span><span class="stringliteral">            The x location of the text in display coords.</span></div>
<div class="line"><span class="lineno">  520</span><span class="stringliteral">        y : float</span></div>
<div class="line"><span class="lineno">  521</span><span class="stringliteral">            The y location of the text baseline in display coords.</span></div>
<div class="line"><span class="lineno">  522</span><span class="stringliteral">        s : str</span></div>
<div class="line"><span class="lineno">  523</span><span class="stringliteral">            The text string.</span></div>
<div class="line"><span class="lineno">  524</span><span class="stringliteral">        prop : `matplotlib.font_manager.FontProperties`</span></div>
<div class="line"><span class="lineno">  525</span><span class="stringliteral">            The font properties.</span></div>
<div class="line"><span class="lineno">  526</span><span class="stringliteral">        angle : float</span></div>
<div class="line"><span class="lineno">  527</span><span class="stringliteral">            The rotation angle in degrees anti-clockwise.</span></div>
<div class="line"><span class="lineno">  528</span><span class="stringliteral">        mtext : `matplotlib.text.Text`</span></div>
<div class="line"><span class="lineno">  529</span><span class="stringliteral">            The original text object to be rendered.</span></div>
<div class="line"><span class="lineno">  530</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  531</span><span class="stringliteral">        Notes</span></div>
<div class="line"><span class="lineno">  532</span><span class="stringliteral">        -----</span></div>
<div class="line"><span class="lineno">  533</span><span class="stringliteral">        **Note for backend implementers:**</span></div>
<div class="line"><span class="lineno">  534</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  535</span><span class="stringliteral">        When you are trying to determine if you have gotten your bounding box</span></div>
<div class="line"><span class="lineno">  536</span><span class="stringliteral">        right (which is what enables the text layout/alignment to work</span></div>
<div class="line"><span class="lineno">  537</span><span class="stringliteral">        properly), it helps to change the line in text.py::</span></div>
<div class="line"><span class="lineno">  538</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  539</span><span class="stringliteral">            if 0: bbox_artist(self, renderer)</span></div>
<div class="line"><span class="lineno">  540</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  541</span><span class="stringliteral">        to if 1, and then the actual bounding box will be plotted along with</span></div>
<div class="line"><span class="lineno">  542</span><span class="stringliteral">        your text.</span></div>
<div class="line"><span class="lineno">  543</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>        self._draw_text_as_path(gc, x, y, s, prop, angle, ismath)</div>
<div class="line"><span class="lineno">  546</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4f438e3083fa2e4421bc236a24d6b081" name="a4f438e3083fa2e4421bc236a24d6b081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f438e3083fa2e4421bc236a24d6b081">&#9670;&#160;</a></span>flipy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.flipy </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether y values increase from top to bottom.

Note that this only affects drawing of texts.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#a809fd8a1254b36897dfd1512cbd27409">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a6737178d2e4fcb53c8b18ac1da308a74">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#aebd2fbd35ee42bff7bcc59ff0695775d">matplotlib.backends.backend_svg.RendererSVG</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a56ac48a404ee67426210e4d36d5b3500">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a795f5a4dc3c2b1d2ac38fd7134c752e5">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  632</span>    <span class="keyword">def </span>flipy(self):</div>
<div class="line"><span class="lineno">  633</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  634</span><span class="stringliteral">        Return whether y values increase from top to bottom.</span></div>
<div class="line"><span class="lineno">  635</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  636</span><span class="stringliteral">        Note that this only affects drawing of texts.</span></div>
<div class="line"><span class="lineno">  637</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  638</span>        <span class="keywordflow">return</span> <span class="keyword">True</span></div>
<div class="line"><span class="lineno">  639</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a4069acee5688f39184ff2d93b97123ce" name="a4069acee5688f39184ff2d93b97123ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4069acee5688f39184ff2d93b97123ce">&#9670;&#160;</a></span>get_canvas_width_height()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.get_canvas_width_height </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the canvas width and height in display coords.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#aee3e804b690304abbfb9793a43f8a737">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#ac23f9d6fa3184e93e0982d84df974fbb">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#ae2222aa8c226855ace3e887976dc17fe">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#aa57e382f5c9212b129bc1ad7c654201c">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a11493114cf76c1b2c8832059a8b840f0">matplotlib.backends.backend_svg.RendererSVG</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a6b0f34824ce022157aefaae0dbcc3c35">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#ab81ab7674fc3e6714c2d142090670a31">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  640</span>    <span class="keyword">def </span>get_canvas_width_height(self):</div>
<div class="line"><span class="lineno">  641</span>        <span class="stringliteral">&quot;&quot;&quot;Return the canvas width and height in display coords.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  642</span>        <span class="keywordflow">return</span> 1, 1</div>
<div class="line"><span class="lineno">  643</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a685b555f442f50426a70926e772c1bd3" name="a685b555f442f50426a70926e772c1bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685b555f442f50426a70926e772c1bd3">&#9670;&#160;</a></span>get_image_magnification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.get_image_magnification </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the factor by which to magnify images passed to `draw_image`.
Allows a backend to have images at a different resolution to other
artists.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a6b36d2cf2035f6bfacae07dda424c9c0">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__ps_1_1_renderer_p_s.html#ae30356702ba1b1109b1686f1441bc612">matplotlib.backends.backend_ps.RendererPS</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a4d20e6bb8ab24b4b394372f94ed39637">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  448</span>    <span class="keyword">def </span>get_image_magnification(self):</div>
<div class="line"><span class="lineno">  449</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  450</span><span class="stringliteral">        Get the factor by which to magnify images passed to `draw_image`.</span></div>
<div class="line"><span class="lineno">  451</span><span class="stringliteral">        Allows a backend to have images at a different resolution to other</span></div>
<div class="line"><span class="lineno">  452</span><span class="stringliteral">        artists.</span></div>
<div class="line"><span class="lineno">  453</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  454</span>        <span class="keywordflow">return</span> 1.0</div>
<div class="line"><span class="lineno">  455</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a97588e7597ca3f3081a35fa44d76302c" name="a97588e7597ca3f3081a35fa44d76302c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97588e7597ca3f3081a35fa44d76302c">&#9670;&#160;</a></span>get_texmanager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.get_texmanager </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the `.TexManager` instance.</pre> <div class="fragment"><div class="line"><span class="lineno">  644</span>    <span class="keyword">def </span>get_texmanager(self):</div>
<div class="line"><span class="lineno">  645</span>        <span class="stringliteral">&quot;&quot;&quot;Return the `.TexManager` instance.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  646</span>        <span class="keywordflow">if</span> self._texmanager <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line"><span class="lineno">  647</span>            self._texmanager = TexManager()</div>
<div class="line"><span class="lineno">  648</span>        <span class="keywordflow">return</span> self._texmanager</div>
<div class="line"><span class="lineno">  649</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a5949e6973c36e18d99075c10481b4d91" name="a5949e6973c36e18d99075c10481b4d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5949e6973c36e18d99075c10481b4d91">&#9670;&#160;</a></span>get_text_width_height_descent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.get_text_width_height_descent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ismath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Get the width, height, and descent (offset from the bottom
to the baseline), in display coords, of the string *s* with
`.FontProperties` *prop*.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#a032a9a45f4c931057aab11dac5e395c4">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#a3394f94e84854c93bbc7ff173364bc72">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a62a6ce21f869f568ae3f5e50adddfbac">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#af38e6a2af6ba93e8ea1483ad622a1069">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a9768c1d8b66c14db1cfa8f696978363d">matplotlib.backends.backend_svg.RendererSVG</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a6c5cb933987405e4136c301540ab3d72">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a1a8b96520be900e41b02e2bbb8b3af0f">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  602</span>    <span class="keyword">def </span>get_text_width_height_descent(self, s, prop, ismath):</div>
<div class="line"><span class="lineno">  603</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  604</span><span class="stringliteral">        Get the width, height, and descent (offset from the bottom</span></div>
<div class="line"><span class="lineno">  605</span><span class="stringliteral">        to the baseline), in display coords, of the string *s* with</span></div>
<div class="line"><span class="lineno">  606</span><span class="stringliteral">        `.FontProperties` *prop*.</span></div>
<div class="line"><span class="lineno">  607</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  608</span>        fontsize = prop.get_size_in_points()</div>
<div class="line"><span class="lineno">  609</span> </div>
<div class="line"><span class="lineno">  610</span>        <span class="keywordflow">if</span> ismath == <span class="stringliteral">&#39;TeX&#39;</span>:</div>
<div class="line"><span class="lineno">  611</span>            <span class="comment"># todo: handle props</span></div>
<div class="line"><span class="lineno">  612</span>            <span class="keywordflow">return</span> TexManager().get_text_width_height_descent(</div>
<div class="line"><span class="lineno">  613</span>                s, fontsize, renderer=self)</div>
<div class="line"><span class="lineno">  614</span> </div>
<div class="line"><span class="lineno">  615</span>        dpi = self.points_to_pixels(72)</div>
<div class="line"><span class="lineno">  616</span>        <span class="keywordflow">if</span> ismath:</div>
<div class="line"><span class="lineno">  617</span>            dims = self._text2path.mathtext_parser.parse(s, dpi, prop)</div>
<div class="line"><span class="lineno">  618</span>            <span class="keywordflow">return</span> dims[0:3]  <span class="comment"># return width, height, descent</span></div>
<div class="line"><span class="lineno">  619</span> </div>
<div class="line"><span class="lineno">  620</span>        flags = self._text2path._get_hinting_flag()</div>
<div class="line"><span class="lineno">  621</span>        font = self._text2path._get_font(prop)</div>
<div class="line"><span class="lineno">  622</span>        font.set_size(fontsize, dpi)</div>
<div class="line"><span class="lineno">  623</span>        <span class="comment"># the width and height of unrotated string</span></div>
<div class="line"><span class="lineno">  624</span>        font.set_text(s, 0.0, flags=flags)</div>
<div class="line"><span class="lineno">  625</span>        w, h = font.get_width_height()</div>
<div class="line"><span class="lineno">  626</span>        d = font.get_descent()</div>
<div class="line"><span class="lineno">  627</span>        w /= 64.0  <span class="comment"># convert from subpixels</span></div>
<div class="line"><span class="lineno">  628</span>        h /= 64.0</div>
<div class="line"><span class="lineno">  629</span>        d /= 64.0</div>
<div class="line"><span class="lineno">  630</span>        <span class="keywordflow">return</span> w, h, d</div>
<div class="line"><span class="lineno">  631</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a2e126c3f377d4c8636c2b92b28d1fab8" name="a2e126c3f377d4c8636c2b92b28d1fab8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e126c3f377d4c8636c2b92b28d1fab8">&#9670;&#160;</a></span>new_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.new_gc </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return an instance of a `.GraphicsContextBase`.</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a8375b3897a7f557270e7747202835951">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pdf_1_1_renderer_pdf.html#a633e4335daeb1683874b942a7a4ba326">matplotlib.backends.backend_pdf.RendererPdf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#a8e75ab3218ac9d001a3753b1a6cc1292">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a090b22f3e942694f419a06c7152e0759">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  650</span>    <span class="keyword">def </span>new_gc(self):</div>
<div class="line"><span class="lineno">  651</span>        <span class="stringliteral">&quot;&quot;&quot;Return an instance of a `.GraphicsContextBase`.&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  652</span>        <span class="keywordflow">return</span> GraphicsContextBase()</div>
<div class="line"><span class="lineno">  653</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ab0bd6c68209c2c4068d0e91266b27802" name="ab0bd6c68209c2c4068d0e91266b27802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bd6c68209c2c4068d0e91266b27802">&#9670;&#160;</a></span>open_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.open_group </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>gid</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Open a grouping element with label *s* and *gid* (if set) as id.

Only used by the SVG renderer.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a3523ee37e64777241a810a27a06e838a">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  179</span>    <span class="keyword">def </span>open_group(self, s, gid=None):</div>
<div class="line"><span class="lineno">  180</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  181</span><span class="stringliteral">        Open a grouping element with label *s* and *gid* (if set) as id.</span></div>
<div class="line"><span class="lineno">  182</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  183</span><span class="stringliteral">        Only used by the SVG renderer.</span></div>
<div class="line"><span class="lineno">  184</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  185</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ae27745a3b892e5c2ec892a0b503a1290" name="ae27745a3b892e5c2ec892a0b503a1290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27745a3b892e5c2ec892a0b503a1290">&#9670;&#160;</a></span>option_image_nocomposite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.option_image_nocomposite </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether image composition by Matplotlib should be skipped.

Raster backends should usually return False (letting the C-level
rasterizer take care of image composition); vector backends should
usually return ``not rcParams["image.composite_image"]``.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#af5468d00405ef90ba8870ec0fa919fa7">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#aa2d192e26d1d201045f36f0c71ca53e8">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#a8b9463ffe37cb912acf1eb2b721bf83e">matplotlib.backends.backend_pgf.RendererPgf</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a6060d4b06a5fce9d741f24f8b97dd9bd">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  488</span>    <span class="keyword">def </span>option_image_nocomposite(self):</div>
<div class="line"><span class="lineno">  489</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  490</span><span class="stringliteral">        Return whether image composition by Matplotlib should be skipped.</span></div>
<div class="line"><span class="lineno">  491</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  492</span><span class="stringliteral">        Raster backends should usually return False (letting the C-level</span></div>
<div class="line"><span class="lineno">  493</span><span class="stringliteral">        rasterizer take care of image composition); vector backends should</span></div>
<div class="line"><span class="lineno">  494</span><span class="stringliteral">        usually return ``not rcParams[&quot;image.composite_image&quot;]``.</span></div>
<div class="line"><span class="lineno">  495</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  496</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  497</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a16aef7c1964720d255a5f303588763e1" name="a16aef7c1964720d255a5f303588763e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16aef7c1964720d255a5f303588763e1">&#9670;&#160;</a></span>option_scale_image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.option_scale_image </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return whether arbitrary affine transformations in `draw_image` are
supported (True for most vector backends).
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1__backend__pdf__ps_1_1_renderer_p_d_f_p_s_base.html#a5775f981528279b0e3dde5a8ce849e48">matplotlib.backends._backend_pdf_ps.RendererPDFPSBase</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#a8da44f74f210d3f657c72100026ed382">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#aba8b62d09074f18f8d797160e5ad465e">matplotlib.backends.backend_pgf.RendererPgf</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__svg_1_1_renderer_s_v_g.html#a6ae36c87bb406881fd7ed9e272672c6a">matplotlib.backends.backend_svg.RendererSVG</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  498</span>    <span class="keyword">def </span>option_scale_image(self):</div>
<div class="line"><span class="lineno">  499</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  500</span><span class="stringliteral">        Return whether arbitrary affine transformations in `draw_image` are</span></div>
<div class="line"><span class="lineno">  501</span><span class="stringliteral">        supported (True for most vector backends).</span></div>
<div class="line"><span class="lineno">  502</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  503</span>        <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"><span class="lineno">  504</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a127fe58cf106a6d048297da52a313f77" name="a127fe58cf106a6d048297da52a313f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127fe58cf106a6d048297da52a313f77">&#9670;&#160;</a></span>points_to_pixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.points_to_pixels </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert points to display units.

You need to override this function (unless your backend
doesn't have a dpi, e.g., postscript or svg).  Some imaging
systems assume some value for pixels per inch::

    points to pixels = points * pixels_per_inch/72 * dpi/72

Parameters
----------
points : float or array-like
    a float or a numpy array of float

Returns
-------
Points converted to pixels
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#a0be6bac21faa8d846f06513ee9f8b4a2">matplotlib.backends.backend_agg.RendererAgg</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__cairo_1_1_renderer_cairo.html#a394bb6844d754f8ceefaf65206bfb142">matplotlib.backends.backend_cairo.RendererCairo</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__pgf_1_1_renderer_pgf.html#aa4306c73237dc493fd6da22f3ec670d7">matplotlib.backends.backend_pgf.RendererPgf</a>, <a class="el" href="classmatplotlib_1_1backends_1_1backend__template_1_1_renderer_template.html#af705696492079d9cbe612270fc1c9bb9">matplotlib.backends.backend_template.RendererTemplate</a>, and <a class="el" href="classmatplotlib_1_1backends_1_1backend__wx_1_1_renderer_wx.html#a83cf6afe5011bd165b390ad126c9e876">matplotlib.backends.backend_wx.RendererWx</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  654</span>    <span class="keyword">def </span>points_to_pixels(self, points):</div>
<div class="line"><span class="lineno">  655</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  656</span><span class="stringliteral">        Convert points to display units.</span></div>
<div class="line"><span class="lineno">  657</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  658</span><span class="stringliteral">        You need to override this function (unless your backend</span></div>
<div class="line"><span class="lineno">  659</span><span class="stringliteral">        doesn&#39;t have a dpi, e.g., postscript or svg).  Some imaging</span></div>
<div class="line"><span class="lineno">  660</span><span class="stringliteral">        systems assume some value for pixels per inch::</span></div>
<div class="line"><span class="lineno">  661</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  662</span><span class="stringliteral">            points to pixels = points * pixels_per_inch/72 * dpi/72</span></div>
<div class="line"><span class="lineno">  663</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  664</span><span class="stringliteral">        Parameters</span></div>
<div class="line"><span class="lineno">  665</span><span class="stringliteral">        ----------</span></div>
<div class="line"><span class="lineno">  666</span><span class="stringliteral">        points : float or array-like</span></div>
<div class="line"><span class="lineno">  667</span><span class="stringliteral">            a float or a numpy array of float</span></div>
<div class="line"><span class="lineno">  668</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  669</span><span class="stringliteral">        Returns</span></div>
<div class="line"><span class="lineno">  670</span><span class="stringliteral">        -------</span></div>
<div class="line"><span class="lineno">  671</span><span class="stringliteral">        Points converted to pixels</span></div>
<div class="line"><span class="lineno">  672</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  673</span>        <span class="keywordflow">return</span> points</div>
<div class="line"><span class="lineno">  674</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="aa6beb00ce176a5b747083d7f458a0bd0" name="aa6beb00ce176a5b747083d7f458a0bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6beb00ce176a5b747083d7f458a0bd0">&#9670;&#160;</a></span>start_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.start_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch to a temporary renderer for image filtering effects.

Currently only supported by the agg renderer.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#adbbae4dc7712a46fb1f9cf93ec2277ca">matplotlib.backends.backend_agg.RendererAgg</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  690</span>    <span class="keyword">def </span>start_filter(self):</div>
<div class="line"><span class="lineno">  691</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  692</span><span class="stringliteral">        Switch to a temporary renderer for image filtering effects.</span></div>
<div class="line"><span class="lineno">  693</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  694</span><span class="stringliteral">        Currently only supported by the agg renderer.</span></div>
<div class="line"><span class="lineno">  695</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  696</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e0547ce0393c194d1faba19e1a3ef4f" name="a9e0547ce0393c194d1faba19e1a3ef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0547ce0393c194d1faba19e1a3ef4f">&#9670;&#160;</a></span>start_rasterizing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.start_rasterizing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch to the raster renderer.

Used by `.MixedModeRenderer`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  675</span>    <span class="keyword">def </span>start_rasterizing(self):</div>
<div class="line"><span class="lineno">  676</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  677</span><span class="stringliteral">        Switch to the raster renderer.</span></div>
<div class="line"><span class="lineno">  678</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  679</span><span class="stringliteral">        Used by `.MixedModeRenderer`.</span></div>
<div class="line"><span class="lineno">  680</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  681</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="a1cfb06429e71210e38e81a0ebcd83ef6" name="a1cfb06429e71210e38e81a0ebcd83ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cfb06429e71210e38e81a0ebcd83ef6">&#9670;&#160;</a></span>stop_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.stop_filter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>filter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch back to the original renderer.  The contents of the temporary
renderer is processed with the *filter_func* and is drawn on the
original renderer as an image.

Currently only supported by the agg renderer.
</pre> 
<p>Reimplemented in <a class="el" href="classmatplotlib_1_1backends_1_1backend__agg_1_1_renderer_agg.html#ad6bcc84379fd87d2648a0164b42f9b54">matplotlib.backends.backend_agg.RendererAgg</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  697</span>    <span class="keyword">def </span>stop_filter(self, filter_func):</div>
<div class="line"><span class="lineno">  698</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  699</span><span class="stringliteral">        Switch back to the original renderer.  The contents of the temporary</span></div>
<div class="line"><span class="lineno">  700</span><span class="stringliteral">        renderer is processed with the *filter_func* and is drawn on the</span></div>
<div class="line"><span class="lineno">  701</span><span class="stringliteral">        original renderer as an image.</span></div>
<div class="line"><span class="lineno">  702</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  703</span><span class="stringliteral">        Currently only supported by the agg renderer.</span></div>
<div class="line"><span class="lineno">  704</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  705</span> </div>
</div><!-- fragment -->
</div>
</div>
<a id="ad93097cdf41f0f34380f5f8723803911" name="ad93097cdf41f0f34380f5f8723803911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93097cdf41f0f34380f5f8723803911">&#9670;&#160;</a></span>stop_rasterizing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase.stop_rasterizing </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Switch back to the vector renderer and draw the contents of the raster
renderer as an image on the vector renderer.

Used by `.MixedModeRenderer`.
</pre> <div class="fragment"><div class="line"><span class="lineno">  682</span>    <span class="keyword">def </span>stop_rasterizing(self):</div>
<div class="line"><span class="lineno">  683</span>        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  684</span><span class="stringliteral">        Switch back to the vector renderer and draw the contents of the raster</span></div>
<div class="line"><span class="lineno">  685</span><span class="stringliteral">        renderer as an image on the vector renderer.</span></div>
<div class="line"><span class="lineno">  686</span><span class="stringliteral"></span> </div>
<div class="line"><span class="lineno">  687</span><span class="stringliteral">        Used by `.MixedModeRenderer`.</span></div>
<div class="line"><span class="lineno">  688</span><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line"><span class="lineno">  689</span> </div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7327683a5b666d0cd9c3c94b962e10ff" name="a7327683a5b666d0cd9c3c94b962e10ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7327683a5b666d0cd9c3c94b962e10ff">&#9670;&#160;</a></span>_raster_depth</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._raster_depth</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2404cfcbab1234c60978bf806aa2a1ce" name="a2404cfcbab1234c60978bf806aa2a1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2404cfcbab1234c60978bf806aa2a1ce">&#9670;&#160;</a></span>_rasterizing</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._rasterizing</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a56481bcf7dda3fb3d391ef69e03c4e60" name="a56481bcf7dda3fb3d391ef69e03c4e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56481bcf7dda3fb3d391ef69e03c4e60">&#9670;&#160;</a></span>_texmanager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._texmanager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ccfad0a85e2dda1bb5f7f50cbdbf4c9" name="a6ccfad0a85e2dda1bb5f7f50cbdbf4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccfad0a85e2dda1bb5f7f50cbdbf4c9">&#9670;&#160;</a></span>_text2path</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">matplotlib.backend_bases.RendererBase._text2path</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/Users/rafael/Documents/GitHub/PUC-GCES-PY/Tp-GCS-Rafael-Augusto/venv/lib/python3.9/site-packages/matplotlib/<a class="el" href="backend__bases_8py.html">backend_bases.py</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
